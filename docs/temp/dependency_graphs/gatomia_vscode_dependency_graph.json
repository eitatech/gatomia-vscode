{
  ".codex.skills..system.skill-creator.scripts.init_skill.normalize_skill_name": {
    "id": ".codex.skills..system.skill-creator.scripts.init_skill.normalize_skill_name",
    "name": "normalize_skill_name",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/init_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/init_skill.py",
    "depends_on": [],
    "source_code": "def normalize_skill_name(skill_name):\n    \"\"\"Normalize a skill name to lowercase hyphen-case.\"\"\"\n    normalized = skill_name.strip().lower()\n    normalized = re.sub(r\"[^a-z0-9]+\", \"-\", normalized)\n    normalized = normalized.strip(\"-\")\n    normalized = re.sub(r\"-{2,}\", \"-\", normalized)\n    return normalized",
    "start_line": 194,
    "end_line": 200,
    "has_docstring": true,
    "docstring": "Normalize a skill name to lowercase hyphen-case.",
    "parameters": [
      "skill_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalize_skill_name",
    "component_id": ".codex.skills..system.skill-creator.scripts.init_skill.normalize_skill_name"
  },
  ".codex.skills..system.skill-creator.scripts.init_skill.title_case_skill_name": {
    "id": ".codex.skills..system.skill-creator.scripts.init_skill.title_case_skill_name",
    "name": "title_case_skill_name",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/init_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/init_skill.py",
    "depends_on": [],
    "source_code": "def title_case_skill_name(skill_name):\n    \"\"\"Convert hyphenated skill name to Title Case for display.\"\"\"\n    return \" \".join(word.capitalize() for word in skill_name.split(\"-\"))",
    "start_line": 203,
    "end_line": 205,
    "has_docstring": true,
    "docstring": "Convert hyphenated skill name to Title Case for display.",
    "parameters": [
      "skill_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function title_case_skill_name",
    "component_id": ".codex.skills..system.skill-creator.scripts.init_skill.title_case_skill_name"
  },
  ".codex.skills..system.skill-creator.scripts.init_skill.parse_resources": {
    "id": ".codex.skills..system.skill-creator.scripts.init_skill.parse_resources",
    "name": "parse_resources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/init_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/init_skill.py",
    "depends_on": [],
    "source_code": "def parse_resources(raw_resources):\n    if not raw_resources:\n        return []\n    resources = [item.strip() for item in raw_resources.split(\",\") if item.strip()]\n    invalid = sorted({item for item in resources if item not in ALLOWED_RESOURCES})\n    if invalid:\n        allowed = \", \".join(sorted(ALLOWED_RESOURCES))\n        print(f\"[ERROR] Unknown resource type(s): {', '.join(invalid)}\")\n        print(f\"   Allowed: {allowed}\")\n        sys.exit(1)\n    deduped = []\n    seen = set()\n    for resource in resources:\n        if resource not in seen:\n            deduped.append(resource)\n            seen.add(resource)\n    return deduped",
    "start_line": 208,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "raw_resources"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_resources",
    "component_id": ".codex.skills..system.skill-creator.scripts.init_skill.parse_resources"
  },
  ".codex.skills..system.skill-creator.scripts.init_skill.create_resource_dirs": {
    "id": ".codex.skills..system.skill-creator.scripts.init_skill.create_resource_dirs",
    "name": "create_resource_dirs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/init_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/init_skill.py",
    "depends_on": [],
    "source_code": "def create_resource_dirs(skill_dir, skill_name, skill_title, resources, include_examples):\n    for resource in resources:\n        resource_dir = skill_dir / resource\n        resource_dir.mkdir(exist_ok=True)\n        if resource == \"scripts\":\n            if include_examples:\n                example_script = resource_dir / \"example.py\"\n                example_script.write_text(EXAMPLE_SCRIPT.format(skill_name=skill_name))\n                example_script.chmod(0o755)\n                print(\"[OK] Created scripts/example.py\")\n            else:\n                print(\"[OK] Created scripts/\")\n        elif resource == \"references\":\n            if include_examples:\n                example_reference = resource_dir / \"api_reference.md\"\n                example_reference.write_text(EXAMPLE_REFERENCE.format(skill_title=skill_title))\n                print(\"[OK] Created references/api_reference.md\")\n            else:\n                print(\"[OK] Created references/\")\n        elif resource == \"assets\":\n            if include_examples:\n                example_asset = resource_dir / \"example_asset.txt\"\n                example_asset.write_text(EXAMPLE_ASSET)\n                print(\"[OK] Created assets/example_asset.txt\")\n            else:\n                print(\"[OK] Created assets/\")",
    "start_line": 227,
    "end_line": 252,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "skill_dir",
      "skill_name",
      "skill_title",
      "resources",
      "include_examples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_resource_dirs",
    "component_id": ".codex.skills..system.skill-creator.scripts.init_skill.create_resource_dirs"
  },
  ".codex.skills..system.skill-creator.scripts.init_skill.init_skill": {
    "id": ".codex.skills..system.skill-creator.scripts.init_skill.init_skill",
    "name": "init_skill",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/init_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/init_skill.py",
    "depends_on": [
      "src.providers.steering-explorer-provider.exists",
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      ".codex.skills..system.skill-creator.scripts.init_skill.title_case_skill_name",
      ".codex.skills..system.skill-creator.scripts.init_skill.create_resource_dirs"
    ],
    "source_code": "def init_skill(skill_name, path, resources, include_examples):\n    \"\"\"\n    Initialize a new skill directory with template SKILL.md.\n\n    Args:\n        skill_name: Name of the skill\n        path: Path where the skill directory should be created\n        resources: Resource directories to create\n        include_examples: Whether to create example files in resource directories\n\n    Returns:\n        Path to created skill directory, or None if error\n    \"\"\"\n    # Determine skill directory path\n    skill_dir = Path(path).resolve() / skill_name\n\n    # Check if directory already exists\n    if skill_dir.exists():\n        print(f\"[ERROR] Skill directory already exists: {skill_dir}\")\n        return None\n\n    # Create skill directory\n    try:\n        skill_dir.mkdir(parents=True, exist_ok=False)\n        print(f\"[OK] Created skill directory: {skill_dir}\")\n    except Exception as e:\n        print(f\"[ERROR] Error creating directory: {e}\")\n        return None\n\n    # Create SKILL.md from template\n    skill_title = title_case_skill_name(skill_name)\n    skill_content = SKILL_TEMPLATE.format(skill_name=skill_name, skill_title=skill_title)\n\n    skill_md_path = skill_dir / \"SKILL.md\"\n    try:\n        skill_md_path.write_text(skill_content)\n        print(\"[OK] Created SKILL.md\")\n    except Exception as e:\n        print(f\"[ERROR] Error creating SKILL.md: {e}\")\n        return None\n\n    # Create resource directories if requested\n    if resources:\n        try:\n            create_resource_dirs(skill_dir, skill_name, skill_title, resources, include_examples)\n        except Exception as e:\n            print(f\"[ERROR] Error creating resource directories: {e}\")\n            return None\n\n    # Print next steps\n    print(f\"\\n[OK] Skill '{skill_name}' initialized successfully at {skill_dir}\")\n    print(\"\\nNext steps:\")\n    print(\"1. Edit SKILL.md to complete the TODO items and update the description\")\n    if resources:\n        if include_examples:\n            print(\"2. Customize or delete the example files in scripts/, references/, and assets/\")\n        else:\n            print(\"2. Add resources to scripts/, references/, and assets/ as needed\")\n    else:\n        print(\"2. Create resource directories only if needed (scripts/, references/, assets/)\")\n    print(\"3. Run the validator when ready to check the skill structure\")\n\n    return skill_dir",
    "start_line": 255,
    "end_line": 317,
    "has_docstring": true,
    "docstring": "Initialize a new skill directory with template SKILL.md.\n\nArgs:\n    skill_name: Name of the skill\n    path: Path where the skill directory should be created\n    resources: Resource directories to create\n    include_examples: Whether to create example files in resource directories\n\nReturns:\n    Path to created skill directory, or None if error",
    "parameters": [
      "skill_name",
      "path",
      "resources",
      "include_examples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function init_skill",
    "component_id": ".codex.skills..system.skill-creator.scripts.init_skill.init_skill"
  },
  ".codex.skills..system.skill-creator.scripts.init_skill.main": {
    "id": ".codex.skills..system.skill-creator.scripts.init_skill.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/init_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/init_skill.py",
    "depends_on": [
      ".codex.skills..system.skill-creator.scripts.init_skill.parse_resources",
      ".codex.skills..system.skill-creator.scripts.init_skill.init_skill",
      ".codex.skills..system.skill-creator.scripts.init_skill.normalize_skill_name"
    ],
    "source_code": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Create a new skill directory with a SKILL.md template.\",\n    )\n    parser.add_argument(\"skill_name\", help=\"Skill name (normalized to hyphen-case)\")\n    parser.add_argument(\"--path\", required=True, help=\"Output directory for the skill\")\n    parser.add_argument(\n        \"--resources\",\n        default=\"\",\n        help=\"Comma-separated list: scripts,references,assets\",\n    )\n    parser.add_argument(\n        \"--examples\",\n        action=\"store_true\",\n        help=\"Create example files inside the selected resource directories\",\n    )\n    args = parser.parse_args()\n\n    raw_skill_name = args.skill_name\n    skill_name = normalize_skill_name(raw_skill_name)\n    if not skill_name:\n        print(\"[ERROR] Skill name must include at least one letter or digit.\")\n        sys.exit(1)\n    if len(skill_name) > MAX_SKILL_NAME_LENGTH:\n        print(\n            f\"[ERROR] Skill name '{skill_name}' is too long ({len(skill_name)} characters). \"\n            f\"Maximum is {MAX_SKILL_NAME_LENGTH} characters.\"\n        )\n        sys.exit(1)\n    if skill_name != raw_skill_name:\n        print(f\"Note: Normalized skill name from '{raw_skill_name}' to '{skill_name}'.\")\n\n    resources = parse_resources(args.resources)\n    if args.examples and not resources:\n        print(\"[ERROR] --examples requires --resources to be set.\")\n        sys.exit(1)\n\n    path = args.path\n\n    print(f\"Initializing skill: {skill_name}\")\n    print(f\"   Location: {path}\")\n    if resources:\n        print(f\"   Resources: {', '.join(resources)}\")\n        if args.examples:\n            print(\"   Examples: enabled\")\n    else:\n        print(\"   Resources: none (create as needed)\")\n    print()\n\n    result = init_skill(skill_name, path, resources, args.examples)\n\n    if result:\n        sys.exit(0)\n    else:\n        sys.exit(1)",
    "start_line": 320,
    "end_line": 374,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": ".codex.skills..system.skill-creator.scripts.init_skill.main"
  },
  ".codex.skills..system.skill-creator.scripts.package_skill.package_skill": {
    "id": ".codex.skills..system.skill-creator.scripts.package_skill.package_skill",
    "name": "package_skill",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/package_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/package_skill.py",
    "depends_on": [
      ".codex.skills..system.skill-creator.scripts.quick_validate.validate_skill",
      "src.providers.steering-explorer-provider.exists",
      "src.features.hooks.services.mcp-parameter-resolver.resolve"
    ],
    "source_code": "def package_skill(skill_path, output_dir=None):\n    \"\"\"\n    Package a skill folder into a .skill file.\n\n    Args:\n        skill_path: Path to the skill folder\n        output_dir: Optional output directory for the .skill file (defaults to current directory)\n\n    Returns:\n        Path to the created .skill file, or None if error\n    \"\"\"\n    skill_path = Path(skill_path).resolve()\n\n    # Validate skill folder exists\n    if not skill_path.exists():\n        print(f\"[ERROR] Skill folder not found: {skill_path}\")\n        return None\n\n    if not skill_path.is_dir():\n        print(f\"[ERROR] Path is not a directory: {skill_path}\")\n        return None\n\n    # Validate SKILL.md exists\n    skill_md = skill_path / \"SKILL.md\"\n    if not skill_md.exists():\n        print(f\"[ERROR] SKILL.md not found in {skill_path}\")\n        return None\n\n    # Run validation before packaging\n    print(\"Validating skill...\")\n    valid, message = validate_skill(skill_path)\n    if not valid:\n        print(f\"[ERROR] Validation failed: {message}\")\n        print(\"   Please fix the validation errors before packaging.\")\n        return None\n    print(f\"[OK] {message}\\n\")\n\n    # Determine output location\n    skill_name = skill_path.name\n    if output_dir:\n        output_path = Path(output_dir).resolve()\n        output_path.mkdir(parents=True, exist_ok=True)\n    else:\n        output_path = Path.cwd()\n\n    skill_filename = output_path / f\"{skill_name}.skill\"\n\n    # Create the .skill file (zip format)\n    try:\n        with zipfile.ZipFile(skill_filename, \"w\", zipfile.ZIP_DEFLATED) as zipf:\n            # Walk through the skill directory\n            for file_path in skill_path.rglob(\"*\"):\n                if file_path.is_file():\n                    # Calculate the relative path within the zip\n                    arcname = file_path.relative_to(skill_path.parent)\n                    zipf.write(file_path, arcname)\n                    print(f\"  Added: {arcname}\")\n\n        print(f\"\\n[OK] Successfully packaged skill to: {skill_filename}\")\n        return skill_filename\n\n    except Exception as e:\n        print(f\"[ERROR] Error creating .skill file: {e}\")\n        return None",
    "start_line": 20,
    "end_line": 83,
    "has_docstring": true,
    "docstring": "Package a skill folder into a .skill file.\n\nArgs:\n    skill_path: Path to the skill folder\n    output_dir: Optional output directory for the .skill file (defaults to current directory)\n\nReturns:\n    Path to the created .skill file, or None if error",
    "parameters": [
      "skill_path",
      "output_dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function package_skill",
    "component_id": ".codex.skills..system.skill-creator.scripts.package_skill.package_skill"
  },
  ".codex.skills..system.skill-creator.scripts.package_skill.main": {
    "id": ".codex.skills..system.skill-creator.scripts.package_skill.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/package_skill.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/package_skill.py",
    "depends_on": [
      ".codex.skills..system.skill-creator.scripts.package_skill.package_skill"
    ],
    "source_code": "def main():\n    if len(sys.argv) < 2:\n        print(\"Usage: python utils/package_skill.py <path/to/skill-folder> [output-directory]\")\n        print(\"\\nExample:\")\n        print(\"  python utils/package_skill.py skills/public/my-skill\")\n        print(\"  python utils/package_skill.py skills/public/my-skill ./dist\")\n        sys.exit(1)\n\n    skill_path = sys.argv[1]\n    output_dir = sys.argv[2] if len(sys.argv) > 2 else None\n\n    print(f\"Packaging skill: {skill_path}\")\n    if output_dir:\n        print(f\"   Output directory: {output_dir}\")\n    print()\n\n    result = package_skill(skill_path, output_dir)\n\n    if result:\n        sys.exit(0)\n    else:\n        sys.exit(1)",
    "start_line": 86,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": ".codex.skills..system.skill-creator.scripts.package_skill.main"
  },
  ".codex.skills..system.skill-creator.scripts.quick_validate.validate_skill": {
    "id": ".codex.skills..system.skill-creator.scripts.quick_validate.validate_skill",
    "name": "validate_skill",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-creator/scripts/quick_validate.py",
    "relative_path": ".codex/skills/.system/skill-creator/scripts/quick_validate.py",
    "depends_on": [
      "src.features.agents.resource-cache.get",
      "src.providers.steering-explorer-provider.exists"
    ],
    "source_code": "def validate_skill(skill_path):\n    \"\"\"Basic validation of a skill\"\"\"\n    skill_path = Path(skill_path)\n\n    skill_md = skill_path / \"SKILL.md\"\n    if not skill_md.exists():\n        return False, \"SKILL.md not found\"\n\n    content = skill_md.read_text()\n    if not content.startswith(\"---\"):\n        return False, \"No YAML frontmatter found\"\n\n    match = re.match(r\"^---\\n(.*?)\\n---\", content, re.DOTALL)\n    if not match:\n        return False, \"Invalid frontmatter format\"\n\n    frontmatter_text = match.group(1)\n\n    try:\n        frontmatter = yaml.safe_load(frontmatter_text)\n        if not isinstance(frontmatter, dict):\n            return False, \"Frontmatter must be a YAML dictionary\"\n    except yaml.YAMLError as e:\n        return False, f\"Invalid YAML in frontmatter: {e}\"\n\n    allowed_properties = {\"name\", \"description\", \"license\", \"allowed-tools\", \"metadata\"}\n\n    unexpected_keys = set(frontmatter.keys()) - allowed_properties\n    if unexpected_keys:\n        allowed = \", \".join(sorted(allowed_properties))\n        unexpected = \", \".join(sorted(unexpected_keys))\n        return (\n            False,\n            f\"Unexpected key(s) in SKILL.md frontmatter: {unexpected}. Allowed properties are: {allowed}\",\n        )\n\n    if \"name\" not in frontmatter:\n        return False, \"Missing 'name' in frontmatter\"\n    if \"description\" not in frontmatter:\n        return False, \"Missing 'description' in frontmatter\"\n\n    name = frontmatter.get(\"name\", \"\")\n    if not isinstance(name, str):\n        return False, f\"Name must be a string, got {type(name).__name__}\"\n    name = name.strip()\n    if name:\n        if not re.match(r\"^[a-z0-9-]+$\", name):\n            return (\n                False,\n                f\"Name '{name}' should be hyphen-case (lowercase letters, digits, and hyphens only)\",\n            )\n        if name.startswith(\"-\") or name.endswith(\"-\") or \"--\" in name:\n            return (\n                False,\n                f\"Name '{name}' cannot start/end with hyphen or contain consecutive hyphens\",\n            )\n        if len(name) > MAX_SKILL_NAME_LENGTH:\n            return (\n                False,\n                f\"Name is too long ({len(name)} characters). \"\n                f\"Maximum is {MAX_SKILL_NAME_LENGTH} characters.\",\n            )\n\n    description = frontmatter.get(\"description\", \"\")\n    if not isinstance(description, str):\n        return False, f\"Description must be a string, got {type(description).__name__}\"\n    description = description.strip()\n    if description:\n        if \"<\" in description or \">\" in description:\n            return False, \"Description cannot contain angle brackets (< or >)\"\n        if len(description) > 1024:\n            return (\n                False,\n                f\"Description is too long ({len(description)} characters). Maximum is 1024 characters.\",\n            )\n\n    return True, \"Skill is valid!\"",
    "start_line": 15,
    "end_line": 91,
    "has_docstring": true,
    "docstring": "Basic validation of a skill",
    "parameters": [
      "skill_path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_skill",
    "component_id": ".codex.skills..system.skill-creator.scripts.quick_validate.validate_skill"
  },
  ".codex.skills..system.skill-installer.scripts.github_utils.github_request": {
    "id": ".codex.skills..system.skill-installer.scripts.github_utils.github_request",
    "name": "github_request",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/github_utils.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/github_utils.py",
    "depends_on": [
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "def github_request(url: str, user_agent: str) -> bytes:\n    headers = {\"User-Agent\": user_agent}\n    token = os.environ.get(\"GITHUB_TOKEN\") or os.environ.get(\"GH_TOKEN\")\n    if token:\n        headers[\"Authorization\"] = f\"token {token}\"\n    req = urllib.request.Request(url, headers=headers)\n    with urllib.request.urlopen(req) as resp:\n        return resp.read()",
    "start_line": 10,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "user_agent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function github_request",
    "component_id": ".codex.skills..system.skill-installer.scripts.github_utils.github_request"
  },
  ".codex.skills..system.skill-installer.scripts.github_utils.github_api_contents_url": {
    "id": ".codex.skills..system.skill-installer.scripts.github_utils.github_api_contents_url",
    "name": "github_api_contents_url",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/github_utils.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/github_utils.py",
    "depends_on": [],
    "source_code": "def github_api_contents_url(repo: str, path: str, ref: str) -> str:\n    return f\"https://api.github.com/repos/{repo}/contents/{path}?ref={ref}\"",
    "start_line": 20,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repo",
      "path",
      "ref"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function github_api_contents_url",
    "component_id": ".codex.skills..system.skill-installer.scripts.github_utils.github_api_contents_url"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Args": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Args",
    "name": "Args",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [],
    "source_code": "class Args:\n    url: str | None = None\n    repo: str | None = None\n    path: list[str] | None = None\n    ref: str = DEFAULT_REF\n    dest: str | None = None\n    name: str | None = None\n    method: str = \"auto\"",
    "start_line": 22,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class Args",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Args"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Source": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Source",
    "name": "Source",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [],
    "source_code": "class Source:\n    owner: str\n    repo: str\n    ref: str\n    paths: list[str]\n    repo_url: str | None = None",
    "start_line": 33,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class Source",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Source"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError",
    "name": "InstallError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [],
    "source_code": "class InstallError(Exception):\n    pass",
    "start_line": 41,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Exception"
    ],
    "class_name": null,
    "display_name": "class InstallError",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._codex_home": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._codex_home",
    "name": "_codex_home",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "def _codex_home() -> str:\n    return os.environ.get(\"CODEX_HOME\", os.path.expanduser(\"~/.codex\"))",
    "start_line": 45,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _codex_home",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._codex_home"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._tmp_root": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._tmp_root",
    "name": "_tmp_root",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [],
    "source_code": "def _tmp_root() -> str:\n    base = os.path.join(tempfile.gettempdir(), \"codex\")\n    os.makedirs(base, exist_ok=True)\n    return base",
    "start_line": 49,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _tmp_root",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._tmp_root"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._request": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._request",
    "name": "_request",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.github_utils.github_request"
    ],
    "source_code": "def _request(url: str) -> bytes:\n    return github_request(url, \"codex-skill-install\")",
    "start_line": 55,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _request",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._request"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_github_url": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_github_url",
    "name": "_parse_github_url",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _parse_github_url(url: str, default_ref: str) -> tuple[str, str, str, str | None]:\n    parsed = urllib.parse.urlparse(url)\n    if parsed.netloc != \"github.com\":\n        raise InstallError(\"Only GitHub URLs are supported for download mode.\")\n    parts = [p for p in parsed.path.split(\"/\") if p]\n    if len(parts) < 2:\n        raise InstallError(\"Invalid GitHub URL.\")\n    owner, repo = parts[0], parts[1]\n    ref = default_ref\n    subpath = \"\"\n    if len(parts) > 2:\n        if parts[2] in (\"tree\", \"blob\"):\n            if len(parts) < 4:\n                raise InstallError(\"GitHub URL missing ref or path.\")\n            ref = parts[3]\n            subpath = \"/\".join(parts[4:])\n        else:\n            subpath = \"/\".join(parts[2:])\n    return owner, repo, ref, subpath or None",
    "start_line": 59,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "default_ref"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _parse_github_url",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_github_url"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._download_repo_zip": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._download_repo_zip",
    "name": "_download_repo_zip",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._safe_extract_zip",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._request"
    ],
    "source_code": "def _download_repo_zip(owner: str, repo: str, ref: str, dest_dir: str) -> str:\n    zip_url = f\"https://codeload.github.com/{owner}/{repo}/zip/{ref}\"\n    zip_path = os.path.join(dest_dir, \"repo.zip\")\n    try:\n        payload = _request(zip_url)\n    except urllib.error.HTTPError as exc:\n        raise InstallError(f\"Download failed: HTTP {exc.code}\") from exc\n    with open(zip_path, \"wb\") as file_handle:\n        file_handle.write(payload)\n    with zipfile.ZipFile(zip_path, \"r\") as zip_file:\n        _safe_extract_zip(zip_file, dest_dir)\n        top_levels = {name.split(\"/\")[0] for name in zip_file.namelist() if name}\n    if not top_levels:\n        raise InstallError(\"Downloaded archive was empty.\")\n    if len(top_levels) != 1:\n        raise InstallError(\"Unexpected archive layout.\")\n    return os.path.join(dest_dir, next(iter(top_levels)))",
    "start_line": 80,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "owner",
      "repo",
      "ref",
      "dest_dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _download_repo_zip",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._download_repo_zip"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._run_git": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._run_git",
    "name": "_run_git",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _run_git(args: list[str]) -> None:\n    result = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    if result.returncode != 0:\n        raise InstallError(result.stderr.strip() or \"Git command failed.\")",
    "start_line": 99,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _run_git",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._run_git"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._safe_extract_zip": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._safe_extract_zip",
    "name": "_safe_extract_zip",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _safe_extract_zip(zip_file: zipfile.ZipFile, dest_dir: str) -> None:\n    dest_root = os.path.realpath(dest_dir)\n    for info in zip_file.infolist():\n        extracted_path = os.path.realpath(os.path.join(dest_dir, info.filename))\n        if extracted_path == dest_root or extracted_path.startswith(dest_root + os.sep):\n            continue\n        raise InstallError(\"Archive contains files outside the destination.\")\n    zip_file.extractall(dest_dir)",
    "start_line": 105,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "zip_file",
      "dest_dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _safe_extract_zip",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._safe_extract_zip"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_relative_path": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_relative_path",
    "name": "_validate_relative_path",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _validate_relative_path(path: str) -> None:\n    if os.path.isabs(path) or os.path.normpath(path).startswith(\"..\"):\n        raise InstallError(\"Skill path must be a relative path inside the repo.\")",
    "start_line": 115,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _validate_relative_path",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_relative_path"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill_name": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill_name",
    "name": "_validate_skill_name",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _validate_skill_name(name: str) -> None:\n    altsep = os.path.altsep\n    if not name or os.path.sep in name or (altsep and altsep in name):\n        raise InstallError(\"Skill name must be a single path segment.\")\n    if name in (\".\", \"..\"):\n        raise InstallError(\"Invalid skill name.\")",
    "start_line": 120,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _validate_skill_name",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill_name"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._git_sparse_checkout": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._git_sparse_checkout",
    "name": "_git_sparse_checkout",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._run_git"
    ],
    "source_code": "def _git_sparse_checkout(repo_url: str, ref: str, paths: list[str], dest_dir: str) -> str:\n    repo_dir = os.path.join(dest_dir, \"repo\")\n    clone_cmd = [\n        \"git\",\n        \"clone\",\n        \"--filter=blob:none\",\n        \"--depth\",\n        \"1\",\n        \"--sparse\",\n        \"--single-branch\",\n        \"--branch\",\n        ref,\n        repo_url,\n        repo_dir,\n    ]\n    try:\n        _run_git(clone_cmd)\n    except InstallError:\n        _run_git(\n            [\n                \"git\",\n                \"clone\",\n                \"--filter=blob:none\",\n                \"--depth\",\n                \"1\",\n                \"--sparse\",\n                \"--single-branch\",\n                repo_url,\n                repo_dir,\n            ]\n        )\n    _run_git([\"git\", \"-C\", repo_dir, \"sparse-checkout\", \"set\", *paths])\n    _run_git([\"git\", \"-C\", repo_dir, \"checkout\", ref])\n    return repo_dir",
    "start_line": 128,
    "end_line": 161,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repo_url",
      "ref",
      "paths",
      "dest_dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _git_sparse_checkout",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._git_sparse_checkout"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill",
    "name": "_validate_skill",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _validate_skill(path: str) -> None:\n    if not os.path.isdir(path):\n        raise InstallError(f\"Skill path not found: {path}\")\n    skill_md = os.path.join(path, \"SKILL.md\")\n    if not os.path.isfile(skill_md):\n        raise InstallError(\"SKILL.md not found in selected skill directory.\")",
    "start_line": 164,
    "end_line": 169,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _validate_skill",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._copy_skill": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._copy_skill",
    "name": "_copy_skill",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      "src.providers.steering-explorer-provider.exists",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _copy_skill(src: str, dest_dir: str) -> None:\n    os.makedirs(os.path.dirname(dest_dir), exist_ok=True)\n    if os.path.exists(dest_dir):\n        raise InstallError(f\"Destination already exists: {dest_dir}\")\n    shutil.copytree(src, dest_dir)",
    "start_line": 172,
    "end_line": 176,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "src",
      "dest_dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _copy_skill",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._copy_skill"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_url": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_url",
    "name": "_build_repo_url",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [],
    "source_code": "def _build_repo_url(owner: str, repo: str) -> str:\n    return f\"https://github.com/{owner}/{repo}.git\"",
    "start_line": 179,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "owner",
      "repo"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _build_repo_url",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_url"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_ssh": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_ssh",
    "name": "_build_repo_ssh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [],
    "source_code": "def _build_repo_ssh(owner: str, repo: str) -> str:\n    return f\"git@github.com:{owner}/{repo}.git\"",
    "start_line": 183,
    "end_line": 184,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "owner",
      "repo"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _build_repo_ssh",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_ssh"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._prepare_repo": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._prepare_repo",
    "name": "_prepare_repo",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._git_sparse_checkout",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._download_repo_zip",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_url",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._build_repo_ssh",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _prepare_repo(source: Source, method: str, tmp_dir: str) -> str:\n    if method in (\"download\", \"auto\"):\n        try:\n            return _download_repo_zip(source.owner, source.repo, source.ref, tmp_dir)\n        except InstallError as exc:\n            if method == \"download\":\n                raise\n            err_msg = str(exc)\n            if \"HTTP 401\" in err_msg or \"HTTP 403\" in err_msg or \"HTTP 404\" in err_msg:\n                pass\n            else:\n                raise\n    if method in (\"git\", \"auto\"):\n        repo_url = source.repo_url or _build_repo_url(source.owner, source.repo)\n        try:\n            return _git_sparse_checkout(repo_url, source.ref, source.paths, tmp_dir)\n        except InstallError:\n            repo_url = _build_repo_ssh(source.owner, source.repo)\n            return _git_sparse_checkout(repo_url, source.ref, source.paths, tmp_dir)\n    raise InstallError(\"Unsupported method.\")",
    "start_line": 187,
    "end_line": 206,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "source",
      "method",
      "tmp_dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _prepare_repo",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._prepare_repo"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._resolve_source": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._resolve_source",
    "name": "_resolve_source",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Source",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._resolve_source",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Args",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_github_url",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError"
    ],
    "source_code": "def _resolve_source(args: Args) -> Source:\n    if args.url:\n        owner, repo, ref, url_path = _parse_github_url(args.url, args.ref)\n        if args.path is not None:\n            paths = list(args.path)\n        elif url_path:\n            paths = [url_path]\n        else:\n            paths = []\n        if not paths:\n            raise InstallError(\"Missing --path for GitHub URL.\")\n        return Source(owner=owner, repo=repo, ref=ref, paths=paths)\n\n    if not args.repo:\n        raise InstallError(\"Provide --repo or --url.\")\n    if \"://\" in args.repo:\n        return _resolve_source(\n            Args(url=args.repo, repo=None, path=args.path, ref=args.ref)\n        )\n\n    repo_parts = [p for p in args.repo.split(\"/\") if p]\n    if len(repo_parts) != 2:\n        raise InstallError(\"--repo must be in owner/repo format.\")\n    if not args.path:\n        raise InstallError(\"Missing --path for --repo.\")\n    paths = list(args.path)\n    return Source(\n        owner=repo_parts[0],\n        repo=repo_parts[1],\n        ref=args.ref,\n        paths=paths,\n    )",
    "start_line": 209,
    "end_line": 240,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _resolve_source",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._resolve_source"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._default_dest": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._default_dest",
    "name": "_default_dest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._codex_home"
    ],
    "source_code": "def _default_dest() -> str:\n    return os.path.join(_codex_home(), \"skills\")",
    "start_line": 243,
    "end_line": 244,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _default_dest",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._default_dest"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_args": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_args",
    "name": "_parse_args",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.Args"
    ],
    "source_code": "def _parse_args(argv: list[str]) -> Args:\n    parser = argparse.ArgumentParser(description=\"Install a skill from GitHub.\")\n    parser.add_argument(\"--repo\", help=\"owner/repo\")\n    parser.add_argument(\"--url\", help=\"https://github.com/owner/repo[/tree/ref/path]\")\n    parser.add_argument(\n        \"--path\",\n        nargs=\"+\",\n        help=\"Path(s) to skill(s) inside repo\",\n    )\n    parser.add_argument(\"--ref\", default=DEFAULT_REF)\n    parser.add_argument(\"--dest\", help=\"Destination skills directory\")\n    parser.add_argument(\n        \"--name\", help=\"Destination skill name (defaults to basename of path)\"\n    )\n    parser.add_argument(\n        \"--method\",\n        choices=[\"auto\", \"download\", \"git\"],\n        default=\"auto\",\n    )\n    return parser.parse_args(argv, namespace=Args())",
    "start_line": 247,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "argv"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _parse_args",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_args"
  },
  ".codex.skills..system.skill-installer.scripts.install-skill-from-github.main": {
    "id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/install-skill-from-github.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill_name",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github.InstallError",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._resolve_source",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._parse_args",
      "src.providers.steering-explorer-provider.exists",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_relative_path",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._prepare_repo",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._copy_skill",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._validate_skill",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._default_dest",
      ".codex.skills..system.skill-installer.scripts.install-skill-from-github._tmp_root"
    ],
    "source_code": "def main(argv: list[str]) -> int:\n    args = _parse_args(argv)\n    try:\n        source = _resolve_source(args)\n        source.ref = source.ref or args.ref\n        if not source.paths:\n            raise InstallError(\"No skill paths provided.\")\n        for path in source.paths:\n            _validate_relative_path(path)\n        dest_root = args.dest or _default_dest()\n        tmp_dir = tempfile.mkdtemp(prefix=\"skill-install-\", dir=_tmp_root())\n        try:\n            repo_root = _prepare_repo(source, args.method, tmp_dir)\n            installed = []\n            for path in source.paths:\n                skill_name = args.name if len(source.paths) == 1 else None\n                skill_name = skill_name or os.path.basename(path.rstrip(\"/\"))\n                _validate_skill_name(skill_name)\n                if not skill_name:\n                    raise InstallError(\"Unable to derive skill name.\")\n                dest_dir = os.path.join(dest_root, skill_name)\n                if os.path.exists(dest_dir):\n                    raise InstallError(f\"Destination already exists: {dest_dir}\")\n                skill_src = os.path.join(repo_root, path)\n                _validate_skill(skill_src)\n                _copy_skill(skill_src, dest_dir)\n                installed.append((skill_name, dest_dir))\n        finally:\n            if os.path.isdir(tmp_dir):\n                shutil.rmtree(tmp_dir, ignore_errors=True)\n        for skill_name, dest_dir in installed:\n            print(f\"Installed {skill_name} to {dest_dir}\")\n        return 0\n    except InstallError as exc:\n        print(f\"Error: {exc}\", file=sys.stderr)\n        return 1",
    "start_line": 269,
    "end_line": 304,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "argv"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": ".codex.skills..system.skill-installer.scripts.install-skill-from-github.main"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills.ListError": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills.ListError",
    "name": "ListError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [],
    "source_code": "class ListError(Exception):\n    pass",
    "start_line": 19,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Exception"
    ],
    "class_name": null,
    "display_name": "class ListError",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills.ListError"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills.Args": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills.Args",
    "name": "Args",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [],
    "source_code": "class Args(argparse.Namespace):\n    repo: str\n    path: str\n    ref: str\n    format: str",
    "start_line": 23,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "argparse.Namespace"
    ],
    "class_name": null,
    "display_name": "class Args",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills.Args"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills._request": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._request",
    "name": "_request",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.github_utils.github_request"
    ],
    "source_code": "def _request(url: str) -> bytes:\n    return github_request(url, \"codex-skill-list\")",
    "start_line": 30,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _request",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._request"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills._codex_home": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._codex_home",
    "name": "_codex_home",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "def _codex_home() -> str:\n    return os.environ.get(\"CODEX_HOME\", os.path.expanduser(\"~/.codex\"))",
    "start_line": 34,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _codex_home",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._codex_home"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills._installed_skills": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._installed_skills",
    "name": "_installed_skills",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.list-curated-skills._codex_home"
    ],
    "source_code": "def _installed_skills() -> set[str]:\n    root = os.path.join(_codex_home(), \"skills\")\n    if not os.path.isdir(root):\n        return set()\n    entries = set()\n    for name in os.listdir(root):\n        path = os.path.join(root, name)\n        if os.path.isdir(path):\n            entries.add(name)\n    return entries",
    "start_line": 38,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _installed_skills",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._installed_skills"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills._list_curated": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._list_curated",
    "name": "_list_curated",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.github_utils.github_api_contents_url",
      ".codex.skills..system.skill-installer.scripts.list-curated-skills._request",
      ".codex.skills..system.skill-installer.scripts.list-curated-skills.ListError",
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "def _list_curated(repo: str, path: str, ref: str) -> list[str]:\n    api_url = github_api_contents_url(repo, path, ref)\n    try:\n        payload = _request(api_url)\n    except urllib.error.HTTPError as exc:\n        if exc.code == 404:\n            raise ListError(\n                \"Curated skills path not found: \"\n                f\"https://github.com/{repo}/tree/{ref}/{path}\"\n            ) from exc\n        raise ListError(f\"Failed to fetch curated skills: HTTP {exc.code}\") from exc\n    data = json.loads(payload.decode(\"utf-8\"))\n    if not isinstance(data, list):\n        raise ListError(\"Unexpected curated listing response.\")\n    skills = [item[\"name\"] for item in data if item.get(\"type\") == \"dir\"]\n    return sorted(skills)",
    "start_line": 50,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repo",
      "path",
      "ref"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _list_curated",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._list_curated"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills._parse_args": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._parse_args",
    "name": "_parse_args",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.list-curated-skills.Args"
    ],
    "source_code": "def _parse_args(argv: list[str]) -> Args:\n    parser = argparse.ArgumentParser(description=\"List curated skills.\")\n    parser.add_argument(\"--repo\", default=DEFAULT_REPO)\n    parser.add_argument(\"--path\", default=DEFAULT_PATH)\n    parser.add_argument(\"--ref\", default=DEFAULT_REF)\n    parser.add_argument(\n        \"--format\",\n        choices=[\"text\", \"json\"],\n        default=\"text\",\n        help=\"Output format\",\n    )\n    return parser.parse_args(argv, namespace=Args())",
    "start_line": 68,
    "end_line": 79,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "argv"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _parse_args",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills._parse_args"
  },
  ".codex.skills..system.skill-installer.scripts.list-curated-skills.main": {
    "id": ".codex.skills..system.skill-installer.scripts.list-curated-skills.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/.codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "relative_path": ".codex/skills/.system/skill-installer/scripts/list-curated-skills.py",
    "depends_on": [
      ".codex.skills..system.skill-installer.scripts.list-curated-skills._installed_skills",
      ".codex.skills..system.skill-installer.scripts.list-curated-skills._parse_args",
      ".codex.skills..system.skill-installer.scripts.list-curated-skills._list_curated"
    ],
    "source_code": "def main(argv: list[str]) -> int:\n    args = _parse_args(argv)\n    try:\n        skills = _list_curated(args.repo, args.path, args.ref)\n        installed = _installed_skills()\n        if args.format == \"json\":\n            payload = [\n                {\"name\": name, \"installed\": name in installed} for name in skills\n            ]\n            print(json.dumps(payload))\n        else:\n            for idx, name in enumerate(skills, start=1):\n                suffix = \" (already installed)\" if name in installed else \"\"\n                print(f\"{idx}. {name}{suffix}\")\n        return 0\n    except ListError as exc:\n        print(f\"Error: {exc}\", file=sys.stderr)\n        return 1",
    "start_line": 82,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "argv"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": ".codex.skills..system.skill-installer.scripts.list-curated-skills.main"
  },
  "scripts.build-prompts.findMarkdownFiles": {
    "id": "scripts.build-prompts.findMarkdownFiles",
    "name": "findMarkdownFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [
      "scripts.build-prompts.walk"
    ],
    "source_code": "function findMarkdownFiles(dir) {\n\tconst files = [];\n\n\tfunction walk(currentDir) {\n\t\tconst entries = fs.readdirSync(currentDir);\n\n\t\tfor (const entry of entries) {\n\t\t\tconst fullPath = path.join(currentDir, entry);\n\t\t\tconst stat = fs.statSync(fullPath);\n\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\twalk(fullPath);\n\t\t\t} else if (entry.endsWith(\".md\")) {\n\t\t\t\tfiles.push(fullPath);\n\t\t\t}\n\t\t}\n\t}\n\n\twalk(dir);\n\treturn files;\n}",
    "start_line": 10,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findMarkdownFiles",
    "component_id": "scripts.build-prompts.findMarkdownFiles"
  },
  "scripts.build-prompts.walk": {
    "id": "scripts.build-prompts.walk",
    "name": "walk",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [
      "scripts.build-prompts.walk"
    ],
    "source_code": "function walk(dir) {\n\t\tconst entries = fs.readdirSync(dir);\n\t\tconst files = [];\n\t\tfor (const entry of entries) {\n\t\t\tconst full = path.join(dir, entry);\n\t\t\tconst stat = fs.statSync(full);\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tfiles.push(...walk(full));\n\t\t\t} else if (\n\t\t\t\tstat.isFile() &&\n\t\t\t\tentry.endsWith(\".ts\") &&\n\t\t\t\tentry !== \"index.ts\"\n\t\t\t) {\n\t\t\t\tfiles.push(full);\n\t\t\t}\n\t\t}\n\t\treturn files;\n\t}",
    "start_line": 80,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function walk",
    "component_id": "scripts.build-prompts.walk"
  },
  "scripts.build-prompts.convertMarkdownToTypeScript": {
    "id": "scripts.build-prompts.convertMarkdownToTypeScript",
    "name": "convertMarkdownToTypeScript",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [],
    "source_code": "function convertMarkdownToTypeScript(mdPath, outputDir) {\n\tconst content = fs.readFileSync(mdPath, \"utf8\");\n\tconst { data, content: body } = matter(content);\n\t// Normalize body newlines to LF to ensure consistent output across OSes\n\tconst normalizedBody = body.replace(/\\r\\n/g, \"\\n\");\n\t// Normalize the displayed source path to POSIX-style (forward slashes)\n\tconst displayMdPath = path\n\t\t.relative(process.cwd(), mdPath)\n\t\t.split(path.sep)\n\t\t.join(\"/\");\n\n\t// Generate TypeScript code\n\tconst tsContent = `// Auto-generated from ${displayMdPath}\n// DO NOT EDIT MANUALLY\n\nexport const frontmatter = ${JSON.stringify(data, null, 2)};\n\nexport const content = ${JSON.stringify(normalizedBody)};\n\nexport default {\n  frontmatter,\n  content\n};\n`;\n\n\t// Calculate output path - maintain relative directory structure\n\tconst promptsDir = path.join(__dirname, \"..\", \"src\", \"prompts\");\n\tconst relativePath = path.relative(promptsDir, mdPath);\n\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\tconst tsFileName = relativePath.replace(/\\.md$/, \".ts\");\n\tconst tsPath = path.join(outputDir, tsFileName);\n\n\t// Ensure output directory exists\n\tconst tsDir = path.dirname(tsPath);\n\tif (!fs.existsSync(tsDir)) {\n\t\tfs.mkdirSync(tsDir, { recursive: true });\n\t}\n\n\t// Write file with LF line endings regardless of host OS\n\tconst tsContentLf = tsContent.replace(/\\r\\n/g, \"\\n\");\n\tfs.writeFileSync(tsPath, tsContentLf, { encoding: \"utf8\" });\n\tconsole.log(`Generated: ${path.relative(process.cwd(), tsPath)}`);\n}",
    "start_line": 33,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mdPath",
      "outputDir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convertMarkdownToTypeScript",
    "component_id": "scripts.build-prompts.convertMarkdownToTypeScript"
  },
  "scripts.build-prompts.generateIndex": {
    "id": "scripts.build-prompts.generateIndex",
    "name": "generateIndex",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [
      "scripts.build-prompts.relFromOutput",
      "scripts.build-prompts.toCamel",
      "scripts.build-prompts.walk"
    ],
    "source_code": "function generateIndex(outputDir) {\n\t// Collect all .ts files under outputDir (recursively), excluding index.ts\n\tfunction walk(dir) {\n\t\tconst entries = fs.readdirSync(dir);\n\t\tconst files = [];\n\t\tfor (const entry of entries) {\n\t\t\tconst full = path.join(dir, entry);\n\t\t\tconst stat = fs.statSync(full);\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tfiles.push(...walk(full));\n\t\t\t} else if (\n\t\t\t\tstat.isFile() &&\n\t\t\t\tentry.endsWith(\".ts\") &&\n\t\t\t\tentry !== \"index.ts\"\n\t\t\t) {\n\t\t\t\tfiles.push(full);\n\t\t\t}\n\t\t}\n\t\treturn files;\n\t}\n\n\tconst files = walk(outputDir);\n\n\t// Create export lines with stable camelCase aliases\n\tconst toCamel = (filePath) => {\n\t\tlet name = path.basename(filePath, \".ts\");\n\t\t// Remove .prompt suffix if present to avoid \"Prompt\" in the alias\n\t\tif (name.endsWith(\".prompt\")) {\n\t\t\tname = name.slice(0, -7);\n\t\t}\n\t\treturn name\n\t\t\t.split(SEPARATOR_REGEX)\n\t\t\t.map((seg, i) =>\n\t\t\t\ti === 0 ? seg : seg.charAt(0).toUpperCase() + seg.slice(1)\n\t\t\t)\n\t\t\t.join(\"\");\n\t};\n\n\tconst relFromOutput = (absPath) => {\n\t\tconst rel = path.relative(outputDir, absPath).split(path.sep).join(\"/\");\n\t\treturn `./${\n\t\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\t\trel.replace(/\\.ts$/, \"\")\n\t\t}`;\n\t};\n\n\tconst lines = [\n\t\t\"// Auto-generated index file\",\n\t\t\"// Re-export all prompt modules\",\n\t\t\"\",\n\t];\n\n\t// Ensure deterministic ordering\n\tfiles.sort((a, b) => a.localeCompare(b));\n\n\tfor (const file of files) {\n\t\tconst alias = toCamel(file);\n\t\tconst modulePath = relFromOutput(file);\n\t\tlines.push(`export { default as ${alias} } from '${modulePath}';`);\n\t}\n\n\tconst indexPath = path.join(outputDir, \"index.ts\");\n\tconst content = `${lines.join(\"\\n\")}\\n`;\n\tfs.writeFileSync(indexPath, content, { encoding: \"utf8\" });\n\tconsole.log(`Generated index: ${path.relative(process.cwd(), indexPath)}`);\n}",
    "start_line": 78,
    "end_line": 143,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "outputDir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateIndex",
    "component_id": "scripts.build-prompts.generateIndex"
  },
  "scripts.build-prompts.toCamel": {
    "id": "scripts.build-prompts.toCamel",
    "name": "toCamel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [],
    "source_code": "toCamel = (filePath) => {\n\t\tlet name = path.basename(filePath, \".ts\");\n\t\t// Remove .prompt suffix if present to avoid \"Prompt\" in the alias\n\t\tif (name.endsWith(\".prompt\")) {\n\t\t\tname = name.slice(0, -7);\n\t\t}\n\t\treturn name\n\t\t\t.split(SEPARATOR_REGEX)\n\t\t\t.map((seg, i) =>\n\t\t\t\ti === 0 ? seg : seg.charAt(0).toUpperCase() + seg.slice(1)\n\t\t\t)\n\t\t\t.join(\"\");\n\t}",
    "start_line": 102,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toCamel",
    "component_id": "scripts.build-prompts.toCamel"
  },
  "scripts.build-prompts.relFromOutput": {
    "id": "scripts.build-prompts.relFromOutput",
    "name": "relFromOutput",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [],
    "source_code": "relFromOutput = (absPath) => {\n\t\tconst rel = path.relative(outputDir, absPath).split(path.sep).join(\"/\");\n\t\treturn `./${\n\t\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\t\trel.replace(/\\.ts$/, \"\")\n\t\t}`;\n\t}",
    "start_line": 116,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "absPath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function relFromOutput",
    "component_id": "scripts.build-prompts.relFromOutput"
  },
  "scripts.build-prompts.main": {
    "id": "scripts.build-prompts.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/scripts/build-prompts.js",
    "relative_path": "scripts/build-prompts.js",
    "depends_on": [
      "scripts.build-prompts.convertMarkdownToTypeScript",
      "scripts.build-prompts.generateIndex",
      "scripts.build-prompts.findMarkdownFiles"
    ],
    "source_code": "function main() {\n\tconst promptsDir = path.join(__dirname, \"..\", \"src\", \"prompts\");\n\tconst outputDir = path.join(__dirname, \"..\", \"src\", \"prompts\", \"target\");\n\n\t// Ensure directory exists\n\tif (!fs.existsSync(promptsDir)) {\n\t\tconsole.log(\"Creating prompts directory...\");\n\t\tfs.mkdirSync(promptsDir, { recursive: true });\n\t}\n\n\t// Ensure output directory exists\n\tif (!fs.existsSync(outputDir)) {\n\t\tconsole.log(\"Creating prompts target directory...\");\n\t\tfs.mkdirSync(outputDir, { recursive: true });\n\t}\n\n\t// Find and convert all Markdown files\n\tconst mdFiles = findMarkdownFiles(promptsDir);\n\n\tif (mdFiles.length === 0) {\n\t\tconsole.log(\"No markdown files found in\", promptsDir);\n\t\treturn;\n\t}\n\n\tconsole.log(`Converting ${mdFiles.length} markdown files...`);\n\t// biome-ignore lint/complexity/noForEach: ignore\n\t// biome-ignore lint/suspicious/useIterableCallbackReturn: ignore\n\tmdFiles.forEach((mdFile) => convertMarkdownToTypeScript(mdFile, outputDir));\n\n\t// After generating modules, rebuild index to include all prompts\n\tgenerateIndex(outputDir);\n\n\tconsole.log(\"Build complete!\");\n}",
    "start_line": 146,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "scripts.build-prompts.main"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.ServerStatus": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ServerStatus",
    "name": "ServerStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "type ServerStatus = \"available\" | \"unavailable\" | \"unknown\";",
    "start_line": 12,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ServerStatus",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ServerStatus"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServer": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServer",
    "name": "MCPServer",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTool",
      "specs.005-mcp-hooks-integration.contracts.mcp-service.ServerStatus"
    ],
    "source_code": "interface MCPServer {\n\tid: string;\n\tname: string;\n\tdescription?: string;\n\tstatus: ServerStatus;\n\ttools: MCPTool[];\n\tlastDiscovered: number;\n}",
    "start_line": 14,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServer",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServer"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTool": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTool",
    "name": "MCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchema"
    ],
    "source_code": "interface MCPTool {\n\tname: string;\n\tdisplayName: string;\n\tdescription: string;\n\tinputSchema: JSONSchema;\n\tserverId: string;\n}",
    "start_line": 23,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPTool",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTool"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchema": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchema",
    "name": "JSONSchema",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchemaProperty"
    ],
    "source_code": "interface JSONSchema {\n\ttype: string;\n\tproperties?: Record<string, JSONSchemaProperty>;\n\trequired?: string[];\n}",
    "start_line": 31,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchema",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchema"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchemaProperty": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchemaProperty",
    "name": "JSONSchemaProperty",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "interface JSONSchemaProperty {\n\ttype: string;\n\tdescription?: string;\n\tenum?: unknown[];\n\tdefault?: unknown;\n}",
    "start_line": 37,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchemaProperty",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.JSONSchemaProperty"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterMapping": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterMapping",
    "name": "ParameterMapping",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "interface ParameterMapping {\n\ttoolParam: string;\n\tsource: \"context\" | \"literal\" | \"template\";\n\tvalue: string;\n}",
    "start_line": 44,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterMapping",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterMapping"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPDiscoveryService": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPDiscoveryService",
    "name": "IMCPDiscoveryService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServer",
      "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTool"
    ],
    "source_code": "interface IMCPDiscoveryService {\n\t/**\n\t * Discover all MCP servers configured in Copilot\n\t * @param forceRefresh - Skip cache and force fresh discovery\n\t * @returns Promise resolving to array of MCP servers with their tools\n\t */\n\tdiscoverServers(forceRefresh?: boolean): Promise<MCPServer[]>;\n\n\t/**\n\t * Get a specific MCP server by ID\n\t * @param serverId - Server identifier\n\t * @returns Promise resolving to server or undefined if not found\n\t */\n\tgetServer(serverId: string): Promise<MCPServer | undefined>;\n\n\t/**\n\t * Get a specific tool from a server\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool name\n\t * @returns Promise resolving to tool or undefined if not found\n\t */\n\tgetTool(serverId: string, toolName: string): Promise<MCPTool | undefined>;\n\n\t/**\n\t * Clear the discovery cache\n\t */\n\tclearCache(): void;\n\n\t/**\n\t * Check if cache is fresh\n\t */\n\tisCacheFresh(): boolean;\n}",
    "start_line": 57,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPDiscoveryService",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPDiscoveryService"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPClientService": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPClientService",
    "name": "IMCPClientService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolExecutionResult",
      "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationResult"
    ],
    "source_code": "interface IMCPClientService {\n\t/**\n\t * Execute an MCP tool with resolved parameters\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool to execute\n\t * @param parameters - Resolved parameter values (JSON object)\n\t * @param timeout - Execution timeout in milliseconds\n\t * @returns Promise resolving to execution result\n\t */\n\texecuteTool(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>,\n\t\ttimeout?: number\n\t): Promise<MCPToolExecutionResult>;\n\n\t/**\n\t * Validate parameters against tool's input schema\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool name\n\t * @param parameters - Parameters to validate\n\t * @returns Validation result with errors if invalid\n\t */\n\tvalidateParameters(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>\n\t): Promise<ParameterValidationResult>;\n}",
    "start_line": 94,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPClientService",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPClientService"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPParameterResolver": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPParameterResolver",
    "name": "IMCPParameterResolver",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterMapping",
      "specs.005-mcp-hooks-integration.contracts.mcp-service.TemplateContext"
    ],
    "source_code": "interface IMCPParameterResolver {\n\t/**\n\t * Resolve parameter mappings using template context\n\t * @param mappings - Parameter mapping definitions\n\t * @param context - Template context (feature, branch, etc.)\n\t * @returns Resolved parameters as key-value pairs\n\t */\n\tresolve(\n\t\tmappings: ParameterMapping[],\n\t\tcontext: TemplateContext\n\t): Record<string, unknown>;\n\n\t/**\n\t * Resolve a single parameter mapping\n\t * @param mapping - Single parameter mapping\n\t * @param context - Template context\n\t * @returns Resolved value (string, number, boolean, etc.)\n\t */\n\tresolveSingle(mapping: ParameterMapping, context: TemplateContext): unknown;\n}",
    "start_line": 127,
    "end_line": 146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPParameterResolver",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPParameterResolver"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolExecutionResult": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolExecutionResult",
    "name": "MCPToolExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPExecutionError"
    ],
    "source_code": "interface MCPToolExecutionResult {\n\tsuccess: boolean;\n\toutput?: unknown;\n\terror?: MCPExecutionError;\n\tduration: number;\n}",
    "start_line": 152,
    "end_line": 157,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPToolExecutionResult",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolExecutionResult"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPExecutionError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPExecutionError",
    "name": "MCPExecutionError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "interface MCPExecutionError {\n\tcode: string;\n\tmessage: string;\n\tdetails?: unknown;\n}",
    "start_line": 159,
    "end_line": 163,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPExecutionError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPExecutionError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationResult": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationResult",
    "name": "ParameterValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationError"
    ],
    "source_code": "interface ParameterValidationResult {\n\tvalid: boolean;\n\terrors: ParameterValidationError[];\n}",
    "start_line": 165,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterValidationResult",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationResult"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationError",
    "name": "ParameterValidationError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "interface ParameterValidationError {\n\tparameter: string;\n\tmessage: string;\n\texpected?: string;\n\tactual?: string;\n}",
    "start_line": 170,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterValidationError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.TemplateContext": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.TemplateContext",
    "name": "TemplateContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "interface TemplateContext {\n\tfeature?: string;\n\tbranch?: string;\n\ttimestamp?: string;\n\tuser?: string;\n}",
    "start_line": 181,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateContext",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.TemplateContext"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPExecutionPool": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPExecutionPool",
    "name": "IMCPExecutionPool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.PoolStatus"
    ],
    "source_code": "interface IMCPExecutionPool {\n\t/**\n\t * Execute a task with concurrency control\n\t * @param task - Async task to execute\n\t * @returns Promise that resolves when task completes\n\t */\n\texecute<T>(task: () => Promise<T>): Promise<T>;\n\n\t/**\n\t * Get current pool status\n\t */\n\tgetStatus(): PoolStatus;\n\n\t/**\n\t * Wait for all queued tasks to complete\n\t */\n\tdrain(): Promise<void>;\n}",
    "start_line": 195,
    "end_line": 212,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPExecutionPool",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.IMCPExecutionPool"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.PoolStatus": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.PoolStatus",
    "name": "PoolStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "interface PoolStatus {\n\tactive: number;\n\tqueued: number;\n\tcapacity: number;\n}",
    "start_line": 214,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PoolStatus",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.PoolStatus"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServerNotFoundError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServerNotFoundError",
    "name": "MCPServerNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "class MCPServerNotFoundError extends Error {\n\tconstructor(serverId: string) {\n\t\tsuper(`MCP server not found: ${serverId}`);\n\t\tthis.name = \"MCPServerNotFoundError\";\n\t}\n}",
    "start_line": 224,
    "end_line": 229,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPServerNotFoundError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServerNotFoundError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolNotFoundError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolNotFoundError",
    "name": "MCPToolNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "class MCPToolNotFoundError extends Error {\n\tconstructor(serverId: string, toolName: string) {\n\t\tsuper(`MCP tool '${toolName}' not found on server '${serverId}'`);\n\t\tthis.name = \"MCPToolNotFoundError\";\n\t}\n}",
    "start_line": 231,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPToolNotFoundError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPToolNotFoundError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServerUnavailableError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServerUnavailableError",
    "name": "MCPServerUnavailableError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "class MCPServerUnavailableError extends Error {\n\tconstructor(serverId: string) {\n\t\tsuper(`MCP server unavailable: ${serverId}`);\n\t\tthis.name = \"MCPServerUnavailableError\";\n\t}\n}",
    "start_line": 238,
    "end_line": 243,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPServerUnavailableError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPServerUnavailableError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPParameterValidationError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPParameterValidationError",
    "name": "MCPParameterValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [
      "specs.005-mcp-hooks-integration.contracts.mcp-service.ParameterValidationError"
    ],
    "source_code": "class MCPParameterValidationError extends Error {\n\terrors: ParameterValidationError[];\n\n\tconstructor(errors: ParameterValidationError[]) {\n\t\tsuper(\n\t\t\t`Parameter validation failed: ${errors.map((e) => e.message).join(\", \")}`\n\t\t);\n\t\tthis.name = \"MCPParameterValidationError\";\n\t\tthis.errors = errors;\n\t}\n}",
    "start_line": 245,
    "end_line": 255,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPParameterValidationError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPParameterValidationError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTimeoutError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTimeoutError",
    "name": "MCPTimeoutError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "class MCPTimeoutError extends Error {\n\ttimeout: number;\n\n\tconstructor(timeout: number) {\n\t\tsuper(`MCP tool execution timed out after ${timeout}ms`);\n\t\tthis.name = \"MCPTimeoutError\";\n\t\tthis.timeout = timeout;\n\t}\n}",
    "start_line": 257,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPTimeoutError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPTimeoutError"
  },
  "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPDiscoveryError": {
    "id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPDiscoveryError",
    "name": "MCPDiscoveryError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "relative_path": "specs/005-mcp-hooks-integration/contracts/mcp-service.ts",
    "depends_on": [],
    "source_code": "class MCPDiscoveryError extends Error {\n\tcause?: Error;\n\n\tconstructor(message: string, cause?: Error) {\n\t\tsuper(message);\n\t\tthis.name = \"MCPDiscoveryError\";\n\t\tthis.cause = cause;\n\t}\n}",
    "start_line": 267,
    "end_line": 275,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPDiscoveryError",
    "component_id": "specs.005-mcp-hooks-integration.contracts.mcp-service.MCPDiscoveryError"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.ToolHandler": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolHandler",
    "name": "ToolHandler",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [
      "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionParams",
      "specs.010-copilot-agents.contracts.tool-handler-interface.ToolResponse"
    ],
    "source_code": "type ToolHandler = (\n\tparams: ToolExecutionParams\n) => Promise<ToolResponse>;",
    "start_line": 12,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ToolHandler",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolHandler"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionParams": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionParams",
    "name": "ToolExecutionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [
      "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionContext",
      "specs.010-copilot-agents.contracts.tool-handler-interface.AgentResources"
    ],
    "source_code": "interface ToolExecutionParams {\n\t/** User input after command (free-text string for custom parsing) */\n\tinput: string;\n\n\t/** Execution context with workspace info and VS Code APIs */\n\tcontext: ToolExecutionContext;\n\n\t/** Agent resources (prompts, skills, instructions) loaded from cache */\n\tresources: AgentResources;\n\n\t/** Cancellation token for long-running operations */\n\ttoken: vscode.CancellationToken;\n}",
    "start_line": 19,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolExecutionParams",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionParams"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionContext": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionContext",
    "name": "ToolExecutionContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [
      "specs.010-copilot-agents.contracts.tool-handler-interface.TelemetryReporter",
      "src.utils.chat-prompt-runner.ChatContext"
    ],
    "source_code": "interface ToolExecutionContext {\n\t/** Workspace information */\n\tworkspace: {\n\t\t/** Workspace root URI */\n\t\turi: vscode.Uri;\n\t\t/** Workspace name */\n\t\tname: string;\n\t\t/** All workspace folders */\n\t\tfolders: vscode.WorkspaceFolder[];\n\t};\n\n\t/** VS Code APIs */\n\tvscode: {\n\t\twindow: typeof vscode.window;\n\t\tworkspace: typeof vscode.workspace;\n\t\tcommands: typeof vscode.commands;\n\t};\n\n\t/** Chat context (history, references) */\n\tchatContext: vscode.ChatContext;\n\n\t/** Extension output channel for logging */\n\toutputChannel: vscode.OutputChannel;\n\n\t/** Telemetry reporter for metrics */\n\ttelemetry: TelemetryReporter;\n}",
    "start_line": 36,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolExecutionContext",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolExecutionContext"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.AgentResources": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.AgentResources",
    "name": "AgentResources",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [],
    "source_code": "interface AgentResources {\n\t/** Prompt templates indexed by filename */\n\tprompts: Map<string, string>;\n\n\t/** Domain knowledge packages indexed by filename */\n\tskills: Map<string, string>;\n\n\t/** Behavior guidelines indexed by filename */\n\tinstructions: Map<string, string>;\n}",
    "start_line": 67,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentResources",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.AgentResources"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.ToolResponse": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolResponse",
    "name": "ToolResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [
      "specs.010-copilot-agents.contracts.tool-handler-interface.FileReference",
      "specs.010-copilot-agents.contracts.tool-handler-interface.ResponseMetadata"
    ],
    "source_code": "interface ToolResponse {\n\t/** Markdown-formatted content to display in chat */\n\tcontent: string;\n\n\t/** Optional file references for navigation */\n\tfiles?: FileReference[];\n\n\t/** Optional metadata for telemetry and debugging */\n\tmetadata?: ResponseMetadata;\n}",
    "start_line": 81,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolResponse",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.ToolResponse"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.FileReference": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.FileReference",
    "name": "FileReference",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [],
    "source_code": "interface FileReference {\n\t/** File URI */\n\turi: vscode.Uri;\n\n\t/** Display label (defaults to filename if omitted) */\n\tlabel?: string;\n\n\t/** Action performed on file */\n\taction?: \"created\" | \"modified\" | \"deleted\";\n}",
    "start_line": 95,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FileReference",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.FileReference"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.ResponseMetadata": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.ResponseMetadata",
    "name": "ResponseMetadata",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [],
    "source_code": "interface ResponseMetadata {\n\t/** Execution duration in milliseconds */\n\tduration?: number;\n\n\t/** LLM tokens used (if applicable) */\n\ttokensUsed?: number;\n\n\t/** Custom metadata fields */\n\t[key: string]: any;\n}",
    "start_line": 109,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResponseMetadata",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.ResponseMetadata"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.TelemetryReporter": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.TelemetryReporter",
    "name": "TelemetryReporter",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [],
    "source_code": "interface TelemetryReporter {\n\tsendTelemetryEvent(\n\t\teventName: string,\n\t\tproperties?: { [key: string]: string },\n\t\tmeasurements?: { [key: string]: number }\n\t): void;\n\tsendTelemetryErrorEvent(\n\t\teventName: string,\n\t\tproperties?: { [key: string]: string },\n\t\tmeasurements?: { [key: string]: number }\n\t): void;\n}",
    "start_line": 123,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TelemetryReporter",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.TelemetryReporter"
  },
  "specs.010-copilot-agents.contracts.tool-handler-interface.exampleToolHandler": {
    "id": "specs.010-copilot-agents.contracts.tool-handler-interface.exampleToolHandler",
    "name": "exampleToolHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "relative_path": "specs/010-copilot-agents/contracts/tool-handler-interface.ts",
    "depends_on": [
      "specs.010-copilot-agents.contracts.tool-handler-interface.ToolHandler",
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "exampleToolHandler: ToolHandler = async (params) => {\n\tconst { input, context, resources, token } = params;\n\n\t// Check for cancellation\n\tif (token.isCancellationRequested) {\n\t\tthrow new Error(\"Operation cancelled\");\n\t}\n\n\t// Access resources\n\tconst prompt = resources.prompts.get(\"example.prompt.md\");\n\tif (!prompt) {\n\t\tthrow new Error(\"Required prompt not found\");\n\t}\n\n\t// Perform operation\n\tcontext.outputChannel.appendLine(`Executing with input: ${input}`);\n\n\t// Return response\n\treturn {\n\t\tcontent: \" Operation completed successfully\",\n\t\tfiles: [\n\t\t\t{\n\t\t\t\turi: vscode.Uri.file(\"/path/to/file\"),\n\t\t\t\tlabel: \"Generated file\",\n\t\t\t\taction: \"created\",\n\t\t\t},\n\t\t],\n\t\tmetadata: {\n\t\t\tduration: 150,\n\t\t},\n\t};\n}",
    "start_line": 139,
    "end_line": 170,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function exampleToolHandler",
    "component_id": "specs.010-copilot-agents.contracts.tool-handler-interface.exampleToolHandler"
  },
  "specs.010-copilot-agents.generate-issues-readonly.parse_tasks_from_file": {
    "id": "specs.010-copilot-agents.generate-issues-readonly.parse_tasks_from_file",
    "name": "parse_tasks_from_file",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues-readonly.py",
    "relative_path": "specs/010-copilot-agents/generate-issues-readonly.py",
    "depends_on": [],
    "source_code": "def parse_tasks_from_file(filepath: str):\n    \"\"\"Parse tasks.md and extract all tasks\"\"\"\n    with open(filepath, 'r') as f:\n        content = f.read()\n    \n    tasks = []\n    current_phase = \"Unknown\"\n    \n    lines = content.split('\\n')\n    for i, line in enumerate(lines):\n        # Track current phase\n        if line.startswith('## Phase'):\n            phase_match = re.search(r'Phase\\s+(\\d+)[:\\s]+(.+?)(?:\\s+\\(|$)', line)\n            if phase_match:\n                current_phase = f\"Phase {phase_match.group(1)}: {phase_match.group(2)}\"\n        \n        # Find task lines\n        task_match = re.match(r'^-\\s+\\[\\s*\\]\\s+(T\\d+)\\s+(.+)$', line)\n        if task_match:\n            task_id = task_match.group(1)\n            task_desc = task_match.group(2)\n            \n            # Determine labels\n            labels = [f\"feature:{FEATURE_NUMBER}\"]\n            \n            # Phase label\n            phase_num = re.search(r'Phase\\s+(\\d+)', current_phase)\n            if phase_num:\n                pn = int(phase_num.group(1))\n                if pn == 1:\n                    labels.append(\"phase:setup\")\n                elif pn == 2:\n                    labels.append(\"phase:foundational\")\n                elif pn <= 8:\n                    labels.append(\"phase:implementation\")\n                else:\n                    labels.append(\"phase:polish\")\n            \n            # Check for markers\n            if '[P]' in task_desc:\n                labels.append(\"parallel\")\n            \n            # User story\n            us_match = re.search(r'\\[US(\\d+)\\]', task_desc)\n            if us_match:\n                labels.append(f\"user-story:{us_match.group(1)}\")\n            \n            # Priority\n            if 'Priority: P1' in current_phase or ' MVP' in current_phase:\n                labels.append(\"priority:p1\")\n            elif 'Priority: P2' in current_phase:\n                labels.append(\"priority:p2\")\n            elif 'Priority: P3' in current_phase:\n                labels.append(\"priority:p3\")\n            elif 'CRITICAL' in current_phase or 'CRITICAL' in task_desc:\n                labels.append(\"priority:critical\")\n            \n            # Clean title\n            title = re.sub(r'\\[P\\]|\\[US\\d+\\]', '', task_desc).strip()\n            title = f\"[{task_id}] {title}\"\n            \n            # Build body\n            body = f\"\"\"**Phase**: {current_phase}\n**Task**: {task_id}\n**Feature**: {FEATURE_NUMBER}-{FEATURE_NAME}\n\n## Description\n{task_desc}\n\n## Reference\nFrom specs/{FEATURE_NUMBER}-{FEATURE_NAME}/tasks.md\n\"\"\"\n            \n            tasks.append({\n                'title': title[:80],  # GitHub limits\n                'body': body.replace('\\n', '\\\\n'),  # CSV escape\n                'labels': ','.join(labels),\n                'task_id': task_id,\n                'phase': current_phase,\n                'description': task_desc\n            })\n    \n    return tasks",
    "start_line": 16,
    "end_line": 98,
    "has_docstring": true,
    "docstring": "Parse tasks.md and extract all tasks",
    "parameters": [
      "filepath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_tasks_from_file",
    "component_id": "specs.010-copilot-agents.generate-issues-readonly.parse_tasks_from_file"
  },
  "specs.010-copilot-agents.generate-issues-readonly.generate_csv": {
    "id": "specs.010-copilot-agents.generate-issues-readonly.generate_csv",
    "name": "generate_csv",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues-readonly.py",
    "relative_path": "specs/010-copilot-agents/generate-issues-readonly.py",
    "depends_on": [],
    "source_code": "def generate_csv(tasks, output_file):\n    \"\"\"Generate CSV for GitHub bulk import\"\"\"\n    with open(output_file, 'w', newline='', encoding='utf-8') as f:\n        writer = csv.DictWriter(f, fieldnames=['title', 'body', 'labels'])\n        writer.writeheader()\n        for task in tasks:\n            writer.writerow({\n                'title': task['title'],\n                'body': task['body'],\n                'labels': task['labels']\n            })\n    print(f\" Created CSV file: {output_file}\")\n    print(f\"   You can import this via GitHub web UI\")",
    "start_line": 101,
    "end_line": 113,
    "has_docstring": true,
    "docstring": "Generate CSV for GitHub bulk import",
    "parameters": [
      "tasks",
      "output_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_csv",
    "component_id": "specs.010-copilot-agents.generate-issues-readonly.generate_csv"
  },
  "specs.010-copilot-agents.generate-issues-readonly.generate_markdown_checklist": {
    "id": "specs.010-copilot-agents.generate-issues-readonly.generate_markdown_checklist",
    "name": "generate_markdown_checklist",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues-readonly.py",
    "relative_path": "specs/010-copilot-agents/generate-issues-readonly.py",
    "depends_on": [],
    "source_code": "def generate_markdown_checklist(tasks, output_file):\n    \"\"\"Generate markdown file with gh commands\"\"\"\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(f\"# GitHub Issues for Feature {FEATURE_NUMBER}\\n\\n\")\n        f.write(\"**IMPORTANT**: You need WRITE permissions to create these issues.\\n\\n\")\n        f.write(\"## Contact Repository Admin\\n\\n\")\n        f.write(\"Ask the `eitatech` organization admin to grant you **Write** or **Maintain** permissions.\\n\\n\")\n        f.write(\"Check who has admin access: Go to https://github.com/eitatech/gatomia-vscode/settings/access\\n\\n\")\n        f.write(\"---\\n\\n\")\n        f.write(\"## Manual Creation Commands\\n\\n\")\n        f.write(\"Once you have permissions, run these commands:\\n\\n\")\n        f.write(\"```bash\\n\")\n        \n        for task in tasks:\n            # Escape quotes and newlines for shell\n            title = task['title'].replace('\"', '\\\\\"')\n            body = task['description'].replace('\"', '\\\\\"').replace('\\n', '\\\\n')\n            \n            f.write(f'\\n# {task[\"task_id\"]}\\n')\n            f.write(f'gh issue create -R eitatech/gatomia-vscode \\\\\\n')\n            f.write(f'  --title \"{title}\" \\\\\\n')\n            f.write(f'  --body \"{body}\" \\\\\\n')\n            f.write(f'  --label \"{task[\"labels\"]}\"\\n')\n        \n        f.write(\"```\\n\\n\")\n        f.write(\"---\\n\\n\")\n        f.write(\"## Issues Summary\\n\\n\")\n        \n        for task in tasks:\n            f.write(f\"- [ ] **{task['task_id']}**: {task['description'][:100]}...\\n\")\n            f.write(f\"      - Phase: {task['phase']}\\n\")\n            f.write(f\"      - Labels: {task['labels']}\\n\\n\")\n    \n    print(f\" Created markdown file: {output_file}\")\n    print(f\"   This contains all commands to run once you have permissions\")",
    "start_line": 116,
    "end_line": 150,
    "has_docstring": true,
    "docstring": "Generate markdown file with gh commands",
    "parameters": [
      "tasks",
      "output_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_markdown_checklist",
    "component_id": "specs.010-copilot-agents.generate-issues-readonly.generate_markdown_checklist"
  },
  "specs.010-copilot-agents.generate-issues-readonly.main": {
    "id": "specs.010-copilot-agents.generate-issues-readonly.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues-readonly.py",
    "relative_path": "specs/010-copilot-agents/generate-issues-readonly.py",
    "depends_on": [
      "specs.010-copilot-agents.generate-issues-readonly.generate_csv",
      "specs.010-copilot-agents.generate-issues-readonly.generate_markdown_checklist",
      "specs.010-copilot-agents.generate-issues-readonly.parse_tasks_from_file"
    ],
    "source_code": "def main():\n    print(\"\\n\" + \"=\" * 80)\n    print(\"GitHub Issues Helper (Read-Only Mode)\")\n    print(\"=\" * 80 + \"\\n\")\n    \n    tasks_file = f\"specs/{FEATURE_NUMBER}-{FEATURE_NAME}/tasks.md\"\n    print(f\"Parsing tasks from {tasks_file}...\")\n    \n    tasks = parse_tasks_from_file(tasks_file)\n    print(f\" Found {len(tasks)} tasks\\n\")\n    \n    # Generate CSV for web import\n    csv_file = f\"specs/{FEATURE_NUMBER}-{FEATURE_NAME}/issues-import.csv\"\n    generate_csv(tasks, csv_file)\n    \n    # Generate markdown with commands\n    md_file = f\"specs/{FEATURE_NUMBER}-{FEATURE_NAME}/issues-commands.md\"\n    generate_markdown_checklist(tasks, md_file)\n    \n    print(\"\\n\" + \"=\" * 80)\n    print(\"Summary\")\n    print(\"=\" * 80)\n    print(f\"Total tasks: {len(tasks)}\")\n    print(f\"\\nNext steps:\")\n    print(f\"1. Request Write permissions from eitatech organization admin\")\n    print(f\"2. Option A: Use {csv_file} for bulk import via GitHub web UI\")\n    print(f\"3. Option B: Run commands from {md_file} once you have permissions\")\n    print(f\"4. Option C: Create issues manually from the checklist in {md_file}\")\n    print()",
    "start_line": 153,
    "end_line": 181,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "specs.010-copilot-agents.generate-issues-readonly.main"
  },
  "specs.010-copilot-agents.generate-issues.create_label": {
    "id": "specs.010-copilot-agents.generate-issues.create_label",
    "name": "create_label",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [],
    "source_code": "def create_label(name: str, color: str, description: str) -> bool:\n    \"\"\"Create a GitHub label if it doesn't exist\"\"\"\n    # Check if label exists\n    result = subprocess.run(\n        [\"gh\", \"label\", \"list\", \"-R\", REPO],\n        capture_output=True,\n        text=True\n    )\n    \n    if name in result.stdout:\n        print(f\" Label already exists: {name}\")\n        return True\n    \n    # Create label\n    try:\n        subprocess.run(\n            [\"gh\", \"label\", \"create\", name, \"--color\", color, \"--description\", description, \"-R\", REPO],\n            check=True,\n            capture_output=True\n        )\n        print(f\" Created label: {name}\")\n        return True\n    except subprocess.CalledProcessError as e:\n        print(f\" Failed to create label {name}: {e.stderr.decode()}\")\n        return False",
    "start_line": 69,
    "end_line": 93,
    "has_docstring": true,
    "docstring": "Create a GitHub label if it doesn't exist",
    "parameters": [
      "name",
      "color",
      "description"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_label",
    "component_id": "specs.010-copilot-agents.generate-issues.create_label"
  },
  "specs.010-copilot-agents.generate-issues.create_labels": {
    "id": "specs.010-copilot-agents.generate-issues.create_labels",
    "name": "create_labels",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [
      "specs.010-copilot-agents.generate-issues.create_label"
    ],
    "source_code": "def create_labels():\n    \"\"\"Create all labels\"\"\"\n    print(\"=\" * 80)\n    print(f\"Creating GitHub labels for feature {FEATURE_NUMBER}...\")\n    print(\"=\" * 80)\n    \n    success_count = 0\n    for name, color, description in LABELS:\n        if create_label(name, color, description):\n            success_count += 1\n    \n    print(f\"\\n Successfully created/verified {success_count}/{len(LABELS)} labels\\n\")",
    "start_line": 96,
    "end_line": 107,
    "has_docstring": true,
    "docstring": "Create all labels",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_labels",
    "component_id": "specs.010-copilot-agents.generate-issues.create_labels"
  },
  "specs.010-copilot-agents.generate-issues.parse_phase_info": {
    "id": "specs.010-copilot-agents.generate-issues.parse_phase_info",
    "name": "parse_phase_info",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [],
    "source_code": "def parse_phase_info(content: str) -> Dict[str, str]:\n    \"\"\"Extract phase information from content\"\"\"\n    phase_map = {\n        \"Phase 1\": \"phase:setup\",\n        \"Phase 2\": \"phase:foundational\",\n        \"Phase 3\": \"phase:implementation\",\n        \"Phase 4\": \"phase:implementation\",\n        \"Phase 5\": \"phase:implementation\",\n        \"Phase 6\": \"phase:implementation\",\n        \"Phase 7\": \"phase:implementation\",\n        \"Phase 8\": \"phase:implementation\",\n        \"Phase 9\": \"phase:polish\",\n    }\n    \n    for phase_name, label in phase_map.items():\n        if phase_name in content:\n            return {\"label\": label, \"name\": phase_name}\n    \n    return {\"label\": \"phase:implementation\", \"name\": \"Unknown Phase\"}",
    "start_line": 110,
    "end_line": 128,
    "has_docstring": true,
    "docstring": "Extract phase information from content",
    "parameters": [
      "content"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_phase_info",
    "component_id": "specs.010-copilot-agents.generate-issues.parse_phase_info"
  },
  "specs.010-copilot-agents.generate-issues.extract_task_metadata": {
    "id": "specs.010-copilot-agents.generate-issues.extract_task_metadata",
    "name": "extract_task_metadata",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [],
    "source_code": "def extract_task_metadata(task_line: str, section_content: str) -> Dict:\n    \"\"\"Extract metadata from task line\"\"\"\n    metadata = {\n        \"parallel\": \"[P]\" in task_line,\n        \"user_story\": None,\n        \"priority\": None,\n    }\n    \n    # Extract user story\n    us_match = re.search(r'\\[US(\\d+)\\]', task_line)\n    if us_match:\n        metadata[\"user_story\"] = us_match.group(1)\n    \n    # Determine priority from section\n    if \"Priority: P1\" in section_content or \" MVP\" in section_content:\n        metadata[\"priority\"] = \"p1\"\n    elif \"Priority: P2\" in section_content:\n        metadata[\"priority\"] = \"p2\"\n    elif \"Priority: P3\" in section_content:\n        metadata[\"priority\"] = \"p3\"\n    elif \"CRITICAL\" in section_content:\n        metadata[\"priority\"] = \"critical\"\n    \n    return metadata",
    "start_line": 131,
    "end_line": 154,
    "has_docstring": true,
    "docstring": "Extract metadata from task line",
    "parameters": [
      "task_line",
      "section_content"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_task_metadata",
    "component_id": "specs.010-copilot-agents.generate-issues.extract_task_metadata"
  },
  "specs.010-copilot-agents.generate-issues.build_labels_list": {
    "id": "specs.010-copilot-agents.generate-issues.build_labels_list",
    "name": "build_labels_list",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [],
    "source_code": "def build_labels_list(phase_label: str, metadata: Dict) -> str:\n    \"\"\"Build comma-separated labels list\"\"\"\n    labels = [f\"feature:{FEATURE_NUMBER}\", phase_label]\n    \n    if metadata[\"parallel\"]:\n        labels.append(\"parallel\")\n    \n    if metadata[\"priority\"]:\n        labels.append(f\"priority:{metadata['priority']}\")\n    \n    if metadata[\"user_story\"]:\n        labels.append(f\"user-story:{metadata['user_story']}\")\n    \n    return \",\".join(labels)",
    "start_line": 157,
    "end_line": 170,
    "has_docstring": true,
    "docstring": "Build comma-separated labels list",
    "parameters": [
      "phase_label",
      "metadata"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function build_labels_list",
    "component_id": "specs.010-copilot-agents.generate-issues.build_labels_list"
  },
  "specs.010-copilot-agents.generate-issues.create_issue": {
    "id": "specs.010-copilot-agents.generate-issues.create_issue",
    "name": "create_issue",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [],
    "source_code": "def create_issue(title: str, body: str, labels: str) -> bool:\n    \"\"\"Create a GitHub issue\"\"\"\n    print(f\"Creating: {title}\")\n    \n    try:\n        subprocess.run(\n            [\"gh\", \"issue\", \"create\", \"-R\", REPO, \"--title\", title, \"--body\", body, \"--label\", labels],\n            check=True,\n            capture_output=True,\n            text=True\n        )\n        return True\n    except subprocess.CalledProcessError as e:\n        print(f\" Failed to create: {title}\")\n        print(f\"  Error: {e.stderr}\")\n        return False",
    "start_line": 173,
    "end_line": 188,
    "has_docstring": true,
    "docstring": "Create a GitHub issue",
    "parameters": [
      "title",
      "body",
      "labels"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_issue",
    "component_id": "specs.010-copilot-agents.generate-issues.create_issue"
  },
  "specs.010-copilot-agents.generate-issues.parse_tasks_from_file": {
    "id": "specs.010-copilot-agents.generate-issues.parse_tasks_from_file",
    "name": "parse_tasks_from_file",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [
      "specs.010-copilot-agents.generate-issues.extract_task_metadata",
      "specs.010-copilot-agents.generate-issues.parse_phase_info",
      "specs.010-copilot-agents.generate-issues.build_labels_list"
    ],
    "source_code": "def parse_tasks_from_file(filepath: str) -> List[Dict]:\n    \"\"\"Parse tasks.md and extract all tasks with metadata\"\"\"\n    with open(filepath, 'r') as f:\n        content = f.read()\n    \n    tasks = []\n    \n    # Split by phase sections\n    phase_sections = re.split(r'##\\s+Phase\\s+\\d+:', content)\n    \n    for i, section in enumerate(phase_sections[1:], 1):  # Skip first empty section\n        phase_info = parse_phase_info(f\"Phase {i}\")\n        \n        # Find all task lines\n        task_pattern = r'^-\\s+\\[\\s*\\]\\s+(T\\d+)(.*?)$'\n        for match in re.finditer(task_pattern, section, re.MULTILINE):\n            task_id = match.group(1)\n            task_desc = match.group(2).strip()\n            \n            # Extract metadata\n            metadata = extract_task_metadata(task_desc, section)\n            \n            # Build title (remove markers like [P], [US1] from title)\n            title = re.sub(r'\\[P\\]\\s*|\\[US\\d+\\]\\s*', '', task_desc).strip()\n            title = f\"[{task_id}] {title[:100]}\"  # Limit title length\n            \n            # Build labels\n            labels = build_labels_list(phase_info[\"label\"], metadata)\n            \n            tasks.append({\n                \"id\": task_id,\n                \"title\": title,\n                \"description\": task_desc,\n                \"phase\": phase_info[\"name\"],\n                \"labels\": labels,\n                \"metadata\": metadata,\n            })\n    \n    return tasks",
    "start_line": 191,
    "end_line": 229,
    "has_docstring": true,
    "docstring": "Parse tasks.md and extract all tasks with metadata",
    "parameters": [
      "filepath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_tasks_from_file",
    "component_id": "specs.010-copilot-agents.generate-issues.parse_tasks_from_file"
  },
  "specs.010-copilot-agents.generate-issues.generate_issue_body": {
    "id": "specs.010-copilot-agents.generate-issues.generate_issue_body",
    "name": "generate_issue_body",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [],
    "source_code": "def generate_issue_body(task: Dict) -> str:\n    \"\"\"Generate issue body from task info\"\"\"\n    body = f\"\"\"**Phase**: {task['phase']}\n**Feature**: {FEATURE_NUMBER}-{FEATURE_NAME}\"\"\"\n    \n    if task['metadata']['user_story']:\n        body += f\"\\n**User Story**: US{task['metadata']['user_story']}\"\n    \n    if task['metadata']['parallel']:\n        body += \"\\n**Can Run in Parallel**: Yes [P]\"\n    \n    body += f\"\"\"\n\n## Description\n{task['description']}\n\n## Task\n{task['id']} from specs/{FEATURE_NUMBER}-{FEATURE_NAME}/tasks.md\n\n---\n*This issue was auto-generated from tasks.md*\n\"\"\"\n    \n    return body",
    "start_line": 232,
    "end_line": 255,
    "has_docstring": true,
    "docstring": "Generate issue body from task info",
    "parameters": [
      "task"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_issue_body",
    "component_id": "specs.010-copilot-agents.generate-issues.generate_issue_body"
  },
  "specs.010-copilot-agents.generate-issues.main": {
    "id": "specs.010-copilot-agents.generate-issues.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/010-copilot-agents/generate-issues.py",
    "relative_path": "specs/010-copilot-agents/generate-issues.py",
    "depends_on": [
      "specs.010-copilot-agents.generate-issues.create_issue",
      "specs.010-copilot-agents.generate-issues.parse_tasks_from_file",
      "specs.010-copilot-agents.generate-issues.create_labels",
      "specs.010-copilot-agents.generate-issues.generate_issue_body"
    ],
    "source_code": "def main():\n    \"\"\"Main execution\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(f\"GitHub Issue Generator for Feature {FEATURE_NUMBER}\")\n    print(\"=\" * 80 + \"\\n\")\n    \n    # Step 1: Create labels\n    create_labels()\n    \n    # Step 2: Parse tasks\n    tasks_file = f\"specs/{FEATURE_NUMBER}-{FEATURE_NAME}/tasks.md\"\n    print(f\"Parsing tasks from {tasks_file}...\")\n    \n    try:\n        tasks = parse_tasks_from_file(tasks_file)\n        print(f\" Found {len(tasks)} tasks\\n\")\n    except FileNotFoundError:\n        print(f\" Error: {tasks_file} not found\")\n        print(\"  Make sure you're running from the repository root\")\n        sys.exit(1)\n    \n    # Step 3: Create issues\n    print(\"=\" * 80)\n    print(\"Creating GitHub issues...\")\n    print(\"=\" * 80 + \"\\n\")\n    \n    success_count = 0\n    for task in tasks:\n        body = generate_issue_body(task)\n        if create_issue(task[\"title\"], body, task[\"labels\"]):\n            success_count += 1\n    \n    # Summary\n    print(\"\\n\" + \"=\" * 80)\n    print(f\" Successfully created {success_count}/{len(tasks)} issues\")\n    print(\"=\" * 80)\n    print(f\"\\nView all issues at:\")\n    print(f\"https://github.com/{REPO}/issues?q=is%3Aissue+label%3Afeature%3A{FEATURE_NUMBER}\")\n    print()",
    "start_line": 258,
    "end_line": 296,
    "has_docstring": true,
    "docstring": "Main execution",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "specs.010-copilot-agents.generate-issues.main"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.BaseMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.BaseMessage",
    "name": "BaseMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface BaseMessage {\n\ttype: string; // Message type identifier\n\trequestId?: string; // Optional correlation ID for request/response\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 25,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface BaseMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.BaseMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RequestMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RequestMessage",
    "name": "RequestMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface RequestMessage extends BaseMessage {\n\ttype: string;\n\trequestId: string; // Required for requests\n}",
    "start_line": 34,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RequestMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RequestMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ResponseMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ResponseMessage",
    "name": "ResponseMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ErrorPayload"
    ],
    "source_code": "interface ResponseMessage extends BaseMessage {\n\ttype: string;\n\trequestId: string; // Correlates with request\n\tsuccess: boolean;\n\terror?: ErrorPayload;\n}",
    "start_line": 42,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResponseMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ResponseMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.EventMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.EventMessage",
    "name": "EventMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface EventMessage extends BaseMessage {\n\ttype: string;\n\t// No requestId for events\n}",
    "start_line": 52,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EventMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.EventMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsRequest",
    "name": "GetAgentsRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface GetAgentsRequest extends RequestMessage {\n\ttype: \"get-agents\";\n\tpayload: {\n\t\tfilter?: {\n\t\t\ttype?: \"local\" | \"background\"; // Filter by agent type\n\t\t\tsearchTerm?: string; // Filter by name/description\n\t\t};\n\t\tgrouped?: boolean; // If true, return grouped by type\n\t};\n}",
    "start_line": 64,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GetAgentsRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityRequest",
    "name": "CheckAgentAvailabilityRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface CheckAgentAvailabilityRequest extends RequestMessage {\n\ttype: \"check-agent-availability\";\n\tpayload: {\n\t\tagentId: string; // Agent to check\n\t};\n}",
    "start_line": 78,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CheckAgentAvailabilityRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentDetailsRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentDetailsRequest",
    "name": "GetAgentDetailsRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface GetAgentDetailsRequest extends RequestMessage {\n\ttype: \"get-agent-details\";\n\tpayload: {\n\t\tagentId: string; // Agent to retrieve\n\t};\n}",
    "start_line": 88,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GetAgentDetailsRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentDetailsRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsRequest",
    "name": "RefreshAgentsRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface RefreshAgentsRequest extends RequestMessage {\n\ttype: \"refresh-agents\";\n\tpayload?: {\n\t\tsource?: \"file\" | \"extension\"; // Optional: refresh specific source\n\t};\n}",
    "start_line": 98,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefreshAgentsRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentSelectedNotification": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentSelectedNotification",
    "name": "AgentSelectedNotification",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface AgentSelectedNotification extends BaseMessage {\n\ttype: \"agent-selected\";\n\tpayload: {\n\t\tagentId: string; // Selected agent ID\n\t\tagentName: string; // Selected agent name\n\t\tagentType: \"local\" | \"background\"; // Selected agent type\n\t};\n}",
    "start_line": 108,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentSelectedNotification",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentSelectedNotification"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.WebviewRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.WebviewRequest",
    "name": "WebviewRequest",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "type WebviewRequest =\n\t| GetAgentsRequest\n\t| CheckAgentAvailabilityRequest\n\t| GetAgentDetailsRequest\n\t| RefreshAgentsRequest\n\t| AgentSelectedNotification;",
    "start_line": 120,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type WebviewRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.WebviewRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsResponse",
    "name": "GetAgentsResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "src.features.hooks.agent-registry.GroupedAgents",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface GetAgentsResponse extends ResponseMessage {\n\ttype: \"get-agents-response\";\n\tpayload?: {\n\t\tagents: AgentRegistryEntry[]; // Flat list\n\t\tgrouped?: GroupedAgents; // Grouped by type (if requested)\n\t\ttotal: number; // Total count\n\t};\n}",
    "start_line": 134,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GetAgentsResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityResponse",
    "name": "CheckAgentAvailabilityResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface CheckAgentAvailabilityResponse extends ResponseMessage {\n\ttype: \"check-agent-availability-response\";\n\tpayload?: {\n\t\tagentId: string;\n\t\tavailable: boolean;\n\t\treason?: string; // Why unavailable (if applicable)\n\t};\n}",
    "start_line": 146,
    "end_line": 153,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CheckAgentAvailabilityResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentDetailsResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentDetailsResponse",
    "name": "GetAgentDetailsResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface GetAgentDetailsResponse extends ResponseMessage {\n\ttype: \"get-agent-details-response\";\n\tpayload?: {\n\t\tagent: AgentRegistryEntry; // Full agent details\n\t};\n}",
    "start_line": 158,
    "end_line": 163,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GetAgentDetailsResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentDetailsResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsResponse",
    "name": "RefreshAgentsResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface RefreshAgentsResponse extends ResponseMessage {\n\ttype: \"refresh-agents-response\";\n\tpayload?: {\n\t\taddedCount: number; // New agents discovered\n\t\tremovedCount: number; // Agents removed\n\t\tupdatedCount: number; // Agents updated\n\t};\n}",
    "start_line": 168,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefreshAgentsResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ExtensionResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ExtensionResponse",
    "name": "ExtensionResponse",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "type ExtensionResponse =\n\t| GetAgentsResponse\n\t| CheckAgentAvailabilityResponse\n\t| GetAgentDetailsResponse\n\t| RefreshAgentsResponse;",
    "start_line": 180,
    "end_line": 184,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExtensionResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ExtensionResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentsChangedEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentsChangedEvent",
    "name": "AgentsChangedEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface AgentsChangedEvent extends EventMessage {\n\ttype: \"agents-changed\";\n\tpayload: {\n\t\tchangeType: \"added\" | \"removed\" | \"updated\";\n\t\tagentIds: string[]; // Affected agent IDs\n\t\tagents?: AgentRegistryEntry[]; // New/updated agents (if applicable)\n\t};\n}",
    "start_line": 193,
    "end_line": 200,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentsChangedEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentsChangedEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentAvailabilityChangedEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentAvailabilityChangedEvent",
    "name": "AgentAvailabilityChangedEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface AgentAvailabilityChangedEvent extends EventMessage {\n\ttype: \"agent-availability-changed\";\n\tpayload: {\n\t\tagentId: string;\n\t\tavailable: boolean;\n\t\treason?: string; // Why unavailable (if applicable)\n\t};\n}",
    "start_line": 205,
    "end_line": 212,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentAvailabilityChangedEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentAvailabilityChangedEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshStartedEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshStartedEvent",
    "name": "RefreshStartedEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface RefreshStartedEvent extends EventMessage {\n\ttype: \"refresh-started\";\n\tpayload: {\n\t\tsource?: \"file\" | \"extension\"; // Source being refreshed\n\t};\n}",
    "start_line": 217,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefreshStartedEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshStartedEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshCompletedEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshCompletedEvent",
    "name": "RefreshCompletedEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface RefreshCompletedEvent extends EventMessage {\n\ttype: \"refresh-completed\";\n\tpayload: {\n\t\tsuccess: boolean;\n\t\taddedCount: number;\n\t\tremovedCount: number;\n\t\tupdatedCount: number;\n\t\terrors?: string[]; // Any errors during refresh\n\t};\n}",
    "start_line": 227,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefreshCompletedEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshCompletedEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ExtensionEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ExtensionEvent",
    "name": "ExtensionEvent",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "type ExtensionEvent =\n\t| AgentsChangedEvent\n\t| AgentAvailabilityChangedEvent\n\t| RefreshStartedEvent\n\t| RefreshCompletedEvent;",
    "start_line": 241,
    "end_line": 245,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExtensionEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ExtensionEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ErrorPayload": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ErrorPayload",
    "name": "ErrorPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "interface ErrorPayload {\n\tcode: string; // Error code (e.g., \"AGENT_NOT_FOUND\")\n\tmessage: string; // Human-readable error message\n\tdetails?: unknown; // Additional error context\n}",
    "start_line": 254,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ErrorPayload",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ErrorPayload"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message",
    "name": "Message",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "type Message = WebviewRequest | ExtensionResponse | ExtensionEvent;",
    "start_line": 263,
    "end_line": 263,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Message",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isRequestMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isRequestMessage",
    "name": "isRequestMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
    ],
    "source_code": "function isRequestMessage(message: Message): message is WebviewRequest {\n\treturn \"requestId\" in message && message.requestId !== undefined;\n}",
    "start_line": 272,
    "end_line": 274,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isRequestMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isRequestMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isResponseMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isResponseMessage",
    "name": "isResponseMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
    ],
    "source_code": "function isResponseMessage(\n\tmessage: Message\n): message is ExtensionResponse {\n\treturn (\n\t\t\"requestId\" in message &&\n\t\tmessage.requestId !== undefined &&\n\t\t\"success\" in message\n\t);\n}",
    "start_line": 279,
    "end_line": 287,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isResponseMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isResponseMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isEventMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isEventMessage",
    "name": "isEventMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
    ],
    "source_code": "function isEventMessage(message: Message): message is ExtensionEvent {\n\treturn !(\"requestId\" in message);\n}",
    "start_line": 292,
    "end_line": 294,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isEventMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isEventMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isGetAgentsRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isGetAgentsRequest",
    "name": "isGetAgentsRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
    ],
    "source_code": "function isGetAgentsRequest(\n\tmessage: Message\n): message is GetAgentsRequest {\n\treturn message.type === \"get-agents\";\n}",
    "start_line": 299,
    "end_line": 303,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isGetAgentsRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isGetAgentsRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isCheckAgentAvailabilityRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isCheckAgentAvailabilityRequest",
    "name": "isCheckAgentAvailabilityRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
    ],
    "source_code": "function isCheckAgentAvailabilityRequest(\n\tmessage: Message\n): message is CheckAgentAvailabilityRequest {\n\treturn message.type === \"check-agent-availability\";\n}",
    "start_line": 308,
    "end_line": 312,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isCheckAgentAvailabilityRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isCheckAgentAvailabilityRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isAgentsChangedEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isAgentsChangedEvent",
    "name": "isAgentsChangedEvent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.Message"
    ],
    "source_code": "function isAgentsChangedEvent(\n\tmessage: Message\n): message is AgentsChangedEvent {\n\treturn message.type === \"agents-changed\";\n}",
    "start_line": 317,
    "end_line": 321,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isAgentsChangedEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isAgentsChangedEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createGetAgentsRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createGetAgentsRequest",
    "name": "createGetAgentsRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.generateRequestId",
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsRequest"
    ],
    "source_code": "function createGetAgentsRequest(\n\tfilter?: GetAgentsRequest[\"payload\"][\"filter\"],\n\tgrouped?: boolean\n): GetAgentsRequest {\n\treturn {\n\t\ttype: \"get-agents\",\n\t\trequestId: generateRequestId(),\n\t\ttimestamp: Date.now(),\n\t\tpayload: {\n\t\t\tfilter,\n\t\t\tgrouped,\n\t\t},\n\t};\n}",
    "start_line": 330,
    "end_line": 343,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filter",
      "grouped"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createGetAgentsRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createGetAgentsRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createCheckAgentAvailabilityRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createCheckAgentAvailabilityRequest",
    "name": "createCheckAgentAvailabilityRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.generateRequestId",
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.CheckAgentAvailabilityRequest"
    ],
    "source_code": "function createCheckAgentAvailabilityRequest(\n\tagentId: string\n): CheckAgentAvailabilityRequest {\n\treturn {\n\t\ttype: \"check-agent-availability\",\n\t\trequestId: generateRequestId(),\n\t\ttimestamp: Date.now(),\n\t\tpayload: {\n\t\t\tagentId,\n\t\t},\n\t};\n}",
    "start_line": 348,
    "end_line": 359,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createCheckAgentAvailabilityRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createCheckAgentAvailabilityRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createRefreshAgentsRequest": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createRefreshAgentsRequest",
    "name": "createRefreshAgentsRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.generateRequestId",
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.RefreshAgentsRequest"
    ],
    "source_code": "function createRefreshAgentsRequest(\n\tsource?: \"file\" | \"extension\"\n): RefreshAgentsRequest {\n\treturn {\n\t\ttype: \"refresh-agents\",\n\t\trequestId: generateRequestId(),\n\t\ttimestamp: Date.now(),\n\t\tpayload: source ? { source } : undefined,\n\t};\n}",
    "start_line": 364,
    "end_line": 373,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "source"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createRefreshAgentsRequest",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createRefreshAgentsRequest"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createAgentSelectedNotification": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createAgentSelectedNotification",
    "name": "createAgentSelectedNotification",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentSelectedNotification"
    ],
    "source_code": "function createAgentSelectedNotification(\n\tagentId: string,\n\tagentName: string,\n\tagentType: \"local\" | \"background\"\n): AgentSelectedNotification {\n\treturn {\n\t\ttype: \"agent-selected\",\n\t\ttimestamp: Date.now(),\n\t\tpayload: {\n\t\t\tagentId,\n\t\t\tagentName,\n\t\t\tagentType,\n\t\t},\n\t};\n}",
    "start_line": 378,
    "end_line": 392,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId",
      "agentName",
      "agentType"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createAgentSelectedNotification",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createAgentSelectedNotification"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createGetAgentsResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createGetAgentsResponse",
    "name": "createGetAgentsResponse",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "src.features.hooks.agent-registry.GroupedAgents",
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.GetAgentsResponse",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "function createGetAgentsResponse(\n\trequestId: string,\n\tagents: AgentRegistryEntry[],\n\tgrouped?: GroupedAgents\n): GetAgentsResponse {\n\treturn {\n\t\ttype: \"get-agents-response\",\n\t\trequestId,\n\t\ttimestamp: Date.now(),\n\t\tsuccess: true,\n\t\tpayload: {\n\t\t\tagents,\n\t\t\tgrouped,\n\t\t\ttotal: agents.length,\n\t\t},\n\t};\n}",
    "start_line": 397,
    "end_line": 413,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "requestId",
      "agents",
      "grouped"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createGetAgentsResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createGetAgentsResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createErrorResponse": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createErrorResponse",
    "name": "createErrorResponse",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.ErrorPayload"
    ],
    "source_code": "function createErrorResponse<T extends ResponseMessage>(\n\ttype: T[\"type\"],\n\trequestId: string,\n\terror: ErrorPayload\n): T {\n\treturn {\n\t\ttype,\n\t\trequestId,\n\t\ttimestamp: Date.now(),\n\t\tsuccess: false,\n\t\terror,\n\t} as T;\n}",
    "start_line": 418,
    "end_line": 430,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type",
      "requestId",
      "error"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createErrorResponse",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createErrorResponse"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createAgentsChangedEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createAgentsChangedEvent",
    "name": "createAgentsChangedEvent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.AgentsChangedEvent",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "function createAgentsChangedEvent(\n\tchangeType: \"added\" | \"removed\" | \"updated\",\n\tagentIds: string[],\n\tagents?: AgentRegistryEntry[]\n): AgentsChangedEvent {\n\treturn {\n\t\ttype: \"agents-changed\",\n\t\ttimestamp: Date.now(),\n\t\tpayload: {\n\t\t\tchangeType,\n\t\t\tagentIds,\n\t\t\tagents,\n\t\t},\n\t};\n}",
    "start_line": 435,
    "end_line": 449,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changeType",
      "agentIds",
      "agents"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createAgentsChangedEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.createAgentsChangedEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.generateRequestId": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.generateRequestId",
    "name": "generateRequestId",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "function generateRequestId(): string {\n\treturn `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}",
    "start_line": 458,
    "end_line": 460,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateRequestId",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.generateRequestId"
  },
  "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isValidMessage": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isValidMessage",
    "name": "isValidMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-dropdown-events.ts",
    "depends_on": [],
    "source_code": "function isValidMessage(obj: unknown): obj is Message {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst message = obj as Message;\n\n\treturn (\n\t\ttypeof message.type === \"string\" &&\n\t\ttypeof message.timestamp === \"number\" &&\n\t\tmessage.timestamp > 0\n\t);\n}",
    "start_line": 465,
    "end_line": 477,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidMessage",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-dropdown-events.isValidMessage"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.IAgentRegistry": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IAgentRegistry",
    "name": "IAgentRegistry",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentFilter",
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry",
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeEvent",
      "src.features.hooks.agent-registry-types.AgentAvailabilityCheck",
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.GroupedAgents"
    ],
    "source_code": "interface IAgentRegistry {\n\t/**\n\t * Initialize the registry by discovering all available agents\n\t * @returns Promise resolving to initial discovery result\n\t */\n\tinitialize(): Promise<AgentDiscoveryResult[]>;\n\n\t/**\n\t * Get all registered agents\n\t * @param filter Optional filter criteria\n\t * @returns Array of agent registry entries\n\t */\n\tgetAllAgents(filter?: AgentFilter): AgentRegistryEntry[];\n\n\t/**\n\t * Get a single agent by ID\n\t * @param agentId Unique agent identifier (format: \"source:name\")\n\t * @returns Agent entry or undefined if not found\n\t */\n\tgetAgentById(agentId: string): AgentRegistryEntry | undefined;\n\n\t/**\n\t * Get agents grouped by type (local vs background)\n\t * @returns Grouped agents for UI dropdown rendering\n\t */\n\tgetAgentsGroupedByType(): GroupedAgents;\n\n\t/**\n\t * Check if an agent is currently available for invocation\n\t * @param agentId Unique agent identifier\n\t * @returns Availability check result with reason if unavailable\n\t */\n\tcheckAgentAvailability(agentId: string): Promise<AgentAvailabilityCheck>;\n\n\t/**\n\t * Force refresh of agent registry from all sources\n\t * @returns Promise resolving to new discovery results\n\t */\n\trefresh(): Promise<AgentDiscoveryResult[]>;\n\n\t/**\n\t * Register callback for registry changes (new agents, removals, updates)\n\t * @param callback Function to call when registry changes\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeRegistry(\n\t\tcallback: (event: RegistryChangeEvent) => void\n\t): { dispose: () => void };\n}",
    "start_line": 30,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IAgentRegistry",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IAgentRegistry"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.IAgentDiscoveryService": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IAgentDiscoveryService",
    "name": "IAgentDiscoveryService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentSourceEnum",
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult"
    ],
    "source_code": "interface IAgentDiscoveryService {\n\t/**\n\t * Discover agents from all configured sources\n\t * @returns Promise resolving to array of discovery results (one per source)\n\t */\n\tdiscoverAll(): Promise<AgentDiscoveryResult[]>;\n\n\t/**\n\t * Discover agents from a specific source\n\t * @param source Source to discover from\n\t * @returns Promise resolving to discovery result\n\t */\n\tdiscoverFromSource(source: AgentSourceEnum): Promise<AgentDiscoveryResult>;\n}",
    "start_line": 91,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IAgentDiscoveryService",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IAgentDiscoveryService"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.IFileAgentDiscovery": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IFileAgentDiscovery",
    "name": "IFileAgentDiscovery",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface IFileAgentDiscovery {\n\t/**\n\t * Discover all agents from local .agent.md files\n\t * @param agentsDir Absolute path to agents directory\n\t * @returns Promise resolving to discovery result\n\t */\n\tdiscoverAgents(agentsDir: string): Promise<AgentDiscoveryResult>;\n\n\t/**\n\t * Parse a single .agent.md file\n\t * @param filePath Absolute path to agent file\n\t * @returns Promise resolving to agent registry entry\n\t */\n\tparseAgentFile(filePath: string): Promise<AgentRegistryEntry>;\n\n\t/**\n\t * Validate an agent definition\n\t * @param entry Agent registry entry to validate\n\t * @returns Validation result with errors if any\n\t */\n\tvalidateAgent(entry: AgentRegistryEntry): {\n\t\tvalid: boolean;\n\t\terrors: string[];\n\t};\n}",
    "start_line": 115,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IFileAgentDiscovery",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IFileAgentDiscovery"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.IExtensionAgentDiscovery": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IExtensionAgentDiscovery",
    "name": "IExtensionAgentDiscovery",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface IExtensionAgentDiscovery {\n\t/**\n\t * Discover all agents registered by VS Code extensions\n\t * @returns Promise resolving to discovery result\n\t */\n\tdiscoverAgents(): Promise<AgentDiscoveryResult>;\n\n\t/**\n\t * Get agent metadata from a specific extension\n\t * @param extensionId VS Code extension identifier\n\t * @returns Promise resolving to agent registry entry or undefined\n\t */\n\tgetAgentFromExtension(\n\t\textensionId: string\n\t): Promise<AgentRegistryEntry | undefined>;\n\n\t/**\n\t * Check if an extension provides chat participants\n\t * @param extensionId VS Code extension identifier\n\t * @returns True if extension has chatParticipants contribution\n\t */\n\tisAgentExtension(extensionId: string): boolean;\n}",
    "start_line": 150,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IExtensionAgentDiscovery",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IExtensionAgentDiscovery"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.IFileWatcherService": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IFileWatcherService",
    "name": "IFileWatcherService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.FileChangeEvent"
    ],
    "source_code": "interface IFileWatcherService {\n\t/**\n\t * Start watching the agents directory\n\t * @param agentsDir Absolute path to agents directory\n\t */\n\tstartWatching(agentsDir: string): void;\n\n\t/**\n\t * Stop watching the agents directory\n\t */\n\tstopWatching(): void;\n\n\t/**\n\t * Register callback for file change events\n\t * @param callback Function to call when files change\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeFiles(\n\t\tcallback: (event: FileChangeEvent) => void\n\t): { dispose: () => void };\n}",
    "start_line": 186,
    "end_line": 206,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IFileWatcherService",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IFileWatcherService"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.FileChangeEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.FileChangeEvent",
    "name": "FileChangeEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [],
    "source_code": "interface FileChangeEvent {\n\ttype: \"created\" | \"modified\" | \"deleted\";\n\tfilePath: string; // Absolute path\n\taffectedAgentIds: string[]; // Agent IDs that need refresh\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 211,
    "end_line": 216,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FileChangeEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.FileChangeEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.IExtensionMonitorService": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IExtensionMonitorService",
    "name": "IExtensionMonitorService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.ExtensionChangeEvent"
    ],
    "source_code": "interface IExtensionMonitorService {\n\t/**\n\t * Start monitoring extension changes\n\t */\n\tstartMonitoring(): void;\n\n\t/**\n\t * Stop monitoring extension changes\n\t */\n\tstopMonitoring(): void;\n\n\t/**\n\t * Register callback for extension change events\n\t * @param callback Function to call when extensions change\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeExtensions(\n\t\tcallback: (event: ExtensionChangeEvent) => void\n\t): { dispose: () => void };\n}",
    "start_line": 230,
    "end_line": 249,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IExtensionMonitorService",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.IExtensionMonitorService"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.ExtensionChangeEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.ExtensionChangeEvent",
    "name": "ExtensionChangeEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [],
    "source_code": "interface ExtensionChangeEvent {\n\ttype: \"installed\" | \"uninstalled\" | \"enabled\" | \"disabled\";\n\textensionId: string; // VS Code extension identifier\n\taffectedAgentIds: string[]; // Agent IDs that need refresh\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 254,
    "end_line": 259,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExtensionChangeEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.ExtensionChangeEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentFilter": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentFilter",
    "name": "AgentFilter",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentSourceEnum",
      "src.features.hooks.agent-registry-types.AgentTypeEnum"
    ],
    "source_code": "interface AgentFilter {\n\ttype?: AgentTypeEnum; // Filter by agent type\n\tsource?: AgentSourceEnum; // Filter by discovery source\n\tavailable?: boolean; // Filter by availability status\n\tsearchTerm?: string; // Filter by name/description text match\n}",
    "start_line": 268,
    "end_line": 273,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentFilter",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentFilter"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.GroupedAgents": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.GroupedAgents",
    "name": "GroupedAgents",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface GroupedAgents {\n\tlocal: AgentRegistryEntry[]; // Local agents from .agent.md files\n\tbackground: AgentRegistryEntry[]; // Background CLI/extension agents\n}",
    "start_line": 278,
    "end_line": 281,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupedAgents",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.GroupedAgents"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeEvent": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeEvent",
    "name": "RegistryChangeEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeType"
    ],
    "source_code": "interface RegistryChangeEvent {\n\ttype: RegistryChangeType;\n\tagentIds: string[]; // Affected agent IDs\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 286,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RegistryChangeEvent",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeEvent"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeType": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeType",
    "name": "RegistryChangeType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [],
    "source_code": "type RegistryChangeType =\n\t| \"agents-added\" // New agents discovered\n\t| \"agents-removed\" // Agents removed (file deleted, extension uninstalled)\n\t| \"agents-updated\" // Agent metadata or availability changed\n\t| \"registry-cleared\";",
    "start_line": 295,
    "end_line": 299,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RegistryChangeType",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.RegistryChangeType"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryError": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryError",
    "name": "AgentRegistryError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryErrorCode"
    ],
    "source_code": "class AgentRegistryError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic readonly code: AgentRegistryErrorCode,\n\t\tpublic readonly details?: unknown\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"AgentRegistryError\";\n\t}\n}",
    "start_line": 308,
    "end_line": 317,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AgentRegistryError",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryError"
  },
  "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryErrorCode": {
    "id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryErrorCode",
    "name": "AgentRegistryErrorCode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/agent-registry-api.ts",
    "depends_on": [],
    "source_code": "type AgentRegistryErrorCode =\n\t| \"DISCOVERY_FAILED\" // Failed to discover agents from source\n\t| \"PARSE_ERROR\" // Failed to parse agent file\n\t| \"VALIDATION_ERROR\" // Agent schema validation failed\n\t| \"FILE_NOT_FOUND\" // Agent file doesn't exist\n\t| \"EXTENSION_NOT_FOUND\" // Extension doesn't exist\n\t| \"DUPLICATE_ID\" // Agent ID already registered\n\t| \"AGENT_UNAVAILABLE\" // Agent cannot be invoked\n\t| \"REGISTRY_NOT_INITIALIZED\" // Registry not initialized yet\n\t| \"UNKNOWN_ERROR\";",
    "start_line": 322,
    "end_line": 331,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentRegistryErrorCode",
    "component_id": "specs.011-custom-agent-hooks.contracts.agent-registry-api.AgentRegistryErrorCode"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.ITemplateVariableParser": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.ITemplateVariableParser",
    "name": "ITemplateVariableParser",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateContext",
      "ui.src.features.hooks-view.types.OperationType",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariable",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationResult"
    ],
    "source_code": "interface ITemplateVariableParser {\n\t/**\n\t * Parse template string to extract all variable references\n\t * @param template Template string with {variable} syntax\n\t * @returns Array of extracted variable names\n\t */\n\textractVariables(template: string): string[];\n\n\t/**\n\t * Substitute variables in template with values from context\n\t * @param template Template string with {variable} syntax\n\t * @param context Context object with variable values\n\t * @returns Resolved string with variables replaced\n\t */\n\tsubstitute(template: string, context: TemplateContext): string;\n\n\t/**\n\t * Validate template string for syntax errors\n\t * @param template Template string to validate\n\t * @returns Validation result with errors if any\n\t */\n\tvalidateSyntax(template: string): TemplateValidationResult;\n\n\t/**\n\t * Validate that all variables in template are available for trigger type\n\t * @param template Template string to validate\n\t * @param triggerType Type of trigger that will provide context\n\t * @returns Validation result with warnings for unavailable variables\n\t */\n\tvalidateVariables(\n\t\ttemplate: string,\n\t\ttriggerType: OperationType\n\t): TemplateValidationResult;\n\n\t/**\n\t * Get all available variables for a specific trigger type\n\t * @param triggerType Type of trigger\n\t * @returns Array of variable definitions available for this trigger\n\t */\n\tgetAvailableVariables(triggerType: OperationType): TemplateVariable[];\n}",
    "start_line": 26,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ITemplateVariableParser",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.ITemplateVariableParser"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariable": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariable",
    "name": "TemplateVariable",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariableCategory",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValueType"
    ],
    "source_code": "interface TemplateVariable {\n\t// Identity\n\tname: string; // Variable name (without braces)\n\n\t// Metadata\n\tdescription: string; // Human-readable description\n\tvalueType: TemplateValueType; // Expected value type\n\n\t// Availability\n\tavailableFor: OperationType[]; // Trigger types that provide this variable\n\trequired: boolean; // Always present for specified triggers?\n\n\t// Default behavior\n\tdefaultValue?: string; // Value if unavailable (default: empty string)\n\n\t// Display\n\texample?: string; // Example value for UI display\n\tcategory?: TemplateVariableCategory; // Grouping for UI organization\n}",
    "start_line": 75,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateVariable",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariable"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValueType": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValueType",
    "name": "TemplateValueType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "type TemplateValueType =\n\t| \"string\" // Text value\n\t| \"number\" // Numeric value\n\t| \"boolean\" // True/false\n\t| \"timestamp\" // ISO 8601 timestamp\n\t| \"path\" // File system path\n\t| \"url\";",
    "start_line": 98,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateValueType",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValueType"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariableCategory": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariableCategory",
    "name": "TemplateVariableCategory",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "type TemplateVariableCategory =\n\t| \"standard\" // Available for all triggers\n\t| \"spec\" // Spec-related triggers\n\t| \"file\" // File operation triggers\n\t| \"git\" // Git operation triggers\n\t| \"user\";",
    "start_line": 109,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateVariableCategory",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariableCategory"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateContext": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateContext",
    "name": "TemplateContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType"
    ],
    "source_code": "interface TemplateContext {\n\t// Standard variables (always present)\n\ttimestamp: string; // ISO 8601 format\n\ttriggerType: OperationType; // Type of trigger\n\n\t// Optional standard variables\n\tuser?: string; // Git user name\n\tbranch?: string; // Current git branch\n\tfeature?: string; // Current feature name\n\n\t// Dynamic variables (populated based on trigger type)\n\t[key: string]: string | number | boolean | undefined;\n}",
    "start_line": 119,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateContext",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateContext"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationResult": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationResult",
    "name": "TemplateValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationWarning",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationError"
    ],
    "source_code": "interface TemplateValidationResult {\n\tvalid: boolean; // Syntax and variable availability OK?\n\terrors: TemplateValidationError[]; // Syntax errors\n\twarnings: TemplateValidationWarning[]; // Missing variables (non-blocking)\n}",
    "start_line": 136,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateValidationResult",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationResult"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationError": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationError",
    "name": "TemplateValidationError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateErrorCode"
    ],
    "source_code": "interface TemplateValidationError {\n\tcode: TemplateErrorCode;\n\tmessage: string; // Human-readable error\n\tposition?: number; // Character position in template\n\tvariable?: string; // Variable name (if applicable)\n}",
    "start_line": 145,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateValidationError",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationError"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationWarning": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationWarning",
    "name": "TemplateValidationWarning",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateWarningCode"
    ],
    "source_code": "interface TemplateValidationWarning {\n\tcode: TemplateWarningCode;\n\tmessage: string; // Human-readable warning\n\tvariable: string; // Variable name\n\tsuggestion?: string; // How to fix the issue\n}",
    "start_line": 155,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateValidationWarning",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateValidationWarning"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateErrorCode": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateErrorCode",
    "name": "TemplateErrorCode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "type TemplateErrorCode =\n\t| \"UNCLOSED_BRACE\" // {variable without closing }\n\t| \"UNOPENED_BRACE\" // variable} without opening {\n\t| \"EMPTY_VARIABLE\" // {} with no name\n\t| \"INVALID_VARIABLE_NAME\" // {123abc} or {var-name} (invalid characters)\n\t| \"NESTED_BRACES\";",
    "start_line": 165,
    "end_line": 170,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateErrorCode",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateErrorCode"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateWarningCode": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateWarningCode",
    "name": "TemplateWarningCode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "type TemplateWarningCode =\n\t| \"VARIABLE_NOT_AVAILABLE\" // Variable not provided by trigger type\n\t| \"VARIABLE_NOT_REQUIRED\" // Variable may be missing at runtime\n\t| \"DEPRECATED_VARIABLE\";",
    "start_line": 175,
    "end_line": 178,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateWarningCode",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateWarningCode"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.ITemplateContextBuilder": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.ITemplateContextBuilder",
    "name": "ITemplateContextBuilder",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateContext",
      "ui.src.features.hooks-view.types.OperationType",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TriggerEventData"
    ],
    "source_code": "interface ITemplateContextBuilder {\n\t/**\n\t * Build context for a specific trigger event\n\t * @param triggerType Type of trigger\n\t * @param eventData Trigger event data\n\t * @returns Populated template context\n\t */\n\tbuildContext(\n\t\ttriggerType: OperationType,\n\t\teventData: TriggerEventData\n\t): TemplateContext;\n\n\t/**\n\t * Add standard variables to context\n\t * @param context Context to populate\n\t */\n\taddStandardVariables(context: TemplateContext): void;\n\n\t/**\n\t * Add trigger-specific variables to context\n\t * @param context Context to populate\n\t * @param triggerType Type of trigger\n\t * @param eventData Trigger event data\n\t */\n\taddTriggerVariables(\n\t\tcontext: TemplateContext,\n\t\ttriggerType: OperationType,\n\t\teventData: TriggerEventData\n\t): void;\n}",
    "start_line": 364,
    "end_line": 393,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ITemplateContextBuilder",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.ITemplateContextBuilder"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.TriggerEventData": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TriggerEventData",
    "name": "TriggerEventData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "interface TriggerEventData {\n\t// Event metadata\n\ttimestamp: number; // Unix timestamp (milliseconds)\n\n\t// Dynamic event data\n\t[key: string]: unknown;\n}",
    "start_line": 398,
    "end_line": 404,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TriggerEventData",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.TriggerEventData"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.extractVariableNames": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.extractVariableNames",
    "name": "extractVariableNames",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "function extractVariableNames(template: string): string[] {\n\tconst matches = [...template.matchAll(TEMPLATE_VARIABLE_PATTERN)];\n\tconst names = matches.map((match) => match[1]);\n\treturn [...new Set(names)]; // Remove duplicates\n}",
    "start_line": 443,
    "end_line": 447,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractVariableNames",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.extractVariableNames"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.hasVariables": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.hasVariables",
    "name": "hasVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "function hasVariables(template: string): boolean {\n\treturn TEMPLATE_VARIABLE_PATTERN.test(template);\n}",
    "start_line": 454,
    "end_line": 456,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function hasVariables",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.hasVariables"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.escapeRegex": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.escapeRegex",
    "name": "escapeRegex",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "function escapeRegex(str: string): string {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}",
    "start_line": 463,
    "end_line": 465,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function escapeRegex",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.escapeRegex"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariableDefinition": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariableDefinition",
    "name": "getVariableDefinition",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariable"
    ],
    "source_code": "function getVariableDefinition(\n\tname: string\n): TemplateVariable | undefined {\n\treturn ALL_TEMPLATE_VARIABLES.find((v) => v.name === name);\n}",
    "start_line": 472,
    "end_line": 476,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getVariableDefinition",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariableDefinition"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariablesForTrigger": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariablesForTrigger",
    "name": "getVariablesForTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType",
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.TemplateVariable"
    ],
    "source_code": "function getVariablesForTrigger(\n\ttriggerType: OperationType\n): TemplateVariable[] {\n\treturn ALL_TEMPLATE_VARIABLES.filter(\n\t\t(v) =>\n\t\t\tv.availableFor.length === 0 || // Available for all triggers\n\t\t\tv.availableFor.includes(triggerType) // Available for specific trigger\n\t);\n}",
    "start_line": 483,
    "end_line": 491,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "triggerType"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getVariablesForTrigger",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariablesForTrigger"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.isVariableAvailable": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.isVariableAvailable",
    "name": "isVariableAvailable",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [
      "specs.011-custom-agent-hooks.contracts.template-variable-schema.getVariableDefinition",
      "ui.src.features.hooks-view.types.OperationType"
    ],
    "source_code": "function isVariableAvailable(\n\tvariableName: string,\n\ttriggerType: OperationType\n): boolean {\n\tconst variable = getVariableDefinition(variableName);\n\tif (!variable) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\tvariable.availableFor.length === 0 ||\n\t\tvariable.availableFor.includes(triggerType)\n\t);\n}",
    "start_line": 499,
    "end_line": 512,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "variableName",
      "triggerType"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isVariableAvailable",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.isVariableAvailable"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.isTemplateContext": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.isTemplateContext",
    "name": "isTemplateContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "function isTemplateContext(obj: unknown): obj is TemplateContext {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst context = obj as TemplateContext;\n\n\treturn (\n\t\ttypeof context.timestamp === \"string\" &&\n\t\ttypeof context.triggerType === \"string\"\n\t);\n}",
    "start_line": 521,
    "end_line": 532,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isTemplateContext",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.isTemplateContext"
  },
  "specs.011-custom-agent-hooks.contracts.template-variable-schema.isTemplateVariable": {
    "id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.isTemplateVariable",
    "name": "isTemplateVariable",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "relative_path": "specs/011-custom-agent-hooks/contracts/template-variable-schema.ts",
    "depends_on": [],
    "source_code": "function isTemplateVariable(obj: unknown): obj is TemplateVariable {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst variable = obj as TemplateVariable;\n\n\treturn (\n\t\ttypeof variable.name === \"string\" &&\n\t\ttypeof variable.description === \"string\" &&\n\t\ttypeof variable.valueType === \"string\" &&\n\t\tArray.isArray(variable.availableFor) &&\n\t\ttypeof variable.required === \"boolean\"\n\t);\n}",
    "start_line": 537,
    "end_line": 551,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isTemplateVariable",
    "component_id": "specs.011-custom-agent-hooks.contracts.template-variable-schema.isTemplateVariable"
  },
  "src.constants.SpecSystemMode": {
    "id": "src.constants.SpecSystemMode",
    "name": "SpecSystemMode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/constants.ts",
    "relative_path": "src/constants.ts",
    "depends_on": [],
    "source_code": "type SpecSystemMode =\n\t(typeof SPEC_SYSTEM_MODE)[keyof typeof SPEC_SYSTEM_MODE];",
    "start_line": 46,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SpecSystemMode",
    "component_id": "src.constants.SpecSystemMode"
  },
  "src.extension.HookCommandTarget": {
    "id": "src.extension.HookCommandTarget",
    "name": "HookCommandTarget",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "type HookCommandTarget = { hookId?: string } | string;",
    "start_line": 93,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type HookCommandTarget",
    "component_id": "src.extension.HookCommandTarget"
  },
  "src.extension.activate": {
    "id": "src.extension.activate",
    "name": "activate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.features.steering.steering-manager.SteeringManager",
      "src.services.refinement-gateway.submitRequest",
      "src.features.hooks.trigger-registry.TriggerRegistry",
      "src.utils.workspace-state.shouldShowWelcomeAutomatically",
      "src.utils.spec-kit-adapter.getPromptsBasePath",
      "src.utils.spec-kit-adapter.initialize",
      "src.providers.spec-explorer-provider.SpecExplorerProvider",
      "src.extension.renderPreviewForUri",
      "src.features.hooks.agent-registry.AgentRegistry",
      "src.utils.workspace-state.markWelcomeAsShown",
      "src.panels.document-preview-panel.DocumentPreviewPanel",
      "src.services.prompt-loader.loadPromptsFromDirectory",
      "src.providers.actions-explorer-provider.ActionsExplorerProvider",
      "src.features.hooks.services.mcp-discovery.MCPDiscoveryService",
      "src.features.spec.spec-manager.setTriggerRegistry",
      "src.providers.hook-view-provider.HookViewProvider",
      "src.utils.task-parser.getTasksFilePath",
      "src.providers.spec-task-code-lens-provider.SpecTaskCodeLensProvider",
      "src.extension.registerCommands",
      "src.features.spec.spec-manager.SpecManager",
      "src.utils.config-manager.loadSettings",
      "src.features.spec.review-flow.state.initializeAutoReviewTransitions",
      "src.services.document-preview-service.persistFormSubmission",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter",
      "src.extension.setupDocumentPreviewWatchers",
      "src.providers.dependencies-view-provider.show",
      "src.providers.quick-access-explorer-provider.QuickAccessExplorerProvider",
      "src.features.hooks.hook-executor.HookExecutor",
      "src.extension.setupFileWatchers",
      "src.services.document-preview-service.DocumentPreviewService",
      "src.providers.spec-explorer-provider.setSpecManager",
      "src.providers.steering-explorer-provider.setSteeringManager",
      "src.services.agent-service.dispose",
      "src.services.refinement-gateway.RefinementGateway",
      "src.extension.openActivePreviewInEditor",
      "src.providers.welcome-screen-provider.getCallbacks",
      "src.providers.steering-explorer-provider.SteeringExplorerProvider",
      "src.providers.welcome-screen-provider.WelcomeScreenProvider",
      "src.providers.hooks-explorer-provider.HooksExplorerProvider",
      "src.services.agent-service.AgentService",
      "src.features.hooks.hook-manager.HookManager",
      "src.utils.task-parser.parseTasksFromFile",
      "src.features.hooks.services.command-completion-detector.CommandCompletionDetector",
      "src.utils.spec-kit-adapter.getActiveSystem",
      "src.utils.spec-kit-adapter.getInstance",
      "src.providers.dependencies-view-provider.DependenciesViewProvider",
      "src.providers.copilot-provider.CopilotProvider",
      "src.utils.chat-prompt-runner.sendPromptToChat",
      "src.extension.syncAllSpecReviewFlowSummaries"
    ],
    "source_code": "async function activate(context: ExtensionContext) {\n\t// Create output channel for debugging\n\toutputChannel = window.createOutputChannel(\"GatomIA - Debug\");\n\n\t// Initialize PromptLoader\n\ttry {\n\t\tconst promptLoader = PromptLoader.getInstance();\n\t\tpromptLoader.initialize();\n\t\toutputChannel.appendLine(\"PromptLoader initialized successfully\");\n\t} catch (error) {\n\t\toutputChannel.appendLine(`Failed to initialize PromptLoader: ${error} `);\n\t\twindow.showErrorMessage(`Failed to initialize prompt system: ${error} `);\n\t}\n\n\t// Check workspace status\n\tconst workspaceFolders = workspace.workspaceFolders;\n\tif (!workspaceFolders || workspaceFolders.length === 0) {\n\t\toutputChannel.appendLine(\"WARNING: No workspace folder found!\");\n\t}\n\n\t// Initialize Copilot provider\n\tcopilotProvider = new CopilotProvider(context, outputChannel);\n\n\tconst configManager = ConfigManager.getInstance();\n\tawait configManager.loadSettings();\n\n\t// Initialize Spec System Adapter\n\ttry {\n\t\tconst adapter = getSpecSystemAdapter();\n\t\tawait adapter.initialize();\n\t\toutputChannel.appendLine(\n\t\t\t`Spec System Adapter initialized.Active system: ${adapter.getActiveSystem()} `\n\t\t);\n\n\t\t// Load prompts from active system\n\t\tconst promptsPath = adapter.getPromptsBasePath();\n\t\tPromptLoader.getInstance().loadPromptsFromDirectory(promptsPath);\n\t\toutputChannel.appendLine(`Loaded prompts from: ${promptsPath} `);\n\t} catch (error) {\n\t\toutputChannel.appendLine(\n\t\t\t`Failed to initialize Spec System Adapter: ${error} `\n\t\t);\n\t}\n\n\t// Initialize feature managers with output channel\n\tspecManager = new SpecManager(context, outputChannel);\n\tsteeringManager = new SteeringManager(\n\t\tcontext,\n\t\tcopilotProvider,\n\t\toutputChannel\n\t);\n\n\t// Initialize AgentService\n\ttry {\n\t\toutputChannel.appendLine(\"[Extension] Initializing AgentService...\");\n\t\tagentService = new AgentService(outputChannel);\n\t\tawait agentService.initialize(context.extensionPath);\n\t\tcontext.subscriptions.push(agentService);\n\t\toutputChannel.appendLine(\n\t\t\t\"[Extension] AgentService initialized successfully\"\n\t\t);\n\t} catch (error) {\n\t\toutputChannel.appendLine(\n\t\t\t`[Extension] Failed to initialize AgentService: ${error}`\n\t\t);\n\t\t// Don't fail extension activation if agent service fails\n\t}\n\n\t// TODO: Initialize AgentService when implemented in Phase 2 (User Story 1)\n\t// agentService = new AgentService(context, outputChannel);\n\t// await agentService.initialize();\n\n\t// Initialize TriggerRegistry for hooks\n\ttriggerRegistry = new TriggerRegistry(outputChannel);\n\ttriggerRegistry.initialize();\n\toutputChannel.appendLine(\"TriggerRegistry initialized\");\n\n\t// Connect TriggerRegistry to SpecManager\n\tspecManager.setTriggerRegistry(triggerRegistry);\n\n\t// Initialize MCP Discovery Service (needed for HookManager and HookExecutor)\n\tmcpDiscoveryService = new MCPDiscoveryService();\n\toutputChannel.appendLine(\"MCPDiscoveryService initialized\");\n\n\t// Initialize AgentRegistry for custom agent hooks (Phase 2 - T010, T018)\n\t// Must be initialized before HookManager to enable agent validation\n\tconst agentWorkspaceRoot = workspaceFolders?.[0]?.uri.fsPath || \"\";\n\tagentRegistry = new AgentRegistry(agentWorkspaceRoot);\n\tawait agentRegistry.initialize();\n\toutputChannel.appendLine(\"AgentRegistry initialized\");\n\n\t// Initialize Hook infrastructure with MCP support and AgentRegistry (T025)\n\thookManager = new HookManager(\n\t\tcontext,\n\t\toutputChannel,\n\t\tmcpDiscoveryService,\n\t\tagentRegistry\n\t);\n\tawait hookManager.initialize();\n\n\thookExecutor = new HookExecutor(\n\t\thookManager,\n\t\ttriggerRegistry,\n\t\toutputChannel,\n\t\tmcpDiscoveryService,\n\t\tagentRegistry\n\t);\n\thookExecutor.initialize();\n\n\t// Initialize CommandCompletionDetector to detect when SpecKit commands complete\n\tcommandCompletionDetector = new CommandCompletionDetector(\n\t\ttriggerRegistry,\n\t\toutputChannel\n\t);\n\tcommandCompletionDetector.initialize();\n\toutputChannel.appendLine(\"CommandCompletionDetector initialized\");\n\n\thookViewProvider = new HookViewProvider({\n\t\tcontext,\n\t\thookManager,\n\t\thookExecutor,\n\t\tmcpDiscoveryService,\n\t\toutputChannel,\n\t});\n\thookViewProvider.initialize();\n\n\t// Initialize Dependencies View Provider\n\tdependenciesViewProvider = new DependenciesViewProvider(\n\t\tcontext,\n\t\toutputChannel\n\t);\n\n\tdocumentPreviewService = new DocumentPreviewService(outputChannel, context);\n\trefinementGateway = new RefinementGateway(outputChannel);\n\tdocumentPreviewPanel = new DocumentPreviewPanel(context, outputChannel, {\n\t\tonReloadRequested: async () => {\n\t\t\tif (activePreviewUri) {\n\t\t\t\tawait renderPreviewForUri(activePreviewUri);\n\t\t\t}\n\t\t},\n\t\tonEditAttempt: () => {\n\t\t\toutputChannel.appendLine(\"[Preview] Prevented raw document edit request\");\n\t\t},\n\t\tonOpenInEditor: () => openActivePreviewInEditor(),\n\t\tonFormSubmit: async (payload) => {\n\t\t\tif (!documentPreviewService) {\n\t\t\t\treturn { status: \"error\", message: \"Preview service not ready\" };\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait documentPreviewService.persistFormSubmission(payload);\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[Preview] Form submission received for ${payload.documentId}`\n\t\t\t\t);\n\t\t\t\treturn { status: \"success\" as const };\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[Preview] Failed to persist form submission: ${message} `\n\t\t\t\t);\n\t\t\t\treturn { status: \"error\" as const, message };\n\t\t\t}\n\t\t},\n\t\tonRefineSubmit: async (payload) => {\n\t\t\tif (!refinementGateway) {\n\t\t\t\treturn {\n\t\t\t\t\tstatus: \"error\" as const,\n\t\t\t\t\tmessage: \"Refinement gateway not ready\",\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn await refinementGateway.submitRequest(payload);\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\toutputChannel.appendLine(`[RefinementGateway] Failed: ${message} `);\n\t\t\t\treturn { status: \"error\" as const, message };\n\t\t\t}\n\t\t},\n\t\tonExecuteTaskGroup: async (groupName: string) => {\n\t\t\t// Get the current active preview URI\n\t\t\tif (!activePreviewUri) {\n\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\"No document is currently previewed. Open a spec document first.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Extract spec name from URI (e.g., \"001-document-preview\")\n\t\t\t\tconst pathParts = activePreviewUri.fsPath.split(\"/\");\n\t\t\t\tconst specName = pathParts.find((part) =>\n\t\t\t\t\tpart.match(SPEC_NAME_PATTERN)\n\t\t\t\t);\n\t\t\t\tif (!specName) {\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t\"Could not identify spec name from current document.\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Get the tasks file path and parse tasks\n\t\t\t\tconst tasksFilePath = getTasksFilePath(specName);\n\t\t\t\tif (!tasksFilePath) {\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`Could not find tasks.md for spec: ${specName} `\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst taskGroups = parseTasksFromFile(tasksFilePath);\n\n\t\t\t\t// Find matching group (e.g., \"Phase 1: Foundation & Core Types\")\n\t\t\t\t// The groupName from the button will be like \"Phase 1: Foundation & Core Types\"\n\t\t\t\tconst matchingGroup = taskGroups.find(\n\t\t\t\t\t(group) =>\n\t\t\t\t\t\tgroup.name.includes(groupName) || groupName.includes(group.name)\n\t\t\t\t);\n\n\t\t\t\tif (!matchingGroup || matchingGroup.tasks.length === 0) {\n\t\t\t\t\twindow.showErrorMessage(`No tasks found for group: ${groupName} `);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Aggregate task IDs\n\t\t\t\tconst taskDescriptions = matchingGroup.tasks\n\t\t\t\t\t.map((t) => `${t.id}: ${t.title} `)\n\t\t\t\t\t.join(\"\\n- \");\n\n\t\t\t\t// Send to Copilot with all task IDs\n\t\t\t\tconst prompt = `/ speckit.implement ${groupName} \\n\\nTasks: \\n - ${taskDescriptions} `;\n\t\t\t\tawait sendPromptToChat(prompt);\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\twindow.showErrorMessage(`Failed to execute task group: ${message} `);\n\t\t\t\toutputChannel.appendLine(`[Execute Task Group]Failed: ${message} `);\n\t\t\t}\n\t\t},\n\t\tonOpenFile: async (filePath: string) => {\n\t\t\tif (!filePath) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Get workspace root\n\t\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\t\tif (!workspaceRoot) {\n\t\t\t\t\twindow.showErrorMessage(\"No workspace open.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet absolutePath: Uri;\n\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[Open File]Processing: ${filePath}, activePreviewUri: ${activePreviewUri?.fsPath} `\n\t\t\t\t);\n\n\t\t\t\t// If the path is absolute, use it directly\n\t\t\t\tif (filePath.startsWith(\"/\")) {\n\t\t\t\t\tabsolutePath = Uri.file(filePath);\n\t\t\t\t} else if (activePreviewUri) {\n\t\t\t\t\t// Get the directory of the currently previewed file\n\t\t\t\t\tconst currentFileDir = dirname(activePreviewUri.fsPath);\n\n\t\t\t\t\t// Resolve relative path from the current file's directory\n\t\t\t\t\tconst resolvedPath = join(currentFileDir, filePath);\n\t\t\t\t\tabsolutePath = Uri.file(resolvedPath);\n\n\t\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t\t`[Open File] Resolved relative path: ${filePath} -> ${resolvedPath} `\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Fallback: try to resolve from workspace root\n\t\t\t\t\tabsolutePath = Uri.file(join(workspaceRoot, filePath));\n\t\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t\t`[Open File] Using workspace root fallback: ${absolutePath.fsPath} `\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Check if file exists\n\t\t\t\ttry {\n\t\t\t\t\tawait workspace.fs.stat(absolutePath);\n\t\t\t\t} catch {\n\t\t\t\t\tconst suggestion = `Path: ${absolutePath.fsPath} `;\n\t\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t\t`[Open File] File not found: ${suggestion} `\n\t\t\t\t\t);\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`File not found: ${filePath} \\n\\nResolved to: ${absolutePath.fsPath} `\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Render the file in the preview\n\t\t\t\tawait renderPreviewForUri(absolutePath);\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\twindow.showErrorMessage(`Failed to open file: ${message} `);\n\t\t\t\toutputChannel.appendLine(`[Open File]Failed: ${message} `);\n\t\t\t}\n\t\t},\n\t});\n\tsetupDocumentPreviewWatchers(context);\n\n\t// Register tree data providers\n\tconst quickAccessExplorer = new QuickAccessExplorerProvider();\n\tconst specExplorer = new SpecExplorerProvider(context);\n\tconst steeringExplorer = new SteeringExplorerProvider(context);\n\tconst actionsExplorer = new ActionsExplorerProvider(context);\n\tconst hooksExplorer = new HooksExplorerProvider(hookManager);\n\thooksExplorer.initialize();\n\n\t// Set managers\n\tspecExplorer.setSpecManager(specManager);\n\tsteeringExplorer.setSteeringManager(steeringManager);\n\tinitializeAutoReviewTransitions();\n\toutputChannel.appendLine(\"[ReviewFlow] Auto review transitions initialized\");\n\tawait syncAllSpecReviewFlowSummaries(specManager);\n\n\tcontext.subscriptions.push(\n\t\twindow.registerTreeDataProvider(\n\t\t\tQuickAccessExplorerProvider.viewId,\n\t\t\tquickAccessExplorer\n\t\t),\n\t\twindow.registerTreeDataProvider(\"gatomia.views.specExplorer\", specExplorer),\n\t\twindow.registerTreeDataProvider(\n\t\t\t\"gatomia.views.steeringExplorer\",\n\t\t\tsteeringExplorer\n\t\t),\n\t\twindow.registerTreeDataProvider(\n\t\t\t\"gatomia.views.actionsExplorer\",\n\t\t\tactionsExplorer\n\t\t),\n\t\twindow.registerTreeDataProvider(HooksExplorerProvider.viewId, hooksExplorer)\n\t);\n\tcontext.subscriptions.push(\n\t\t{ dispose: () => hookManager.dispose() },\n\t\t{ dispose: () => hookExecutor.dispose() },\n\t\t{ dispose: () => commandCompletionDetector.dispose() },\n\t\t{ dispose: () => hookViewProvider.dispose() },\n\t\t{ dispose: () => hooksExplorer.dispose() },\n\t\t{ dispose: () => quickAccessExplorer.dispose() },\n\t\t{ dispose: () => dependenciesViewProvider.dispose() }\n\t);\n\n\t// Register commands\n\tregisterCommands({\n\t\tcontext,\n\t\tspecExplorer,\n\t\tsteeringExplorer,\n\t\tactionsExplorer,\n\t\thooksExplorer,\n\t});\n\n\t// Set up file watchers\n\tsetupFileWatchers(context, specExplorer, steeringExplorer, actionsExplorer);\n\n\t// Register CodeLens provider for spec tasks\n\tconst specTaskCodeLensProvider = new SpecTaskCodeLensProvider();\n\tconst selector: DocumentSelector = [\n\t\t{\n\t\t\tlanguage: \"markdown\",\n\t\t\tpattern: \"**/*tasks.md\",\n\t\t\tscheme: \"file\",\n\t\t},\n\t];\n\tconst specTasksDisposable = languages.registerCodeLensProvider(\n\t\tselector,\n\t\tspecTaskCodeLensProvider\n\t);\n\tcontext.subscriptions.push(specTasksDisposable);\n\toutputChannel.appendLine(\"CodeLens provider for spec tasks registered\");\n\n\t// T019-T020: First-time welcome screen activation\n\ttry {\n\t\tconst shouldShow = shouldShowWelcomeAutomatically(context);\n\t\toutputChannel.appendLine(`[Welcome] First - time check: ${shouldShow} `);\n\n\t\tif (shouldShow) {\n\t\t\toutputChannel.appendLine(\n\t\t\t\t\"[Welcome] Showing welcome screen for first time\"\n\t\t\t);\n\n\t\t\t// Initialize welcome screen provider\n\t\t\tconst welcomeProvider = new WelcomeScreenProvider(context, outputChannel);\n\t\t\toutputChannel.appendLine(\"[Welcome] Provider created\");\n\n\t\t\t// Get callbacks with panel reference setter\n\t\t\tconst callbacks = welcomeProvider.getCallbacks();\n\t\t\toutputChannel.appendLine(\"[Welcome] Callbacks retrieved\");\n\n\t\t\t// Show welcome screen panel with provider callbacks\n\t\t\tconst welcomePanel = WelcomeScreenPanel.show(\n\t\t\t\tcontext,\n\t\t\t\toutputChannel,\n\t\t\t\tcallbacks\n\t\t\t);\n\t\t\toutputChannel.appendLine(\"[Welcome] Panel created\");\n\n\t\t\t// Set panel reference in callbacks (T028-T032)\n\t\t\tif (callbacks.setPanel) {\n\t\t\t\tcallbacks.setPanel(welcomePanel);\n\t\t\t\toutputChannel.appendLine(\"[Welcome] Panel reference set in callbacks\");\n\t\t\t}\n\n\t\t\t// Mark as shown for next time\n\t\t\tawait markWelcomeAsShown(context);\n\t\t\toutputChannel.appendLine(\"[Welcome] Marked as shown\");\n\t\t}\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\toutputChannel.appendLine(\n\t\t\t`[Welcome] Failed to show first - time screen: ${message} `\n\t\t);\n\t\t// Don't show error to user - welcome screen is optional\n\t}\n\n\t// No UI mode toggle commands required\n}",
    "start_line": 102,
    "end_line": 520,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function activate",
    "component_id": "src.extension.activate"
  },
  "src.extension.syncAllSpecReviewFlowSummaries": {
    "id": "src.extension.syncAllSpecReviewFlowSummaries",
    "name": "syncAllSpecReviewFlowSummaries",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.features.spec.spec-manager.getAllSpecsUnified",
      "src.extension.syncSpecReviewFlowSummary",
      "src.features.spec.spec-manager.SpecManager"
    ],
    "source_code": "async function syncAllSpecReviewFlowSummaries(\n\tspecManagerInstance: SpecManager\n): Promise<void> {\n\ttry {\n\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\tif (!workspaceRoot) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst unifiedSpecs = await specManagerInstance.getAllSpecsUnified();\n\t\tfor (const spec of unifiedSpecs) {\n\t\t\tawait syncSpecReviewFlowSummary({\n\t\t\t\tworkspaceRoot,\n\t\t\t\tspecId: spec.id,\n\t\t\t\tspecTitle: spec.name,\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\toutputChannel.appendLine(\n\t\t\t`[ReviewFlow] Failed to sync initial pending summaries: ${error} `\n\t\t);\n\t}\n}",
    "start_line": 522,
    "end_line": 544,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specManagerInstance"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function syncAllSpecReviewFlowSummaries",
    "component_id": "src.extension.syncAllSpecReviewFlowSummaries"
  },
  "src.extension.extractSpecIdFromPath": {
    "id": "src.extension.extractSpecIdFromPath",
    "name": "extractSpecIdFromPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "function extractSpecIdFromPath(filePath: string): string | null {\n\tconst parts = filePath.split(\"/\");\n\treturn parts.find((part) => part.match(SPEC_NAME_PATTERN)) ?? null;\n}",
    "start_line": 546,
    "end_line": 549,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractSpecIdFromPath",
    "component_id": "src.extension.extractSpecIdFromPath"
  },
  "src.extension.resolveSpecLinks": {
    "id": "src.extension.resolveSpecLinks",
    "name": "resolveSpecLinks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "function resolveSpecLinks(options: { workspaceRoot: string; specId: string }): {\n\tspecPath: string;\n\tdocUrl?: string;\n} {\n\t// We keep this lightweight: the specPath does not need to exist for state to function.\n\treturn {\n\t\tspecPath: join(options.workspaceRoot, \"specs\", options.specId, \"spec.md\"),\n\t};\n}",
    "start_line": 551,
    "end_line": 559,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function resolveSpecLinks",
    "component_id": "src.extension.resolveSpecLinks"
  },
  "src.extension.computePendingSummary": {
    "id": "src.extension.computePendingSummary",
    "name": "computePendingSummary",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.utils.checklist-parser.getChecklistStatusFromFile",
      "src.utils.task-parser.parseTasksFromFile",
      "src.utils.task-parser.getTasksFilePath"
    ],
    "source_code": "async function computePendingSummary(options: {\n\tworkspaceRoot: string;\n\tspecId: string;\n}): Promise<{ pendingTasks: number; pendingChecklistItems: number }> {\n\tconst tasksFilePath = getTasksFilePath(options.specId);\n\tconst pendingTasks = (() => {\n\t\tif (!tasksFilePath) {\n\t\t\t// Treat missing tasks file as a blocker to avoid false-positive auto transitions.\n\t\t\treturn 1;\n\t\t}\n\t\tconst groups = parseTasksFromFile(tasksFilePath);\n\t\tconst allTasks = groups.flatMap((group) => group.tasks);\n\t\treturn allTasks.filter((task) => task.status !== \"completed\").length;\n\t})();\n\n\tconst checklistsFolderCandidates = [\n\t\tjoin(options.workspaceRoot, \"specs\", options.specId, \"checklists\"),\n\t\tjoin(\n\t\t\toptions.workspaceRoot,\n\t\t\t\"openspec\",\n\t\t\t\"specs\",\n\t\t\toptions.specId,\n\t\t\t\"checklists\"\n\t\t),\n\t\tjoin(options.workspaceRoot, \"openspec\", options.specId, \"checklists\"),\n\t];\n\n\tconst { existsSync, readdirSync, statSync } = await import(\"node:fs\");\n\tlet pendingChecklistItems = 0;\n\tconst folderPath = checklistsFolderCandidates.find((candidate) =>\n\t\texistsSync(candidate)\n\t);\n\tif (folderPath) {\n\t\tfor (const entry of readdirSync(folderPath)) {\n\t\t\tif (!entry.endsWith(\".md\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst filePath = join(folderPath, entry);\n\t\t\tif (!statSync(filePath).isFile()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { total, completed } = getChecklistStatusFromFile(filePath);\n\t\t\tpendingChecklistItems += Math.max(0, total - completed);\n\t\t}\n\t}\n\n\treturn { pendingTasks, pendingChecklistItems };\n}",
    "start_line": 561,
    "end_line": 608,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function computePendingSummary",
    "component_id": "src.extension.computePendingSummary"
  },
  "src.extension.syncSpecReviewFlowSummary": {
    "id": "src.extension.syncSpecReviewFlowSummary",
    "name": "syncSpecReviewFlowSummary",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.extension.computePendingSummary",
      "src.features.spec.review-flow.state.updatePendingSummary",
      "src.features.spec.review-flow.state.upsertSpecState",
      "src.extension.resolveSpecLinks"
    ],
    "source_code": "async function syncSpecReviewFlowSummary(options: {\n\tworkspaceRoot: string;\n\tspecId: string;\n\tspecTitle: string;\n}): Promise<void> {\n\tconst links = resolveSpecLinks({\n\t\tworkspaceRoot: options.workspaceRoot,\n\t\tspecId: options.specId,\n\t});\n\n\tupsertSpecState({\n\t\tspecId: options.specId,\n\t\ttitle: options.specTitle,\n\t\towner: \"unknown\",\n\t\tlinks,\n\t});\n\n\tconst { pendingTasks, pendingChecklistItems } = await computePendingSummary({\n\t\tworkspaceRoot: options.workspaceRoot,\n\t\tspecId: options.specId,\n\t});\n\n\tupdatePendingSummary(options.specId, pendingTasks, pendingChecklistItems);\n}",
    "start_line": 610,
    "end_line": 633,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function syncSpecReviewFlowSummary",
    "component_id": "src.extension.syncSpecReviewFlowSummary"
  },
  "src.extension.RegisterCommandsOptions": {
    "id": "src.extension.RegisterCommandsOptions",
    "name": "RegisterCommandsOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.providers.actions-explorer-provider.ActionsExplorerProvider",
      "src.providers.steering-explorer-provider.SteeringExplorerProvider",
      "src.providers.spec-explorer-provider.SpecExplorerProvider",
      "src.providers.hooks-explorer-provider.HooksExplorerProvider"
    ],
    "source_code": "interface RegisterCommandsOptions {\n\tcontext: ExtensionContext;\n\tspecExplorer: SpecExplorerProvider;\n\tsteeringExplorer: SteeringExplorerProvider;\n\tactionsExplorer: ActionsExplorerProvider;\n\thooksExplorer: HooksExplorerProvider;\n}",
    "start_line": 635,
    "end_line": 641,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RegisterCommandsOptions",
    "component_id": "src.extension.RegisterCommandsOptions"
  },
  "src.extension.registerCommands": {
    "id": "src.extension.registerCommands",
    "name": "registerCommands",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.utils.spec-kit-migration.generateConstitution",
      "src.features.hooks.hook-manager.updateHook",
      "src.utils.config-manager.getPath",
      "src.features.hooks.hook-manager.exportHooks",
      "src.extension.resolveWorkspaceRelativeUri",
      "src.extension.RegisterCommandsOptions",
      "src.features.spec.review-flow.commands.reopen-spec-command.handleReopenSpec",
      "src.providers.hook-view-provider.showCreateHookForm",
      "src.extension.getDefaultWorkspaceFileUri",
      "src.utils.spec-kit-migration.createBackup",
      "src.utils.spec-kit-migration.SpecKitMigration",
      "src.extension.renderPreviewForUri",
      "src.features.spec.review-flow.commands.send-to-archived-command.handleUnarchive",
      "src.providers.hook-view-provider.showLogsPanel",
      "src.features.spec.review-flow.commands.send-to-review-command.handleSendToReview",
      "src.extension.HookCommandTarget",
      "src.features.spec.spec-manager.executeSpecKitCommand",
      "src.features.hooks.hook-manager.getHook",
      "src.providers.welcome-screen-provider.openExternal",
      "src.utils.platform-utils.getMcpConfigPath",
      "src.features.spec.spec-manager.openDocument",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter",
      "src.extension.getHooksExportFileName",
      "src.providers.hook-view-provider.showEditHookForm",
      "src.utils.spec-kit-migration.migrateAllSpecs",
      "src.providers.dependencies-view-provider.show",
      "src.features.hooks.hook-manager.deleteHook",
      "src.features.steering.steering-manager.createUserInstructionRule",
      "src.extension.openDocumentInEditor",
      "src.extension.createNewFile",
      "src.providers.welcome-screen-provider.getCallbacks",
      "src.features.steering.steering-manager.createConstitutionRequest",
      "src.providers.steering-explorer-provider.refresh",
      "src.extension.toggleViews",
      "src.providers.actions-explorer-provider.renamePrompt",
      "src.features.spec.review-flow.commands.send-to-archived-command.handleSendToArchived",
      "src.features.spec.spec-manager.runOpenSpecApply",
      "src.utils.config-manager.getAbsolutePath",
      "src.features.spec.spec-manager.navigateToDocument",
      "src.providers.welcome-screen-provider.executeCommand",
      "src.extension.handleHooksImport",
      "src.utils.spec-kit-adapter.selectSpecSystem",
      "src.features.spec.spec-submission-strategy.create",
      "src.utils.spec-kit-adapter.getInstance",
      "src.providers.welcome-screen-provider.WelcomeScreenProvider",
      "src.utils.chat-prompt-runner.sendPromptToChat",
      "src.features.spec.spec-manager.delete",
      "src.features.steering.steering-manager.createProjectInstructionRule"
    ],
    "source_code": "function registerCommands({\n\tcontext,\n\tspecExplorer,\n\tsteeringExplorer,\n\tactionsExplorer,\n\thooksExplorer,\n}: RegisterCommandsOptions) {\n\tconst createSpecCommand = commands.registerCommand(\n\t\t\"gatomia.spec.create\",\n\t\tasync () => {\n\t\t\toutputChannel.appendLine(\n\t\t\t\t`[Spec] create command triggered at ${new Date().toISOString()} `\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\tawait specManager.create();\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\toutputChannel.appendLine(`[Spec] create command failed: ${message} `);\n\t\t\t\twindow.showErrorMessage(`Failed to create spec prompt: ${message} `);\n\t\t\t}\n\t\t}\n\t);\n\n\tconst resolveHookId = (target?: HookCommandTarget): string | undefined => {\n\t\tif (!target) {\n\t\t\treturn;\n\t\t}\n\t\tif (typeof target === \"string\") {\n\t\t\treturn target;\n\t\t}\n\t\tif (typeof target.hookId === \"string\") {\n\t\t\treturn target.hookId;\n\t\t}\n\t\treturn;\n\t};\n\n\tcontext.subscriptions.push(\n\t\tcommands.registerCommand(\"gatomia.noop\", () => {\n\t\t\t// noop\n\t\t}),\n\t\tcreateSpecCommand,\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.navigate.requirements\",\n\t\t\tasync (specName: string) => {\n\t\t\t\tawait specManager.navigateToDocument(specName, \"requirements\");\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.navigate.design\",\n\t\t\tasync (specName: string) => {\n\t\t\t\tawait specManager.navigateToDocument(specName, \"design\");\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.navigate.tasks\",\n\t\t\tasync (specName: string) => {\n\t\t\t\tawait specManager.navigateToDocument(specName, \"tasks\");\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.implTask\",\n\t\t\tasync (documentUri: Uri) => {\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[Task Execute] Generating GatomIA apply prompt for: ${documentUri.fsPath} `\n\t\t\t\t);\n\t\t\t\tawait specManager.runOpenSpecApply(documentUri);\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.runTask\",\n\t\t\tasync (item?: { task?: { id: string; title: string } }) => {\n\t\t\t\tif (!item?.task) {\n\t\t\t\t\twindow.showErrorMessage(\"Select a task to run.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { id, title } = item.task;\n\t\t\t\tconst taskDescription = `${id}: ${title} `;\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[Run Task] Triggering speckit.implement for task: ${taskDescription} `\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tawait sendPromptToChat(`/ speckit.implement ${taskDescription} `);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\twindow.showErrorMessage(`Failed to run task: ${message} `);\n\t\t\t\t\toutputChannel.appendLine(`[Run Task]Failed: ${message} `);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.runTaskGroup\",\n\t\t\tasync (args?: { parentName?: string; filePath?: string }) => {\n\t\t\t\tif (!args?.parentName) {\n\t\t\t\t\twindow.showErrorMessage(\"Select a task group to run.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst groupName = args.parentName;\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[Run Task Group] Triggering speckit.implement for group: ${groupName} `\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tawait sendPromptToChat(`/ speckit.implement ${groupName} `);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\twindow.showErrorMessage(`Failed to run task group: ${message} `);\n\t\t\t\t\toutputChannel.appendLine(`[Run Task Group]Failed: ${message} `);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.open\",\n\t\t\tasync (relativePath: string, type: string, line?: number) => {\n\t\t\t\tconst uri = resolveWorkspaceRelativeUri(relativePath);\n\t\t\t\tif (uri) {\n\t\t\t\t\tconst artifact = await renderPreviewForUri(uri);\n\t\t\t\t\tif (artifact) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tawait specManager.openDocument(relativePath, type);\n\t\t\t\tif (uri && typeof line === \"number\") {\n\t\t\t\t\tawait openDocumentInEditor(uri, line);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\"gatomia.preview.openActiveDocument\", async () => {\n\t\t\tconst editor = window.activeTextEditor;\n\t\t\tif (!editor) {\n\t\t\t\twindow.showErrorMessage(\"Open a document to preview.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait renderPreviewForUri(editor.document.uri);\n\t\t}),\n\t\t// biome-ignore lint/suspicious/useAwait: ignore\n\t\tcommands.registerCommand(\"gatomia.spec.refresh\", async () => {\n\t\t\toutputChannel.appendLine(\"[Manual Refresh] Refreshing spec explorer...\");\n\t\t\tspecExplorer.refresh();\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\tSEND_TO_REVIEW_COMMAND_ID,\n\t\t\tasync (specArg: unknown) => {\n\t\t\t\tawait handleSendToReview(specArg, () => specExplorer.refresh());\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\n\t\t\tSEND_TO_ARCHIVED_COMMAND_ID,\n\t\t\tasync (specArg: unknown) => {\n\t\t\t\tawait handleSendToArchived(specArg, () => specExplorer.refresh());\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(UNARCHIVE_COMMAND_ID, async (specArg: unknown) => {\n\t\t\tawait handleUnarchive(specArg, () => specExplorer.refresh());\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\tREOPEN_SPEC_COMMAND_ID,\n\t\t\tasync (specArg: unknown) => {\n\t\t\t\tawait handleReopenSpec(specArg, () => specExplorer.refresh());\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\"gatomia.hooks.export\", async () => {\n\t\t\tif (!hookManager) {\n\t\t\t\twindow.showErrorMessage(\"Hook manager is not ready yet.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst defaultUri = getDefaultWorkspaceFileUri(getHooksExportFileName());\n\t\t\tconst saveUri = await window.showSaveDialog({\n\t\t\t\ttitle: \"Export Hooks\",\n\t\t\t\tsaveLabel: \"Export\",\n\t\t\t\tdefaultUri: defaultUri ?? undefined,\n\t\t\t\tfilters: { JSON: [\"json\"] },\n\t\t\t});\n\n\t\t\tif (!saveUri) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst json = hookManager.exportHooks();\n\t\t\t\tawait workspace.fs.writeFile(saveUri, Buffer.from(json, \"utf8\"));\n\n\t\t\t\tconst message = `Exported hooks to ${saveUri.fsPath} `;\n\t\t\t\twindow.showInformationMessage(message);\n\t\t\t\toutputChannel.appendLine(`[Hooks] ${message} `);\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\twindow.showErrorMessage(`Failed to export hooks: ${message} `);\n\t\t\t\toutputChannel.appendLine(`[Hooks] Failed to export hooks: ${message} `);\n\t\t\t}\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.hooks.import\", async () => {\n\t\t\tawait handleHooksImport();\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.hooks.addHook\", async () => {\n\t\t\tif (!hookViewProvider) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tawait hookViewProvider.showCreateHookForm();\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.hooks.viewLogs\",\n\t\t\tasync (target?: HookCommandTarget) => {\n\t\t\t\tif (!hookViewProvider) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tawait hookViewProvider.showLogsPanel(resolveHookId(target));\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\"gatomia.hooks.refresh\", () => {\n\t\t\toutputChannel.appendLine(\"[Manual Refresh] Refreshing hooks explorer...\");\n\t\t\thooksExplorer.refresh();\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.hooks.edit\",\n\t\t\tasync (target?: HookCommandTarget) => {\n\t\t\t\tif (!(hookViewProvider && hookManager)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst hookId = resolveHookId(target);\n\t\t\t\tif (!hookId) {\n\t\t\t\t\twindow.showErrorMessage(\"Select a hook to edit.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst hook = hookManager.getHook(hookId);\n\t\t\t\tif (!hook) {\n\t\t\t\t\twindow.showErrorMessage(\"Hook could not be found.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tawait hookViewProvider.showEditHookForm(hook);\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.hooks.enable\",\n\t\t\tasync (target?: HookCommandTarget) => {\n\t\t\t\tif (!hookManager) {\n\t\t\t\t\twindow.showErrorMessage(\"Hook manager is not ready yet.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst hookId = resolveHookId(target);\n\t\t\t\tif (!hookId) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tawait hookManager.updateHook(hookId, { enabled: true });\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\twindow.showErrorMessage(`Failed to enable hook: ${message} `);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.hooks.disable\",\n\t\t\tasync (target?: HookCommandTarget) => {\n\t\t\t\tif (!hookManager) {\n\t\t\t\t\twindow.showErrorMessage(\"Hook manager is not ready yet.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst hookId = resolveHookId(target);\n\t\t\t\tif (!hookId) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tawait hookManager.updateHook(hookId, { enabled: false });\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\twindow.showErrorMessage(`Failed to pause hook: ${message} `);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.hooks.delete\",\n\t\t\tasync (target?: HookCommandTarget) => {\n\t\t\t\tif (!hookManager) {\n\t\t\t\t\twindow.showErrorMessage(\"Hook manager is not ready yet.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst hookId = resolveHookId(target);\n\t\t\t\tif (!hookId) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst confirmation = await window.showWarningMessage(\n\t\t\t\t\t\"Delete this hook? This action cannot be undone.\",\n\t\t\t\t\t{ modal: true },\n\t\t\t\t\t\"Delete\"\n\t\t\t\t);\n\t\t\t\tif (confirmation !== \"Delete\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tawait hookManager.deleteHook(hookId);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\twindow.showErrorMessage(`Failed to delete hook: ${message} `);\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t);\n\n\t// No UI mode toggle commands required\n\n\t// Steering commands\n\tcontext.subscriptions.push(\n\t\t// Configuration commands\n\t\tcommands.registerCommand(\"gatomia.steering.createUserRule\", async () => {\n\t\t\tconst created = await steeringManager.createUserInstructionRule();\n\t\t\tif (created) {\n\t\t\t\tsteeringExplorer.refresh();\n\t\t\t}\n\t\t}),\n\n\t\tcommands.registerCommand(\"gatomia.steering.createProjectRule\", async () => {\n\t\t\tconst created = await steeringManager.createProjectInstructionRule();\n\t\t\tif (created) {\n\t\t\t\tsteeringExplorer.refresh();\n\t\t\t}\n\t\t}),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.steering.createConstitution\",\n\t\t\tasync () => {\n\t\t\t\tawait steeringManager.createConstitutionRequest();\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\"gatomia.steering.refresh\", () => {\n\t\t\toutputChannel.appendLine(\n\t\t\t\t\"[Manual Refresh] Refreshing steering explorer...\"\n\t\t\t);\n\t\t\tsteeringExplorer.refresh();\n\t\t})\n\t);\n\n\t// Add file save confirmation for agent files\n\tcontext.subscriptions.push(\n\t\tworkspace.onWillSaveTextDocument(async (event) => {\n\t\t\tconst document = event.document;\n\t\t\tconst filePath = document.fileName;\n\n\t\t\t// Check if this is an agent file in .copilot directories\n\t\t\tif (filePath.includes(\".copilot/agents/\") && filePath.endsWith(\".md\")) {\n\t\t\t\t// Show confirmation dialog\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t\"Are you sure you want to save changes to this agent file?\",\n\t\t\t\t\t{ modal: true },\n\t\t\t\t\t\"Save\",\n\t\t\t\t\t\"Cancel\"\n\t\t\t\t);\n\n\t\t\t\tif (result !== \"Save\") {\n\t\t\t\t\t// Cancel the save operation by waiting forever\n\t\t\t\t\t// biome-ignore lint/suspicious/noEmptyBlockStatements: ignore\n\t\t\t\t\tevent.waitUntil(new Promise(() => {}));\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n\n\t// Context menu for folders\n\tcontext.subscriptions.push(\n\t\tcommands.registerCommand(\"gatomia.newSpec\", async (uri: Uri) => {\n\t\t\tawait createNewFile(uri, \".spec.md\");\n\t\t})\n\t);\n\n\tcontext.subscriptions.push(\n\t\tcommands.registerCommand(\"gatomia.newChecklist\", async (uri: Uri) => {\n\t\t\tawait createNewFile(uri, \".checklist.md\");\n\t\t})\n\t);\n\n\t// Spec delete command\n\tcontext.subscriptions.push(\n\t\tcommands.registerCommand(\"gatomia.spec.delete\", async (item: unknown) => {\n\t\t\tconst resolvedSpecId = (() => {\n\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t\tif (!item || typeof item !== \"object\") {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst record = item as { specName?: unknown; label?: unknown };\n\t\t\t\tif (typeof record.specName === \"string\" && record.specName.length > 0) {\n\t\t\t\t\treturn record.specName;\n\t\t\t\t}\n\t\t\t\tif (typeof record.label === \"string\" && record.label.length > 0) {\n\t\t\t\t\treturn record.label;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t})();\n\n\t\t\tif (!resolvedSpecId) {\n\t\t\t\tawait window.showErrorMessage(\n\t\t\t\t\t\"Could not determine which spec to delete. Please refresh and try again.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst system =\n\t\t\t\titem && typeof item === \"object\"\n\t\t\t\t\t? (item as { system?: unknown }).system\n\t\t\t\t\t: undefined;\n\n\t\t\tawait specManager.delete(\n\t\t\t\tresolvedSpecId,\n\t\t\t\tsystem as Parameters<typeof specManager.delete>[1]\n\t\t\t);\n\t\t\tspecExplorer.refresh();\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.spec.archiveChange\",\n\t\t\tasync (item: any) => {\n\t\t\t\t// item is SpecItem, item.specName is the ID\n\t\t\t\tconst changeId = item.specName;\n\t\t\t\tif (!changeId) {\n\t\t\t\t\twindow.showErrorMessage(\"Could not determine change ID.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\t\t\tif (!ws) {\n\t\t\t\t\twindow.showErrorMessage(\"No workspace folder found\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst promptPath = Uri.joinPath(\n\t\t\t\t\tws.uri,\n\t\t\t\t\t\".github/prompts/openspec-archive.prompt.md\"\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst promptContent = await workspace.fs.readFile(promptPath);\n\t\t\t\t\tconst promptString = new TextDecoder().decode(promptContent);\n\t\t\t\t\tconst fullPrompt = `${promptString} \\n\\nid: ${changeId} `;\n\n\t\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t\t`[Archive Change] Archiving change: ${changeId} `\n\t\t\t\t\t);\n\t\t\t\t\tawait sendPromptToChat(fullPrompt);\n\t\t\t\t} catch (error) {\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`Failed to read archive prompt: ${error instanceof Error ? error.message : String(error)} `\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t);\n\n\t// Copilot integration commands\n\t// Copilot CLI integration commands\n\n\t// Actions commands\n\tcontext.subscriptions.push(\n\t\tcommands.registerCommand(\"gatomia.actions.refresh\", () => {\n\t\t\toutputChannel.appendLine(\n\t\t\t\t\"[Manual Refresh] Refreshing actions explorer...\"\n\t\t\t);\n\t\t\tactionsExplorer.refresh();\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.actions.createSkill\", async () => {\n\t\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\t\tif (!ws) {\n\t\t\t\twindow.showErrorMessage(\"No workspace folder found\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst name = await window.showInputBox({\n\t\t\t\ttitle: \"Create Skill\",\n\t\t\t\tplaceHolder: \"skill-name (kebab-case)\",\n\t\t\t\tprompt: \"A SKILL.md file will be created under .github/skills/<name>/\",\n\t\t\t\tvalidateInput: (v) => (v ? undefined : \"Name is required\"),\n\t\t\t});\n\n\t\t\tif (!name) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst skillDir = Uri.joinPath(ws.uri, \".github\", \"skills\", name);\n\t\t\tconst skillFile = Uri.joinPath(skillDir, \"SKILL.md\");\n\n\t\t\ttry {\n\t\t\t\tawait workspace.fs.createDirectory(skillDir);\n\t\t\t\tconst content = Buffer.from(\n\t\t\t\t\t`# ${name}\\n\\n## Description\\nDescribe the purpose of this skill.\\n\\n## Instructions\\nProvide specific instructions for Copilot on how to use this skill.\\n`\n\t\t\t\t);\n\t\t\t\tawait workspace.fs.writeFile(skillFile, content);\n\t\t\t\tconst doc = await workspace.openTextDocument(skillFile);\n\t\t\t\tawait window.showTextDocument(doc);\n\t\t\t\tactionsExplorer.refresh();\n\t\t\t} catch (e) {\n\t\t\t\twindow.showErrorMessage(`Failed to create skill: ${e}`);\n\t\t\t}\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.actions.createCopilotPrompt\",\n\t\t\tasync () => {\n\t\t\t\tawait commands.executeCommand(\"workbench.command.new.prompt\");\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\"gatomia.actions.create\", async (item?: any) => {\n\t\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\t\tif (!ws) {\n\t\t\t\twindow.showErrorMessage(\"No workspace folder found\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst configManager = ConfigManager.getInstance();\n\n\t\t\tlet targetDir: Uri;\n\t\t\tconst actionsPathLabel = configManager.getPath(\"prompts\");\n\t\t\ttargetDir = Uri.joinPath(ws.uri, \".copilot\", \"prompts\");\n\t\t\ttry {\n\t\t\t\ttargetDir = Uri.file(configManager.getAbsolutePath(\"prompts\"));\n\t\t\t} catch {\n\t\t\t\t// fall back to default under workspace\n\t\t\t}\n\n\t\t\tconst name = await window.showInputBox({\n\t\t\t\ttitle: \"Create Prompt\",\n\t\t\t\tplaceHolder: \"prompt-name (kebab-case)\",\n\t\t\t\tprompt: `A markdown file will be created under ${actionsPathLabel} `,\n\t\t\t\tvalidateInput: (v) => (v ? undefined : \"Name is required\"),\n\t\t\t});\n\t\t\tif (!name) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst file = Uri.joinPath(targetDir, `${name}.prompt.md`);\n\t\t\ttry {\n\t\t\t\tawait workspace.fs.createDirectory(targetDir);\n\t\t\t\tconst content = Buffer.from(\n\t\t\t\t\t`# ${name} \\n\\nDescribe your action here.This file will be sent to Copilot when executed.\\n`\n\t\t\t\t);\n\t\t\t\tawait workspace.fs.writeFile(file, content);\n\t\t\t\tconst doc = await workspace.openTextDocument(file);\n\t\t\t\tawait window.showTextDocument(doc);\n\t\t\t\tactionsExplorer.refresh();\n\t\t\t} catch (e) {\n\t\t\t\twindow.showErrorMessage(`Failed to create action: ${e} `);\n\t\t\t}\n\t\t}),\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.actions.run\",\n\t\t\t// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: ignore\n\t\t\tasync (filePathOrItem?: any) => {\n\t\t\t\ttry {\n\t\t\t\t\tlet targetUri: Uri | undefined;\n\n\t\t\t\t\tif (typeof filePathOrItem === \"string\") {\n\t\t\t\t\t\ttargetUri = Uri.file(filePathOrItem);\n\t\t\t\t\t} else if (filePathOrItem && typeof filePathOrItem === \"object\") {\n\t\t\t\t\t\tconst candidateUri: Uri | undefined =\n\t\t\t\t\t\t\tfilePathOrItem.resourceUri ??\n\t\t\t\t\t\t\t(typeof filePathOrItem.resourcePath === \"string\"\n\t\t\t\t\t\t\t\t? Uri.file(filePathOrItem.resourcePath)\n\t\t\t\t\t\t\t\t: undefined);\n\n\t\t\t\t\t\tif (candidateUri) {\n\t\t\t\t\t\t\ttargetUri = candidateUri;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!targetUri) {\n\t\t\t\t\t\ttargetUri = window.activeTextEditor?.document.uri;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!targetUri) {\n\t\t\t\t\t\twindow.showErrorMessage(\"No action selection found\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst fileData = await workspace.fs.readFile(targetUri);\n\t\t\t\t\tconst promptContent = new TextDecoder().decode(fileData);\n\t\t\t\t\tawait sendPromptToChat(promptContent, {\n\t\t\t\t\t\tinstructionType: \"runPrompt\",\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\twindow.showErrorMessage(`Failed to run action: ${e} `);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t\tcommands.registerCommand(\"gatomia.actions.rename\", async (item?: any) => {\n\t\t\tawait actionsExplorer.renamePrompt(item);\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.actions.delete\", async (item: any) => {\n\t\t\tif (!item?.resourceUri) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst uri = item.resourceUri as Uri;\n\t\t\tconst confirm = await window.showWarningMessage(\n\t\t\t\t`Are you sure you want to delete '${basename(uri.fsPath)}' ? `,\n\t\t\t\t{ modal: true },\n\t\t\t\t\"Delete\"\n\t\t\t);\n\t\t\tif (confirm !== \"Delete\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait workspace.fs.delete(uri);\n\t\t\t\tactionsExplorer.refresh();\n\t\t\t} catch (e) {\n\t\t\t\twindow.showErrorMessage(`Failed to delete action: ${e} `);\n\t\t\t}\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.actions.createAgentFile\", async () => {\n\t\t\tawait commands.executeCommand(\"workbench.command.new.agent\");\n\t\t}),\n\n\t\t// SpecKit commands\n\t\tcommands.registerCommand(\"gatomia.speckit.constitution\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"constitution\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.specify\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"specify\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.plan\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"plan\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.unit-test\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"unit-test\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.integration-test\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"integration-test\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.implementation\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"implementation\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.clarify\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"clarify\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.analyze\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"analyze\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.checklist\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"checklist\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.tasks\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"tasks\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.taskstoissues\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"taskstoissues\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.research\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"research\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.datamodel\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"datamodel\");\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.speckit.design\", async () => {\n\t\t\tawait specManager.executeSpecKitCommand(\"design\");\n\t\t})\n\t);\n\n\t// Update checker command\n\n\t// Group the following commands in a single subscriptions push\n\tcontext.subscriptions.push(\n\t\t// Overview and settings commands\n\t\tcommands.registerCommand(\"gatomia.settings.open\", async () => {\n\t\t\toutputChannel.appendLine(\"Opening GatomIA settings...\");\n\t\t\tawait commands.executeCommand(\n\t\t\t\t\"workbench.action.openSettings\",\n\t\t\t\tVSC_CONFIG_NAMESPACE\n\t\t\t);\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.settings.selectSpecSystem\", async () => {\n\t\t\tconst adapter = getSpecSystemAdapter();\n\t\t\tawait adapter.selectSpecSystem();\n\t\t}),\n\t\tcommands.registerCommand(\"gatomia.settings.openGlobalConfig\", async () => {\n\t\t\toutputChannel.appendLine(\"Opening MCP config...\");\n\n\t\t\tconst configPath = await getMcpConfigPath();\n\t\t\tconst configUri = Uri.file(configPath);\n\n\t\t\ttry {\n\t\t\t\tawait workspace.fs.stat(configUri);\n\t\t\t} catch {\n\t\t\t\twindow.showWarningMessage(\n\t\t\t\t\t`MCP config not found at ${configUri.fsPath}.`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst document = await workspace.openTextDocument(configUri);\n\t\t\t\tawait window.showTextDocument(document, { preview: false });\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\twindow.showErrorMessage(`Failed to open MCP config: ${message} `);\n\t\t\t}\n\t\t}),\n\n\t\t// biome-ignore lint/suspicious/useAwait: ignore\n\t\tcommands.registerCommand(\"gatomia.help.open\", async () => {\n\t\t\toutputChannel.appendLine(\"Opening GatomIA help...\");\n\t\t\tconst helpUrl = \"https://github.com/eitatech/gatomia-vscode#readme\";\n\t\t\tenv.openExternal(Uri.parse(helpUrl));\n\t\t}),\n\n\t\t// biome-ignore lint/suspicious/useAwait: ignore\n\t\tcommands.registerCommand(\"gatomia.help.install\", async () => {\n\t\t\toutputChannel.appendLine(\"Opening SpecKit installation guide...\");\n\t\t\tconst installUrl = \"https://github.com/github/spec-kit#readme\";\n\t\t\tenv.openExternal(Uri.parse(installUrl));\n\t\t}),\n\n\t\tcommands.registerCommand(\"gatomia.dependencies.check\", async () => {\n\t\t\toutputChannel.appendLine(\"Opening dependencies checker...\");\n\t\t\tawait dependenciesViewProvider.show();\n\t\t}),\n\n\t\tcommands.registerCommand(\"gatomia.showWelcome\", () => {\n\t\t\toutputChannel.appendLine(\"Showing welcome screen (on-demand)...\");\n\t\t\ttry {\n\t\t\t\tconst welcomeProvider = new WelcomeScreenProvider(\n\t\t\t\t\tcontext,\n\t\t\t\t\toutputChannel\n\t\t\t\t);\n\t\t\t\tconst callbacks = welcomeProvider.getCallbacks();\n\t\t\t\tconst panel = WelcomeScreenPanel.show(\n\t\t\t\t\tcontext,\n\t\t\t\t\toutputChannel,\n\t\t\t\t\tcallbacks\n\t\t\t\t);\n\n\t\t\t\t// Set panel reference in callbacks (T028-T032)\n\t\t\t\tif (callbacks.setPanel) {\n\t\t\t\t\tcallbacks.setPanel(panel);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\t\toutputChannel.appendLine(`[Welcome] Failed to show: ${message} `);\n\t\t\t\twindow.showErrorMessage(`Failed to show welcome screen: ${message} `);\n\t\t\t}\n\t\t}),\n\n\t\tcommands.registerCommand(\"gatomia.menu.open\", async () => {\n\t\t\toutputChannel.appendLine(\"Opening GatomIA menu...\");\n\t\t\tawait toggleViews();\n\t\t}),\n\n\t\tcommands.registerCommand(\"gatomia.migration.start\", async () => {\n\t\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\t\tif (!ws) {\n\t\t\t\twindow.showErrorMessage(\"No workspace folder found\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst migration = new SpecKitMigration(ws.uri.fsPath);\n\t\t\tawait migration.migrateAllSpecs();\n\t\t}),\n\n\t\tcommands.registerCommand(\n\t\t\t\"gatomia.migration.generateConstitution\",\n\t\t\tasync () => {\n\t\t\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\t\t\tif (!ws) {\n\t\t\t\t\twindow.showErrorMessage(\"No workspace folder found\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst migration = new SpecKitMigration(ws.uri.fsPath);\n\t\t\t\tawait migration.generateConstitution();\n\t\t\t}\n\t\t),\n\n\t\tcommands.registerCommand(\"gatomia.migration.createBackup\", () => {\n\t\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\t\tif (!ws) {\n\t\t\t\twindow.showErrorMessage(\"No workspace folder found\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst migration = new SpecKitMigration(ws.uri.fsPath);\n\t\t\tconst backupPath = migration.createBackup();\n\t\t\tif (backupPath) {\n\t\t\t\twindow.showInformationMessage(`Backup created at: ${backupPath} `);\n\t\t\t} else {\n\t\t\t\twindow.showWarningMessage(\n\t\t\t\t\t\"No OpenSpec directory found to backup, or backup failed.\"\n\t\t\t\t);\n\t\t\t}\n\t\t})\n\t);\n}",
    "start_line": 643,
    "end_line": 1439,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function registerCommands",
    "component_id": "src.extension.registerCommands"
  },
  "src.extension.toggleViews": {
    "id": "src.extension.toggleViews",
    "name": "toggleViews",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.features.agents.resource-cache.get",
      "src.services.configuration-service.getConfiguration"
    ],
    "source_code": "async function toggleViews() {\n\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\tconst currentVisibility = {\n\t\tspecs: config.get(\"views.specs.visible\", true),\n\t\thooks: config.get(\"views.hooks.visible\", false),\n\t\tsteering: config.get(\"views.steering.visible\", true),\n\t\tactions: config.get(\"views.actions.visible\", true),\n\t\tmcp: config.get(\"views.mcp.visible\", false),\n\t};\n\n\tconst items: Array<{ label: string; picked: boolean; id: string }> = [\n\t\t{\n\t\t\tlabel: `$(${currentVisibility.specs ? \"check\" : \"blank\"}) Specs`,\n\t\t\tpicked: currentVisibility.specs,\n\t\t\tid: \"specs\",\n\t\t},\n\t\t{\n\t\t\tlabel: `$(${currentVisibility.actions ? \"check\" : \"blank\"}) Actions`,\n\t\t\tpicked: currentVisibility.actions,\n\t\t\tid: \"actions\",\n\t\t},\n\t\t{\n\t\t\tlabel: `$(${currentVisibility.hooks ? \"check\" : \"blank\"}) Hooks`,\n\t\t\tpicked: currentVisibility.hooks,\n\t\t\tid: \"hooks\",\n\t\t},\n\n\t\t{\n\t\t\tlabel: `$(${currentVisibility.steering ? \"check\" : \"blank\"}) Agent Steering`,\n\t\t\tpicked: currentVisibility.steering,\n\t\t\tid: \"steering\",\n\t\t},\n\t];\n\tconst selected = await window.showQuickPick(items, {\n\t\tcanPickMany: true,\n\t\tplaceHolder: \"Select views to show\",\n\t});\n\n\tif (selected) {\n\t\tconst newVisibility = {\n\t\t\tspecs: selected.some((item) => item.id === \"specs\"),\n\t\t\thooks: selected.some((item) => item.id === \"hooks\"),\n\t\t\tsteering: selected.some((item) => item.id === \"steering\"),\n\t\t\tactions: selected.some((item) => item.id === \"actions\"),\n\t\t\tmcp: selected.some((item) => item.id === \"mcp\"),\n\t\t};\n\n\t\tawait config.update(\n\t\t\t\"views.specs.visible\",\n\t\t\tnewVisibility.specs,\n\t\t\tConfigurationTarget.Workspace\n\t\t);\n\t\tawait config.update(\n\t\t\t\"views.actions.visible\",\n\t\t\tnewVisibility.actions,\n\t\t\tConfigurationTarget.Workspace\n\t\t);\n\t\tawait config.update(\n\t\t\t\"views.steering.visible\",\n\t\t\tnewVisibility.steering,\n\t\t\tConfigurationTarget.Workspace\n\t\t);\n\n\t\twindow.showInformationMessage(\"View visibility updated!\");\n\t}\n}",
    "start_line": 1441,
    "end_line": 1506,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function toggleViews",
    "component_id": "src.extension.toggleViews"
  },
  "src.extension.setupFileWatchers": {
    "id": "src.extension.setupFileWatchers",
    "name": "setupFileWatchers",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "src.providers.actions-explorer-provider.ActionsExplorerProvider",
      "src.extension.extractSpecIdFromPath",
      "src.utils.config-manager.getSettings",
      "src.extension.syncSpecReviewFlowSummary",
      "src.providers.steering-explorer-provider.SteeringExplorerProvider",
      "src.utils.spec-kit-adapter.getInstance",
      "src.providers.spec-explorer-provider.SpecExplorerProvider",
      "src.providers.steering-explorer-provider.refresh"
    ],
    "source_code": "function setupFileWatchers(\n\tcontext: ExtensionContext,\n\tspecExplorer: SpecExplorerProvider,\n\tsteeringExplorer: SteeringExplorerProvider,\n\tactionsExplorer: ActionsExplorerProvider\n) {\n\t// Watch for changes in .copilot directories with debouncing\n\tconst copilotWatcher = workspace.createFileSystemWatcher(\"**/.copilot/**/*\");\n\n\tlet refreshTimeout: NodeJS.Timeout | undefined;\n\tconst pendingReviewFlowSpecIds = new Set<string>();\n\tconst debouncedRefresh = (event: string, uri: Uri) => {\n\t\toutputChannel.appendLine(`[FileWatcher] ${event}: ${uri.fsPath} `);\n\t\tconst specId = extractSpecIdFromPath(uri.fsPath);\n\t\tif (specId) {\n\t\t\tconst isTasksFile = uri.fsPath.endsWith(\"/tasks.md\");\n\t\t\tconst isChecklistFile =\n\t\t\t\turi.fsPath.includes(\"/checklists/\") && uri.fsPath.endsWith(\".md\");\n\t\t\tif (isTasksFile || isChecklistFile) {\n\t\t\t\tpendingReviewFlowSpecIds.add(specId);\n\t\t\t}\n\t\t}\n\n\t\tif (refreshTimeout) {\n\t\t\tclearTimeout(refreshTimeout);\n\t\t}\n\t\trefreshTimeout = setTimeout(() => {\n\t\t\tspecExplorer.refresh();\n\t\t\tsteeringExplorer.refresh();\n\t\t\tactionsExplorer.refresh();\n\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\tif (workspaceRoot && pendingReviewFlowSpecIds.size > 0) {\n\t\t\t\tconst specIds = Array.from(pendingReviewFlowSpecIds);\n\t\t\t\tpendingReviewFlowSpecIds.clear();\n\t\t\t\tprocessReviewFlowSync(workspaceRoot, specIds).catch((error) => {\n\t\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t\t`[ReviewFlow] Failed to process pending summary sync: ${error} `\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000); // Increase debounce time to 1 second\n\t};\n\n\tconst processReviewFlowSync = async (\n\t\tworkspaceRoot: string,\n\t\tspecIds: string[]\n\t): Promise<void> => {\n\t\tfor (const id of specIds) {\n\t\t\ttry {\n\t\t\t\tawait syncSpecReviewFlowSummary({\n\t\t\t\t\tworkspaceRoot,\n\t\t\t\t\tspecId: id,\n\t\t\t\t\tspecTitle: id,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\toutputChannel.appendLine(\n\t\t\t\t\t`[ReviewFlow] Failed to sync pending summary for ${id}: ${error} `\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst attachWatcherHandlers = (watcher: FileSystemWatcher) => {\n\t\twatcher.onDidCreate((uri) => debouncedRefresh(\"Create\", uri));\n\t\twatcher.onDidDelete((uri) => debouncedRefresh(\"Delete\", uri));\n\t\twatcher.onDidChange((uri) => debouncedRefresh(\"Change\", uri));\n\t};\n\n\tattachWatcherHandlers(copilotWatcher);\n\n\tconst watchers: FileSystemWatcher[] = [copilotWatcher];\n\n\tconst wsFolder = workspace.workspaceFolders?.[0];\n\tif (wsFolder) {\n\t\tconst normalizeRelativePath = (value: string) =>\n\t\t\tvalue\n\t\t\t\t.replace(/\\\\/g, \"/\")\n\t\t\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\t\t\t.replace(/^\\.\\//, \"\")\n\t\t\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\t\t\t.replace(/\\/+$/, \"\");\n\n\t\tconst configManager = ConfigManager.getInstance();\n\t\tconst settings = configManager.getSettings();\n\t\tconst configuredPaths = [\n\t\t\tsettings.paths.prompts,\n\t\t\tsettings.paths.specs,\n\t\t\tsettings.speckit.paths.specs,\n\t\t\tsettings.speckit.paths.templates,\n\t\t\tsettings.speckit.paths.memory,\n\t\t];\n\n\t\tconst extraPatterns = new Set<string>();\n\t\tfor (const rawPath of configuredPaths) {\n\t\t\tconst normalized = normalizeRelativePath(rawPath);\n\t\t\tif (!normalized || normalized.startsWith(\"..\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (normalized === \".copilot\" || normalized.startsWith(\".copilot/\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\textraPatterns.add(`${normalized}/**/* `);\n\t\t}\n\n\t\tfor (const pattern of extraPatterns) {\n\t\t\tconst watcher = workspace.createFileSystemWatcher(\n\t\t\t\tnew RelativePattern(wsFolder, pattern)\n\t\t\t);\n\t\t\tattachWatcherHandlers(watcher);\n\t\t\twatchers.push(watcher);\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(...watchers);\n\n\t// Watch for changes in copilot-instructions.md files\n\tconst globalHome = homedir() || process.env.USERPROFILE || \"\";\n\tconst globalCopilotMdWatcher = workspace.createFileSystemWatcher(\n\t\tnew RelativePattern(globalHome, \".github/copilot-instructions.md\")\n\t);\n\tconst projectCopilotMdWatcher = workspace.createFileSystemWatcher(\n\t\t\"**/copilot-instructions.md\"\n\t);\n\n\tglobalCopilotMdWatcher.onDidCreate(() => steeringExplorer.refresh());\n\tglobalCopilotMdWatcher.onDidDelete(() => steeringExplorer.refresh());\n\tprojectCopilotMdWatcher.onDidCreate(() => steeringExplorer.refresh());\n\tprojectCopilotMdWatcher.onDidDelete(() => steeringExplorer.refresh());\n\n\tcontext.subscriptions.push(globalCopilotMdWatcher, projectCopilotMdWatcher);\n}",
    "start_line": 1508,
    "end_line": 1639,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "specExplorer",
      "steeringExplorer",
      "actionsExplorer"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setupFileWatchers",
    "component_id": "src.extension.setupFileWatchers"
  },
  "src.extension.getDefaultWorkspaceFileUri": {
    "id": "src.extension.getDefaultWorkspaceFileUri",
    "name": "getDefaultWorkspaceFileUri",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "function getDefaultWorkspaceFileUri(fileName: string): Uri | undefined {\n\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\tif (!workspaceFolder) {\n\t\treturn;\n\t}\n\n\treturn Uri.joinPath(workspaceFolder.uri, fileName);\n}",
    "start_line": 1641,
    "end_line": 1648,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fileName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getDefaultWorkspaceFileUri",
    "component_id": "src.extension.getDefaultWorkspaceFileUri"
  },
  "src.extension.getHooksExportFileName": {
    "id": "src.extension.getHooksExportFileName",
    "name": "getHooksExportFileName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "function getHooksExportFileName(): string {\n\tconst timestamp = new Date().toISOString().replace(/[:]/g, \"-\");\n\treturn `gatomia - hooks - ${timestamp}.json`;\n}",
    "start_line": 1650,
    "end_line": 1653,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getHooksExportFileName",
    "component_id": "src.extension.getHooksExportFileName"
  },
  "src.extension.handleHooksImport": {
    "id": "src.extension.handleHooksImport",
    "name": "handleHooksImport",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.features.hooks.hook-manager.importHooks"
    ],
    "source_code": "async function handleHooksImport(): Promise<void> {\n\tif (!hookManager) {\n\t\twindow.showErrorMessage(\"Hook manager is not ready yet.\");\n\t\treturn;\n\t}\n\n\tconst defaultUri = workspace.workspaceFolders?.[0]?.uri;\n\tconst openUris = await window.showOpenDialog({\n\t\ttitle: \"Import Hooks\",\n\t\topenLabel: \"Import\",\n\t\tdefaultUri: defaultUri ?? undefined,\n\t\tcanSelectMany: false,\n\t\tfilters: { JSON: [\"json\"] },\n\t});\n\n\tif (!openUris || openUris.length === 0) {\n\t\treturn;\n\t}\n\n\tconst hooksFile = openUris[0];\n\n\ttry {\n\t\tconst bytes = await workspace.fs.readFile(hooksFile);\n\t\tconst json = Buffer.from(bytes).toString(\"utf8\");\n\t\tconst importedCount = await hookManager.importHooks(json);\n\n\t\tconst summary =\n\t\t\timportedCount === 0\n\t\t\t\t? \"No new hooks imported\"\n\t\t\t\t: `Imported ${importedCount} hook${importedCount === 1 ? \"\" : \"s\"} `;\n\n\t\twindow.showInformationMessage(`${summary} from ${hooksFile.fsPath} `);\n\t\toutputChannel.appendLine(`[Hooks] ${summary} from ${hooksFile.fsPath} `);\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\twindow.showErrorMessage(`Failed to import hooks: ${message} `);\n\t\toutputChannel.appendLine(`[Hooks] Failed to import hooks: ${message} `);\n\t}\n}",
    "start_line": 1655,
    "end_line": 1693,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handleHooksImport",
    "component_id": "src.extension.handleHooksImport"
  },
  "src.extension.deactivate": {
    "id": "src.extension.deactivate",
    "name": "deactivate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "function deactivate() {}",
    "start_line": 1696,
    "end_line": 1696,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deactivate",
    "component_id": "src.extension.deactivate"
  },
  "src.extension.setupDocumentPreviewWatchers": {
    "id": "src.extension.setupDocumentPreviewWatchers",
    "name": "setupDocumentPreviewWatchers",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.extension.renderPreviewForUri",
      "src.extension.extractSpecIdFromPath"
    ],
    "source_code": "function setupDocumentPreviewWatchers(context: ExtensionContext) {\n\tconst watcher = workspace.createFileSystemWatcher(\"**/*.md\");\n\n\tconst SPEC_FILES = new Set([\n\t\t\"spec.md\",\n\t\t\"plan.md\",\n\t\t\"research.md\",\n\t\t\"data-model.md\",\n\t\t\"datamodel.md\",\n\t\t\"quickstart.md\",\n\t\t\"tasks.md\",\n\t]);\n\n\tconst isSpecOrChecklistFile = (uri: Uri): boolean => {\n\t\tconst fileName = basename(uri.fsPath).toLowerCase();\n\t\tconst isSpecFile = SPEC_FILES.has(fileName);\n\t\tconst isChecklistFile =\n\t\t\turi.fsPath.includes(\"/checklists/\") && fileName.endsWith(\".md\");\n\n\t\t// Ensure it's within a spec folder (matching 001-...)\n\t\tconst hasSpecId = extractSpecIdFromPath(uri.fsPath) !== null;\n\n\t\treturn hasSpecId && (isSpecFile || isChecklistFile);\n\t};\n\n\tconst handleChangeOrDelete = async (uri: Uri) => {\n\t\tif (activePreviewUri && uri.fsPath === activePreviewUri.fsPath) {\n\t\t\toutputChannel.appendLine(\n\t\t\t\t`[Preview] Auto - reloading active document: ${uri.fsPath} `\n\t\t\t);\n\t\t\tawait renderPreviewForUri(uri);\n\t\t}\n\t};\n\n\tconst handleCreate = (uri: Uri) => {\n\t\tif (isSpecOrChecklistFile(uri)) {\n\t\t\tconst fileName = basename(uri.fsPath);\n\t\t\twindow\n\t\t\t\t.showInformationMessage(\n\t\t\t\t\t`New document created: ${fileName}. Do you want to open it ? `,\n\t\t\t\t\t\"Open\"\n\t\t\t\t)\n\t\t\t\t.then((selection) => {\n\t\t\t\t\tif (selection === \"Open\") {\n\t\t\t\t\t\trenderPreviewForUri(uri);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t};\n\n\twatcher.onDidChange(handleChangeOrDelete);\n\twatcher.onDidDelete(handleChangeOrDelete);\n\twatcher.onDidCreate(handleCreate);\n\n\tcontext.subscriptions.push(watcher);\n}",
    "start_line": 1698,
    "end_line": 1753,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setupDocumentPreviewWatchers",
    "component_id": "src.extension.setupDocumentPreviewWatchers"
  },
  "src.extension.renderPreviewForUri": {
    "id": "src.extension.renderPreviewForUri",
    "name": "renderPreviewForUri",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "ui.src.features.preview.types.DocumentArtifact",
      "src.panels.document-preview-panel.renderDocument",
      "src.services.document-preview-service.loadDocument"
    ],
    "source_code": "async function renderPreviewForUri(\n\turi: Uri\n): Promise<DocumentArtifact | undefined> {\n\tif (!(documentPreviewService && documentPreviewPanel)) {\n\t\twindow.showErrorMessage(\n\t\t\t\"Document preview infrastructure is not ready yet.\"\n\t\t);\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst artifact = await documentPreviewService.loadDocument(uri);\n\t\tactivePreviewUri = uri;\n\t\tawait documentPreviewPanel.renderDocument(artifact);\n\t\treturn artifact;\n\t} catch (error) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\twindow.showErrorMessage(`Failed to open document preview: ${message} `);\n\t\toutputChannel.appendLine(`[Preview] Failed to open document: ${message} `);\n\t}\n}",
    "start_line": 1755,
    "end_line": 1775,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function renderPreviewForUri",
    "component_id": "src.extension.renderPreviewForUri"
  },
  "src.extension.createNewFile": {
    "id": "src.extension.createNewFile",
    "name": "createNewFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "async function createNewFile(uri: Uri, suffix: string): Promise<void> {\n\tconst folder = uri || workspace.workspaceFolders?.[0]?.uri;\n\tif (!folder) {\n\t\treturn;\n\t}\n\n\tconst name = await window.showInputBox({\n\t\tprompt: `Enter name for new file (without ${suffix})`,\n\t\tplaceHolder: \"example\",\n\t});\n\n\tif (!name) {\n\t\treturn;\n\t}\n\n\tconst fileName = name.endsWith(suffix) ? name : `${name}${suffix}`;\n\tconst targetUri = Uri.joinPath(folder, fileName);\n\n\ttry {\n\t\tawait workspace.fs.writeFile(targetUri, new Uint8Array());\n\t\tawait window.showTextDocument(targetUri);\n\t} catch (error) {\n\t\twindow.showErrorMessage(`Failed to create file: ${error}`);\n\t}\n}",
    "start_line": 1777,
    "end_line": 1801,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "suffix"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function createNewFile",
    "component_id": "src.extension.createNewFile"
  },
  "src.extension.resolveWorkspaceRelativeUri": {
    "id": "src.extension.resolveWorkspaceRelativeUri",
    "name": "resolveWorkspaceRelativeUri",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "function resolveWorkspaceRelativeUri(relativePath: string): Uri | undefined {\n\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\tif (!workspaceFolder) {\n\t\treturn;\n\t}\n\n\treturn Uri.joinPath(workspaceFolder.uri, relativePath);\n}",
    "start_line": 1803,
    "end_line": 1810,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "relativePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function resolveWorkspaceRelativeUri",
    "component_id": "src.extension.resolveWorkspaceRelativeUri"
  },
  "src.extension.openDocumentInEditor": {
    "id": "src.extension.openDocumentInEditor",
    "name": "openDocumentInEditor",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [],
    "source_code": "async function openDocumentInEditor(uri: Uri, line?: number): Promise<void> {\n\tconst doc = await workspace.openTextDocument(uri);\n\tconst editor = await window.showTextDocument(doc, { preview: false });\n\tif (typeof line === \"number\" && line >= 0) {\n\t\tconst position = new Position(line, 0);\n\t\teditor.selection = new Selection(position, position);\n\t\teditor.revealRange(new Range(position, position));\n\t}\n}",
    "start_line": 1812,
    "end_line": 1820,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "line"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function openDocumentInEditor",
    "component_id": "src.extension.openDocumentInEditor"
  },
  "src.extension.openActivePreviewInEditor": {
    "id": "src.extension.openActivePreviewInEditor",
    "name": "openActivePreviewInEditor",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/extension.ts",
    "relative_path": "src/extension.ts",
    "depends_on": [
      "src.extension.openDocumentInEditor"
    ],
    "source_code": "async function openActivePreviewInEditor(): Promise<void> {\n\tif (!activePreviewUri) {\n\t\twindow.showInformationMessage(\"No preview is currently active.\");\n\t\treturn;\n\t}\n\n\tawait openDocumentInEditor(activePreviewUri);\n}",
    "start_line": 1822,
    "end_line": 1829,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function openActivePreviewInEditor",
    "component_id": "src.extension.openActivePreviewInEditor"
  },
  "src.features.agents.agent-loader.AgentLoader": {
    "id": "src.features.agents.agent-loader.AgentLoader",
    "name": "AgentLoader",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [
      "src.features.agents.agent-loader.validateFullName",
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.agent-loader.validateId",
      "src.features.agents.agent-loader.validateDescription",
      "src.features.agents.agent-loader.validateName",
      "src.features.agents.agent-loader.validateDefinition",
      "src.features.agents.agent-loader.parseStringArray",
      "src.features.agents.agent-loader.processAgentFile",
      "src.features.agents.agent-loader.parseAgentFile",
      "src.features.agents.agent-loader.validateCommand",
      "src.features.hooks.file-agent-discovery.parseAgentFile",
      "src.features.hooks.agent-registry-types.AgentCommand",
      "src.features.agents.agent-loader.loadAgentsFromDirectory",
      "src.types.prompt.types.ValidationResult",
      "src.features.hooks.actions.agent-action.validateCommand",
      "src.features.agents.agent-loader.parseCommands",
      "src.features.agents.agent-loader.validateCommands",
      "src.features.agents.agent-loader.checkDirectoryExists",
      "src.features.agents.agent-loader.logValidationErrors",
      "src.features.agents.agent-loader.shouldProcessFile"
    ],
    "source_code": "class AgentLoader {\n\tprivate readonly outputChannel: OutputChannel;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Load all agent definitions from a directory\n\t * @param agentsDir Absolute path to agents directory\n\t * @returns Array of valid agent definitions\n\t */\n\tasync loadAgents(agentsDir: string): Promise<AgentDefinition[]> {\n\t\tconst agents: AgentDefinition[] = [];\n\n\t\ttry {\n\t\t\tconst dirUri = Uri.file(agentsDir);\n\n\t\t\tif (!(await this.checkDirectoryExists(dirUri, agentsDir))) {\n\t\t\t\treturn agents;\n\t\t\t}\n\n\t\t\tawait this.loadAgentsFromDirectory(dirUri, agents);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Loaded ${agents.length} agent(s) from ${agentsDir}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Failed to load agents from ${agentsDir}: ${message}`\n\t\t\t);\n\t\t}\n\n\t\treturn agents;\n\t}\n\n\t/**\n\t * Recursively load agents from directory and subdirectories\n\t */\n\tprivate async loadAgentsFromDirectory(\n\t\tdirUri: Uri,\n\t\tagents: AgentDefinition[]\n\t): Promise<void> {\n\t\tconst entries = await workspace.fs.readDirectory(dirUri);\n\n\t\tfor (const [name, fileType] of entries) {\n\t\t\tconst fullPath = `${dirUri.fsPath}/${name}`;\n\n\t\t\tif (fileType === 2) {\n\t\t\t\t// Directory - recurse\n\t\t\t\tawait this.loadAgentsFromDirectory(Uri.file(fullPath), agents);\n\t\t\t} else if (this.shouldProcessFile(name, fileType)) {\n\t\t\t\t// File - process if it's an agent file\n\t\t\t\tawait this.processAgentFile(fullPath, name, agents);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check if directory exists\n\t */\n\tprivate async checkDirectoryExists(\n\t\tdirUri: Uri,\n\t\tagentsDir: string\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\tawait workspace.fs.stat(dirUri);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Error loading agents: Agents directory not found: ${agentsDir}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Check if file should be processed\n\t */\n\tprivate shouldProcessFile(name: string, fileType: number): boolean {\n\t\treturn fileType === 1 && name.endsWith(\".agent.md\");\n\t}\n\n\t/**\n\t * Process a single agent file\n\t */\n\tprivate async processAgentFile(\n\t\tfilePath: string,\n\t\tname: string,\n\t\tagents: AgentDefinition[]\n\t): Promise<void> {\n\t\ttry {\n\t\t\tconst agent = await this.parseAgentFile(filePath);\n\t\t\tconst validation = this.validateDefinition(agent);\n\n\t\t\tif (validation.valid) {\n\t\t\t\tagents.push(agent);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentLoader] Loaded agent: ${agent.id} (${agent.name})`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.logValidationErrors(name, validation.errors);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Failed to parse ${name}: ${message}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Log validation errors\n\t */\n\tprivate logValidationErrors(name: string, errors: string[]): void {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[AgentLoader] Invalid agent definition in ${name}:`\n\t\t);\n\t\tfor (const error of errors) {\n\t\t\tthis.outputChannel.appendLine(`  - ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Parse an agent definition file\n\t * @param filePath Absolute path to agent file\n\t * @returns Parsed agent definition\n\t */\n\tasync parseAgentFile(filePath: string): Promise<AgentDefinition> {\n\t\tconst uri = Uri.file(filePath);\n\n\t\t// Read file contents\n\t\tconst bytes = await workspace.fs.readFile(uri);\n\t\tconst content = Buffer.from(bytes).toString(\"utf8\");\n\n\t\t// Parse YAML frontmatter\n\t\tconst parsed = matter(content);\n\n\t\t// Check if frontmatter exists\n\t\tif (!parsed.data || Object.keys(parsed.data).length === 0) {\n\t\t\tthrow new Error(`No frontmatter found in ${filePath}`);\n\t\t}\n\n\t\t// Extract frontmatter data\n\t\tconst data = parsed.data as Record<string, unknown>;\n\t\tconst resources = (data.resources as Record<string, unknown>) || {};\n\n\t\t// Build agent definition\n\t\tconst commands = this.parseCommands(data.commands);\n\n\t\t// T068 - Automatically inject /help command if not already defined\n\t\tconst hasHelpCommand = commands.some((cmd) => cmd.name === \"help\");\n\t\tif (!hasHelpCommand) {\n\t\t\tcommands.push({\n\t\t\t\tname: \"help\",\n\t\t\t\tdescription: \"Show help information for this agent\",\n\t\t\t\ttool: \"agent.help\",\n\t\t\t});\n\t\t}\n\n\t\tconst agent: AgentDefinition = {\n\t\t\tid: String(data.id || \"\"),\n\t\t\tname: String(data.name || \"\"),\n\t\t\tfullName: String(data.fullName || data.name || \"\"),\n\t\t\tdescription: String(data.description || \"\"),\n\t\t\ticon: data.icon ? String(data.icon) : undefined,\n\t\t\tcommands,\n\t\t\tresources: {\n\t\t\t\tprompts: this.parseStringArray(resources.prompts),\n\t\t\t\tskills: this.parseStringArray(resources.skills),\n\t\t\t\tinstructions: this.parseStringArray(resources.instructions),\n\t\t\t},\n\t\t\tfilePath,\n\t\t\tcontent: parsed.content,\n\t\t};\n\n\t\treturn agent;\n\t}\n\n\t/**\n\t * Parse commands array from frontmatter\n\t */\n\tprivate parseCommands(commands: unknown): AgentCommand[] {\n\t\tif (!Array.isArray(commands)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn commands\n\t\t\t.map((cmd) => {\n\t\t\t\tif (typeof cmd !== \"object\" || cmd === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst command = cmd as Record<string, unknown>;\n\n\t\t\t\treturn {\n\t\t\t\t\tname: String(command.name || \"\"),\n\t\t\t\t\tdescription: String(command.description || \"\"),\n\t\t\t\t\ttool: String(command.tool || \"\"),\n\t\t\t\t\tparameters: Array.isArray(command.parameters)\n\t\t\t\t\t\t? (command.parameters as unknown[]).map((p) => {\n\t\t\t\t\t\t\t\tif (typeof p === \"object\" && p !== null) {\n\t\t\t\t\t\t\t\t\treturn p as Record<string, unknown>;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn {} as Record<string, unknown>;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t})\n\t\t\t.filter((cmd): cmd is Agentcommand => cmd !== null);\n\t}\n\n\t/**\n\t * Parse string array from frontmatter field\n\t */\n\tprivate parseStringArray(value: unknown): string[] | undefined {\n\t\tif (!Array.isArray(value)) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn value\n\t\t\t.filter((item) => typeof item === \"string\")\n\t\t\t.map((item) => String(item));\n\t}\n\n\t/**\n\t * Validate an agent definition\n\t * @param agent Agent definition to validate\n\t * @returns Validation result with errors if any\n\t */\n\tvalidateDefinition(agent: AgentDefinition): ValidationResult {\n\t\tconst errors: string[] = [];\n\n\t\tthis.validateId(agent.id, errors);\n\t\tthis.validateName(agent.name, errors);\n\t\tthis.validateFullName(agent.fullName, errors);\n\t\tthis.validateDescription(agent.description, errors);\n\t\tthis.validateCommands(agent.commands, errors);\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t};\n\t}\n\n\t/**\n\t * Validate agent ID\n\t */\n\tprivate validateId(id: string | undefined, errors: string[]): void {\n\t\tif (!(id && AGENT_ID_PATTERN.test(id))) {\n\t\t\terrors.push(\n\t\t\t\t\"Agent id must be lowercase alphanumeric with hyphens (e.g., 'task-planner')\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate agent name\n\t */\n\tprivate validateName(name: string | undefined, errors: string[]): void {\n\t\tif (!name || name.trim().length === 0) {\n\t\t\terrors.push(\"Agent name is required\");\n\t\t}\n\t}\n\n\t/**\n\t * Validate agent full name\n\t */\n\tprivate validateFullName(\n\t\tfullName: string | undefined,\n\t\terrors: string[]\n\t): void {\n\t\tif (!fullName || fullName.trim().length === 0) {\n\t\t\terrors.push(\"Agent fullName is required\");\n\t\t}\n\t}\n\n\t/**\n\t * Validate agent description\n\t */\n\tprivate validateDescription(\n\t\tdescription: string | undefined,\n\t\terrors: string[]\n\t): void {\n\t\tif (!description || description.trim().length === 0) {\n\t\t\terrors.push(\"Agent description is required\");\n\t\t}\n\t}\n\n\t/**\n\t * Validate agent commands\n\t */\n\tprivate validateCommands(\n\t\tcommands: AgentCommand[] | undefined,\n\t\terrors: string[]\n\t): void {\n\t\tif (!commands || commands.length === 0) {\n\t\t\terrors.push(\"Agent must have at least one commands\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < commands.length; i++) {\n\t\t\tthis.validateCommand(commands[i], i + 1, errors);\n\t\t}\n\t}\n\n\t/**\n\t * Validate a single command\n\t */\n\tprivate validateCommand(\n\t\tcmd: AgentCommand,\n\t\tindex: number,\n\t\terrors: string[]\n\t): void {\n\t\tconst prefix = `command ${index}`;\n\n\t\tif (!cmd.name || cmd.name.trim().length === 0) {\n\t\t\terrors.push(`${prefix}: name is required`);\n\t\t}\n\n\t\tif (!cmd.description || cmd.description.trim().length === 0) {\n\t\t\terrors.push(`${prefix}: description is required`);\n\t\t}\n\n\t\tif (!cmd.tool || cmd.tool.trim().length === 0) {\n\t\t\terrors.push(`${prefix}: tool is required`);\n\t\t}\n\t}\n}",
    "start_line": 14,
    "end_line": 343,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AgentLoader",
    "component_id": "src.features.agents.agent-loader.AgentLoader"
  },
  "src.features.agents.agent-loader.loadAgents": {
    "id": "src.features.agents.agent-loader.loadAgents",
    "name": "loadAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "async loadAgents(agentsDir: string): Promise<AgentDefinition[]> {\n\t\tconst agents: AgentDefinition[] = [];\n\n\t\ttry {\n\t\t\tconst dirUri = Uri.file(agentsDir);\n\n\t\t\tif (!(await this.checkDirectoryExists(dirUri, agentsDir))) {\n\t\t\t\treturn agents;\n\t\t\t}\n\n\t\t\tawait this.loadAgentsFromDirectory(dirUri, agents);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Loaded ${agents.length} agent(s) from ${agentsDir}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Failed to load agents from ${agentsDir}: ${message}`\n\t\t\t);\n\t\t}\n\n\t\treturn agents;\n\t}",
    "start_line": 26,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentsDir"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadAgents",
    "component_id": "src.features.agents.agent-loader.loadAgents"
  },
  "src.features.agents.agent-loader.loadAgentsFromDirectory": {
    "id": "src.features.agents.agent-loader.loadAgentsFromDirectory",
    "name": "loadAgentsFromDirectory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private async loadAgentsFromDirectory(\n\t\tdirUri: Uri,\n\t\tagents: AgentDefinition[]\n\t): Promise<void> {\n\t\tconst entries = await workspace.fs.readDirectory(dirUri);\n\n\t\tfor (const [name, fileType] of entries) {\n\t\t\tconst fullPath = `${dirUri.fsPath}/${name}`;\n\n\t\t\tif (fileType === 2) {\n\t\t\t\t// Directory - recurse\n\t\t\t\tawait this.loadAgentsFromDirectory(Uri.file(fullPath), agents);\n\t\t\t} else if (this.shouldProcessFile(name, fileType)) {\n\t\t\t\t// File - process if it's an agent file\n\t\t\t\tawait this.processAgentFile(fullPath, name, agents);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 54,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dirUri",
      "agents"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadAgentsFromDirectory",
    "component_id": "src.features.agents.agent-loader.loadAgentsFromDirectory"
  },
  "src.features.agents.agent-loader.checkDirectoryExists": {
    "id": "src.features.agents.agent-loader.checkDirectoryExists",
    "name": "checkDirectoryExists",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private async checkDirectoryExists(\n\t\tdirUri: Uri,\n\t\tagentsDir: string\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\tawait workspace.fs.stat(dirUri);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Error loading agents: Agents directory not found: ${agentsDir}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 76,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dirUri",
      "agentsDir"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkDirectoryExists",
    "component_id": "src.features.agents.agent-loader.checkDirectoryExists"
  },
  "src.features.agents.agent-loader.shouldProcessFile": {
    "id": "src.features.agents.agent-loader.shouldProcessFile",
    "name": "shouldProcessFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private shouldProcessFile(name: string, fileType: number): boolean {\n\t\treturn fileType === 1 && name.endsWith(\".agent.md\");\n\t}",
    "start_line": 94,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "fileType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method shouldProcessFile",
    "component_id": "src.features.agents.agent-loader.shouldProcessFile"
  },
  "src.features.agents.agent-loader.processAgentFile": {
    "id": "src.features.agents.agent-loader.processAgentFile",
    "name": "processAgentFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private async processAgentFile(\n\t\tfilePath: string,\n\t\tname: string,\n\t\tagents: AgentDefinition[]\n\t): Promise<void> {\n\t\ttry {\n\t\t\tconst agent = await this.parseAgentFile(filePath);\n\t\t\tconst validation = this.validateDefinition(agent);\n\n\t\t\tif (validation.valid) {\n\t\t\t\tagents.push(agent);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentLoader] Loaded agent: ${agent.id} (${agent.name})`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.logValidationErrors(name, validation.errors);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentLoader] Failed to parse ${name}: ${message}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 101,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath",
      "name",
      "agents"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method processAgentFile",
    "component_id": "src.features.agents.agent-loader.processAgentFile"
  },
  "src.features.agents.agent-loader.logValidationErrors": {
    "id": "src.features.agents.agent-loader.logValidationErrors",
    "name": "logValidationErrors",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private logValidationErrors(name: string, errors: string[]): void {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[AgentLoader] Invalid agent definition in ${name}:`\n\t\t);\n\t\tfor (const error of errors) {\n\t\t\tthis.outputChannel.appendLine(`  - ${error}`);\n\t\t}\n\t}",
    "start_line": 129,
    "end_line": 136,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method logValidationErrors",
    "component_id": "src.features.agents.agent-loader.logValidationErrors"
  },
  "src.features.agents.agent-loader.parseAgentFile": {
    "id": "src.features.agents.agent-loader.parseAgentFile",
    "name": "parseAgentFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "async parseAgentFile(filePath: string): Promise<AgentDefinition> {\n\t\tconst uri = Uri.file(filePath);\n\n\t\t// Read file contents\n\t\tconst bytes = await workspace.fs.readFile(uri);\n\t\tconst content = Buffer.from(bytes).toString(\"utf8\");\n\n\t\t// Parse YAML frontmatter\n\t\tconst parsed = matter(content);\n\n\t\t// Check if frontmatter exists\n\t\tif (!parsed.data || Object.keys(parsed.data).length === 0) {\n\t\t\tthrow new Error(`No frontmatter found in ${filePath}`);\n\t\t}\n\n\t\t// Extract frontmatter data\n\t\tconst data = parsed.data as Record<string, unknown>;\n\t\tconst resources = (data.resources as Record<string, unknown>) || {};\n\n\t\t// Build agent definition\n\t\tconst commands = this.parseCommands(data.commands);\n\n\t\t// T068 - Automatically inject /help command if not already defined\n\t\tconst hasHelpCommand = commands.some((cmd) => cmd.name === \"help\");\n\t\tif (!hasHelpCommand) {\n\t\t\tcommands.push({\n\t\t\t\tname: \"help\",\n\t\t\t\tdescription: \"Show help information for this agent\",\n\t\t\t\ttool: \"agent.help\",\n\t\t\t});\n\t\t}\n\n\t\tconst agent: AgentDefinition = {\n\t\t\tid: String(data.id || \"\"),\n\t\t\tname: String(data.name || \"\"),\n\t\t\tfullName: String(data.fullName || data.name || \"\"),\n\t\t\tdescription: String(data.description || \"\"),\n\t\t\ticon: data.icon ? String(data.icon) : undefined,\n\t\t\tcommands,\n\t\t\tresources: {\n\t\t\t\tprompts: this.parseStringArray(resources.prompts),\n\t\t\t\tskills: this.parseStringArray(resources.skills),\n\t\t\t\tinstructions: this.parseStringArray(resources.instructions),\n\t\t\t},\n\t\t\tfilePath,\n\t\t\tcontent: parsed.content,\n\t\t};\n\n\t\treturn agent;\n\t}",
    "start_line": 143,
    "end_line": 192,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method parseAgentFile",
    "component_id": "src.features.agents.agent-loader.parseAgentFile"
  },
  "src.features.agents.agent-loader.parseCommands": {
    "id": "src.features.agents.agent-loader.parseCommands",
    "name": "parseCommands",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private parseCommands(commands: unknown): AgentCommand[] {\n\t\tif (!Array.isArray(commands)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn commands\n\t\t\t.map((cmd) => {\n\t\t\t\tif (typeof cmd !== \"object\" || cmd === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst command = cmd as Record<string, unknown>;\n\n\t\t\t\treturn {\n\t\t\t\t\tname: String(command.name || \"\"),\n\t\t\t\t\tdescription: String(command.description || \"\"),\n\t\t\t\t\ttool: String(command.tool || \"\"),\n\t\t\t\t\tparameters: Array.isArray(command.parameters)\n\t\t\t\t\t\t? (command.parameters as unknown[]).map((p) => {\n\t\t\t\t\t\t\t\tif (typeof p === \"object\" && p !== null) {\n\t\t\t\t\t\t\t\t\treturn p as Record<string, unknown>;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn {} as Record<string, unknown>;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t})\n\t\t\t.filter((cmd): cmd is Agentcommand => cmd !== null);\n\t}",
    "start_line": 197,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method parseCommands",
    "component_id": "src.features.agents.agent-loader.parseCommands"
  },
  "src.features.agents.agent-loader.parseStringArray": {
    "id": "src.features.agents.agent-loader.parseStringArray",
    "name": "parseStringArray",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private parseStringArray(value: unknown): string[] | undefined {\n\t\tif (!Array.isArray(value)) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn value\n\t\t\t.filter((item) => typeof item === \"string\")\n\t\t\t.map((item) => String(item));\n\t}",
    "start_line": 230,
    "end_line": 238,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method parseStringArray",
    "component_id": "src.features.agents.agent-loader.parseStringArray"
  },
  "src.features.agents.agent-loader.validateDefinition": {
    "id": "src.features.agents.agent-loader.validateDefinition",
    "name": "validateDefinition",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "validateDefinition(agent: AgentDefinition): ValidationResult {\n\t\tconst errors: string[] = [];\n\n\t\tthis.validateId(agent.id, errors);\n\t\tthis.validateName(agent.name, errors);\n\t\tthis.validateFullName(agent.fullName, errors);\n\t\tthis.validateDescription(agent.description, errors);\n\t\tthis.validateCommands(agent.commands, errors);\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t};\n\t}",
    "start_line": 245,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateDefinition",
    "component_id": "src.features.agents.agent-loader.validateDefinition"
  },
  "src.features.agents.agent-loader.validateId": {
    "id": "src.features.agents.agent-loader.validateId",
    "name": "validateId",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private validateId(id: string | undefined, errors: string[]): void {\n\t\tif (!(id && AGENT_ID_PATTERN.test(id))) {\n\t\t\terrors.push(\n\t\t\t\t\"Agent id must be lowercase alphanumeric with hyphens (e.g., 'task-planner')\"\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 263,
    "end_line": 269,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateId",
    "component_id": "src.features.agents.agent-loader.validateId"
  },
  "src.features.agents.agent-loader.validateName": {
    "id": "src.features.agents.agent-loader.validateName",
    "name": "validateName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private validateName(name: string | undefined, errors: string[]): void {\n\t\tif (!name || name.trim().length === 0) {\n\t\t\terrors.push(\"Agent name is required\");\n\t\t}\n\t}",
    "start_line": 274,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateName",
    "component_id": "src.features.agents.agent-loader.validateName"
  },
  "src.features.agents.agent-loader.validateFullName": {
    "id": "src.features.agents.agent-loader.validateFullName",
    "name": "validateFullName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private validateFullName(\n\t\tfullName: string | undefined,\n\t\terrors: string[]\n\t): void {\n\t\tif (!fullName || fullName.trim().length === 0) {\n\t\t\terrors.push(\"Agent fullName is required\");\n\t\t}\n\t}",
    "start_line": 283,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fullName",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateFullName",
    "component_id": "src.features.agents.agent-loader.validateFullName"
  },
  "src.features.agents.agent-loader.validateDescription": {
    "id": "src.features.agents.agent-loader.validateDescription",
    "name": "validateDescription",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private validateDescription(\n\t\tdescription: string | undefined,\n\t\terrors: string[]\n\t): void {\n\t\tif (!description || description.trim().length === 0) {\n\t\t\terrors.push(\"Agent description is required\");\n\t\t}\n\t}",
    "start_line": 295,
    "end_line": 302,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "description",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateDescription",
    "component_id": "src.features.agents.agent-loader.validateDescription"
  },
  "src.features.agents.agent-loader.validateCommands": {
    "id": "src.features.agents.agent-loader.validateCommands",
    "name": "validateCommands",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private validateCommands(\n\t\tcommands: AgentCommand[] | undefined,\n\t\terrors: string[]\n\t): void {\n\t\tif (!commands || commands.length === 0) {\n\t\t\terrors.push(\"Agent must have at least one commands\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < commands.length; i++) {\n\t\t\tthis.validateCommand(commands[i], i + 1, errors);\n\t\t}\n\t}",
    "start_line": 307,
    "end_line": 319,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateCommands",
    "component_id": "src.features.agents.agent-loader.validateCommands"
  },
  "src.features.agents.agent-loader.validateCommand": {
    "id": "src.features.agents.agent-loader.validateCommand",
    "name": "validateCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/agent-loader.ts",
    "relative_path": "src/features/agents/agent-loader.ts",
    "depends_on": [],
    "source_code": "private validateCommand(\n\t\tcmd: AgentCommand,\n\t\tindex: number,\n\t\terrors: string[]\n\t): void {\n\t\tconst prefix = `command ${index}`;\n\n\t\tif (!cmd.name || cmd.name.trim().length === 0) {\n\t\t\terrors.push(`${prefix}: name is required`);\n\t\t}\n\n\t\tif (!cmd.description || cmd.description.trim().length === 0) {\n\t\t\terrors.push(`${prefix}: description is required`);\n\t\t}\n\n\t\tif (!cmd.tool || cmd.tool.trim().length === 0) {\n\t\t\terrors.push(`${prefix}: tool is required`);\n\t\t}\n\t}",
    "start_line": 324,
    "end_line": 342,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "cmd",
      "index",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateCommand",
    "component_id": "src.features.agents.agent-loader.validateCommand"
  },
  "src.features.agents.chat-participant-registry.ChatParticipantRegistry": {
    "id": "src.features.agents.chat-participant-registry.ChatParticipantRegistry",
    "name": "ChatParticipantRegistry",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [
      "src.features.agents.types.ResourceCache",
      "src.features.agents.chat-participant-registry.handleChatRequest",
      "src.utils.chat-prompt-runner.ChatContext",
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.chat-participant-registry.renderResponse",
      "src.features.agents.tool-registry.ToolRegistry",
      "src.features.agents.chat-participant-registry.buildExecutionContext",
      "src.features.hooks.services.mcp-execution-pool.execute",
      "src.features.agents.types.TelemetryReporter",
      "src.features.spec.spec-manager.delete",
      "src.services.agent-service.dispose",
      "src.features.agents.resource-cache.get",
      "src.features.agents.chat-participant-registry.handleToolExecutionError",
      "src.features.agents.types.ToolExecutionContext",
      "src.utils.telemetry.clear",
      "src.features.agents.chat-participant-registry.dispose",
      "src.features.agents.error-formatter.formatError",
      "src.features.agents.error-formatter.getErrorSeverity",
      "src.features.hooks.agent-registry-types.AgentResources",
      "src.features.agents.chat-participant-registry.loadAgentResources",
      "src.features.agents.chat-participant-registry.loadResourcesByType"
    ],
    "source_code": "class ChatParticipantRegistry {\n\tprivate readonly participants = new Map<string, ChatParticipant>();\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate toolRegistry: ToolRegistry | null = null;\n\tprivate resourceCache: ResourceCache | null = null;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Set tool registry for command execution\n\t */\n\tsetToolRegistry(registry: ToolRegistry): void {\n\t\tthis.toolRegistry = registry;\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[ChatParticipantRegistry] Tool registry configured\"\n\t\t);\n\t}\n\n\t/**\n\t * Set resource cache for loading agent resources\n\t */\n\tsetResourceCache(cache: ResourceCache): void {\n\t\tthis.resourceCache = cache;\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[ChatParticipantRegistry] Resource cache configured\"\n\t\t);\n\t}\n\n\t/**\n\t * Register an agent as a chat participant\n\t * @param agent Agent definition to register\n\t * @returns Disposable to unregister the participant\n\t */\n\tregisterAgent(agent: AgentDefinition): Disposable | null {\n\t\ttry {\n\t\t\t// Check if VS Code Chat API is available\n\t\t\tif (!chat) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] VS Code Chat API not available. Skipping registration for agent: ${agent.id}`\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Check if already registered\n\t\t\tif (this.participants.has(agent.id)) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] Agent already registered: ${agent.id}`\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Registering agent: ${agent.id}`\n\t\t\t);\n\n\t\t\t// Create chat participant\n\t\t\tconst participant = chat.createChatParticipant(\n\t\t\t\tagent.id,\n\t\t\t\t(\n\t\t\t\t\trequest: ChatRequest,\n\t\t\t\t\tcontext: ChatContext,\n\t\t\t\t\tstream: ChatResponseStream,\n\t\t\t\t\ttoken: CancellationToken\n\t\t\t\t) => this.handleChatRequest({ agent, request, context, stream, token })\n\t\t\t);\n\n\t\t\t// Set participant metadata\n\t\t\tparticipant.iconPath = agent.icon ? Uri.file(agent.icon) : undefined;\n\n\t\t\t// Register commands as follow-ups\n\t\t\tparticipant.followupProvider = {\n\t\t\t\tprovideFollowups: (\n\t\t\t\t\tresult: ChatResult,\n\t\t\t\t\tcontext: ChatContext,\n\t\t\t\t\ttoken: CancellationToken\n\t\t\t\t) =>\n\t\t\t\t\tagent.commands.map((cmd) => ({\n\t\t\t\t\t\tprompt: `/${cmd.name}`,\n\t\t\t\t\t\tlabel: cmd.description,\n\t\t\t\t\t\tcommand: cmd.name,\n\t\t\t\t\t})),\n\t\t\t};\n\n\t\t\t// Store participant\n\t\t\tthis.participants.set(agent.id, participant);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Successfully registered agent: ${agent.id} with ${agent.commands.length} commands`\n\t\t\t);\n\n\t\t\t// Return disposable to unregister\n\t\t\treturn new Disposable(() => {\n\t\t\t\tparticipant.dispose();\n\t\t\t\tthis.participants.delete(agent.id);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] Unregistered agent: ${agent.id}`\n\t\t\t\t);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Error registering agent ${agent.id}: ${error}`\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Handle chat request for an agent\n\t */\n\tprivate async handleChatRequest(options: {\n\t\tagent: AgentDefinition;\n\t\trequest: ChatRequest;\n\t\tcontext: ChatContext;\n\t\tstream: ChatResponseStream;\n\t\ttoken: CancellationToken;\n\t}): Promise<void> {\n\t\tconst { agent, request, context, stream, token } = options;\n\t\ttry {\n\t\t\t// Parse command from request\n\t\t\tconst commandName = request.command;\n\n\t\t\tif (!commandName) {\n\t\t\t\tstream.markdown(\n\t\t\t\t\t`Available commands for ${agent.name}:\\n\\n${agent.commands\n\t\t\t\t\t\t.map((cmd) => `- \\`/${cmd.name}\\`: ${cmd.description}`)\n\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find command\n\t\t\tconst command = agent.commands.find((cmd) => cmd.name === commandName);\n\n\t\t\tif (!command) {\n\t\t\t\tstream.markdown(\n\t\t\t\t\t`Unknown command: \\`/${commandName}\\`. Available commands:\\n\\n${agent.commands\n\t\t\t\t\t\t.map((cmd) => `- \\`/${cmd.name}\\`: ${cmd.description}`)\n\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Executing command: ${agent.id}/${commandName}`\n\t\t\t);\n\n\t\t\t// Check if tool registry is available\n\t\t\tif (!this.toolRegistry) {\n\t\t\t\tstream.markdown(\n\t\t\t\t\t\" Tool execution is not available. Tool registry not initialized.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Show progress\n\t\t\tstream.progress(`Executing /${commandName}...`);\n\n\t\t\t// Build execution context\n\t\t\tconst executionContext = this.buildExecutionContext(agent, context);\n\n\t\t\t// Load agent resources\n\t\t\tconst resources = this.loadAgentResources(agent);\n\n\t\t\t// Execute tool\n\t\t\tconst startTime = Date.now();\n\t\t\ttry {\n\t\t\t\tconst response = await this.toolRegistry.execute(command.tool, {\n\t\t\t\t\tinput: request.prompt,\n\t\t\t\t\tcontext: executionContext,\n\t\t\t\t\tresources,\n\t\t\t\t\ttoken,\n\t\t\t\t});\n\n\t\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t\t// Render response\n\t\t\t\tthis.renderResponse(stream, response);\n\n\t\t\t\t// Send telemetry\n\t\t\t\tcontext.telemetry.sendTelemetryEvent(\n\t\t\t\t\t\"agent.tool.executed\",\n\t\t\t\t\t{\n\t\t\t\t\t\tagentId: agent.id,\n\t\t\t\t\t\tcommandName,\n\t\t\t\t\t\ttoolName: command.tool,\n\t\t\t\t\t\tsuccess: \"true\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tduration,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] Tool '${command.tool}' completed in ${duration}ms`\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t\t// T061 - Render error with actionable guidance\n\t\t\t\t// T062 - Send error telemetry with classification\n\t\t\t\tthis.handleToolExecutionError(error, stream, context.telemetry, {\n\t\t\t\t\tagentId: agent.id,\n\t\t\t\t\tcommandName,\n\t\t\t\t\ttoolName: command.tool,\n\t\t\t\t\tduration,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Error handling request for ${agent.id}: ${error}`\n\t\t\t);\n\t\t\tstream.markdown(`Error: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Build execution context for tool handlers\n\t */\n\tprivate buildExecutionContext(\n\t\tagent: AgentDefinition,\n\t\tchatContext: ChatContext\n\t): ToolExecutionContext {\n\t\tconst workspaceFolders = workspace.workspaceFolders || [];\n\t\tconst workspaceUri = workspaceFolders[0]?.uri || Uri.file(process.cwd());\n\t\tconst workspaceName = workspaceFolders[0]?.name || \"Workspace\";\n\n\t\treturn {\n\t\t\tagent,\n\t\t\tworkspace: {\n\t\t\t\turi: workspaceUri,\n\t\t\t\tname: workspaceName,\n\t\t\t\tfolders: workspaceFolders,\n\t\t\t},\n\t\t\tvscode: {\n\t\t\t\twindow,\n\t\t\t\tworkspace,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t\tchatContext,\n\t\t\toutputChannel: this.outputChannel,\n\t\t\ttelemetry: {\n\t\t\t\tsendTelemetryEvent: (eventName, properties, measurements) => {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[Telemetry] ${eventName} ${JSON.stringify({ properties, measurements })}`\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsendTelemetryErrorEvent: (eventName, properties, measurements) => {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[Telemetry Error] ${eventName} ${JSON.stringify({ properties, measurements })}`\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * T061 - Handle tool execution errors with user-friendly rendering\n\t * T062 - Send detailed error telemetry with classification\n\t */\n\tprivate handleToolExecutionError(\n\t\terror: unknown,\n\t\tstream: ChatResponseStream,\n\t\ttelemetry: TelemetryReporter,\n\t\tcontext: {\n\t\t\tagentId: string;\n\t\t\tcommandName: string;\n\t\t\ttoolName: string;\n\t\t\tduration: number;\n\t\t}\n\t): void {\n\t\tconst err = error instanceof Error ? error : new Error(String(error));\n\n\t\t// Format error for display and logging\n\t\tconst formatted = formatError(err, {\n\t\t\tagent: context.agentId,\n\t\t\ttool: context.toolName,\n\t\t});\n\n\t\t// T061 - Render user-friendly error message with actionable guidance\n\t\tstream.markdown(`##  Command Failed\\n\\n${formatted.userMessage}`);\n\n\t\tif (formatted.actionableGuidance) {\n\t\t\tstream.markdown(\n\t\t\t\t`\\n\\n**What you can do:**\\n${formatted.actionableGuidance}`\n\t\t\t);\n\t\t}\n\n\t\tstream.markdown(\n\t\t\t`\\n\\n<details>\\n<summary>Technical Details</summary>\\n\\n\\`\\`\\`\\n${formatted.technicalDetails}\\n\\`\\`\\`\\n</details>`\n\t\t);\n\n\t\t// T062 - Send error telemetry with classification\n\t\ttelemetry.sendTelemetryErrorEvent(\n\t\t\t\"agent.tool.failed\",\n\t\t\t{\n\t\t\t\tagentId: context.agentId,\n\t\t\t\tcommandName: context.commandName,\n\t\t\t\ttoolName: context.toolName,\n\t\t\t\terrorType: err.name,\n\t\t\t\terrorCategory: formatted.category,\n\t\t\t\terrorCode: formatted.code || \"none\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tduration: context.duration,\n\t\t\t}\n\t\t);\n\n\t\t// Log with appropriate severity\n\t\tconst severity = getErrorSeverity(formatted.category as ErrorCategory);\n\t\tconst logPrefix = `[ChatParticipantRegistry] ${severity.toUpperCase()}`;\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`${logPrefix}: Tool '${context.toolName}' failed after ${context.duration}ms`\n\t\t);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`${logPrefix}: ${formatted.technicalDetails}`\n\t\t);\n\n\t\tif (err.stack) {\n\t\t\tthis.outputChannel.appendLine(`${logPrefix}: Stack trace:\\n${err.stack}`);\n\t\t}\n\t}\n\n\t/**\n\t * Load agent-specific resources from cache\n\t */\n\tprivate loadAgentResources(agent: AgentDefinition): AgentResources {\n\t\tconst resources: AgentResources = {\n\t\t\tprompts: new Map(),\n\t\t\tskills: new Map(),\n\t\t\tinstructions: new Map(),\n\t\t};\n\n\t\tif (!this.resourceCache) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[ChatParticipantRegistry] Resource cache not available, returning empty resources\"\n\t\t\t);\n\t\t\treturn resources;\n\t\t}\n\n\t\t// Load prompts\n\t\tthis.loadResourcesByType(\n\t\t\tagent.resources.prompts || [],\n\t\t\t\"prompt\",\n\t\t\tresources.prompts\n\t\t);\n\n\t\t// Load skills\n\t\tthis.loadResourcesByType(\n\t\t\tagent.resources.skills || [],\n\t\t\t\"skill\",\n\t\t\tresources.skills\n\t\t);\n\n\t\t// Load instructions\n\t\tthis.loadResourcesByType(\n\t\t\tagent.resources.instructions || [],\n\t\t\t\"instruction\",\n\t\t\tresources.instructions\n\t\t);\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ChatParticipantRegistry] Loaded resources for ${agent.id}: ${resources.prompts.size} prompts, ${resources.skills.size} skills, ${resources.instructions.size} instructions`\n\t\t);\n\n\t\treturn resources;\n\t}\n\n\t/**\n\t * Load resources by type from cache\n\t */\n\tprivate loadResourcesByType(\n\t\tresourceNames: string[],\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\",\n\t\ttargetMap: Map<string, string>\n\t): void {\n\t\tif (!this.resourceCache) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const name of resourceNames) {\n\t\t\tconst content = this.resourceCache.get(type, name);\n\t\t\tif (content) {\n\t\t\t\ttargetMap.set(name, content);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render tool response in chat stream\n\t */\n\tprivate renderResponse(\n\t\tstream: ChatResponseStream,\n\t\tresponse: {\n\t\t\tcontent: string;\n\t\t\tfiles?: Array<{\n\t\t\t\turi: Uri;\n\t\t\t\tlabel?: string;\n\t\t\t\taction?: \"created\" | \"modified\" | \"deleted\";\n\t\t\t}>;\n\t\t\tmetadata?: Record<string, unknown>;\n\t\t}\n\t): void {\n\t\t// Render markdown content\n\t\tstream.markdown(response.content);\n\n\t\t// Render file references\n\t\tif (response.files && response.files.length > 0) {\n\t\t\tstream.markdown(\"\\n\\n**Files:**\\n\");\n\t\t\tfor (const file of response.files) {\n\t\t\t\tconst action = file.action ? `[${file.action}]` : \"\";\n\t\t\t\tconst label = file.label || file.uri.fsPath.split(\"/\").pop() || \"file\";\n\t\t\t\tstream.markdown(`- ${action} [${label}](${file.uri.toString()})\\n`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get all registered participant IDs\n\t */\n\tgetRegisteredAgents(): string[] {\n\t\treturn Array.from(this.participants.keys());\n\t}\n\n\t/**\n\t * Check if an agent is registered\n\t */\n\tisRegistered(agentId: string): boolean {\n\t\treturn this.participants.has(agentId);\n\t}\n\n\t/**\n\t * Dispose all participants\n\t */\n\tdispose(): void {\n\t\tfor (const participant of this.participants.values()) {\n\t\t\tparticipant.dispose();\n\t\t}\n\t\tthis.participants.clear();\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[ChatParticipantRegistry] Disposed all participants\"\n\t\t);\n\t}\n}",
    "start_line": 36,
    "end_line": 481,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ChatParticipantRegistry",
    "component_id": "src.features.agents.chat-participant-registry.ChatParticipantRegistry"
  },
  "src.features.agents.chat-participant-registry.setToolRegistry": {
    "id": "src.features.agents.chat-participant-registry.setToolRegistry",
    "name": "setToolRegistry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "setToolRegistry(registry: ToolRegistry): void {\n\t\tthis.toolRegistry = registry;\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[ChatParticipantRegistry] Tool registry configured\"\n\t\t);\n\t}",
    "start_line": 49,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "registry"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setToolRegistry",
    "component_id": "src.features.agents.chat-participant-registry.setToolRegistry"
  },
  "src.features.agents.chat-participant-registry.setResourceCache": {
    "id": "src.features.agents.chat-participant-registry.setResourceCache",
    "name": "setResourceCache",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "setResourceCache(cache: ResourceCache): void {\n\t\tthis.resourceCache = cache;\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[ChatParticipantRegistry] Resource cache configured\"\n\t\t);\n\t}",
    "start_line": 59,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "cache"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setResourceCache",
    "component_id": "src.features.agents.chat-participant-registry.setResourceCache"
  },
  "src.features.agents.chat-participant-registry.registerAgent": {
    "id": "src.features.agents.chat-participant-registry.registerAgent",
    "name": "registerAgent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "registerAgent(agent: AgentDefinition): Disposable | null {\n\t\ttry {\n\t\t\t// Check if VS Code Chat API is available\n\t\t\tif (!chat) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] VS Code Chat API not available. Skipping registration for agent: ${agent.id}`\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Check if already registered\n\t\t\tif (this.participants.has(agent.id)) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] Agent already registered: ${agent.id}`\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Registering agent: ${agent.id}`\n\t\t\t);\n\n\t\t\t// Create chat participant\n\t\t\tconst participant = chat.createChatParticipant(\n\t\t\t\tagent.id,\n\t\t\t\t(\n\t\t\t\t\trequest: ChatRequest,\n\t\t\t\t\tcontext: ChatContext,\n\t\t\t\t\tstream: ChatResponseStream,\n\t\t\t\t\ttoken: CancellationToken\n\t\t\t\t) => this.handleChatRequest({ agent, request, context, stream, token })\n\t\t\t);\n\n\t\t\t// Set participant metadata\n\t\t\tparticipant.iconPath = agent.icon ? Uri.file(agent.icon) : undefined;\n\n\t\t\t// Register commands as follow-ups\n\t\t\tparticipant.followupProvider = {\n\t\t\t\tprovideFollowups: (\n\t\t\t\t\tresult: ChatResult,\n\t\t\t\t\tcontext: ChatContext,\n\t\t\t\t\ttoken: CancellationToken\n\t\t\t\t) =>\n\t\t\t\t\tagent.commands.map((cmd) => ({\n\t\t\t\t\t\tprompt: `/${cmd.name}`,\n\t\t\t\t\t\tlabel: cmd.description,\n\t\t\t\t\t\tcommand: cmd.name,\n\t\t\t\t\t})),\n\t\t\t};\n\n\t\t\t// Store participant\n\t\t\tthis.participants.set(agent.id, participant);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Successfully registered agent: ${agent.id} with ${agent.commands.length} commands`\n\t\t\t);\n\n\t\t\t// Return disposable to unregister\n\t\t\treturn new Disposable(() => {\n\t\t\t\tparticipant.dispose();\n\t\t\t\tthis.participants.delete(agent.id);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] Unregistered agent: ${agent.id}`\n\t\t\t\t);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Error registering agent ${agent.id}: ${error}`\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t}",
    "start_line": 71,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method registerAgent",
    "component_id": "src.features.agents.chat-participant-registry.registerAgent"
  },
  "src.features.agents.chat-participant-registry.handleChatRequest": {
    "id": "src.features.agents.chat-participant-registry.handleChatRequest",
    "name": "handleChatRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "private async handleChatRequest(options: {\n\t\tagent: AgentDefinition;\n\t\trequest: ChatRequest;\n\t\tcontext: ChatContext;\n\t\tstream: ChatResponseStream;\n\t\ttoken: CancellationToken;\n\t}): Promise<void> {\n\t\tconst { agent, request, context, stream, token } = options;\n\t\ttry {\n\t\t\t// Parse command from request\n\t\t\tconst commandName = request.command;\n\n\t\t\tif (!commandName) {\n\t\t\t\tstream.markdown(\n\t\t\t\t\t`Available commands for ${agent.name}:\\n\\n${agent.commands\n\t\t\t\t\t\t.map((cmd) => `- \\`/${cmd.name}\\`: ${cmd.description}`)\n\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find command\n\t\t\tconst command = agent.commands.find((cmd) => cmd.name === commandName);\n\n\t\t\tif (!command) {\n\t\t\t\tstream.markdown(\n\t\t\t\t\t`Unknown command: \\`/${commandName}\\`. Available commands:\\n\\n${agent.commands\n\t\t\t\t\t\t.map((cmd) => `- \\`/${cmd.name}\\`: ${cmd.description}`)\n\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Executing command: ${agent.id}/${commandName}`\n\t\t\t);\n\n\t\t\t// Check if tool registry is available\n\t\t\tif (!this.toolRegistry) {\n\t\t\t\tstream.markdown(\n\t\t\t\t\t\" Tool execution is not available. Tool registry not initialized.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Show progress\n\t\t\tstream.progress(`Executing /${commandName}...`);\n\n\t\t\t// Build execution context\n\t\t\tconst executionContext = this.buildExecutionContext(agent, context);\n\n\t\t\t// Load agent resources\n\t\t\tconst resources = this.loadAgentResources(agent);\n\n\t\t\t// Execute tool\n\t\t\tconst startTime = Date.now();\n\t\t\ttry {\n\t\t\t\tconst response = await this.toolRegistry.execute(command.tool, {\n\t\t\t\t\tinput: request.prompt,\n\t\t\t\t\tcontext: executionContext,\n\t\t\t\t\tresources,\n\t\t\t\t\ttoken,\n\t\t\t\t});\n\n\t\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t\t// Render response\n\t\t\t\tthis.renderResponse(stream, response);\n\n\t\t\t\t// Send telemetry\n\t\t\t\tcontext.telemetry.sendTelemetryEvent(\n\t\t\t\t\t\"agent.tool.executed\",\n\t\t\t\t\t{\n\t\t\t\t\t\tagentId: agent.id,\n\t\t\t\t\t\tcommandName,\n\t\t\t\t\t\ttoolName: command.tool,\n\t\t\t\t\t\tsuccess: \"true\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tduration,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ChatParticipantRegistry] Tool '${command.tool}' completed in ${duration}ms`\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t\t// T061 - Render error with actionable guidance\n\t\t\t\t// T062 - Send error telemetry with classification\n\t\t\t\tthis.handleToolExecutionError(error, stream, context.telemetry, {\n\t\t\t\t\tagentId: agent.id,\n\t\t\t\t\tcommandName,\n\t\t\t\t\ttoolName: command.tool,\n\t\t\t\t\tduration,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ChatParticipantRegistry] Error handling request for ${agent.id}: ${error}`\n\t\t\t);\n\t\t\tstream.markdown(`Error: ${error}`);\n\t\t}\n\t}",
    "start_line": 147,
    "end_line": 251,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleChatRequest",
    "component_id": "src.features.agents.chat-participant-registry.handleChatRequest"
  },
  "src.features.agents.chat-participant-registry.buildExecutionContext": {
    "id": "src.features.agents.chat-participant-registry.buildExecutionContext",
    "name": "buildExecutionContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "private buildExecutionContext(\n\t\tagent: AgentDefinition,\n\t\tchatContext: ChatContext\n\t): ToolExecutionContext {\n\t\tconst workspaceFolders = workspace.workspaceFolders || [];\n\t\tconst workspaceUri = workspaceFolders[0]?.uri || Uri.file(process.cwd());\n\t\tconst workspaceName = workspaceFolders[0]?.name || \"Workspace\";\n\n\t\treturn {\n\t\t\tagent,\n\t\t\tworkspace: {\n\t\t\t\turi: workspaceUri,\n\t\t\t\tname: workspaceName,\n\t\t\t\tfolders: workspaceFolders,\n\t\t\t},\n\t\t\tvscode: {\n\t\t\t\twindow,\n\t\t\t\tworkspace,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t\tchatContext,\n\t\t\toutputChannel: this.outputChannel,\n\t\t\ttelemetry: {\n\t\t\t\tsendTelemetryEvent: (eventName, properties, measurements) => {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[Telemetry] ${eventName} ${JSON.stringify({ properties, measurements })}`\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsendTelemetryErrorEvent: (eventName, properties, measurements) => {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[Telemetry Error] ${eventName} ${JSON.stringify({ properties, measurements })}`\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}",
    "start_line": 256,
    "end_line": 291,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "chatContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method buildExecutionContext",
    "component_id": "src.features.agents.chat-participant-registry.buildExecutionContext"
  },
  "src.features.agents.chat-participant-registry.handleToolExecutionError": {
    "id": "src.features.agents.chat-participant-registry.handleToolExecutionError",
    "name": "handleToolExecutionError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "private handleToolExecutionError(\n\t\terror: unknown,\n\t\tstream: ChatResponseStream,\n\t\ttelemetry: TelemetryReporter,\n\t\tcontext: {\n\t\t\tagentId: string;\n\t\t\tcommandName: string;\n\t\t\ttoolName: string;\n\t\t\tduration: number;\n\t\t}\n\t): void {\n\t\tconst err = error instanceof Error ? error : new Error(String(error));\n\n\t\t// Format error for display and logging\n\t\tconst formatted = formatError(err, {\n\t\t\tagent: context.agentId,\n\t\t\ttool: context.toolName,\n\t\t});\n\n\t\t// T061 - Render user-friendly error message with actionable guidance\n\t\tstream.markdown(`##  Command Failed\\n\\n${formatted.userMessage}`);\n\n\t\tif (formatted.actionableGuidance) {\n\t\t\tstream.markdown(\n\t\t\t\t`\\n\\n**What you can do:**\\n${formatted.actionableGuidance}`\n\t\t\t);\n\t\t}\n\n\t\tstream.markdown(\n\t\t\t`\\n\\n<details>\\n<summary>Technical Details</summary>\\n\\n\\`\\`\\`\\n${formatted.technicalDetails}\\n\\`\\`\\`\\n</details>`\n\t\t);\n\n\t\t// T062 - Send error telemetry with classification\n\t\ttelemetry.sendTelemetryErrorEvent(\n\t\t\t\"agent.tool.failed\",\n\t\t\t{\n\t\t\t\tagentId: context.agentId,\n\t\t\t\tcommandName: context.commandName,\n\t\t\t\ttoolName: context.toolName,\n\t\t\t\terrorType: err.name,\n\t\t\t\terrorCategory: formatted.category,\n\t\t\t\terrorCode: formatted.code || \"none\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tduration: context.duration,\n\t\t\t}\n\t\t);\n\n\t\t// Log with appropriate severity\n\t\tconst severity = getErrorSeverity(formatted.category as ErrorCategory);\n\t\tconst logPrefix = `[ChatParticipantRegistry] ${severity.toUpperCase()}`;\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`${logPrefix}: Tool '${context.toolName}' failed after ${context.duration}ms`\n\t\t);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`${logPrefix}: ${formatted.technicalDetails}`\n\t\t);\n\n\t\tif (err.stack) {\n\t\t\tthis.outputChannel.appendLine(`${logPrefix}: Stack trace:\\n${err.stack}`);\n\t\t}\n\t}",
    "start_line": 297,
    "end_line": 359,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "stream",
      "telemetry",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleToolExecutionError",
    "component_id": "src.features.agents.chat-participant-registry.handleToolExecutionError"
  },
  "src.features.agents.chat-participant-registry.loadAgentResources": {
    "id": "src.features.agents.chat-participant-registry.loadAgentResources",
    "name": "loadAgentResources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "private loadAgentResources(agent: AgentDefinition): AgentResources {\n\t\tconst resources: AgentResources = {\n\t\t\tprompts: new Map(),\n\t\t\tskills: new Map(),\n\t\t\tinstructions: new Map(),\n\t\t};\n\n\t\tif (!this.resourceCache) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[ChatParticipantRegistry] Resource cache not available, returning empty resources\"\n\t\t\t);\n\t\t\treturn resources;\n\t\t}\n\n\t\t// Load prompts\n\t\tthis.loadResourcesByType(\n\t\t\tagent.resources.prompts || [],\n\t\t\t\"prompt\",\n\t\t\tresources.prompts\n\t\t);\n\n\t\t// Load skills\n\t\tthis.loadResourcesByType(\n\t\t\tagent.resources.skills || [],\n\t\t\t\"skill\",\n\t\t\tresources.skills\n\t\t);\n\n\t\t// Load instructions\n\t\tthis.loadResourcesByType(\n\t\t\tagent.resources.instructions || [],\n\t\t\t\"instruction\",\n\t\t\tresources.instructions\n\t\t);\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ChatParticipantRegistry] Loaded resources for ${agent.id}: ${resources.prompts.size} prompts, ${resources.skills.size} skills, ${resources.instructions.size} instructions`\n\t\t);\n\n\t\treturn resources;\n\t}",
    "start_line": 364,
    "end_line": 404,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadAgentResources",
    "component_id": "src.features.agents.chat-participant-registry.loadAgentResources"
  },
  "src.features.agents.chat-participant-registry.loadResourcesByType": {
    "id": "src.features.agents.chat-participant-registry.loadResourcesByType",
    "name": "loadResourcesByType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "private loadResourcesByType(\n\t\tresourceNames: string[],\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\",\n\t\ttargetMap: Map<string, string>\n\t): void {\n\t\tif (!this.resourceCache) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const name of resourceNames) {\n\t\t\tconst content = this.resourceCache.get(type, name);\n\t\t\tif (content) {\n\t\t\t\ttargetMap.set(name, content);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 409,
    "end_line": 424,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "resourceNames",
      "type",
      "targetMap"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadResourcesByType",
    "component_id": "src.features.agents.chat-participant-registry.loadResourcesByType"
  },
  "src.features.agents.chat-participant-registry.renderResponse": {
    "id": "src.features.agents.chat-participant-registry.renderResponse",
    "name": "renderResponse",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "private renderResponse(\n\t\tstream: ChatResponseStream,\n\t\tresponse: {\n\t\t\tcontent: string;\n\t\t\tfiles?: Array<{\n\t\t\t\turi: Uri;\n\t\t\t\tlabel?: string;\n\t\t\t\taction?: \"created\" | \"modified\" | \"deleted\";\n\t\t\t}>;\n\t\t\tmetadata?: Record<string, unknown>;\n\t\t}\n\t): void {\n\t\t// Render markdown content\n\t\tstream.markdown(response.content);\n\n\t\t// Render file references\n\t\tif (response.files && response.files.length > 0) {\n\t\t\tstream.markdown(\"\\n\\n**Files:**\\n\");\n\t\t\tfor (const file of response.files) {\n\t\t\t\tconst action = file.action ? `[${file.action}]` : \"\";\n\t\t\t\tconst label = file.label || file.uri.fsPath.split(\"/\").pop() || \"file\";\n\t\t\t\tstream.markdown(`- ${action} [${label}](${file.uri.toString()})\\n`);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 429,
    "end_line": 453,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "stream",
      "response"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method renderResponse",
    "component_id": "src.features.agents.chat-participant-registry.renderResponse"
  },
  "src.features.agents.chat-participant-registry.getRegisteredAgents": {
    "id": "src.features.agents.chat-participant-registry.getRegisteredAgents",
    "name": "getRegisteredAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "getRegisteredAgents(): string[] {\n\t\treturn Array.from(this.participants.keys());\n\t}",
    "start_line": 458,
    "end_line": 460,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRegisteredAgents",
    "component_id": "src.features.agents.chat-participant-registry.getRegisteredAgents"
  },
  "src.features.agents.chat-participant-registry.isRegistered": {
    "id": "src.features.agents.chat-participant-registry.isRegistered",
    "name": "isRegistered",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "isRegistered(agentId: string): boolean {\n\t\treturn this.participants.has(agentId);\n\t}",
    "start_line": 465,
    "end_line": 467,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isRegistered",
    "component_id": "src.features.agents.chat-participant-registry.isRegistered"
  },
  "src.features.agents.chat-participant-registry.dispose": {
    "id": "src.features.agents.chat-participant-registry.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/chat-participant-registry.ts",
    "relative_path": "src/features/agents/chat-participant-registry.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tfor (const participant of this.participants.values()) {\n\t\t\tparticipant.dispose();\n\t\t}\n\t\tthis.participants.clear();\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[ChatParticipantRegistry] Disposed all participants\"\n\t\t);\n\t}",
    "start_line": 472,
    "end_line": 480,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.agents.chat-participant-registry.dispose"
  },
  "src.features.agents.error-formatter.ErrorCategory": {
    "id": "src.features.agents.error-formatter.ErrorCategory",
    "name": "ErrorCategory",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [],
    "source_code": "type ErrorCategory = (typeof ErrorCategory)[keyof typeof ErrorCategory];",
    "start_line": 21,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ErrorCategory",
    "component_id": "src.features.agents.error-formatter.ErrorCategory"
  },
  "src.features.agents.error-formatter.FormattedError": {
    "id": "src.features.agents.error-formatter.FormattedError",
    "name": "FormattedError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.ErrorCategory"
    ],
    "source_code": "interface FormattedError {\n\t/** User-friendly error message */\n\tuserMessage: string;\n\n\t/** Technical error details for logging */\n\ttechnicalDetails: string;\n\n\t/** Error category for telemetry */\n\tcategory: ErrorCategory;\n\n\t/** Optional actionable guidance */\n\tactionableGuidance?: string;\n\n\t/** Error code if available */\n\tcode?: string;\n}",
    "start_line": 26,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormattedError",
    "component_id": "src.features.agents.error-formatter.FormattedError"
  },
  "src.features.agents.error-formatter.formatError": {
    "id": "src.features.agents.error-formatter.formatError",
    "name": "formatError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.formatResourceError",
      "src.features.agents.error-formatter.formatToolExecutionError",
      "src.features.agents.error-formatter.formatGenericError",
      "src.features.agents.error-formatter.formatAgentError",
      "src.features.agents.error-formatter.FormattedError"
    ],
    "source_code": "function formatError(\n\terror: Error,\n\tcontext?: { tool?: string; agent?: string }\n): FormattedError {\n\t// Handle custom error types\n\tif (error instanceof ToolExecutionError) {\n\t\treturn formatToolExecutionError(error, context);\n\t}\n\n\tif (error instanceof ResourceError) {\n\t\treturn formatResourceError(error, context);\n\t}\n\n\tif (error instanceof AgentError) {\n\t\treturn formatAgentError(error, context);\n\t}\n\n\t// Handle generic errors\n\treturn formatGenericError(error, context);\n}",
    "start_line": 49,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatError",
    "component_id": "src.features.agents.error-formatter.formatError"
  },
  "src.features.agents.error-formatter.formatToolExecutionError": {
    "id": "src.features.agents.error-formatter.formatToolExecutionError",
    "name": "formatToolExecutionError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.formatResourceError",
      "src.features.agents.error-formatter.getActionableGuidance",
      "src.features.agents.error-formatter.sanitizeMessage",
      "src.features.agents.error-formatter.categorizeError",
      "src.features.agents.error-formatter.formatAgentError",
      "src.features.agents.error-formatter.FormattedError",
      "src.features.agents.types.ToolExecutionError"
    ],
    "source_code": "function formatToolExecutionError(\n\terror: ToolExecutionError,\n\tcontext?: { tool?: string; agent?: string }\n): FormattedError {\n\tconst toolName = error.tool || context?.tool || \"unknown tool\";\n\n\t// Check if the cause is a known error type\n\tif (error.cause) {\n\t\tif (error.cause instanceof ResourceError) {\n\t\t\treturn formatResourceError(error.cause, { ...context, tool: toolName });\n\t\t}\n\n\t\tif (error.cause instanceof AgentError) {\n\t\t\treturn formatAgentError(error.cause, { ...context, tool: toolName });\n\t\t}\n\t}\n\n\tconst category = categorizeError(error);\n\tconst userMessage = `Command execution failed: ${sanitizeMessage(error.message)}`;\n\tconst actionableGuidance = getActionableGuidance(category, {\n\t\ttool: toolName,\n\t\tcause: error.cause?.message,\n\t});\n\n\treturn {\n\t\tuserMessage,\n\t\ttechnicalDetails: `Tool: ${toolName}, Error: ${error.message}, Cause: ${error.cause?.message || \"none\"}`,\n\t\tcategory,\n\t\tactionableGuidance,\n\t};\n}",
    "start_line": 73,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatToolExecutionError",
    "component_id": "src.features.agents.error-formatter.formatToolExecutionError"
  },
  "src.features.agents.error-formatter.formatResourceError": {
    "id": "src.features.agents.error-formatter.formatResourceError",
    "name": "formatResourceError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.FormattedError",
      "src.features.agents.types.ResourceError"
    ],
    "source_code": "function formatResourceError(\n\terror: ResourceError,\n\tcontext?: { tool?: string; agent?: string }\n): FormattedError {\n\tconst resourceType = error.resourceType;\n\tconst resourceName = error.resourceName;\n\tconst toolInfo = context?.tool ? ` in ${context.tool}` : \"\";\n\n\tconst userMessage = `Missing ${resourceType}: ${resourceName}${toolInfo}`;\n\tconst actionableGuidance = `Ensure the file exists in the resources/${resourceType}s/ directory and is properly configured in the agent definition.`;\n\n\treturn {\n\t\tuserMessage,\n\t\ttechnicalDetails: `ResourceError: Type=${resourceType}, Name=${resourceName}, Tool=${context?.tool || \"unknown\"}`,\n\t\tcategory: ErrorCategory.RESOURCE,\n\t\tactionableGuidance,\n\t};\n}",
    "start_line": 108,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatResourceError",
    "component_id": "src.features.agents.error-formatter.formatResourceError"
  },
  "src.features.agents.error-formatter.formatAgentError": {
    "id": "src.features.agents.error-formatter.formatAgentError",
    "name": "formatAgentError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.FormattedError",
      "src.features.agents.error-formatter.sanitizeMessage",
      "src.features.agents.types.AgentError",
      "src.features.agents.error-formatter.categorizeAgentError"
    ],
    "source_code": "function formatAgentError(\n\terror: AgentError,\n\tcontext?: { tool?: string; agent?: string }\n): FormattedError {\n\tconst category = categorizeAgentError(error);\n\tlet userMessage = sanitizeMessage(error.message);\n\tlet actionableGuidance: string | undefined;\n\n\tswitch (error.code) {\n\t\tcase \"CANCELLED\":\n\t\t\tuserMessage = \"Operation cancelled\";\n\t\t\tactionableGuidance = undefined; // User initiated, no action needed\n\t\t\tbreak;\n\n\t\tcase \"TIMEOUT\":\n\t\t\tuserMessage = \"Operation timed out\";\n\t\t\tactionableGuidance =\n\t\t\t\t\"The operation took too long to complete. Try again or simplify your request.\";\n\t\t\tbreak;\n\n\t\tcase \"CONFIG_ERROR\":\n\t\t\tuserMessage = `Configuration error: ${sanitizeMessage(error.message)}`;\n\t\t\tactionableGuidance =\n\t\t\t\t\"Check the agent definition file for correct configuration.\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tactionableGuidance =\n\t\t\t\t\"Please try again or contact support if the issue persists.\";\n\t}\n\n\treturn {\n\t\tuserMessage,\n\t\ttechnicalDetails: `AgentError: Code=${error.code || \"none\"}, Message=${error.message}`,\n\t\tcategory,\n\t\tactionableGuidance,\n\t\tcode: error.code,\n\t};\n}",
    "start_line": 130,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatAgentError",
    "component_id": "src.features.agents.error-formatter.formatAgentError"
  },
  "src.features.agents.error-formatter.formatGenericError": {
    "id": "src.features.agents.error-formatter.formatGenericError",
    "name": "formatGenericError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.FormattedError",
      "src.features.agents.error-formatter.sanitizeMessage"
    ],
    "source_code": "function formatGenericError(\n\terror: Error,\n\tcontext?: { tool?: string; agent?: string }\n): FormattedError {\n\tconst category = ErrorCategory.UNKNOWN;\n\tconst userMessage = `An unexpected error occurred: ${sanitizeMessage(error.message)}`;\n\tconst actionableGuidance =\n\t\t\"Please try again. If the problem persists, check the output logs for details.\";\n\n\treturn {\n\t\tuserMessage,\n\t\ttechnicalDetails: `GenericError: ${error.name}: ${error.message}, Stack: ${error.stack || \"none\"}`,\n\t\tcategory,\n\t\tactionableGuidance,\n\t};\n}",
    "start_line": 173,
    "end_line": 188,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatGenericError",
    "component_id": "src.features.agents.error-formatter.formatGenericError"
  },
  "src.features.agents.error-formatter.categorizeError": {
    "id": "src.features.agents.error-formatter.categorizeError",
    "name": "categorizeError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.ErrorCategory"
    ],
    "source_code": "function categorizeError(error: Error): ErrorCategory {\n\tconst message = error.message.toLowerCase();\n\n\tif (message.includes(\"cancel\")) {\n\t\treturn ErrorCategory.CANCELLATION;\n\t}\n\n\tif (message.includes(\"timeout\") || message.includes(\"timed out\")) {\n\t\treturn ErrorCategory.TIMEOUT;\n\t}\n\n\tif (\n\t\tmessage.includes(\"invalid\") ||\n\t\tmessage.includes(\"validation\") ||\n\t\tmessage.includes(\"required\")\n\t) {\n\t\treturn ErrorCategory.VALIDATION;\n\t}\n\n\tif (message.includes(\"resource\") || message.includes(\"not found\")) {\n\t\treturn ErrorCategory.RESOURCE;\n\t}\n\n\treturn ErrorCategory.EXECUTION;\n}",
    "start_line": 193,
    "end_line": 217,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function categorizeError",
    "component_id": "src.features.agents.error-formatter.categorizeError"
  },
  "src.features.agents.error-formatter.categorizeAgentError": {
    "id": "src.features.agents.error-formatter.categorizeAgentError",
    "name": "categorizeAgentError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.ErrorCategory",
      "src.features.agents.types.AgentError"
    ],
    "source_code": "function categorizeAgentError(error: AgentError): ErrorCategory {\n\tswitch (error.code) {\n\t\tcase \"CANCELLED\":\n\t\t\treturn ErrorCategory.CANCELLATION;\n\t\tcase \"TIMEOUT\":\n\t\t\treturn ErrorCategory.TIMEOUT;\n\t\tcase \"CONFIG_ERROR\":\n\t\t\treturn ErrorCategory.VALIDATION;\n\t\tdefault:\n\t\t\treturn ErrorCategory.EXECUTION;\n\t}\n}",
    "start_line": 222,
    "end_line": 233,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function categorizeAgentError",
    "component_id": "src.features.agents.error-formatter.categorizeAgentError"
  },
  "src.features.agents.error-formatter.getActionableGuidance": {
    "id": "src.features.agents.error-formatter.getActionableGuidance",
    "name": "getActionableGuidance",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.ErrorCategory"
    ],
    "source_code": "function getActionableGuidance(\n\tcategory: ErrorCategory,\n\tdetails?: { tool?: string; cause?: string }\n): string {\n\tswitch (category) {\n\t\tcase ErrorCategory.VALIDATION:\n\t\t\treturn \"Check your input and try again with the correct format.\";\n\n\t\tcase ErrorCategory.RESOURCE:\n\t\t\treturn \"Ensure all required resources are available and properly configured.\";\n\n\t\tcase ErrorCategory.EXECUTION:\n\t\t\tif (details?.cause) {\n\t\t\t\treturn `Error details: ${details.cause}. Please review and try again.`;\n\t\t\t}\n\t\t\treturn \"The operation failed. Check the logs for details and try again.\";\n\n\t\tcase ErrorCategory.CANCELLATION:\n\t\t\treturn \"\"; // No guidance needed for user-initiated cancellation\n\n\t\tcase ErrorCategory.TIMEOUT:\n\t\t\treturn \"The operation took too long. Try again or simplify your request.\";\n\n\t\tdefault:\n\t\t\treturn \"An unexpected error occurred. Check the logs for details.\";\n\t}\n}",
    "start_line": 238,
    "end_line": 264,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "category",
      "details"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getActionableGuidance",
    "component_id": "src.features.agents.error-formatter.getActionableGuidance"
  },
  "src.features.agents.error-formatter.sanitizeMessage": {
    "id": "src.features.agents.error-formatter.sanitizeMessage",
    "name": "sanitizeMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [],
    "source_code": "function sanitizeMessage(message: string): string {\n\t// Remove stack traces\n\tconst lines = message.split(\"\\n\");\n\tconst firstLine = lines[0];\n\n\t// Remove file paths\n\tlet sanitized = firstLine.replace(/\\/[^\\s]+/g, \"[file]\");\n\n\t// Remove common error prefixes\n\tsanitized = sanitized.replace(ERROR_PREFIX_PATTERN, \"\");\n\n\t// Limit length\n\tif (sanitized.length > 200) {\n\t\tsanitized = `${sanitized.substring(0, 197)}...`;\n\t}\n\n\treturn sanitized;\n}",
    "start_line": 272,
    "end_line": 289,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sanitizeMessage",
    "component_id": "src.features.agents.error-formatter.sanitizeMessage"
  },
  "src.features.agents.error-formatter.getErrorSeverity": {
    "id": "src.features.agents.error-formatter.getErrorSeverity",
    "name": "getErrorSeverity",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/error-formatter.ts",
    "relative_path": "src/features/agents/error-formatter.ts",
    "depends_on": [
      "src.features.agents.error-formatter.ErrorCategory"
    ],
    "source_code": "function getErrorSeverity(\n\tcategory: ErrorCategory\n): \"error\" | \"warning\" | \"info\" {\n\tswitch (category) {\n\t\tcase ErrorCategory.CANCELLATION:\n\t\t\treturn \"info\";\n\n\t\tcase ErrorCategory.VALIDATION:\n\t\tcase ErrorCategory.RESOURCE:\n\t\t\treturn \"warning\";\n\n\t\tdefault:\n\t\t\treturn \"error\";\n\t}\n}",
    "start_line": 294,
    "end_line": 308,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "category"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getErrorSeverity",
    "component_id": "src.features.agents.error-formatter.getErrorSeverity"
  },
  "src.features.agents.file-watcher.ChangeHandler": {
    "id": "src.features.agents.file-watcher.ChangeHandler",
    "name": "ChangeHandler",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/file-watcher.ts",
    "relative_path": "src/features/agents/file-watcher.ts",
    "depends_on": [],
    "source_code": "type ChangeHandler = (changedFiles: string[]) => void;",
    "start_line": 9,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeHandler",
    "component_id": "src.features.agents.file-watcher.ChangeHandler"
  },
  "src.features.agents.file-watcher.FileWatcher": {
    "id": "src.features.agents.file-watcher.FileWatcher",
    "name": "FileWatcher",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/file-watcher.ts",
    "relative_path": "src/features/agents/file-watcher.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "src.features.agents.file-watcher.dispose",
      "src.features.agents.file-watcher.onFileChange",
      "src.services.agent-service.dispose",
      "src.features.agents.file-watcher.flushPendingChanges",
      "src.features.agents.file-watcher.ChangeHandler",
      "src.features.hooks.file-watcher-service.flushPendingChanges"
    ],
    "source_code": "class FileWatcher implements Disposable {\n\tprivate readonly watcher: FileSystemWatcher;\n\tprivate readonly changeHandler: ChangeHandler;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly pendingChanges: Set<string> = new Set();\n\tprivate debounceTimer: NodeJS.Timeout | null = null;\n\tprivate readonly debounceDelayMs = 500;\n\n\tconstructor(\n\t\toutputChannel: OutputChannel,\n\t\twatcher: FileSystemWatcher,\n\t\tchangeHandler: ChangeHandler\n\t) {\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.watcher = watcher;\n\t\tthis.changeHandler = changeHandler;\n\n\t\t// Register event handlers\n\t\tthis.watcher.onDidChange(this.onFileChange.bind(this));\n\t\tthis.watcher.onDidCreate(this.onFileChange.bind(this));\n\t\tthis.watcher.onDidDelete(this.onFileChange.bind(this));\n\n\t\tthis.outputChannel.appendLine(\"[FileWatcher] Initialized\");\n\t}\n\n\t/**\n\t * Handle file change event\n\t * Adds to pending changes and starts/resets debounce timer\n\t */\n\tprivate onFileChange(uri: { fsPath: string }): void {\n\t\tthis.pendingChanges.add(uri.fsPath);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[FileWatcher] Detected change: ${uri.fsPath} (pending: ${this.pendingChanges.size})`\n\t\t);\n\n\t\t// Clear existing timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t}\n\n\t\t// Start new debounce timer\n\t\tthis.debounceTimer = setTimeout(() => {\n\t\t\tthis.flushPendingChanges();\n\t\t}, this.debounceDelayMs);\n\t}\n\n\t/**\n\t * Flush pending changes and invoke callback\n\t */\n\tprivate flushPendingChanges(): void {\n\t\tif (this.pendingChanges.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst changedFiles = Array.from(this.pendingChanges);\n\t\tthis.pendingChanges.clear();\n\t\tthis.debounceTimer = null;\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[FileWatcher] Flushing ${changedFiles.length} pending change(s)`\n\t\t);\n\n\t\ttry {\n\t\t\tthis.changeHandler(changedFiles);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[FileWatcher] Error in change handler: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Cleanup watcher and pending timers\n\t */\n\tdispose(): void {\n\t\t// Clear pending timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t\tthis.debounceTimer = null;\n\t\t}\n\n\t\t// Clear pending changes without invoking callback\n\t\tthis.pendingChanges.clear();\n\n\t\t// Dispose watcher\n\t\tthis.watcher.dispose();\n\n\t\tthis.outputChannel.appendLine(\"[FileWatcher] Disposed\");\n\t}\n}",
    "start_line": 15,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class FileWatcher",
    "component_id": "src.features.agents.file-watcher.FileWatcher"
  },
  "src.features.agents.file-watcher.onFileChange": {
    "id": "src.features.agents.file-watcher.onFileChange",
    "name": "onFileChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/file-watcher.ts",
    "relative_path": "src/features/agents/file-watcher.ts",
    "depends_on": [],
    "source_code": "private onFileChange(uri: { fsPath: string }): void {\n\t\tthis.pendingChanges.add(uri.fsPath);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[FileWatcher] Detected change: ${uri.fsPath} (pending: ${this.pendingChanges.size})`\n\t\t);\n\n\t\t// Clear existing timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t}\n\n\t\t// Start new debounce timer\n\t\tthis.debounceTimer = setTimeout(() => {\n\t\t\tthis.flushPendingChanges();\n\t\t}, this.debounceDelayMs);\n\t}",
    "start_line": 44,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method onFileChange",
    "component_id": "src.features.agents.file-watcher.onFileChange"
  },
  "src.features.agents.file-watcher.flushPendingChanges": {
    "id": "src.features.agents.file-watcher.flushPendingChanges",
    "name": "flushPendingChanges",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/file-watcher.ts",
    "relative_path": "src/features/agents/file-watcher.ts",
    "depends_on": [],
    "source_code": "private flushPendingChanges(): void {\n\t\tif (this.pendingChanges.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst changedFiles = Array.from(this.pendingChanges);\n\t\tthis.pendingChanges.clear();\n\t\tthis.debounceTimer = null;\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[FileWatcher] Flushing ${changedFiles.length} pending change(s)`\n\t\t);\n\n\t\ttry {\n\t\t\tthis.changeHandler(changedFiles);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[FileWatcher] Error in change handler: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 64,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flushPendingChanges",
    "component_id": "src.features.agents.file-watcher.flushPendingChanges"
  },
  "src.features.agents.file-watcher.dispose": {
    "id": "src.features.agents.file-watcher.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/file-watcher.ts",
    "relative_path": "src/features/agents/file-watcher.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\t// Clear pending timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t\tthis.debounceTimer = null;\n\t\t}\n\n\t\t// Clear pending changes without invoking callback\n\t\tthis.pendingChanges.clear();\n\n\t\t// Dispose watcher\n\t\tthis.watcher.dispose();\n\n\t\tthis.outputChannel.appendLine(\"[FileWatcher] Disposed\");\n\t}",
    "start_line": 89,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.agents.file-watcher.dispose"
  },
  "src.features.agents.gray-matter.d.GrayMatterFile": {
    "id": "src.features.agents.gray-matter.d.GrayMatterFile",
    "name": "GrayMatterFile",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/gray-matter.d.ts",
    "relative_path": "src/features/agents/gray-matter.d.ts",
    "depends_on": [],
    "source_code": "interface GrayMatterFile<T> {\n\t\t/** Original content string */\n\t\tcontent: string;\n\t\t/** Parsed data from YAML frontmatter */\n\t\tdata: T;\n\t\t/** Excerpt if defined in options */\n\t\texcerpt?: string;\n\t\t/** Original input string */\n\t\torig: Buffer | string;\n\t\t/** Language of the frontmatter (default: yaml) */\n\t\tlanguage?: string;\n\t\t/** Frontmatter delimiters */\n\t\tmatter?: string;\n\t\t/** String before frontmatter */\n\t\tstringify?: string;\n\t}",
    "start_line": 8,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GrayMatterFile",
    "component_id": "src.features.agents.gray-matter.d.GrayMatterFile"
  },
  "src.features.agents.gray-matter.d.GrayMatterOption": {
    "id": "src.features.agents.gray-matter.d.GrayMatterOption",
    "name": "GrayMatterOption",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/gray-matter.d.ts",
    "relative_path": "src/features/agents/gray-matter.d.ts",
    "depends_on": [
      "src.features.agents.gray-matter.d.GrayMatterFile",
      "src.features.agents.gray-matter.d.GrayMatterOption"
    ],
    "source_code": "interface GrayMatterOption<T> {\n\t\t/** Excerpt function or boolean */\n\t\texcerpt?:\n\t\t\t| boolean\n\t\t\t| ((file: GrayMatterFile<T>, options: GrayMatterOption<T>) => string);\n\t\t/** Excerpt separator */\n\t\texcerpt_separator?: string;\n\t\t/** Custom engines */\n\t\tengines?: Record<string, (input: string) => unknown>;\n\t\t/** Language to use */\n\t\tlanguage?: string;\n\t\t/** Custom delimiters */\n\t\tdelimiters?: string | [string, string];\n\t}",
    "start_line": 25,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GrayMatterOption",
    "component_id": "src.features.agents.gray-matter.d.GrayMatterOption"
  },
  "src.features.agents.resource-cache.ResourceCacheInterface": {
    "id": "src.features.agents.resource-cache.ResourceCacheInterface",
    "name": "ResourceCacheInterface",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "interface ResourceCacheInterface {\n\tprompts: Map<string, string>;\n\tskills: Map<string, string>;\n\tinstructions: Map<string, string>;\n\tload(resourcesDir: string): Promise<void>;\n\treload(changedFiles: string[]): Promise<void>;\n\tget(\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\",\n\t\tname: string\n\t): string | undefined;\n\tgetAll(type: \"prompt\" | \"skill\" | \"instruction\"): Map<string, string>;\n\tdispose(): void;\n}",
    "start_line": 10,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResourceCacheInterface",
    "component_id": "src.features.agents.resource-cache.ResourceCacheInterface"
  },
  "src.features.agents.resource-cache.ResourceCache": {
    "id": "src.features.agents.resource-cache.ResourceCache",
    "name": "ResourceCache",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "src.features.agents.resource-cache.ResourceCacheInterface",
      "src.features.agents.resource-cache.loadResourceType",
      "src.features.agents.resource-cache.get",
      "src.features.agents.resource-cache.loadNestedResources",
      "src.features.agents.resource-cache.getMapForType",
      "src.features.spec.spec-manager.delete",
      "src.features.agents.resource-cache.parseResourcePath",
      "src.features.agents.resource-cache.reloadSingleFile"
    ],
    "source_code": "class ResourceCache implements ResourceCacheInterface, Disposable {\n\treadonly prompts: Map<string, string> = new Map();\n\treadonly skills: Map<string, string> = new Map();\n\treadonly instructions: Map<string, string> = new Map();\n\n\tprivate resourcesDir = \"\";\n\tprivate readonly outputChannel: OutputChannel;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Load all resources from directory\n\t * Scans prompts/, skills/, instructions/ subdirectories\n\t */\n\tasync load(resourcesDir: string): Promise<void> {\n\t\tthis.resourcesDir = resourcesDir;\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ResourceCache] Loading resources from ${resourcesDir}`\n\t\t);\n\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tawait Promise.all([\n\t\t\t\tthis.loadResourceType(\"prompts\", this.prompts),\n\t\t\t\tthis.loadResourceType(\"skills\", this.skills),\n\t\t\t\tthis.loadResourceType(\"instructions\", this.instructions),\n\t\t\t]);\n\n\t\t\tconst duration = Date.now() - startTime;\n\t\t\tconst totalResources =\n\t\t\t\tthis.prompts.size + this.skills.size + this.instructions.size;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Loaded ${totalResources} resources in ${duration}ms (prompts: ${this.prompts.size}, skills: ${this.skills.size}, instructions: ${this.instructions.size})`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Error loading resources: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Load all files from a specific resource type directory\n\t */\n\tprivate async loadResourceType(\n\t\tsubdirName: string,\n\t\ttargetMap: Map<string, string>\n\t): Promise<void> {\n\t\tconst subdirPath = join(this.resourcesDir, subdirName);\n\t\tconst subdirUri = Uri.file(subdirPath);\n\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(subdirUri);\n\n\t\t\tconst loadPromises = entries.map(async ([name, type]) => {\n\t\t\t\tconst fullPath = join(subdirPath, name);\n\t\t\t\tconst fileUri = Uri.file(fullPath);\n\n\t\t\t\tif (type === 1) {\n\t\t\t\t\t// File\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = await workspace.fs.readFile(fileUri);\n\t\t\t\t\t\tconst text = Buffer.from(content).toString(\"utf8\");\n\t\t\t\t\t\ttargetMap.set(name, text);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[ResourceCache] Failed to read file ${name}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 2) {\n\t\t\t\t\t// Directory - recursively load\n\t\t\t\t\tawait this.loadNestedResources(fullPath, name, targetMap);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait Promise.all(loadPromises);\n\t\t} catch (error) {\n\t\t\t// Directory doesn't exist or other error - log and continue\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Skipping ${subdirName} directory: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively load resources from nested directories\n\t */\n\tprivate async loadNestedResources(\n\t\tdirPath: string,\n\t\trelativePath: string,\n\t\ttargetMap: Map<string, string>\n\t): Promise<void> {\n\t\tconst dirUri = Uri.file(dirPath);\n\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(dirUri);\n\n\t\t\tconst loadPromises = entries.map(async ([name, type]) => {\n\t\t\t\tconst fullPath = join(dirPath, name);\n\t\t\t\tconst fileUri = Uri.file(fullPath);\n\t\t\t\tconst nestedRelativePath = `${relativePath}/${name}`;\n\n\t\t\t\tif (type === 1) {\n\t\t\t\t\t// File\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = await workspace.fs.readFile(fileUri);\n\t\t\t\t\t\tconst text = Buffer.from(content).toString(\"utf8\");\n\t\t\t\t\t\ttargetMap.set(nestedRelativePath, text);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[ResourceCache] Failed to read nested file ${nestedRelativePath}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 2) {\n\t\t\t\t\t// Directory - continue recursion\n\t\t\t\t\tawait this.loadNestedResources(\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tnestedRelativePath,\n\t\t\t\t\t\ttargetMap\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait Promise.all(loadPromises);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Error reading nested directory ${relativePath}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Reload specific changed files incrementally\n\t * Handles create, update, and delete operations\n\t */\n\tasync reload(changedFiles: string[]): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ResourceCache] Reloading ${changedFiles.length} changed file(s)`\n\t\t);\n\n\t\tconst startTime = Date.now();\n\t\tlet reloadedCount = 0;\n\n\t\tfor (const filePath of changedFiles) {\n\t\t\ttry {\n\t\t\t\tawait this.reloadSingleFile(filePath);\n\t\t\t\treloadedCount += 1;\n\t\t\t} catch (error) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ResourceCache] Failed to reload ${filePath}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst duration = Date.now() - startTime;\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ResourceCache] Reloaded ${reloadedCount}/${changedFiles.length} file(s) in ${duration}ms`\n\t\t);\n\t}\n\n\t/**\n\t * Reload a single file\n\t */\n\tprivate async reloadSingleFile(filePath: string): Promise<void> {\n\t\tconst fileUri = Uri.file(filePath);\n\n\t\t// Determine resource type from path\n\t\tconst { type, key } = this.parseResourcePath(filePath);\n\t\tif (type === null || key === null) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Ignoring non-resource file: ${filePath}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst targetMap = this.getMapForType(type);\n\n\t\ttry {\n\t\t\t// Try to read file\n\t\t\tconst content = await workspace.fs.readFile(fileUri);\n\t\t\tconst text = Buffer.from(content).toString(\"utf8\");\n\t\t\ttargetMap.set(key, text);\n\t\t\tthis.outputChannel.appendLine(`[ResourceCache] Updated ${type}: ${key}`);\n\t\t} catch (error) {\n\t\t\t// File doesn't exist - remove from cache\n\t\t\tif (targetMap.has(key)) {\n\t\t\t\ttargetMap.delete(key);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ResourceCache] Removed deleted ${type}: ${key}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse resource file path to determine type and key\n\t */\n\tprivate parseResourcePath(filePath: string): {\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\" | null;\n\t\tkey: string | null;\n\t} {\n\t\tif (!this.resourcesDir) {\n\t\t\treturn { type: null, key: null };\n\t\t}\n\n\t\tconst relativePath = relative(this.resourcesDir, filePath);\n\t\tconst parts = relativePath.split(\"/\");\n\n\t\tif (parts.length < 2) {\n\t\t\treturn { type: null, key: null };\n\t\t}\n\n\t\tconst subdir = parts[0];\n\t\tconst fileName = parts.slice(1).join(\"/\");\n\n\t\tif (subdir === \"prompts\") {\n\t\t\treturn { type: \"prompt\", key: fileName };\n\t\t}\n\t\tif (subdir === \"skills\") {\n\t\t\treturn { type: \"skill\", key: fileName };\n\t\t}\n\t\tif (subdir === \"instructions\") {\n\t\t\treturn { type: \"instruction\", key: fileName };\n\t\t}\n\n\t\treturn { type: null, key: null };\n\t}\n\n\t/**\n\t * Get cached resource by type and name\n\t * O(1) lookup complexity\n\t */\n\tget(\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\",\n\t\tname: string\n\t): string | undefined {\n\t\tconst targetMap = this.getMapForType(type);\n\t\treturn targetMap.get(name);\n\t}\n\n\t/**\n\t * Get all resources of a given type\n\t * Returns a copy to prevent external modification\n\t */\n\tgetAll(type: \"prompt\" | \"skill\" | \"instruction\"): Map<string, string> {\n\t\tconst targetMap = this.getMapForType(type);\n\t\treturn new Map(targetMap);\n\t}\n\n\t/**\n\t * Get the appropriate map for a resource type\n\t */\n\tprivate getMapForType(\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\"\n\t): Map<string, string> {\n\t\tswitch (type) {\n\t\t\tcase \"prompt\":\n\t\t\t\treturn this.prompts;\n\t\t\tcase \"skill\":\n\t\t\t\treturn this.skills;\n\t\t\tcase \"instruction\":\n\t\t\t\treturn this.instructions;\n\t\t\tdefault:\n\t\t\t\treturn this.prompts;\n\t\t}\n\t}\n\n\t/**\n\t * Cleanup resources\n\t */\n\tdispose(): void {\n\t\tthis.prompts.clear();\n\t\tthis.skills.clear();\n\t\tthis.instructions.clear();\n\t\tthis.outputChannel.appendLine(\"[ResourceCache] Disposed\");\n\t}\n}",
    "start_line": 27,
    "end_line": 308,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ResourceCache",
    "component_id": "src.features.agents.resource-cache.ResourceCache"
  },
  "src.features.agents.resource-cache.load": {
    "id": "src.features.agents.resource-cache.load",
    "name": "load",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "async load(resourcesDir: string): Promise<void> {\n\t\tthis.resourcesDir = resourcesDir;\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ResourceCache] Loading resources from ${resourcesDir}`\n\t\t);\n\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tawait Promise.all([\n\t\t\t\tthis.loadResourceType(\"prompts\", this.prompts),\n\t\t\t\tthis.loadResourceType(\"skills\", this.skills),\n\t\t\t\tthis.loadResourceType(\"instructions\", this.instructions),\n\t\t\t]);\n\n\t\t\tconst duration = Date.now() - startTime;\n\t\t\tconst totalResources =\n\t\t\t\tthis.prompts.size + this.skills.size + this.instructions.size;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Loaded ${totalResources} resources in ${duration}ms (prompts: ${this.prompts.size}, skills: ${this.skills.size}, instructions: ${this.instructions.size})`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Error loading resources: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}",
    "start_line": 43,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "resourcesDir"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method load",
    "component_id": "src.features.agents.resource-cache.load"
  },
  "src.features.agents.resource-cache.loadResourceType": {
    "id": "src.features.agents.resource-cache.loadResourceType",
    "name": "loadResourceType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "private async loadResourceType(\n\t\tsubdirName: string,\n\t\ttargetMap: Map<string, string>\n\t): Promise<void> {\n\t\tconst subdirPath = join(this.resourcesDir, subdirName);\n\t\tconst subdirUri = Uri.file(subdirPath);\n\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(subdirUri);\n\n\t\t\tconst loadPromises = entries.map(async ([name, type]) => {\n\t\t\t\tconst fullPath = join(subdirPath, name);\n\t\t\t\tconst fileUri = Uri.file(fullPath);\n\n\t\t\t\tif (type === 1) {\n\t\t\t\t\t// File\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = await workspace.fs.readFile(fileUri);\n\t\t\t\t\t\tconst text = Buffer.from(content).toString(\"utf8\");\n\t\t\t\t\t\ttargetMap.set(name, text);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[ResourceCache] Failed to read file ${name}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 2) {\n\t\t\t\t\t// Directory - recursively load\n\t\t\t\t\tawait this.loadNestedResources(fullPath, name, targetMap);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait Promise.all(loadPromises);\n\t\t} catch (error) {\n\t\t\t// Directory doesn't exist or other error - log and continue\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Skipping ${subdirName} directory: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 76,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "subdirName",
      "targetMap"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadResourceType",
    "component_id": "src.features.agents.resource-cache.loadResourceType"
  },
  "src.features.agents.resource-cache.loadNestedResources": {
    "id": "src.features.agents.resource-cache.loadNestedResources",
    "name": "loadNestedResources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "private async loadNestedResources(\n\t\tdirPath: string,\n\t\trelativePath: string,\n\t\ttargetMap: Map<string, string>\n\t): Promise<void> {\n\t\tconst dirUri = Uri.file(dirPath);\n\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(dirUri);\n\n\t\t\tconst loadPromises = entries.map(async ([name, type]) => {\n\t\t\t\tconst fullPath = join(dirPath, name);\n\t\t\t\tconst fileUri = Uri.file(fullPath);\n\t\t\t\tconst nestedRelativePath = `${relativePath}/${name}`;\n\n\t\t\t\tif (type === 1) {\n\t\t\t\t\t// File\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = await workspace.fs.readFile(fileUri);\n\t\t\t\t\t\tconst text = Buffer.from(content).toString(\"utf8\");\n\t\t\t\t\t\ttargetMap.set(nestedRelativePath, text);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[ResourceCache] Failed to read nested file ${nestedRelativePath}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 2) {\n\t\t\t\t\t// Directory - continue recursion\n\t\t\t\t\tawait this.loadNestedResources(\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tnestedRelativePath,\n\t\t\t\t\t\ttargetMap\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait Promise.all(loadPromises);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Error reading nested directory ${relativePath}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 119,
    "end_line": 161,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dirPath",
      "relativePath",
      "targetMap"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadNestedResources",
    "component_id": "src.features.agents.resource-cache.loadNestedResources"
  },
  "src.features.agents.resource-cache.reload": {
    "id": "src.features.agents.resource-cache.reload",
    "name": "reload",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "async reload(changedFiles: string[]): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ResourceCache] Reloading ${changedFiles.length} changed file(s)`\n\t\t);\n\n\t\tconst startTime = Date.now();\n\t\tlet reloadedCount = 0;\n\n\t\tfor (const filePath of changedFiles) {\n\t\t\ttry {\n\t\t\t\tawait this.reloadSingleFile(filePath);\n\t\t\t\treloadedCount += 1;\n\t\t\t} catch (error) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ResourceCache] Failed to reload ${filePath}: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst duration = Date.now() - startTime;\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ResourceCache] Reloaded ${reloadedCount}/${changedFiles.length} file(s) in ${duration}ms`\n\t\t);\n\t}",
    "start_line": 167,
    "end_line": 190,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changedFiles"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method reload",
    "component_id": "src.features.agents.resource-cache.reload"
  },
  "src.features.agents.resource-cache.reloadSingleFile": {
    "id": "src.features.agents.resource-cache.reloadSingleFile",
    "name": "reloadSingleFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "private async reloadSingleFile(filePath: string): Promise<void> {\n\t\tconst fileUri = Uri.file(filePath);\n\n\t\t// Determine resource type from path\n\t\tconst { type, key } = this.parseResourcePath(filePath);\n\t\tif (type === null || key === null) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ResourceCache] Ignoring non-resource file: ${filePath}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst targetMap = this.getMapForType(type);\n\n\t\ttry {\n\t\t\t// Try to read file\n\t\t\tconst content = await workspace.fs.readFile(fileUri);\n\t\t\tconst text = Buffer.from(content).toString(\"utf8\");\n\t\t\ttargetMap.set(key, text);\n\t\t\tthis.outputChannel.appendLine(`[ResourceCache] Updated ${type}: ${key}`);\n\t\t} catch (error) {\n\t\t\t// File doesn't exist - remove from cache\n\t\t\tif (targetMap.has(key)) {\n\t\t\t\ttargetMap.delete(key);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ResourceCache] Removed deleted ${type}: ${key}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 195,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method reloadSingleFile",
    "component_id": "src.features.agents.resource-cache.reloadSingleFile"
  },
  "src.features.agents.resource-cache.parseResourcePath": {
    "id": "src.features.agents.resource-cache.parseResourcePath",
    "name": "parseResourcePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "private parseResourcePath(filePath: string): {\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\" | null;\n\t\tkey: string | null;\n\t} {\n\t\tif (!this.resourcesDir) {\n\t\t\treturn { type: null, key: null };\n\t\t}\n\n\t\tconst relativePath = relative(this.resourcesDir, filePath);\n\t\tconst parts = relativePath.split(\"/\");\n\n\t\tif (parts.length < 2) {\n\t\t\treturn { type: null, key: null };\n\t\t}\n\n\t\tconst subdir = parts[0];\n\t\tconst fileName = parts.slice(1).join(\"/\");\n\n\t\tif (subdir === \"prompts\") {\n\t\t\treturn { type: \"prompt\", key: fileName };\n\t\t}\n\t\tif (subdir === \"skills\") {\n\t\t\treturn { type: \"skill\", key: fileName };\n\t\t}\n\t\tif (subdir === \"instructions\") {\n\t\t\treturn { type: \"instruction\", key: fileName };\n\t\t}\n\n\t\treturn { type: null, key: null };\n\t}",
    "start_line": 229,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method parseResourcePath",
    "component_id": "src.features.agents.resource-cache.parseResourcePath"
  },
  "src.features.agents.resource-cache.get": {
    "id": "src.features.agents.resource-cache.get",
    "name": "get",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "get(\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\",\n\t\tname: string\n\t): string | undefined {\n\t\tconst targetMap = this.getMapForType(type);\n\t\treturn targetMap.get(name);\n\t}",
    "start_line": 264,
    "end_line": 270,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type",
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method get",
    "component_id": "src.features.agents.resource-cache.get"
  },
  "src.features.agents.resource-cache.getAll": {
    "id": "src.features.agents.resource-cache.getAll",
    "name": "getAll",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "getAll(type: \"prompt\" | \"skill\" | \"instruction\"): Map<string, string> {\n\t\tconst targetMap = this.getMapForType(type);\n\t\treturn new Map(targetMap);\n\t}",
    "start_line": 276,
    "end_line": 279,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAll",
    "component_id": "src.features.agents.resource-cache.getAll"
  },
  "src.features.agents.resource-cache.getMapForType": {
    "id": "src.features.agents.resource-cache.getMapForType",
    "name": "getMapForType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "private getMapForType(\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\"\n\t): Map<string, string> {\n\t\tswitch (type) {\n\t\t\tcase \"prompt\":\n\t\t\t\treturn this.prompts;\n\t\t\tcase \"skill\":\n\t\t\t\treturn this.skills;\n\t\t\tcase \"instruction\":\n\t\t\t\treturn this.instructions;\n\t\t\tdefault:\n\t\t\t\treturn this.prompts;\n\t\t}\n\t}",
    "start_line": 284,
    "end_line": 297,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getMapForType",
    "component_id": "src.features.agents.resource-cache.getMapForType"
  },
  "src.features.agents.resource-cache.dispose": {
    "id": "src.features.agents.resource-cache.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/resource-cache.ts",
    "relative_path": "src/features/agents/resource-cache.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.prompts.clear();\n\t\tthis.skills.clear();\n\t\tthis.instructions.clear();\n\t\tthis.outputChannel.appendLine(\"[ResourceCache] Disposed\");\n\t}",
    "start_line": 302,
    "end_line": 307,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.agents.resource-cache.dispose"
  },
  "src.features.agents.tool-registry.ToolRegistry": {
    "id": "src.features.agents.tool-registry.ToolRegistry",
    "name": "ToolRegistry",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [
      "src.features.agents.types.ToolResponse",
      "src.features.agents.tool-registry.validateExecutionParams",
      "src.features.agents.error-formatter.formatError",
      "src.features.agents.error-formatter.getErrorSeverity",
      "src.features.agents.resource-cache.get",
      "src.features.agents.types.ToolHandler",
      "src.features.agents.types.ToolExecutionParams",
      "src.features.agents.tool-registry.getRegisteredTools",
      "src.features.spec.spec-manager.delete",
      "src.features.agents.tool-registry.wrapError",
      "src.features.agents.types.ToolExecutionError"
    ],
    "source_code": "class ToolRegistry {\n\tprivate readonly tools: Map<string, ToolHandler> = new Map();\n\tprivate readonly outputChannel: OutputChannel;\n\n\t// Regex for valid tool names: lowercase alphanumeric with dots and hyphens\n\tprivate static readonly TOOL_NAME_PATTERN = /^[a-z0-9.-]+$/;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.outputChannel.appendLine(\"[ToolRegistry] Initialized\");\n\t}\n\n\t/**\n\t * Register a tool handler\n\t * @param name Tool name (must be lowercase, alphanumeric with dots/hyphens)\n\t * @param handler Tool implementation function\n\t * @throws Error if tool name is invalid or already registered\n\t */\n\tregister(name: string, handler: ToolHandler): void {\n\t\t// Validate tool name format\n\t\tif (!ToolRegistry.TOOL_NAME_PATTERN.test(name)) {\n\t\t\tconst error = `Invalid tool name format: '${name}'. Must be lowercase alphanumeric with dots and hyphens only.`;\n\t\t\tthis.outputChannel.appendLine(`[ToolRegistry] ${error}`);\n\t\t\tthrow new Error(\"Invalid tool name format\");\n\t\t}\n\n\t\t// Check for duplicates\n\t\tif (this.tools.has(name)) {\n\t\t\tconst error = `Tool '${name}' is already registered`;\n\t\t\tthis.outputChannel.appendLine(`[ToolRegistry] ${error}`);\n\t\t\tthrow new Error(error);\n\t\t}\n\n\t\t// Register tool\n\t\tthis.tools.set(name, handler);\n\t\tthis.outputChannel.appendLine(`[ToolRegistry] Registered tool: ${name}`);\n\t}\n\n\t/**\n\t * Execute a registered tool with comprehensive error handling\n\t * T059 - Error classification and handling\n\t * T060 - Error logging with full context\n\t * @param name Tool name\n\t * @param params Execution parameters\n\t * @returns Tool response\n\t * @throws ToolExecutionError if tool not registered or execution fails\n\t */\n\tasync execute(\n\t\tname: string,\n\t\tparams: ToolExecutionParams\n\t): Promise<ToolResponse> {\n\t\t// T063 - Validate parameters before execution\n\t\tthis.validateExecutionParams(name, params);\n\n\t\t// Check if tool exists\n\t\tconst handler = this.tools.get(name);\n\t\tif (!handler) {\n\t\t\tconst availableTools = this.getRegisteredTools();\n\t\t\tconst errorMsg = `Tool '${name}' is not registered. Available tools: ${availableTools.join(\", \") || \"none\"}`;\n\n\t\t\t// T060 - Log error with full context\n\t\t\tthis.outputChannel.appendLine(`[ToolRegistry] ERROR: ${errorMsg}`);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Context: ${availableTools.length} tools registered, requested tool not found`\n\t\t\t);\n\n\t\t\tthrow new Error(errorMsg);\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ToolRegistry] Executing tool: ${name} with input: ${params.input.substring(0, 50)}${params.input.length > 50 ? \"...\" : \"\"}`\n\t\t);\n\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Execute tool handler\n\t\t\tconst response = await handler(params);\n\n\t\t\tconst duration = Date.now() - startTime;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Tool '${name}' completed successfully in ${duration}ms`\n\t\t\t);\n\n\t\t\t// Add duration to metadata if not already set\n\t\t\tif (!response.metadata) {\n\t\t\t\tresponse.metadata = {};\n\t\t\t}\n\t\t\tif (!response.metadata.duration) {\n\t\t\t\tresponse.metadata.duration = duration;\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// T059 - Classify and wrap error\n\t\t\tconst wrappedError = this.wrapError(error, name);\n\n\t\t\t// T060 - Log error with full context\n\t\t\tconst formatted = formatError(wrappedError, { tool: name });\n\t\t\tconst severity = getErrorSeverity(formatted.category);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] ${severity.toUpperCase()}: Tool '${name}' failed after ${duration}ms`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Error Type: ${wrappedError.name}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Technical Details: ${formatted.technicalDetails}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Category: ${formatted.category}`\n\t\t\t);\n\n\t\t\tif (wrappedError instanceof ToolExecutionError && wrappedError.cause) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ToolRegistry] Caused by: ${wrappedError.cause.name}: ${wrappedError.cause.message}`\n\t\t\t\t);\n\t\t\t\tif (wrappedError.cause.stack) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[ToolRegistry] Stack: ${wrappedError.cause.stack}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Re-throw wrapped error\n\t\t\tthrow wrappedError;\n\t\t}\n\t}\n\n\t/**\n\t * T063 - Validate execution parameters\n\t * @param name Tool name\n\t * @param params Execution parameters\n\t * @throws Error if validation fails\n\t */\n\tprivate validateExecutionParams(\n\t\tname: string,\n\t\tparams: ToolExecutionParams\n\t): void {\n\t\tif (!params) {\n\t\t\tthrow new Error(\"Execution parameters are required\");\n\t\t}\n\n\t\tif (params.input === undefined || params.input === null) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] WARNING: Tool '${name}' called with undefined/null input`\n\t\t\t);\n\t\t}\n\n\t\tif (!params.context) {\n\t\t\tthrow new Error(\"Execution context is required\");\n\t\t}\n\n\t\tif (!params.resources) {\n\t\t\tthrow new Error(\"Resources are required\");\n\t\t}\n\n\t\tif (!params.token) {\n\t\t\tthrow new Error(\"Cancellation token is required\");\n\t\t}\n\t}\n\n\t/**\n\t * T059 - Wrap errors in ToolExecutionError if not already wrapped\n\t * @param error Original error\n\t * @param toolName Tool name\n\t * @returns ToolExecutionError\n\t */\n\tprivate wrapError(error: unknown, toolName: string): ToolExecutionError {\n\t\tif (error instanceof ToolExecutionError) {\n\t\t\treturn error;\n\t\t}\n\n\t\tconst originalError =\n\t\t\terror instanceof Error ? error : new Error(String(error));\n\t\treturn new ToolExecutionError(\n\t\t\t`Tool '${toolName}' execution failed: ${originalError.message}`,\n\t\t\ttoolName,\n\t\t\toriginalError\n\t\t);\n\t}\n\n\t/**\n\t * Unregister a tool\n\t * @param name Tool name\n\t */\n\tunregister(name: string): void {\n\t\tif (this.tools.has(name)) {\n\t\t\tthis.tools.delete(name);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Unregistered tool: ${name}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a tool is registered\n\t * @param name Tool name\n\t * @returns true if registered\n\t */\n\tisRegistered(name: string): boolean {\n\t\treturn this.tools.has(name);\n\t}\n\n\t/**\n\t * Get list of all registered tool names\n\t * @returns Array of tool names\n\t */\n\tgetRegisteredTools(): string[] {\n\t\treturn Array.from(this.tools.keys());\n\t}\n\n\t/**\n\t * Get count of registered tools\n\t * @returns Number of registered tools\n\t */\n\tgetToolCount(): number {\n\t\treturn this.tools.size;\n\t}\n}",
    "start_line": 20,
    "end_line": 242,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ToolRegistry",
    "component_id": "src.features.agents.tool-registry.ToolRegistry"
  },
  "src.features.agents.tool-registry.register": {
    "id": "src.features.agents.tool-registry.register",
    "name": "register",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "register(name: string, handler: ToolHandler): void {\n\t\t// Validate tool name format\n\t\tif (!ToolRegistry.TOOL_NAME_PATTERN.test(name)) {\n\t\t\tconst error = `Invalid tool name format: '${name}'. Must be lowercase alphanumeric with dots and hyphens only.`;\n\t\t\tthis.outputChannel.appendLine(`[ToolRegistry] ${error}`);\n\t\t\tthrow new Error(\"Invalid tool name format\");\n\t\t}\n\n\t\t// Check for duplicates\n\t\tif (this.tools.has(name)) {\n\t\t\tconst error = `Tool '${name}' is already registered`;\n\t\t\tthis.outputChannel.appendLine(`[ToolRegistry] ${error}`);\n\t\t\tthrow new Error(error);\n\t\t}\n\n\t\t// Register tool\n\t\tthis.tools.set(name, handler);\n\t\tthis.outputChannel.appendLine(`[ToolRegistry] Registered tool: ${name}`);\n\t}",
    "start_line": 38,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "handler"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method register",
    "component_id": "src.features.agents.tool-registry.register"
  },
  "src.features.agents.tool-registry.execute": {
    "id": "src.features.agents.tool-registry.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "async execute(\n\t\tname: string,\n\t\tparams: ToolExecutionParams\n\t): Promise<ToolResponse> {\n\t\t// T063 - Validate parameters before execution\n\t\tthis.validateExecutionParams(name, params);\n\n\t\t// Check if tool exists\n\t\tconst handler = this.tools.get(name);\n\t\tif (!handler) {\n\t\t\tconst availableTools = this.getRegisteredTools();\n\t\t\tconst errorMsg = `Tool '${name}' is not registered. Available tools: ${availableTools.join(\", \") || \"none\"}`;\n\n\t\t\t// T060 - Log error with full context\n\t\t\tthis.outputChannel.appendLine(`[ToolRegistry] ERROR: ${errorMsg}`);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Context: ${availableTools.length} tools registered, requested tool not found`\n\t\t\t);\n\n\t\t\tthrow new Error(errorMsg);\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[ToolRegistry] Executing tool: ${name} with input: ${params.input.substring(0, 50)}${params.input.length > 50 ? \"...\" : \"\"}`\n\t\t);\n\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Execute tool handler\n\t\t\tconst response = await handler(params);\n\n\t\t\tconst duration = Date.now() - startTime;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Tool '${name}' completed successfully in ${duration}ms`\n\t\t\t);\n\n\t\t\t// Add duration to metadata if not already set\n\t\t\tif (!response.metadata) {\n\t\t\t\tresponse.metadata = {};\n\t\t\t}\n\t\t\tif (!response.metadata.duration) {\n\t\t\t\tresponse.metadata.duration = duration;\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// T059 - Classify and wrap error\n\t\t\tconst wrappedError = this.wrapError(error, name);\n\n\t\t\t// T060 - Log error with full context\n\t\t\tconst formatted = formatError(wrappedError, { tool: name });\n\t\t\tconst severity = getErrorSeverity(formatted.category);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] ${severity.toUpperCase()}: Tool '${name}' failed after ${duration}ms`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Error Type: ${wrappedError.name}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Technical Details: ${formatted.technicalDetails}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Category: ${formatted.category}`\n\t\t\t);\n\n\t\t\tif (wrappedError instanceof ToolExecutionError && wrappedError.cause) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[ToolRegistry] Caused by: ${wrappedError.cause.name}: ${wrappedError.cause.message}`\n\t\t\t\t);\n\t\t\t\tif (wrappedError.cause.stack) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[ToolRegistry] Stack: ${wrappedError.cause.stack}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Re-throw wrapped error\n\t\t\tthrow wrappedError;\n\t\t}\n\t}",
    "start_line": 67,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "params"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "src.features.agents.tool-registry.execute"
  },
  "src.features.agents.tool-registry.validateExecutionParams": {
    "id": "src.features.agents.tool-registry.validateExecutionParams",
    "name": "validateExecutionParams",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "private validateExecutionParams(\n\t\tname: string,\n\t\tparams: ToolExecutionParams\n\t): void {\n\t\tif (!params) {\n\t\t\tthrow new Error(\"Execution parameters are required\");\n\t\t}\n\n\t\tif (params.input === undefined || params.input === null) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] WARNING: Tool '${name}' called with undefined/null input`\n\t\t\t);\n\t\t}\n\n\t\tif (!params.context) {\n\t\t\tthrow new Error(\"Execution context is required\");\n\t\t}\n\n\t\tif (!params.resources) {\n\t\t\tthrow new Error(\"Resources are required\");\n\t\t}\n\n\t\tif (!params.token) {\n\t\t\tthrow new Error(\"Cancellation token is required\");\n\t\t}\n\t}",
    "start_line": 158,
    "end_line": 183,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "params"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateExecutionParams",
    "component_id": "src.features.agents.tool-registry.validateExecutionParams"
  },
  "src.features.agents.tool-registry.wrapError": {
    "id": "src.features.agents.tool-registry.wrapError",
    "name": "wrapError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "private wrapError(error: unknown, toolName: string): ToolExecutionError {\n\t\tif (error instanceof ToolExecutionError) {\n\t\t\treturn error;\n\t\t}\n\n\t\tconst originalError =\n\t\t\terror instanceof Error ? error : new Error(String(error));\n\t\treturn new ToolExecutionError(\n\t\t\t`Tool '${toolName}' execution failed: ${originalError.message}`,\n\t\t\ttoolName,\n\t\t\toriginalError\n\t\t);\n\t}",
    "start_line": 191,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error",
      "toolName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method wrapError",
    "component_id": "src.features.agents.tool-registry.wrapError"
  },
  "src.features.agents.tool-registry.unregister": {
    "id": "src.features.agents.tool-registry.unregister",
    "name": "unregister",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "unregister(name: string): void {\n\t\tif (this.tools.has(name)) {\n\t\t\tthis.tools.delete(name);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[ToolRegistry] Unregistered tool: ${name}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 209,
    "end_line": 216,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method unregister",
    "component_id": "src.features.agents.tool-registry.unregister"
  },
  "src.features.agents.tool-registry.isRegistered": {
    "id": "src.features.agents.tool-registry.isRegistered",
    "name": "isRegistered",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "isRegistered(name: string): boolean {\n\t\treturn this.tools.has(name);\n\t}",
    "start_line": 223,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isRegistered",
    "component_id": "src.features.agents.tool-registry.isRegistered"
  },
  "src.features.agents.tool-registry.getRegisteredTools": {
    "id": "src.features.agents.tool-registry.getRegisteredTools",
    "name": "getRegisteredTools",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "getRegisteredTools(): string[] {\n\t\treturn Array.from(this.tools.keys());\n\t}",
    "start_line": 231,
    "end_line": 233,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRegisteredTools",
    "component_id": "src.features.agents.tool-registry.getRegisteredTools"
  },
  "src.features.agents.tool-registry.getToolCount": {
    "id": "src.features.agents.tool-registry.getToolCount",
    "name": "getToolCount",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tool-registry.ts",
    "relative_path": "src/features/agents/tool-registry.ts",
    "depends_on": [],
    "source_code": "getToolCount(): number {\n\t\treturn this.tools.size;\n\t}",
    "start_line": 239,
    "end_line": 241,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getToolCount",
    "component_id": "src.features.agents.tool-registry.getToolCount"
  },
  "src.features.agents.tools.example-tool-handler.ExampleToolParams": {
    "id": "src.features.agents.tools.example-tool-handler.ExampleToolParams",
    "name": "ExampleToolParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/example-tool-handler.ts",
    "relative_path": "src/features/agents/tools/example-tool-handler.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition"
    ],
    "source_code": "interface ExampleToolParams {\n\t/** The user input or command argument */\n\tinput: string;\n\t/** Context containing the agent definition and extension state */\n\tcontext: {\n\t\tagent: AgentDefinition;\n\t\textensionPath?: string;\n\t};\n\t/** Optional telemetry sender for tracking usage */\n\ttelemetry?: {\n\t\tsendEvent: (eventName: string, properties?: Record<string, any>) => void;\n\t};\n}",
    "start_line": 13,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExampleToolParams",
    "component_id": "src.features.agents.tools.example-tool-handler.ExampleToolParams"
  },
  "src.features.agents.tools.example-tool-handler.ToolResult": {
    "id": "src.features.agents.tools.example-tool-handler.ToolResult",
    "name": "ToolResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/example-tool-handler.ts",
    "relative_path": "src/features/agents/tools/example-tool-handler.ts",
    "depends_on": [],
    "source_code": "interface ToolResult {\n\t/** Markdown-formatted content to display to the user */\n\tcontent: string;\n\t/** Optional file path if the tool created/modified a file */\n\tfilePath?: string;\n\t/** Optional error message if the tool failed */\n\terror?: string;\n}",
    "start_line": 31,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolResult",
    "component_id": "src.features.agents.tools.example-tool-handler.ToolResult"
  },
  "src.features.agents.tools.example-tool-handler.exampleHelloHandler": {
    "id": "src.features.agents.tools.example-tool-handler.exampleHelloHandler",
    "name": "exampleHelloHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/example-tool-handler.ts",
    "relative_path": "src/features/agents/tools/example-tool-handler.ts",
    "depends_on": [
      "src.features.agents.tools.example-tool-handler.ExampleToolParams",
      "src.features.agents.tools.example-tool-handler.ToolResult"
    ],
    "source_code": "function exampleHelloHandler(params: ExampleToolParams): ToolResult {\n\tconst { input, context, telemetry } = params;\n\tconst target = input.trim() || \"World\";\n\tconst agentName = context.agent.name;\n\n\t// Send telemetry event\n\tif (telemetry) {\n\t\ttelemetry.sendEvent(\"example.tool.hello.invoked\", {\n\t\t\tagentId: context.agent.id,\n\t\t\ttargetLength: target.length,\n\t\t});\n\t}\n\n\t// Generate response\n\tconst content = `# Hello, ${target}!\n\nThis is a greeting from the **${agentName}** agent.\n\n## About This Tool\n\nThis is an example tool handler that demonstrates the pattern for implementing agent tools in the GatomIA extension.\n\n### Tool Handler Characteristics:\n- Receives parameters including user input and agent context\n- Can access agent metadata and configuration\n- Returns structured results with markdown content\n- Optionally sends telemetry events\n- Supports optional telemetry for usage tracking\n\n### Example Tool Handlers\n\nThe GatomIA extension provides several built-in tool handlers:\n- **help**: Shows available commands for the agent\n- **example.hello**: This handler - demonstrates a simple greeting\n- **agent.help**: Built-in help functionality for all agents\n\n### Creating Your Own Tool Handler\n\nTo create a custom tool handler:\n\n1. Define a function that accepts \\`ToolParams\\`\n2. Implement your tool logic\n3. Return a \\`ToolResult\\` object with markdown content\n4. Register the tool with the \\`ToolRegistry\\`\n\n\\`\\`\\`typescript\nexport function myCustomTool(params: ToolParams): ToolResult {\n  // Your implementation\n  return { content: \"# Result\" };\n}\n\n// Register in agent service\ntoolRegistry.register(\"my.tool.id\", myCustomTool);\n\\`\\`\\`\n\n---\n\n**Learn more**: Check the [Features/Agents README](../../../features/agents/README.md) for architecture details.`;\n\n\treturn { content };\n}",
    "start_line": 53,
    "end_line": 113,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function exampleHelloHandler",
    "component_id": "src.features.agents.tools.example-tool-handler.exampleHelloHandler"
  },
  "src.features.agents.tools.example-tool-handler.exampleErrorHandler": {
    "id": "src.features.agents.tools.example-tool-handler.exampleErrorHandler",
    "name": "exampleErrorHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/example-tool-handler.ts",
    "relative_path": "src/features/agents/tools/example-tool-handler.ts",
    "depends_on": [
      "src.features.agents.tools.example-tool-handler.ExampleToolParams",
      "src.features.agents.tools.example-tool-handler.ToolResult"
    ],
    "source_code": "function exampleErrorHandler(params: ExampleToolParams): ToolResult {\n\tconst { input, telemetry } = params;\n\n\t// Validate input\n\tif (!input || input.trim().length === 0) {\n\t\tif (telemetry) {\n\t\t\ttelemetry.sendEvent(\"example.tool.error.validation_failed\", {\n\t\t\t\treason: \"empty_input\",\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\terror: \"No input provided\",\n\t\t\tcontent: \"# Error\\n\\nPlease provide input for this tool.\",\n\t\t};\n\t}\n\n\t// Simulate processing\n\tconst content = `# Processing Result\n\nYour input was: **${input}**\n\nThis demonstrates error handling patterns in tool handlers.`;\n\n\treturn { content };\n}",
    "start_line": 120,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function exampleErrorHandler",
    "component_id": "src.features.agents.tools.example-tool-handler.exampleErrorHandler"
  },
  "src.features.agents.tools.example-tool-handler.exampleFileOperationHandler": {
    "id": "src.features.agents.tools.example-tool-handler.exampleFileOperationHandler",
    "name": "exampleFileOperationHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/example-tool-handler.ts",
    "relative_path": "src/features/agents/tools/example-tool-handler.ts",
    "depends_on": [
      "src.features.agents.tools.example-tool-handler.ExampleToolParams",
      "src.features.agents.tools.example-tool-handler.ToolResult"
    ],
    "source_code": "function exampleFileOperationHandler(\n\tparams: ExampleToolParams\n): ToolResult {\n\tconst { context } = params;\n\n\tif (!context.extensionPath) {\n\t\treturn {\n\t\t\terror: \"Extension path not available\",\n\t\t\tcontent:\n\t\t\t\t\"# Error\\n\\nCannot complete file operation without extension path.\",\n\t\t};\n\t}\n\n\t// In a real tool, this would create/modify a file\n\tconst examplePath = `${context.extensionPath}/example-output.md`;\n\n\tconst content = `# File Operation Completed\n\n**File path**: \\`${examplePath}\\`\n\nThis demonstrates how tool handlers can:\n- Access file system paths from agent context\n- Report file operations back to the user\n- Provide file references in results\n\n### File Handler Patterns\n\n1. **Read files**: Use \\`fs\\` module with proper error handling\n2. **Write files**: Check parent directory exists before writing\n3. **Report paths**: Return file path in ToolResult for UI linking\n4. **Handle errors**: Return error message if operation fails\n\nFor real implementations, consider using VS Code's FileSystem API for better reliability.`;\n\n\treturn {\n\t\tcontent,\n\t\tfilePath: examplePath,\n\t};\n}",
    "start_line": 152,
    "end_line": 190,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function exampleFileOperationHandler",
    "component_id": "src.features.agents.tools.example-tool-handler.exampleFileOperationHandler"
  },
  "src.features.agents.tools.help-formatter.FormattedHelp": {
    "id": "src.features.agents.tools.help-formatter.FormattedHelp",
    "name": "FormattedHelp",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [],
    "source_code": "interface FormattedHelp {\n\ttitle: string;\n\tcontent: string;\n}",
    "start_line": 8,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormattedHelp",
    "component_id": "src.features.agents.tools.help-formatter.FormattedHelp"
  },
  "src.features.agents.tools.help-formatter.formatGeneralHelp": {
    "id": "src.features.agents.tools.help-formatter.formatGeneralHelp",
    "name": "formatGeneralHelp",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.tools.help-formatter.FormattedHelp",
      "src.features.agents.tools.help-formatter.formatCommandListItem"
    ],
    "source_code": "function formatGeneralHelp(agent: AgentDefinition): FormattedHelp {\n\tconst commandList = agent.commands\n\t\t.filter((cmd) => cmd.name !== \"help\")\n\t\t.map((cmd) => formatCommandListItem(cmd))\n\t\t.join(\"\\n\\n\");\n\n\tconst content = `# ${agent.fullName}\n\n${agent.description}\n\n## Available Commands\n\n${commandList}\n\n---\n\n**Tip**: Type \\`@${agent.id} /help <command>\\` for detailed help on a specific command.`;\n\n\treturn {\n\t\ttitle: `${agent.name} - Help`,\n\t\tcontent,\n\t};\n}",
    "start_line": 17,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatGeneralHelp",
    "component_id": "src.features.agents.tools.help-formatter.formatGeneralHelp"
  },
  "src.features.agents.tools.help-formatter.formatCommandListItem": {
    "id": "src.features.agents.tools.help-formatter.formatCommandListItem",
    "name": "formatCommandListItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentCommand",
      "src.features.agents.tools.help-formatter.formatParameters"
    ],
    "source_code": "function formatCommandListItem(command: AgentCommand): string {\n\tconst params = command.parameters\n\t\t? ` ${formatParameters(command.parameters)}`\n\t\t: \"\";\n\n\treturn `### /${command.name}${params}\n${command.description}`;\n}",
    "start_line": 44,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatCommandListItem",
    "component_id": "src.features.agents.tools.help-formatter.formatCommandListItem"
  },
  "src.features.agents.tools.help-formatter.formatParameters": {
    "id": "src.features.agents.tools.help-formatter.formatParameters",
    "name": "formatParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [],
    "source_code": "function formatParameters(\n\tparameters: string | Record<string, unknown>[]\n): string {\n\tif (typeof parameters === \"string\") {\n\t\treturn parameters;\n\t}\n\n\tif (Array.isArray(parameters)) {\n\t\treturn parameters\n\t\t\t.map((param) => {\n\t\t\t\tconst name = String(param.name || \"\");\n\t\t\t\tconst required = param.required === true;\n\t\t\t\treturn required ? `<${name}>` : `[${name}]`;\n\t\t\t})\n\t\t\t.join(\" \");\n\t}\n\n\treturn \"\";\n}",
    "start_line": 57,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "parameters"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatParameters",
    "component_id": "src.features.agents.tools.help-formatter.formatParameters"
  },
  "src.features.agents.tools.help-formatter.formatCommandHelp": {
    "id": "src.features.agents.tools.help-formatter.formatCommandHelp",
    "name": "formatCommandHelp",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.tools.help-formatter.FormattedHelp",
      "src.features.agents.tools.help-formatter.extractCommandDocumentation"
    ],
    "source_code": "function formatCommandHelp(\n\tagent: AgentDefinition,\n\tcommandName: string\n): FormattedHelp | null {\n\tconst command = agent.commands.find((cmd) => cmd.name === commandName);\n\n\tif (!command) {\n\t\treturn null;\n\t}\n\n\tconst helpContent = extractCommandDocumentation(agent, commandName);\n\n\treturn {\n\t\ttitle: `${agent.name} - /${command.name}`,\n\t\tcontent: `# ${agent.name} - /${command.name}\n\n${helpContent}`,\n\t};\n}",
    "start_line": 80,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "commandName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatCommandHelp",
    "component_id": "src.features.agents.tools.help-formatter.formatCommandHelp"
  },
  "src.features.agents.tools.help-formatter.extractCommandDocumentation": {
    "id": "src.features.agents.tools.help-formatter.extractCommandDocumentation",
    "name": "extractCommandDocumentation",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.tools.help-formatter.formatParameters"
    ],
    "source_code": "function extractCommandDocumentation(\n\tagent: AgentDefinition,\n\tcommandName: string\n): string {\n\tconst contentLines = agent.content.split(\"\\n\");\n\tconst commandSection: string[] = [];\n\tlet capturing = false;\n\n\tfor (const line of contentLines) {\n\t\tif (line.startsWith(`### /${commandName}`)) {\n\t\t\tcapturing = true;\n\t\t}\n\n\t\tif (capturing) {\n\t\t\tif (line.startsWith(\"### /\") && !line.startsWith(`### /${commandName}`)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcommandSection.push(line);\n\t\t}\n\t}\n\n\tif (commandSection.length > 0) {\n\t\treturn commandSection.join(\"\\n\");\n\t}\n\n\t// Fallback to basic documentation\n\tconst command = agent.commands.find((cmd) => cmd.name === commandName);\n\tif (command) {\n\t\tconst params = command.parameters\n\t\t\t? formatParameters(command.parameters)\n\t\t\t: \"\";\n\t\tconst usage = params\n\t\t\t? `\\n\\n**Usage**: \\`@${agent.id} /${command.name} ${params}\\``\n\t\t\t: \"\";\n\n\t\treturn `### /${command.name}\n\n${command.description}${usage}`;\n\t}\n\n\treturn `No detailed documentation available for /${commandName}`;\n}",
    "start_line": 104,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "commandName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractCommandDocumentation",
    "component_id": "src.features.agents.tools.help-formatter.extractCommandDocumentation"
  },
  "src.features.agents.tools.help-formatter.formatCommandNotFound": {
    "id": "src.features.agents.tools.help-formatter.formatCommandNotFound",
    "name": "formatCommandNotFound",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-formatter.ts",
    "relative_path": "src/features/agents/tools/help-formatter.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.tools.help-formatter.FormattedHelp"
    ],
    "source_code": "function formatCommandNotFound(\n\tagent: AgentDefinition,\n\tcommandName: string\n): FormattedHelp {\n\treturn {\n\t\ttitle: `${agent.name} - Command Not Found`,\n\t\tcontent: ` Command \"/${commandName}\" not found.\n\nUse \\`@${agent.id} /help\\` to see available commands.`,\n\t};\n}",
    "start_line": 150,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "commandName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatCommandNotFound",
    "component_id": "src.features.agents.tools.help-formatter.formatCommandNotFound"
  },
  "src.features.agents.tools.help-handler.HelpHandlerParams": {
    "id": "src.features.agents.tools.help-handler.HelpHandlerParams",
    "name": "HelpHandlerParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-handler.ts",
    "relative_path": "src/features/agents/tools/help-handler.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition"
    ],
    "source_code": "interface HelpHandlerParams {\n\tinput: string;\n\tcontext: {\n\t\tagent: AgentDefinition;\n\t};\n\ttelemetry?: {\n\t\tsendEvent: (eventName: string, properties?: Record<string, any>) => void;\n\t};\n}",
    "start_line": 15,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HelpHandlerParams",
    "component_id": "src.features.agents.tools.help-handler.HelpHandlerParams"
  },
  "src.features.agents.tools.help-handler.HelpResult": {
    "id": "src.features.agents.tools.help-handler.HelpResult",
    "name": "HelpResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-handler.ts",
    "relative_path": "src/features/agents/tools/help-handler.ts",
    "depends_on": [],
    "source_code": "interface HelpResult {\n\tcontent: string;\n}",
    "start_line": 25,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HelpResult",
    "component_id": "src.features.agents.tools.help-handler.HelpResult"
  },
  "src.features.agents.tools.help-handler.helpHandler": {
    "id": "src.features.agents.tools.help-handler.helpHandler",
    "name": "helpHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/tools/help-handler.ts",
    "relative_path": "src/features/agents/tools/help-handler.ts",
    "depends_on": [
      "src.features.agents.tools.help-handler.HelpHandlerParams",
      "src.features.agents.tools.help-formatter.formatCommandNotFound",
      "src.features.agents.tools.help-handler.HelpResult",
      "src.features.agents.tools.help-formatter.formatGeneralHelp",
      "src.features.agents.tools.help-formatter.formatCommandHelp"
    ],
    "source_code": "function helpHandler(params: HelpHandlerParams): HelpResult {\n\tconst agent = params.context.agent;\n\tconst input = params.input.trim();\n\tconst commandName = input\n\t\t? input.replace(COMMAND_PREFIX_PATTERN, \"\").trim()\n\t\t: \"\";\n\n\t// T071 - Send telemetry\n\tif (params.telemetry) {\n\t\tparams.telemetry.sendEvent(\"agent.help.invoked\", {\n\t\t\tagentId: agent.id,\n\t\t\tcommandName: commandName || \"general\",\n\t\t\thasSpecificCommand: Boolean(commandName),\n\t\t});\n\t}\n\n\tif (!input) {\n\t\tconst help = formatGeneralHelp(agent);\n\t\treturn { content: help.content };\n\t}\n\n\tconst help = formatCommandHelp(agent, commandName);\n\n\tif (!help) {\n\t\tconst notFound = formatCommandNotFound(agent, commandName);\n\t\treturn { content: notFound.content };\n\t}\n\n\treturn { content: help.content };\n}",
    "start_line": 35,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function helpHandler",
    "component_id": "src.features.agents.tools.help-handler.helpHandler"
  },
  "src.features.agents.types.AgentDefinition": {
    "id": "src.features.agents.types.AgentDefinition",
    "name": "AgentDefinition",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [
      "src.features.agents.types.AgentResourceRefs",
      "src.features.agents.types.AgentCommand"
    ],
    "source_code": "interface AgentDefinition {\n\t/** Unique agent identifier (lowercase alphanumeric with hyphens) */\n\tid: string;\n\n\t/** Short display name */\n\tname: string;\n\n\t/** Full descriptive name */\n\tfullName: string;\n\n\t/** Brief purpose description */\n\tdescription: string;\n\n\t/** Optional icon path (relative to extension root) */\n\ticon?: string;\n\n\t/** Commands supported by this agent */\n\tcommands: AgentCommand[];\n\n\t/** References to agent resources (prompts, skills, instructions) */\n\tresources: AgentResourceRefs;\n\n\t/** Original file path */\n\tfilePath: string;\n\n\t/** Markdown documentation content */\n\tcontent: string;\n}",
    "start_line": 14,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentDefinition",
    "component_id": "src.features.agents.types.AgentDefinition"
  },
  "src.features.agents.types.AgentCommand": {
    "id": "src.features.agents.types.AgentCommand",
    "name": "AgentCommand",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface AgentCommand {\n\t/** Command name (without leading slash) */\n\tname: string;\n\n\t/** Brief command description (shown in autocomplete) */\n\tdescription: string;\n\n\t/** Name of tool handler to invoke */\n\ttool: string;\n\n\t/** Optional parameter hints or schema */\n\tparameters?: string;\n}",
    "start_line": 46,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentCommand",
    "component_id": "src.features.agents.types.AgentCommand"
  },
  "src.features.agents.types.AgentResourceRefs": {
    "id": "src.features.agents.types.AgentResourceRefs",
    "name": "AgentResourceRefs",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface AgentResourceRefs {\n\t/** Prompt file names */\n\tprompts?: string[];\n\n\t/** Skill file names */\n\tskills?: string[];\n\n\t/** Instruction file names */\n\tinstructions?: string[];\n}",
    "start_line": 63,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentResourceRefs",
    "component_id": "src.features.agents.types.AgentResourceRefs"
  },
  "src.features.agents.types.ToolHandler": {
    "id": "src.features.agents.types.ToolHandler",
    "name": "ToolHandler",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [
      "src.features.agents.types.ToolResponse",
      "src.features.agents.types.ToolExecutionParams"
    ],
    "source_code": "type ToolHandler = (\n\tparams: ToolExecutionParams\n) => Promise<ToolResponse>;",
    "start_line": 77,
    "end_line": 79,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ToolHandler",
    "component_id": "src.features.agents.types.ToolHandler"
  },
  "src.features.agents.types.ToolExecutionParams": {
    "id": "src.features.agents.types.ToolExecutionParams",
    "name": "ToolExecutionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [
      "src.features.agents.types.ToolExecutionContext",
      "src.features.agents.types.AgentResources"
    ],
    "source_code": "interface ToolExecutionParams {\n\t/** User input after command (free-text string for custom parsing) */\n\tinput: string;\n\n\t/** Execution context with workspace info and VS Code APIs */\n\tcontext: ToolExecutionContext;\n\n\t/** Agent resources (prompts, skills, instructions) loaded from cache */\n\tresources: AgentResources;\n\n\t/** Cancellation token for long-running operations */\n\ttoken: vscode.CancellationToken;\n}",
    "start_line": 84,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolExecutionParams",
    "component_id": "src.features.agents.types.ToolExecutionParams"
  },
  "src.features.agents.types.ToolExecutionContext": {
    "id": "src.features.agents.types.ToolExecutionContext",
    "name": "ToolExecutionContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.types.TelemetryReporter",
      "src.utils.chat-prompt-runner.ChatContext"
    ],
    "source_code": "interface ToolExecutionContext {\n\t/** Current agent definition */\n\tagent: AgentDefinition;\n\n\t/** Workspace information */\n\tworkspace: {\n\t\t/** Workspace root URI */\n\t\turi: vscode.Uri;\n\t\t/** Workspace name */\n\t\tname: string;\n\t\t/** All workspace folders */\n\t\tfolders: vscode.WorkspaceFolder[];\n\t};\n\n\t/** VS Code APIs */\n\tvscode: {\n\t\twindow: typeof vscode.window;\n\t\tworkspace: typeof vscode.workspace;\n\t\tcommands: typeof vscode.commands;\n\t};\n\n\t/** Chat context (history, references) */\n\tchatContext: vscode.ChatContext;\n\n\t/** Extension output channel for logging */\n\toutputChannel: vscode.OutputChannel;\n\n\t/** Telemetry reporter for metrics */\n\ttelemetry: TelemetryReporter;\n}",
    "start_line": 101,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolExecutionContext",
    "component_id": "src.features.agents.types.ToolExecutionContext"
  },
  "src.features.agents.types.AgentResources": {
    "id": "src.features.agents.types.AgentResources",
    "name": "AgentResources",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface AgentResources {\n\t/** Prompt templates indexed by filename */\n\tprompts: Map<string, string>;\n\n\t/** Domain knowledge packages indexed by filename */\n\tskills: Map<string, string>;\n\n\t/** Behavior guidelines indexed by filename */\n\tinstructions: Map<string, string>;\n}",
    "start_line": 135,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentResources",
    "component_id": "src.features.agents.types.AgentResources"
  },
  "src.features.agents.types.ToolResponse": {
    "id": "src.features.agents.types.ToolResponse",
    "name": "ToolResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [
      "src.features.agents.types.ResponseMetadata",
      "src.features.agents.types.FileReference"
    ],
    "source_code": "interface ToolResponse {\n\t/** Markdown-formatted content to display in chat */\n\tcontent: string;\n\n\t/** Optional file references for navigation */\n\tfiles?: FileReference[];\n\n\t/** Optional metadata for telemetry and debugging */\n\tmetadata?: ResponseMetadata;\n}",
    "start_line": 149,
    "end_line": 158,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ToolResponse",
    "component_id": "src.features.agents.types.ToolResponse"
  },
  "src.features.agents.types.FileReference": {
    "id": "src.features.agents.types.FileReference",
    "name": "FileReference",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface FileReference {\n\t/** File URI */\n\turi: vscode.Uri;\n\n\t/** Display label (defaults to filename if omitted) */\n\tlabel?: string;\n\n\t/** Action performed on file */\n\taction?: \"created\" | \"modified\" | \"deleted\";\n}",
    "start_line": 163,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FileReference",
    "component_id": "src.features.agents.types.FileReference"
  },
  "src.features.agents.types.ResponseMetadata": {
    "id": "src.features.agents.types.ResponseMetadata",
    "name": "ResponseMetadata",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface ResponseMetadata {\n\t/** Execution duration in milliseconds */\n\tduration?: number;\n\n\t/** LLM tokens used (if applicable) */\n\ttokensUsed?: number;\n\n\t/** Custom metadata fields */\n\t[key: string]: unknown;\n}",
    "start_line": 177,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResponseMetadata",
    "component_id": "src.features.agents.types.ResponseMetadata"
  },
  "src.features.agents.types.TelemetryReporter": {
    "id": "src.features.agents.types.TelemetryReporter",
    "name": "TelemetryReporter",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface TelemetryReporter {\n\tsendTelemetryEvent(\n\t\teventName: string,\n\t\tproperties?: Record<string, string>,\n\t\tmeasurements?: Record<string, number>\n\t): void;\n\n\tsendTelemetryErrorEvent(\n\t\teventName: string,\n\t\tproperties?: Record<string, string>,\n\t\tmeasurements?: Record<string, number>\n\t): void;\n}",
    "start_line": 191,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TelemetryReporter",
    "component_id": "src.features.agents.types.TelemetryReporter"
  },
  "src.features.agents.types.ResourceCache": {
    "id": "src.features.agents.types.ResourceCache",
    "name": "ResourceCache",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface ResourceCache {\n\t/** Prompt templates indexed by filename */\n\tprompts: Map<string, string>;\n\n\t/** Domain knowledge packages indexed by filename */\n\tskills: Map<string, string>;\n\n\t/** Behavior guidelines indexed by filename */\n\tinstructions: Map<string, string>;\n\n\t/**\n\t * Load all resources from directory\n\t * @param resourcesDir Absolute path to resources directory\n\t */\n\tload(resourcesDir: string): Promise<void>;\n\n\t/**\n\t * Reload specific changed files\n\t * @param changedFiles Array of changed file paths\n\t */\n\treload(changedFiles: string[]): Promise<void>;\n\n\t/**\n\t * Get resource by type and name\n\t * @param type Resource type\n\t * @param name Resource filename\n\t */\n\tget(\n\t\ttype: \"prompt\" | \"skill\" | \"instruction\",\n\t\tname: string\n\t): string | undefined;\n}",
    "start_line": 208,
    "end_line": 239,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResourceCache",
    "component_id": "src.features.agents.types.ResourceCache"
  },
  "src.features.agents.types.ValidationResult": {
    "id": "src.features.agents.types.ValidationResult",
    "name": "ValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "interface ValidationResult {\n\t/** Whether validation passed */\n\tvalid: boolean;\n\n\t/** Validation error messages */\n\terrors: string[];\n}",
    "start_line": 244,
    "end_line": 250,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ValidationResult",
    "component_id": "src.features.agents.types.ValidationResult"
  },
  "src.features.agents.types.AgentError": {
    "id": "src.features.agents.types.AgentError",
    "name": "AgentError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "class AgentError extends Error {\n\treadonly code?: string;\n\n\tconstructor(message: string, code?: string) {\n\t\tsuper(message);\n\t\tthis.name = \"AgentError\";\n\t\tthis.code = code;\n\t}\n}",
    "start_line": 255,
    "end_line": 263,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AgentError",
    "component_id": "src.features.agents.types.AgentError"
  },
  "src.features.agents.types.ToolExecutionError": {
    "id": "src.features.agents.types.ToolExecutionError",
    "name": "ToolExecutionError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "class ToolExecutionError extends Error {\n\treadonly tool: string;\n\treadonly cause?: Error;\n\n\tconstructor(message: string, tool: string, cause?: Error) {\n\t\tsuper(message);\n\t\tthis.name = \"ToolExecutionError\";\n\t\tthis.tool = tool;\n\t\tthis.cause = cause;\n\t}\n}",
    "start_line": 268,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ToolExecutionError",
    "component_id": "src.features.agents.types.ToolExecutionError"
  },
  "src.features.agents.types.ResourceError": {
    "id": "src.features.agents.types.ResourceError",
    "name": "ResourceError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/agents/types.ts",
    "relative_path": "src/features/agents/types.ts",
    "depends_on": [],
    "source_code": "class ResourceError extends Error {\n\treadonly resourceType: \"prompt\" | \"skill\" | \"instruction\";\n\treadonly resourceName: string;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tresourceType: \"prompt\" | \"skill\" | \"instruction\",\n\t\tresourceName: string\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"ResourceError\";\n\t\tthis.resourceType = resourceType;\n\t\tthis.resourceName = resourceName;\n\t}\n}",
    "start_line": 283,
    "end_line": 297,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ResourceError",
    "component_id": "src.features.agents.types.ResourceError"
  },
  "src.features.hooks.actions.agent-action.ExecutionResult": {
    "id": "src.features.hooks.actions.agent-action.ExecutionResult",
    "name": "ExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/agent-action.ts",
    "relative_path": "src/features/hooks/actions/agent-action.ts",
    "depends_on": [],
    "source_code": "interface ExecutionResult {\n\tsuccess: boolean;\n\terror?: Error;\n\tduration?: number;\n}",
    "start_line": 13,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionResult",
    "component_id": "src.features.hooks.actions.agent-action.ExecutionResult"
  },
  "src.features.hooks.actions.agent-action.AgentActionExecutor": {
    "id": "src.features.hooks.actions.agent-action.AgentActionExecutor",
    "name": "AgentActionExecutor",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/agent-action.ts",
    "relative_path": "src/features/hooks/actions/agent-action.ts",
    "depends_on": [
      "src.features.hooks.actions.agent-action.ExecutionResult",
      "ui.src.features.hooks-view.types.AgentActionParams",
      "src.features.hooks.types.isValidAgentParams",
      "src.features.hooks.types.ExecutionContext",
      "src.features.hooks.actions.agent-action.validateCommand",
      "src.utils.chat-prompt-runner.sendPromptToChat"
    ],
    "source_code": "class AgentActionExecutor {\n\t/**\n\t * Execute an agent action\n\t *\n\t * @param params - Agent action parameters\n\t * @param context - Execution context (optional)\n\t * @returns Execution result\n\t */\n\tasync execute(\n\t\tparams: AgentActionParams,\n\t\tcontext?: ExecutionContext\n\t): Promise<ExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Validate parameters\n\t\t\tif (!isValidAgentParams(params)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Invalid agent action parameters: command is required and must start with /speckit. or /openspec.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate command format\n\t\t\tthis.validateCommand(params.command);\n\n\t\t\t// Execute command via sendPromptToChat\n\t\t\tawait sendPromptToChat(params.command, {\n\t\t\t\tinstructionType: \"runPrompt\",\n\t\t\t});\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tduration,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error as Error,\n\t\t\t\tduration,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Validate command format\n\t *\n\t * @param command - Agent command to validate\n\t * @throws Error if command is invalid\n\t */\n\tprivate validateCommand(command: string): void {\n\t\t// Check command is not empty\n\t\tif (!command || command.trim().length === 0) {\n\t\t\tthrow new Error(\"Command cannot be empty\");\n\t\t}\n\n\t\t// Check command starts with / (slash command)\n\t\tif (!command.startsWith(\"/\")) {\n\t\t\tthrow new Error('Command must start with \"/\" (slash command)');\n\t\t}\n\n\t\t// Check command is for supported agents\n\t\tconst supportedPrefixes = [\"/speckit.\", \"/openspec.\"];\n\t\tconst isSupported = supportedPrefixes.some((prefix) =>\n\t\t\tcommand.startsWith(prefix)\n\t\t);\n\n\t\tif (!isSupported) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported agent command. Must start with ${supportedPrefixes.join(\" or \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Validate command structure (should have agent.operation format)\n\t\tconst parts = command.slice(1).split(\".\"); // Remove leading / and split\n\t\tif (parts.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid command format. Expected format: /agent.operation\"\n\t\t\t);\n\t\t}\n\n\t\tconst agent = parts[0];\n\t\tconst operation = parts[1];\n\n\t\t// Validate agent\n\t\tconst supportedAgents = [\"speckit\", \"openspec\"];\n\t\tif (!supportedAgents.includes(agent)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported agent: ${agent}. Supported agents: ${supportedAgents.join(\", \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Validate operation is not empty\n\t\tif (!operation || operation.trim().length === 0) {\n\t\t\tthrow new Error(\"Operation cannot be empty\");\n\t\t}\n\n\t\t// Validate operation format (alphanumeric, hyphens, underscores only)\n\t\tif (!OPERATION_FORMAT_PATTERN.test(operation)) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Operation must contain only alphanumeric characters, hyphens, and underscores\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a command is supported by this executor\n\t *\n\t * @param command - Command to check\n\t * @returns True if command is supported\n\t */\n\tisSupported(command: string): boolean {\n\t\ttry {\n\t\t\tthis.validateCommand(command);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n}",
    "start_line": 24,
    "end_line": 146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AgentActionExecutor",
    "component_id": "src.features.hooks.actions.agent-action.AgentActionExecutor"
  },
  "src.features.hooks.actions.agent-action.execute": {
    "id": "src.features.hooks.actions.agent-action.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/agent-action.ts",
    "relative_path": "src/features/hooks/actions/agent-action.ts",
    "depends_on": [],
    "source_code": "async execute(\n\t\tparams: AgentActionParams,\n\t\tcontext?: ExecutionContext\n\t): Promise<ExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Validate parameters\n\t\t\tif (!isValidAgentParams(params)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Invalid agent action parameters: command is required and must start with /speckit. or /openspec.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate command format\n\t\t\tthis.validateCommand(params.command);\n\n\t\t\t// Execute command via sendPromptToChat\n\t\t\tawait sendPromptToChat(params.command, {\n\t\t\t\tinstructionType: \"runPrompt\",\n\t\t\t});\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tduration,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error as Error,\n\t\t\t\tduration,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 32,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "src.features.hooks.actions.agent-action.execute"
  },
  "src.features.hooks.actions.agent-action.validateCommand": {
    "id": "src.features.hooks.actions.agent-action.validateCommand",
    "name": "validateCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/agent-action.ts",
    "relative_path": "src/features/hooks/actions/agent-action.ts",
    "depends_on": [],
    "source_code": "private validateCommand(command: string): void {\n\t\t// Check command is not empty\n\t\tif (!command || command.trim().length === 0) {\n\t\t\tthrow new Error(\"Command cannot be empty\");\n\t\t}\n\n\t\t// Check command starts with / (slash command)\n\t\tif (!command.startsWith(\"/\")) {\n\t\t\tthrow new Error('Command must start with \"/\" (slash command)');\n\t\t}\n\n\t\t// Check command is for supported agents\n\t\tconst supportedPrefixes = [\"/speckit.\", \"/openspec.\"];\n\t\tconst isSupported = supportedPrefixes.some((prefix) =>\n\t\t\tcommand.startsWith(prefix)\n\t\t);\n\n\t\tif (!isSupported) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported agent command. Must start with ${supportedPrefixes.join(\" or \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Validate command structure (should have agent.operation format)\n\t\tconst parts = command.slice(1).split(\".\"); // Remove leading / and split\n\t\tif (parts.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid command format. Expected format: /agent.operation\"\n\t\t\t);\n\t\t}\n\n\t\tconst agent = parts[0];\n\t\tconst operation = parts[1];\n\n\t\t// Validate agent\n\t\tconst supportedAgents = [\"speckit\", \"openspec\"];\n\t\tif (!supportedAgents.includes(agent)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported agent: ${agent}. Supported agents: ${supportedAgents.join(\", \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Validate operation is not empty\n\t\tif (!operation || operation.trim().length === 0) {\n\t\t\tthrow new Error(\"Operation cannot be empty\");\n\t\t}\n\n\t\t// Validate operation format (alphanumeric, hyphens, underscores only)\n\t\tif (!OPERATION_FORMAT_PATTERN.test(operation)) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Operation must contain only alphanumeric characters, hyphens, and underscores\"\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 77,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateCommand",
    "component_id": "src.features.hooks.actions.agent-action.validateCommand"
  },
  "src.features.hooks.actions.agent-action.isSupported": {
    "id": "src.features.hooks.actions.agent-action.isSupported",
    "name": "isSupported",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/agent-action.ts",
    "relative_path": "src/features/hooks/actions/agent-action.ts",
    "depends_on": [],
    "source_code": "isSupported(command: string): boolean {\n\t\ttry {\n\t\t\tthis.validateCommand(command);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 138,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isSupported",
    "component_id": "src.features.hooks.actions.agent-action.isSupported"
  },
  "src.features.hooks.actions.custom-action.CustomActionExecutionResult": {
    "id": "src.features.hooks.actions.custom-action.CustomActionExecutionResult",
    "name": "CustomActionExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "interface CustomActionExecutionResult {\n\tsuccess: boolean;\n\terror?: Error;\n\tduration?: number;\n}",
    "start_line": 11,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CustomActionExecutionResult",
    "component_id": "src.features.hooks.actions.custom-action.CustomActionExecutionResult"
  },
  "src.features.hooks.actions.custom-action.CustomActionValidationError": {
    "id": "src.features.hooks.actions.custom-action.CustomActionValidationError",
    "name": "CustomActionValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "class CustomActionValidationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"CustomActionValidationError\";\n\t}\n}",
    "start_line": 20,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CustomActionValidationError",
    "component_id": "src.features.hooks.actions.custom-action.CustomActionValidationError"
  },
  "src.features.hooks.actions.custom-action.CustomAgentInvocationError": {
    "id": "src.features.hooks.actions.custom-action.CustomAgentInvocationError",
    "name": "CustomAgentInvocationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "class CustomAgentInvocationError extends Error {\n\tconstructor(agentName: string, cause?: Error) {\n\t\tconst message = cause\n\t\t\t? `Failed to invoke custom agent '${agentName}': ${cause.message}`\n\t\t\t: `Failed to invoke custom agent '${agentName}'`;\n\t\tsuper(message);\n\t\tthis.name = \"CustomAgentInvocationError\";\n\t\tthis.cause = cause;\n\t}\n}",
    "start_line": 30,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CustomAgentInvocationError",
    "component_id": "src.features.hooks.actions.custom-action.CustomAgentInvocationError"
  },
  "src.features.hooks.actions.custom-action.CustomActionExecutorOptions": {
    "id": "src.features.hooks.actions.custom-action.CustomActionExecutorOptions",
    "name": "CustomActionExecutorOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "interface CustomActionExecutorOptions {\n\t/**\n\t * Custom prompt sender for testing purposes\n\t */\n\tpromptSender?: (prompt: string) => Promise<void>;\n\t/**\n\t * Logger for warnings and errors\n\t */\n\tlogger?: Pick<typeof console, \"warn\">;\n}",
    "start_line": 44,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CustomActionExecutorOptions",
    "component_id": "src.features.hooks.actions.custom-action.CustomActionExecutorOptions"
  },
  "src.features.hooks.actions.custom-action.CustomActionExecutor": {
    "id": "src.features.hooks.actions.custom-action.CustomActionExecutor",
    "name": "CustomActionExecutor",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [
      "src.features.hooks.actions.custom-action.buildAgentPrompt",
      "src.features.hooks.template-utils.expandTemplate",
      "src.features.hooks.types.TemplateContext",
      "ui.src.features.hooks-view.types.CustomActionParams",
      "src.features.hooks.types.isValidCustomParams",
      "src.features.hooks.actions.custom-action.CustomActionExecutionResult",
      "src.features.hooks.actions.custom-action.CustomActionValidationError",
      "src.features.hooks.actions.custom-action.expandArguments",
      "src.features.hooks.actions.custom-action.validateAgentName",
      "src.features.hooks.actions.custom-action.CustomActionExecutorOptions",
      "src.features.hooks.actions.custom-action.invokeAgent",
      "src.features.hooks.actions.custom-action.CustomAgentInvocationError"
    ],
    "source_code": "class CustomActionExecutor {\n\tprivate readonly promptSender: (prompt: string) => Promise<void>;\n\tprivate readonly logger: Pick<typeof console, \"warn\">;\n\n\tconstructor(options?: CustomActionExecutorOptions) {\n\t\tthis.promptSender = options?.promptSender ?? defaultPromptSender;\n\t\tthis.logger = options?.logger ?? console;\n\t}\n\n\t/**\n\t * Execute a custom action\n\t *\n\t * @param params - Custom action parameters\n\t * @param templateContext - Context for template variable expansion\n\t * @returns Execution result\n\t */\n\tasync execute(\n\t\tparams: CustomActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<CustomActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Validate parameters\n\t\t\tif (!isValidCustomParams(params)) {\n\t\t\t\tthrow new CustomActionValidationError(\n\t\t\t\t\t\"Invalid custom action parameters: agentName is required and must be alphanumeric with hyphens only\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate agent name format\n\t\t\tthis.validateAgentName(params.agentName);\n\n\t\t\t// Expand template variables in arguments\n\t\t\tconst expandedArguments = this.expandArguments(\n\t\t\t\tparams.arguments,\n\t\t\t\ttemplateContext\n\t\t\t);\n\n\t\t\t// Build the prompt for the custom agent\n\t\t\tconst prompt = this.buildAgentPrompt(params.agentName, expandedArguments);\n\n\t\t\t// Invoke the agent via chat\n\t\t\tawait this.invokeAgent(params.agentName, prompt);\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tduration,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.logger.warn?.(`[CustomActionExecutor] ${err.message}`);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: err,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Validate the agent name format\n\t *\n\t * @param agentName - Name of the custom agent\n\t * @throws CustomActionValidationError if invalid\n\t */\n\tprivate validateAgentName(agentName: string): void {\n\t\tif (!agentName || agentName.trim().length === 0) {\n\t\t\tthrow new CustomActionValidationError(\"Agent name cannot be empty\");\n\t\t}\n\n\t\t// Agent name must be alphanumeric with hyphens only\n\t\tif (!VALID_AGENT_NAME_PATTERN.test(agentName)) {\n\t\t\tthrow new CustomActionValidationError(\n\t\t\t\t\"Agent name must contain only alphanumeric characters and hyphens\"\n\t\t\t);\n\t\t}\n\n\t\t// Agent name must not start or end with a hyphen\n\t\tif (agentName.startsWith(\"-\") || agentName.endsWith(\"-\")) {\n\t\t\tthrow new CustomActionValidationError(\n\t\t\t\t\"Agent name must not start or end with a hyphen\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Expand template variables in the arguments string\n\t *\n\t * @param args - Arguments string with possible template variables\n\t * @param context - Template context for expansion\n\t * @returns Expanded arguments string\n\t */\n\tprivate expandArguments(\n\t\targs: string | undefined,\n\t\tcontext: TemplateContext\n\t): string | undefined {\n\t\tif (!args || args.trim().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst expanded = expandTemplate(args, context);\n\t\treturn expanded.trim().length > 0 ? expanded.trim() : undefined;\n\t}\n\n\t/**\n\t * Build the prompt string for invoking the custom agent\n\t *\n\t * @param agentName - Name of the agent to invoke\n\t * @param args - Expanded arguments (optional)\n\t * @returns Formatted prompt string\n\t */\n\tprivate buildAgentPrompt(agentName: string, args?: string): string {\n\t\t// Build prompt in the format: @agentName arguments\n\t\tconst mention = `@${agentName}`;\n\n\t\tif (args && args.trim().length > 0) {\n\t\t\treturn `${mention} ${args.trim()}`;\n\t\t}\n\n\t\treturn mention;\n\t}\n\n\t/**\n\t * Invoke the custom agent via the chat interface\n\t *\n\t * @param agentName - Name of the agent (for error reporting)\n\t * @param prompt - Full prompt to send\n\t * @throws CustomAgentInvocationError on failure\n\t */\n\tprivate async invokeAgent(agentName: string, prompt: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this.promptSender(prompt);\n\t\t} catch (error) {\n\t\t\tthrow new CustomAgentInvocationError(agentName, error as Error);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a custom action is valid\n\t *\n\t * @param params - Parameters to validate\n\t * @returns True if the action is valid\n\t */\n\tisValid(params: CustomActionParams): boolean {\n\t\ttry {\n\t\t\tif (!isValidCustomParams(params)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.validateAgentName(params.agentName);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n}",
    "start_line": 62,
    "end_line": 220,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CustomActionExecutor",
    "component_id": "src.features.hooks.actions.custom-action.CustomActionExecutor"
  },
  "src.features.hooks.actions.custom-action.execute": {
    "id": "src.features.hooks.actions.custom-action.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "async execute(\n\t\tparams: CustomActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<CustomActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Validate parameters\n\t\t\tif (!isValidCustomParams(params)) {\n\t\t\t\tthrow new CustomActionValidationError(\n\t\t\t\t\t\"Invalid custom action parameters: agentName is required and must be alphanumeric with hyphens only\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate agent name format\n\t\t\tthis.validateAgentName(params.agentName);\n\n\t\t\t// Expand template variables in arguments\n\t\t\tconst expandedArguments = this.expandArguments(\n\t\t\t\tparams.arguments,\n\t\t\t\ttemplateContext\n\t\t\t);\n\n\t\t\t// Build the prompt for the custom agent\n\t\t\tconst prompt = this.buildAgentPrompt(params.agentName, expandedArguments);\n\n\t\t\t// Invoke the agent via chat\n\t\t\tawait this.invokeAgent(params.agentName, prompt);\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tduration,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.logger.warn?.(`[CustomActionExecutor] ${err.message}`);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: err,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 78,
    "end_line": 123,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "src.features.hooks.actions.custom-action.execute"
  },
  "src.features.hooks.actions.custom-action.validateAgentName": {
    "id": "src.features.hooks.actions.custom-action.validateAgentName",
    "name": "validateAgentName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "private validateAgentName(agentName: string): void {\n\t\tif (!agentName || agentName.trim().length === 0) {\n\t\t\tthrow new CustomActionValidationError(\"Agent name cannot be empty\");\n\t\t}\n\n\t\t// Agent name must be alphanumeric with hyphens only\n\t\tif (!VALID_AGENT_NAME_PATTERN.test(agentName)) {\n\t\t\tthrow new CustomActionValidationError(\n\t\t\t\t\"Agent name must contain only alphanumeric characters and hyphens\"\n\t\t\t);\n\t\t}\n\n\t\t// Agent name must not start or end with a hyphen\n\t\tif (agentName.startsWith(\"-\") || agentName.endsWith(\"-\")) {\n\t\t\tthrow new CustomActionValidationError(\n\t\t\t\t\"Agent name must not start or end with a hyphen\"\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 131,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateAgentName",
    "component_id": "src.features.hooks.actions.custom-action.validateAgentName"
  },
  "src.features.hooks.actions.custom-action.expandArguments": {
    "id": "src.features.hooks.actions.custom-action.expandArguments",
    "name": "expandArguments",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "private expandArguments(\n\t\targs: string | undefined,\n\t\tcontext: TemplateContext\n\t): string | undefined {\n\t\tif (!args || args.trim().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst expanded = expandTemplate(args, context);\n\t\treturn expanded.trim().length > 0 ? expanded.trim() : undefined;\n\t}",
    "start_line": 158,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method expandArguments",
    "component_id": "src.features.hooks.actions.custom-action.expandArguments"
  },
  "src.features.hooks.actions.custom-action.buildAgentPrompt": {
    "id": "src.features.hooks.actions.custom-action.buildAgentPrompt",
    "name": "buildAgentPrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "private buildAgentPrompt(agentName: string, args?: string): string {\n\t\t// Build prompt in the format: @agentName arguments\n\t\tconst mention = `@${agentName}`;\n\n\t\tif (args && args.trim().length > 0) {\n\t\t\treturn `${mention} ${args.trim()}`;\n\t\t}\n\n\t\treturn mention;\n\t}",
    "start_line": 177,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentName",
      "args"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method buildAgentPrompt",
    "component_id": "src.features.hooks.actions.custom-action.buildAgentPrompt"
  },
  "src.features.hooks.actions.custom-action.invokeAgent": {
    "id": "src.features.hooks.actions.custom-action.invokeAgent",
    "name": "invokeAgent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "private async invokeAgent(agentName: string, prompt: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this.promptSender(prompt);\n\t\t} catch (error) {\n\t\t\tthrow new CustomAgentInvocationError(agentName, error as Error);\n\t\t}\n\t}",
    "start_line": 195,
    "end_line": 201,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentName",
      "prompt"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method invokeAgent",
    "component_id": "src.features.hooks.actions.custom-action.invokeAgent"
  },
  "src.features.hooks.actions.custom-action.isValid": {
    "id": "src.features.hooks.actions.custom-action.isValid",
    "name": "isValid",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [],
    "source_code": "isValid(params: CustomActionParams): boolean {\n\t\ttry {\n\t\t\tif (!isValidCustomParams(params)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.validateAgentName(params.agentName);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 209,
    "end_line": 219,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isValid",
    "component_id": "src.features.hooks.actions.custom-action.isValid"
  },
  "src.features.hooks.actions.custom-action.defaultPromptSender": {
    "id": "src.features.hooks.actions.custom-action.defaultPromptSender",
    "name": "defaultPromptSender",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/custom-action.ts",
    "relative_path": "src/features/hooks/actions/custom-action.ts",
    "depends_on": [
      "src.utils.chat-prompt-runner.sendPromptToChat"
    ],
    "source_code": "defaultPromptSender = async (prompt: string): Promise<void> => {\n\tawait sendPromptToChat(prompt, {\n\t\tinstructionType: \"runPrompt\",\n\t});\n}",
    "start_line": 225,
    "end_line": 229,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "prompt"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function defaultPromptSender",
    "component_id": "src.features.hooks.actions.custom-action.defaultPromptSender"
  },
  "src.features.hooks.actions.git-action.GitActionExecutionResult": {
    "id": "src.features.hooks.actions.git-action.GitActionExecutionResult",
    "name": "GitActionExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "interface GitActionExecutionResult {\n\tsuccess: boolean;\n\terror?: Error;\n\tduration?: number;\n}",
    "start_line": 5,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitActionExecutionResult",
    "component_id": "src.features.hooks.actions.git-action.GitActionExecutionResult"
  },
  "src.features.hooks.actions.git-action.GitExtension": {
    "id": "src.features.hooks.actions.git-action.GitExtension",
    "name": "GitExtension",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [
      "src.features.hooks.actions.git-action.GitAPI"
    ],
    "source_code": "interface GitExtension {\n\tgetAPI(version: number): GitAPI;\n}",
    "start_line": 11,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitExtension",
    "component_id": "src.features.hooks.actions.git-action.GitExtension"
  },
  "src.features.hooks.actions.git-action.GitAPI": {
    "id": "src.features.hooks.actions.git-action.GitAPI",
    "name": "GitAPI",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [
      "src.features.hooks.actions.git-action.GitRepository"
    ],
    "source_code": "interface GitAPI {\n\trepositories: GitRepository[];\n}",
    "start_line": 15,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitAPI",
    "component_id": "src.features.hooks.actions.git-action.GitAPI"
  },
  "src.features.hooks.actions.git-action.CommitOptions": {
    "id": "src.features.hooks.actions.git-action.CommitOptions",
    "name": "CommitOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "interface CommitOptions {\n\tall?: boolean;\n\tamend?: boolean;\n\tstage?: string[];\n}",
    "start_line": 19,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CommitOptions",
    "component_id": "src.features.hooks.actions.git-action.CommitOptions"
  },
  "src.features.hooks.actions.git-action.GitRepository": {
    "id": "src.features.hooks.actions.git-action.GitRepository",
    "name": "GitRepository",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [
      "src.features.hooks.actions.git-action.CommitOptions"
    ],
    "source_code": "interface GitRepository {\n\tcommit(message: string, options?: CommitOptions): Promise<void>;\n\tpush(remote?: string, branch?: string, setUpstream?: boolean): Promise<void>;\n}",
    "start_line": 25,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitRepository",
    "component_id": "src.features.hooks.actions.git-action.GitRepository"
  },
  "src.features.hooks.actions.git-action.GitExtensionNotFoundError": {
    "id": "src.features.hooks.actions.git-action.GitExtensionNotFoundError",
    "name": "GitExtensionNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "class GitExtensionNotFoundError extends Error {\n\tconstructor() {\n\t\tsuper(\n\t\t\t\"VS Code Git extension not found. Install/enable the Git extension to run Git actions.\"\n\t\t);\n\t\tthis.name = \"GitExtensionNotFoundError\";\n\t}\n}",
    "start_line": 30,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitExtensionNotFoundError",
    "component_id": "src.features.hooks.actions.git-action.GitExtensionNotFoundError"
  },
  "src.features.hooks.actions.git-action.GitRepositoryNotFoundError": {
    "id": "src.features.hooks.actions.git-action.GitRepositoryNotFoundError",
    "name": "GitRepositoryNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "class GitRepositoryNotFoundError extends Error {\n\tconstructor() {\n\t\tsuper(\"No Git repository found in the current workspace.\");\n\t\tthis.name = \"GitRepositoryNotFoundError\";\n\t}\n}",
    "start_line": 39,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitRepositoryNotFoundError",
    "component_id": "src.features.hooks.actions.git-action.GitRepositoryNotFoundError"
  },
  "src.features.hooks.actions.git-action.GitActionExecutor": {
    "id": "src.features.hooks.actions.git-action.GitActionExecutor",
    "name": "GitActionExecutor",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [
      "src.features.hooks.actions.git-action.GitRepository",
      "src.features.hooks.template-utils.expandTemplate",
      "src.features.hooks.actions.git-action.GitActionExecutionResult",
      "src.features.hooks.actions.git-action.getGitApi",
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.actions.git-action.GitExtensionNotFoundError",
      "src.features.hooks.actions.git-action.executeCommit",
      "src.features.hooks.actions.git-action.GitAPI",
      "src.features.hooks.actions.git-action.GitExtension",
      "src.features.hooks.actions.git-action.expandTemplate",
      "ui.src.features.hooks-view.types.GitActionParams",
      "src.features.hooks.types.isValidGitParams",
      "src.features.hooks.git-utils.getGitApi",
      "src.features.hooks.actions.git-action.GitRepositoryNotFoundError"
    ],
    "source_code": "class GitActionExecutor {\n\tasync execute(\n\t\tparams: GitActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<GitActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tif (!isValidGitParams(params)) {\n\t\t\t\tthrow new Error(\"Invalid Git action parameters\");\n\t\t\t}\n\n\t\t\tconst git = this.getGitApi();\n\t\t\tif (!git) {\n\t\t\t\tthrow new GitExtensionNotFoundError();\n\t\t\t}\n\n\t\t\tconst repository = git.repositories[0];\n\t\t\tif (!repository) {\n\t\t\t\tthrow new GitRepositoryNotFoundError();\n\t\t\t}\n\n\t\t\tif (params.operation === \"commit\") {\n\t\t\t\tawait this.executeCommit(repository, params, templateContext);\n\t\t\t} else {\n\t\t\t\tawait repository.push();\n\t\t\t}\n\n\t\t\treturn { success: true, duration: Date.now() - startTime };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error as Error,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async executeCommit(\n\t\trepository: GitRepository,\n\t\tparams: GitActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<void> {\n\t\tconst message = this.expandTemplate(\n\t\t\tparams.messageTemplate,\n\t\t\ttemplateContext\n\t\t).trim();\n\n\t\tif (!message) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Commit message cannot be empty after template expansion.\"\n\t\t\t);\n\t\t}\n\n\t\tawait repository.commit(message, { all: true });\n\n\t\tif (params.pushToRemote) {\n\t\t\tawait repository.push();\n\t\t}\n\t}\n\n\tprivate expandTemplate(template: string, context: TemplateContext): string {\n\t\tif (!template) {\n\t\t\treturn template;\n\t\t}\n\n\t\treturn template.replace(/\\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (_match, key) => {\n\t\t\tconst value = context[key as keyof TemplateContext];\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\treturn String(value);\n\t\t});\n\t}\n\n\tprivate getGitApi(): GitAPI | undefined {\n\t\tconst gitExtension = extensions.getExtension<GitExtension>(\"vscode.git\");\n\t\treturn gitExtension?.exports?.getAPI?.(1);\n\t}\n}",
    "start_line": 46,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitActionExecutor",
    "component_id": "src.features.hooks.actions.git-action.GitActionExecutor"
  },
  "src.features.hooks.actions.git-action.execute": {
    "id": "src.features.hooks.actions.git-action.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "async execute(\n\t\tparams: GitActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<GitActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tif (!isValidGitParams(params)) {\n\t\t\t\tthrow new Error(\"Invalid Git action parameters\");\n\t\t\t}\n\n\t\t\tconst git = this.getGitApi();\n\t\t\tif (!git) {\n\t\t\t\tthrow new GitExtensionNotFoundError();\n\t\t\t}\n\n\t\t\tconst repository = git.repositories[0];\n\t\t\tif (!repository) {\n\t\t\t\tthrow new GitRepositoryNotFoundError();\n\t\t\t}\n\n\t\t\tif (params.operation === \"commit\") {\n\t\t\t\tawait this.executeCommit(repository, params, templateContext);\n\t\t\t} else {\n\t\t\t\tawait repository.push();\n\t\t\t}\n\n\t\t\treturn { success: true, duration: Date.now() - startTime };\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error as Error,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 47,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "src.features.hooks.actions.git-action.execute"
  },
  "src.features.hooks.actions.git-action.executeCommit": {
    "id": "src.features.hooks.actions.git-action.executeCommit",
    "name": "executeCommit",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "private async executeCommit(\n\t\trepository: GitRepository,\n\t\tparams: GitActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<void> {\n\t\tconst message = this.expandTemplate(\n\t\t\tparams.messageTemplate,\n\t\t\ttemplateContext\n\t\t).trim();\n\n\t\tif (!message) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Commit message cannot be empty after template expansion.\"\n\t\t\t);\n\t\t}\n\n\t\tawait repository.commit(message, { all: true });\n\n\t\tif (params.pushToRemote) {\n\t\t\tawait repository.push();\n\t\t}\n\t}",
    "start_line": 84,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repository",
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeCommit",
    "component_id": "src.features.hooks.actions.git-action.executeCommit"
  },
  "src.features.hooks.actions.git-action.expandTemplate": {
    "id": "src.features.hooks.actions.git-action.expandTemplate",
    "name": "expandTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "private expandTemplate(template: string, context: TemplateContext): string {\n\t\tif (!template) {\n\t\t\treturn template;\n\t\t}\n\n\t\treturn template.replace(/\\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (_match, key) => {\n\t\t\tconst value = context[key as keyof TemplateContext];\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\treturn String(value);\n\t\t});\n\t}",
    "start_line": 107,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method expandTemplate",
    "component_id": "src.features.hooks.actions.git-action.expandTemplate"
  },
  "src.features.hooks.actions.git-action.getGitApi": {
    "id": "src.features.hooks.actions.git-action.getGitApi",
    "name": "getGitApi",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/git-action.ts",
    "relative_path": "src/features/hooks/actions/git-action.ts",
    "depends_on": [],
    "source_code": "private getGitApi(): GitAPI | undefined {\n\t\tconst gitExtension = extensions.getExtension<GitExtension>(\"vscode.git\");\n\t\treturn gitExtension?.exports?.getAPI?.(1);\n\t}",
    "start_line": 121,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getGitApi",
    "component_id": "src.features.hooks.actions.git-action.getGitApi"
  },
  "src.features.hooks.actions.github-action.GitHubActionExecutionResult": {
    "id": "src.features.hooks.actions.github-action.GitHubActionExecutionResult",
    "name": "GitHubActionExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "interface GitHubActionExecutionResult {\n\tsuccess: boolean;\n\terror?: Error;\n\tduration?: number;\n}",
    "start_line": 9,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitHubActionExecutionResult",
    "component_id": "src.features.hooks.actions.github-action.GitHubActionExecutionResult"
  },
  "src.features.hooks.actions.github-action.GitHubMcpClient": {
    "id": "src.features.hooks.actions.github-action.GitHubMcpClient",
    "name": "GitHubMcpClient",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "interface GitHubMcpClient {\n\topenIssue(args: {\n\t\trepository: string;\n\t\ttitle: string;\n\t\tbody?: string;\n\t}): Promise<void>;\n\tcloseIssue(args: { repository: string; issueNumber: number }): Promise<void>;\n\tcreatePullRequest(args: {\n\t\trepository: string;\n\t\ttitle: string;\n\t\tbody?: string;\n\t}): Promise<void>;\n\taddComment(args: {\n\t\trepository: string;\n\t\tissueNumber: number;\n\t\tbody: string;\n\t}): Promise<void>;\n}",
    "start_line": 15,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitHubMcpClient",
    "component_id": "src.features.hooks.actions.github-action.GitHubMcpClient"
  },
  "src.features.hooks.actions.github-action.GitHubClientProvider": {
    "id": "src.features.hooks.actions.github-action.GitHubClientProvider",
    "name": "GitHubClientProvider",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "type GitHubClientProvider = () => Promise<GitHubMcpClient | undefined>;",
    "start_line": 34,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type GitHubClientProvider",
    "component_id": "src.features.hooks.actions.github-action.GitHubClientProvider"
  },
  "src.features.hooks.actions.github-action.RepositoryResolver": {
    "id": "src.features.hooks.actions.github-action.RepositoryResolver",
    "name": "RepositoryResolver",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "type RepositoryResolver = (repository?: string) => Promise<string>;",
    "start_line": 35,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RepositoryResolver",
    "component_id": "src.features.hooks.actions.github-action.RepositoryResolver"
  },
  "src.features.hooks.actions.github-action.GitHubActionExecutorOptions": {
    "id": "src.features.hooks.actions.github-action.GitHubActionExecutorOptions",
    "name": "GitHubActionExecutorOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [
      "src.features.hooks.actions.github-action.GitHubClientProvider",
      "src.features.hooks.actions.github-action.RepositoryResolver"
    ],
    "source_code": "interface GitHubActionExecutorOptions {\n\tclientProvider?: GitHubClientProvider;\n\trepositoryResolver?: RepositoryResolver;\n\tlogger?: Pick<typeof console, \"warn\">;\n}",
    "start_line": 37,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitHubActionExecutorOptions",
    "component_id": "src.features.hooks.actions.github-action.GitHubActionExecutorOptions"
  },
  "src.features.hooks.actions.github-action.GitHubIntegrationUnavailableError": {
    "id": "src.features.hooks.actions.github-action.GitHubIntegrationUnavailableError",
    "name": "GitHubIntegrationUnavailableError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "class GitHubIntegrationUnavailableError extends Error {\n\tconstructor() {\n\t\tsuper(\n\t\t\t\"GitHub Tools integration is not available. Configure the MCP server to enable GitHub actions.\"\n\t\t);\n\t\tthis.name = \"GitHubIntegrationUnavailableError\";\n\t}\n}",
    "start_line": 46,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitHubIntegrationUnavailableError",
    "component_id": "src.features.hooks.actions.github-action.GitHubIntegrationUnavailableError"
  },
  "src.features.hooks.actions.github-action.GitHubRepositoryResolutionError": {
    "id": "src.features.hooks.actions.github-action.GitHubRepositoryResolutionError",
    "name": "GitHubRepositoryResolutionError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "class GitHubRepositoryResolutionError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"GitHubRepositoryResolutionError\";\n\t}\n}",
    "start_line": 55,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitHubRepositoryResolutionError",
    "component_id": "src.features.hooks.actions.github-action.GitHubRepositoryResolutionError"
  },
  "src.features.hooks.actions.github-action.GitHubActionValidationError": {
    "id": "src.features.hooks.actions.github-action.GitHubActionValidationError",
    "name": "GitHubActionValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "class GitHubActionValidationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"GitHubActionValidationError\";\n\t}\n}",
    "start_line": 62,
    "end_line": 67,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitHubActionValidationError",
    "component_id": "src.features.hooks.actions.github-action.GitHubActionValidationError"
  },
  "src.features.hooks.actions.github-action.GitHubActionExecutor": {
    "id": "src.features.hooks.actions.github-action.GitHubActionExecutor",
    "name": "GitHubActionExecutor",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [
      "src.features.hooks.actions.github-action.GitHubIntegrationUnavailableError",
      "src.features.hooks.actions.github-action.expandRequiredTemplate",
      "ui.src.features.hooks-view.types.GitHubActionParams",
      "src.features.hooks.actions.github-action.GitHubActionExecutionResult",
      "src.features.hooks.types.isValidGitHubParams",
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.actions.github-action.expandOptionalTemplate",
      "src.features.hooks.actions.github-action.GitHubActionExecutorOptions",
      "src.features.hooks.actions.github-action.RepositoryResolver",
      "src.features.hooks.actions.github-action.GitHubMcpClient",
      "src.features.hooks.actions.github-action.GitHubActionValidationError",
      "src.features.hooks.actions.github-action.validateOperationRequirements",
      "src.features.hooks.actions.github-action.GitHubClientProvider",
      "src.features.hooks.actions.github-action.executeOperation"
    ],
    "source_code": "class GitHubActionExecutor {\n\tprivate readonly clientProvider: GitHubClientProvider;\n\tprivate readonly repositoryResolver: RepositoryResolver;\n\tprivate readonly logger: Pick<typeof console, \"warn\">;\n\n\tconstructor(options?: GitHubActionExecutorOptions) {\n\t\tthis.clientProvider = options?.clientProvider ?? defaultClientProvider;\n\t\tthis.repositoryResolver =\n\t\t\toptions?.repositoryResolver ?? defaultRepositoryResolver;\n\t\tthis.logger = options?.logger ?? console;\n\t}\n\n\tasync execute(\n\t\tparams: GitHubActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<GitHubActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tthis.validateOperationRequirements(params);\n\t\t\tif (!isValidGitHubParams(params)) {\n\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t\"Invalid GitHub action parameters\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst repository = await this.repositoryResolver(params.repository);\n\t\t\tconst client = await this.clientProvider();\n\n\t\t\tif (!client) {\n\t\t\t\tthrow new GitHubIntegrationUnavailableError();\n\t\t\t}\n\n\t\t\tawait this.executeOperation(client, params, repository, templateContext);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.logger.warn?.(`[GitHubActionExecutor] ${err.message}`);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: err,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async executeOperation(\n\t\tclient: GitHubMcpClient,\n\t\tparams: GitHubActionParams,\n\t\trepository: string,\n\t\ttemplateContext: TemplateContext\n\t): Promise<void> {\n\t\tswitch (params.operation) {\n\t\t\tcase \"open-issue\": {\n\t\t\t\tconst title = expandRequiredTemplate(\n\t\t\t\t\tparams.titleTemplate,\n\t\t\t\t\ttemplateContext,\n\t\t\t\t\t\"Title\"\n\t\t\t\t);\n\t\t\t\tconst body = expandOptionalTemplate(\n\t\t\t\t\tparams.bodyTemplate,\n\t\t\t\t\ttemplateContext\n\t\t\t\t);\n\t\t\t\tawait client.openIssue({\n\t\t\t\t\trepository,\n\t\t\t\t\ttitle,\n\t\t\t\t\tbody,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"close-issue\": {\n\t\t\t\tif (!params.issueNumber) {\n\t\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t\t\"Issue number is required to close an issue.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tawait client.closeIssue({\n\t\t\t\t\trepository,\n\t\t\t\t\tissueNumber: params.issueNumber,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"create-pr\": {\n\t\t\t\tconst title = expandRequiredTemplate(\n\t\t\t\t\tparams.titleTemplate,\n\t\t\t\t\ttemplateContext,\n\t\t\t\t\t\"Title\"\n\t\t\t\t);\n\t\t\t\tconst body = expandOptionalTemplate(\n\t\t\t\t\tparams.bodyTemplate,\n\t\t\t\t\ttemplateContext\n\t\t\t\t);\n\t\t\t\tawait client.createPullRequest({\n\t\t\t\t\trepository,\n\t\t\t\t\ttitle,\n\t\t\t\t\tbody,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"add-comment\": {\n\t\t\t\tif (!params.issueNumber) {\n\t\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t\t\"Issue number is required to add a comment.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst body = expandRequiredTemplate(\n\t\t\t\t\tparams.bodyTemplate,\n\t\t\t\t\ttemplateContext,\n\t\t\t\t\t\"Comment body\"\n\t\t\t\t);\n\t\t\t\tawait client.addComment({\n\t\t\t\t\trepository,\n\t\t\t\t\tissueNumber: params.issueNumber,\n\t\t\t\t\tbody,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t`Unsupported GitHub operation: ${params.operation}`\n\t\t\t\t);\n\t\t}\n\t}\n\n\tprivate validateOperationRequirements(params: GitHubActionParams): void {\n\t\tif (\n\t\t\t(params.operation === \"close-issue\" ||\n\t\t\t\tparams.operation === \"add-comment\") &&\n\t\t\t(typeof params.issueNumber !== \"number\" || params.issueNumber <= 0)\n\t\t) {\n\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\"Issue number is required for this GitHub operation.\"\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\t(params.operation === \"open-issue\" || params.operation === \"create-pr\") &&\n\t\t\t(!params.titleTemplate || params.titleTemplate.trim().length === 0)\n\t\t) {\n\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\"Title template is required for this GitHub operation.\"\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tparams.operation === \"add-comment\" &&\n\t\t\t(!params.bodyTemplate || params.bodyTemplate.trim().length === 0)\n\t\t) {\n\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\"Comment body template is required.\"\n\t\t\t);\n\t\t}\n\t}\n}",
    "start_line": 69,
    "end_line": 227,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitHubActionExecutor",
    "component_id": "src.features.hooks.actions.github-action.GitHubActionExecutor"
  },
  "src.features.hooks.actions.github-action.execute": {
    "id": "src.features.hooks.actions.github-action.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "async execute(\n\t\tparams: GitHubActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<GitHubActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\tthis.validateOperationRequirements(params);\n\t\t\tif (!isValidGitHubParams(params)) {\n\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t\"Invalid GitHub action parameters\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst repository = await this.repositoryResolver(params.repository);\n\t\t\tconst client = await this.clientProvider();\n\n\t\t\tif (!client) {\n\t\t\t\tthrow new GitHubIntegrationUnavailableError();\n\t\t\t}\n\n\t\t\tawait this.executeOperation(client, params, repository, templateContext);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.logger.warn?.(`[GitHubActionExecutor] ${err.message}`);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: err,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 81,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "src.features.hooks.actions.github-action.execute"
  },
  "src.features.hooks.actions.github-action.executeOperation": {
    "id": "src.features.hooks.actions.github-action.executeOperation",
    "name": "executeOperation",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "private async executeOperation(\n\t\tclient: GitHubMcpClient,\n\t\tparams: GitHubActionParams,\n\t\trepository: string,\n\t\ttemplateContext: TemplateContext\n\t): Promise<void> {\n\t\tswitch (params.operation) {\n\t\t\tcase \"open-issue\": {\n\t\t\t\tconst title = expandRequiredTemplate(\n\t\t\t\t\tparams.titleTemplate,\n\t\t\t\t\ttemplateContext,\n\t\t\t\t\t\"Title\"\n\t\t\t\t);\n\t\t\t\tconst body = expandOptionalTemplate(\n\t\t\t\t\tparams.bodyTemplate,\n\t\t\t\t\ttemplateContext\n\t\t\t\t);\n\t\t\t\tawait client.openIssue({\n\t\t\t\t\trepository,\n\t\t\t\t\ttitle,\n\t\t\t\t\tbody,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"close-issue\": {\n\t\t\t\tif (!params.issueNumber) {\n\t\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t\t\"Issue number is required to close an issue.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tawait client.closeIssue({\n\t\t\t\t\trepository,\n\t\t\t\t\tissueNumber: params.issueNumber,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"create-pr\": {\n\t\t\t\tconst title = expandRequiredTemplate(\n\t\t\t\t\tparams.titleTemplate,\n\t\t\t\t\ttemplateContext,\n\t\t\t\t\t\"Title\"\n\t\t\t\t);\n\t\t\t\tconst body = expandOptionalTemplate(\n\t\t\t\t\tparams.bodyTemplate,\n\t\t\t\t\ttemplateContext\n\t\t\t\t);\n\t\t\t\tawait client.createPullRequest({\n\t\t\t\t\trepository,\n\t\t\t\t\ttitle,\n\t\t\t\t\tbody,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"add-comment\": {\n\t\t\t\tif (!params.issueNumber) {\n\t\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t\t\"Issue number is required to add a comment.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst body = expandRequiredTemplate(\n\t\t\t\t\tparams.bodyTemplate,\n\t\t\t\t\ttemplateContext,\n\t\t\t\t\t\"Comment body\"\n\t\t\t\t);\n\t\t\t\tawait client.addComment({\n\t\t\t\t\trepository,\n\t\t\t\t\tissueNumber: params.issueNumber,\n\t\t\t\t\tbody,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\t`Unsupported GitHub operation: ${params.operation}`\n\t\t\t\t);\n\t\t}\n\t}",
    "start_line": 120,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "client",
      "params",
      "repository",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeOperation",
    "component_id": "src.features.hooks.actions.github-action.executeOperation"
  },
  "src.features.hooks.actions.github-action.validateOperationRequirements": {
    "id": "src.features.hooks.actions.github-action.validateOperationRequirements",
    "name": "validateOperationRequirements",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [],
    "source_code": "private validateOperationRequirements(params: GitHubActionParams): void {\n\t\tif (\n\t\t\t(params.operation === \"close-issue\" ||\n\t\t\t\tparams.operation === \"add-comment\") &&\n\t\t\t(typeof params.issueNumber !== \"number\" || params.issueNumber <= 0)\n\t\t) {\n\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\"Issue number is required for this GitHub operation.\"\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\t(params.operation === \"open-issue\" || params.operation === \"create-pr\") &&\n\t\t\t(!params.titleTemplate || params.titleTemplate.trim().length === 0)\n\t\t) {\n\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\"Title template is required for this GitHub operation.\"\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tparams.operation === \"add-comment\" &&\n\t\t\t(!params.bodyTemplate || params.bodyTemplate.trim().length === 0)\n\t\t) {\n\t\t\tthrow new GitHubActionValidationError(\n\t\t\t\t\"Comment body template is required.\"\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 198,
    "end_line": 226,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateOperationRequirements",
    "component_id": "src.features.hooks.actions.github-action.validateOperationRequirements"
  },
  "src.features.hooks.actions.github-action.defaultClientProvider": {
    "id": "src.features.hooks.actions.github-action.defaultClientProvider",
    "name": "defaultClientProvider",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [
      "src.features.hooks.actions.github-action.GitHubClientProvider",
      "src.features.hooks.services.mcp-parameter-resolver.resolve"
    ],
    "source_code": "defaultClientProvider: GitHubClientProvider = () =>\n\tPromise.resolve(undefined)",
    "start_line": 229,
    "end_line": 230,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function defaultClientProvider",
    "component_id": "src.features.hooks.actions.github-action.defaultClientProvider"
  },
  "src.features.hooks.actions.github-action.defaultRepositoryResolver": {
    "id": "src.features.hooks.actions.github-action.defaultRepositoryResolver",
    "name": "defaultRepositoryResolver",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [
      "src.features.hooks.git-utils.extractGitHubSlugFromRemote",
      "src.features.hooks.actions.github-action.GitHubRepositoryResolutionError",
      "src.features.hooks.git-utils.getPrimaryRepository",
      "src.features.hooks.actions.github-action.RepositoryResolver"
    ],
    "source_code": "defaultRepositoryResolver: RepositoryResolver = (repository) => {\n\tif (repository && repository.trim().length > 0) {\n\t\treturn repository.trim();\n\t}\n\n\ttry {\n\t\tconst gitRepository = getPrimaryRepository();\n\t\tconst remotes = gitRepository.state.remotes ?? [];\n\t\tconst preferredRemote =\n\t\t\tremotes.find((remote) => remote.name === \"origin\") ?? remotes[0];\n\n\t\tconst remoteUrl = preferredRemote?.pushUrl ?? preferredRemote?.fetchUrl;\n\t\tconst slug = remoteUrl ? extractGitHubSlugFromRemote(remoteUrl) : undefined;\n\n\t\tif (slug) {\n\t\t\treturn slug;\n\t\t}\n\t} catch (error) {\n\t\tconst message =\n\t\t\terror instanceof Error ? error.message : String(error ?? \"\");\n\t\tthrow new GitHubRepositoryResolutionError(\n\t\t\t`Unable to resolve GitHub repository: ${message}`\n\t\t);\n\t}\n\n\tthrow new GitHubRepositoryResolutionError(\n\t\t\"Unable to determine GitHub repository. Configure the repository in the hook or add a GitHub remote.\"\n\t);\n}",
    "start_line": 232,
    "end_line": 260,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repository"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function defaultRepositoryResolver",
    "component_id": "src.features.hooks.actions.github-action.defaultRepositoryResolver"
  },
  "src.features.hooks.actions.github-action.expandRequiredTemplate": {
    "id": "src.features.hooks.actions.github-action.expandRequiredTemplate",
    "name": "expandRequiredTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [
      "src.features.hooks.actions.github-action.GitHubActionValidationError",
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.actions.github-action.expandOptionalTemplate"
    ],
    "source_code": "function expandRequiredTemplate(\n\ttemplate: string | undefined,\n\tcontext: TemplateContext,\n\tlabel: string\n): string {\n\tconst expanded = expandOptionalTemplate(template, context);\n\tif (!expanded) {\n\t\tthrow new GitHubActionValidationError(`${label} cannot be empty.`);\n\t}\n\treturn expanded;\n}",
    "start_line": 262,
    "end_line": 272,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "context",
      "label"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function expandRequiredTemplate",
    "component_id": "src.features.hooks.actions.github-action.expandRequiredTemplate"
  },
  "src.features.hooks.actions.github-action.expandOptionalTemplate": {
    "id": "src.features.hooks.actions.github-action.expandOptionalTemplate",
    "name": "expandOptionalTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/github-action.ts",
    "relative_path": "src/features/hooks/actions/github-action.ts",
    "depends_on": [
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.template-utils.expandTemplate"
    ],
    "source_code": "function expandOptionalTemplate(\n\ttemplate: string | undefined,\n\tcontext: TemplateContext\n): string | undefined {\n\tif (!template) {\n\t\treturn;\n\t}\n\n\tconst expanded = expandTemplate(template, context).trim();\n\treturn expanded.length > 0 ? expanded : undefined;\n}",
    "start_line": 274,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function expandOptionalTemplate",
    "component_id": "src.features.hooks.actions.github-action.expandOptionalTemplate"
  },
  "src.features.hooks.actions.mcp-action.MCPActionExecutionResult": {
    "id": "src.features.hooks.actions.mcp-action.MCPActionExecutionResult",
    "name": "MCPActionExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "interface MCPActionExecutionResult {\n\tsuccess: boolean;\n\toutput?: unknown;\n\terror?: Error;\n\tduration?: number;\n\ttruncated?: boolean; // T093: Flag if output was truncated\n}",
    "start_line": 29,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPActionExecutionResult",
    "component_id": "src.features.hooks.actions.mcp-action.MCPActionExecutionResult"
  },
  "src.features.hooks.actions.mcp-action.MCPActionExecutorOptions": {
    "id": "src.features.hooks.actions.mcp-action.MCPActionExecutorOptions",
    "name": "MCPActionExecutorOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
      "src.features.hooks.services.mcp-contracts.IMCPParameterResolver",
      "src.features.hooks.services.mcp-contracts.IMCPClientService",
      "src.features.hooks.services.mcp-contracts.IMCPExecutionPool"
    ],
    "source_code": "interface MCPActionExecutorOptions {\n\tdiscoveryService: IMCPDiscoveryService;\n\tclientService: IMCPClientService;\n\tparameterResolver: IMCPParameterResolver;\n\texecutionPool: IMCPExecutionPool;\n\tlogger?: Pick<typeof console, \"warn\" | \"log\">;\n\tmaxRetries?: number; // T092: Maximum retries for transient failures\n\tretryDelayMs?: number; // T092: Delay between retries\n}",
    "start_line": 40,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPActionExecutorOptions",
    "component_id": "src.features.hooks.actions.mcp-action.MCPActionExecutorOptions"
  },
  "src.features.hooks.actions.mcp-action.MCPActionValidationError": {
    "id": "src.features.hooks.actions.mcp-action.MCPActionValidationError",
    "name": "MCPActionValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "class MCPActionValidationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"MCPActionValidationError\";\n\t}\n}",
    "start_line": 53,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPActionValidationError",
    "component_id": "src.features.hooks.actions.mcp-action.MCPActionValidationError"
  },
  "src.features.hooks.actions.mcp-action.MCPActionExecutor": {
    "id": "src.features.hooks.actions.mcp-action.MCPActionExecutor",
    "name": "MCPActionExecutor",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [
      "src.features.hooks.actions.mcp-action.MCPActionValidationError",
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      "src.features.hooks.services.mcp-contracts.MCPToolExecutionResult",
      "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
      "src.features.hooks.types.isValidMCPParams",
      "src.features.hooks.services.mcp-execution-pool.execute",
      "src.features.hooks.services.mcp-contracts.MCPServerUnavailableError",
      "src.features.hooks.actions.mcp-action.checkServerAvailability",
      "ui.src.features.hooks-view.types.MCPActionParams",
      "src.features.hooks.services.mcp-client.validateParameters",
      "src.features.hooks.actions.mcp-action.validateResolvedParameters",
      "src.features.hooks.actions.mcp-action.execute",
      "src.features.hooks.services.mcp-contracts.MCPParameterValidationError",
      "src.features.hooks.services.mcp-contracts.MCPServerNotFoundError",
      "src.features.hooks.services.mcp-contracts.IMCPExecutionPool",
      "src.features.hooks.actions.mcp-action.resolveParameters",
      "src.features.hooks.services.mcp-contracts.MCPToolNotFoundError",
      "src.features.hooks.actions.mcp-action.validateActionParameters",
      "src.features.hooks.services.mcp-client.executeTool",
      "src.features.hooks.hook-manager.validateActionParameters",
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.services.mcp-contracts.MCPTimeoutError",
      "src.features.hooks.services.mcp-discovery.getServer",
      "src.features.hooks.services.mcp-contracts.IMCPParameterResolver",
      "src.features.hooks.services.mcp-contracts.IMCPClientService",
      "src.features.hooks.actions.mcp-action.delay",
      "src.features.hooks.actions.mcp-action.executeToolWithPool",
      "src.features.hooks.actions.mcp-action.MCPActionExecutorOptions",
      "src.features.hooks.actions.mcp-action.handleLargeOutput",
      "src.features.hooks.actions.mcp-action.MCPActionExecutionResult",
      "src.features.hooks.actions.mcp-action.convertToError",
      "src.features.hooks.actions.mcp-action.isTransientError"
    ],
    "source_code": "class MCPActionExecutor {\n\tprivate readonly discoveryService: IMCPDiscoveryService;\n\tprivate readonly clientService: IMCPClientService;\n\tprivate readonly parameterResolver: IMCPParameterResolver;\n\tprivate readonly executionPool: IMCPExecutionPool;\n\tprivate readonly logger: Pick<typeof console, \"warn\" | \"log\">;\n\tprivate readonly maxRetries: number; // T092\n\tprivate readonly retryDelayMs: number; // T092\n\n\tconstructor(options: MCPActionExecutorOptions) {\n\t\tthis.discoveryService = options.discoveryService;\n\t\tthis.clientService = options.clientService;\n\t\tthis.parameterResolver = options.parameterResolver;\n\t\tthis.executionPool = options.executionPool;\n\t\tthis.logger = options.logger ?? console;\n\t\tthis.maxRetries = options.maxRetries ?? 1; // T092: Default 1 retry\n\t\tthis.retryDelayMs = options.retryDelayMs ?? 2000; // T092: Default 2s delay\n\t}\n\n\t/**\n\t * Execute an MCP action with the given parameters and context\n\t *\n\t * @param params - MCP action parameters (serverId, toolName, parameterMappings, timeout)\n\t * @param templateContext - Template context for parameter resolution (feature, branch, etc.)\n\t * @returns Execution result with success status, output, error, and duration\n\t */\n\tasync execute(\n\t\tparams: MCPActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<MCPActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// T059: Validate action parameters\n\t\t\tthis.validateActionParameters(params);\n\n\t\t\t// T081-T082: Check server availability with graceful degradation\n\t\t\tawait this.checkServerAvailability(params.serverId);\n\n\t\t\t// T060: Resolve parameter mappings from context\n\t\t\tconst resolvedParams = this.resolveParameters(params, templateContext);\n\n\t\t\t// T090: Detailed logging for parameter resolution\n\t\t\tthis.logger.log?.(\n\t\t\t\t`[MCPActionExecutor] Resolved parameters for ${params.toolName}:`,\n\t\t\t\tJSON.stringify(resolvedParams)\n\t\t\t);\n\n\t\t\t// T061: Validate resolved parameters against tool schema\n\t\t\tawait this.validateResolvedParameters(\n\t\t\t\tparams.serverId,\n\t\t\t\tparams.toolName,\n\t\t\t\tresolvedParams\n\t\t\t);\n\n\t\t\t// T062 + T063: Execute tool with concurrency control\n\t\t\tconst timeout = params.timeout ?? MCP_DEFAULT_TIMEOUT;\n\t\t\tconst result = await this.executeToolWithPool(\n\t\t\t\tparams.serverId,\n\t\t\t\tparams.toolName,\n\t\t\t\tresolvedParams,\n\t\t\t\ttimeout\n\t\t\t);\n\n\t\t\t// T093: Handle large output payloads (truncate if >1MB)\n\t\t\tconst { output, truncated } = this.handleLargeOutput(result.output);\n\n\t\t\t// T065: Return execution result\n\t\t\treturn {\n\t\t\t\tsuccess: result.success,\n\t\t\t\toutput,\n\t\t\t\ttruncated,\n\t\t\t\terror: result.error ? this.convertToError(result.error) : undefined,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// T090: Detailed error logging for MCP failures\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Execution failed for ${params.serverId}/${params.toolName}: ${err.name} - ${err.message}`\n\t\t\t);\n\n\t\t\t// Log additional error details\n\t\t\tif (err instanceof MCPServerNotFoundError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Server not found. Verify server ID and Copilot configuration.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPServerUnavailableError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Server is currently unavailable. Check server status.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPToolNotFoundError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Tool not found. Verify tool name in server configuration.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPParameterValidationError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Parameter validation failed. Check parameter mappings.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPTimeoutError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Execution timed out. Consider increasing timeout value.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: err,\n\t\t\t\tduration,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Validate action parameters structure and types\n\t */\n\tprivate validateActionParameters(params: MCPActionParams): void {\n\t\tif (!isValidMCPParams(params)) {\n\t\t\tthrow new MCPActionValidationError(\n\t\t\t\t\"Invalid MCP action parameters structure\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Check if the MCP server is available\n\t * T081: Server availability validation before execution\n\t * T082: Graceful degradation - throw error but don't crash the system\n\t */\n\tprivate async checkServerAvailability(serverId: string): Promise<void> {\n\t\tconst server = await this.discoveryService.getServer(serverId);\n\n\t\tif (!server) {\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Server not found: ${serverId}. Hook execution will be skipped.`\n\t\t\t);\n\t\t\tthrow new MCPServerNotFoundError(serverId);\n\t\t}\n\n\t\tif (server.status === \"unavailable\") {\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Server unavailable: ${serverId}. Hook execution will be skipped.`\n\t\t\t);\n\t\t\tthrow new MCPServerUnavailableError(serverId);\n\t\t}\n\n\t\tthis.logger.log?.(\n\t\t\t`[MCPActionExecutor] Server available: ${serverId} (${server.name})`\n\t\t);\n\t}\n\n\t/**\n\t * Resolve parameter mappings using the template context\n\t */\n\tprivate resolveParameters(\n\t\tparams: MCPActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Record<string, unknown> {\n\t\treturn this.parameterResolver.resolve(\n\t\t\tparams.parameterMappings,\n\t\t\ttemplateContext\n\t\t);\n\t}\n\n\t/**\n\t * Validate resolved parameters against the tool's input schema\n\t */\n\tprivate async validateResolvedParameters(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tresolvedParams: Record<string, unknown>\n\t): Promise<void> {\n\t\tconst validation = await this.clientService.validateParameters(\n\t\t\tserverId,\n\t\t\ttoolName,\n\t\t\tresolvedParams\n\t\t);\n\n\t\tif (!validation.valid) {\n\t\t\tthrow new MCPParameterValidationError(validation.errors);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the MCP tool with concurrency control via execution pool\n\t * T092: Includes automatic retry logic for transient failures\n\t */\n\t// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Retry orchestration requires multiple guarded branches for reliability.\n\tprivate async executeToolWithPool(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tresolvedParams: Record<string, unknown>,\n\t\ttimeout: number\n\t): Promise<MCPToolExecutionResult> {\n\t\tlet lastError: Error | undefined;\n\n\t\t// T092: Retry loop (1 initial attempt + maxRetries retries)\n\t\tfor (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n\t\t\ttry {\n\t\t\t\t// Wrap execution in pool to enforce concurrency limit\n\t\t\t\tconst result = await this.executionPool.execute(() =>\n\t\t\t\t\tthis.clientService.executeTool(\n\t\t\t\t\t\tserverId,\n\t\t\t\t\t\ttoolName,\n\t\t\t\t\t\tresolvedParams,\n\t\t\t\t\t\ttimeout\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// Success - return immediately\n\t\t\t\tif (result.success || attempt === this.maxRetries) {\n\t\t\t\t\tif (attempt > 0) {\n\t\t\t\t\t\tthis.logger.log?.(\n\t\t\t\t\t\t\t`[MCPActionExecutor] Execution succeeded after ${attempt} retries`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// If not successful and not last attempt, prepare for retry\n\t\t\t\tlastError = result.error\n\t\t\t\t\t? this.convertToError(result.error)\n\t\t\t\t\t: new Error(\"Execution failed\");\n\n\t\t\t\t// Check if error is transient (retryable)\n\t\t\t\tconst isTransient = this.isTransientError(lastError);\n\t\t\t\tif (!isTransient) {\n\t\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\t`[MCPActionExecutor] Non-transient error, skipping retries: ${lastError.name}`\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Log retry attempt\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t`[MCPActionExecutor] Execution failed (attempt ${attempt + 1}/${this.maxRetries + 1}): ${lastError.message}. Retrying in ${this.retryDelayMs}ms...`\n\t\t\t\t);\n\n\t\t\t\t// Wait before retrying (T092: 2s delay)\n\t\t\t\tawait this.delay(this.retryDelayMs);\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error as Error;\n\n\t\t\t\t// Check if error is transient\n\t\t\t\tconst isTransient = this.isTransientError(lastError);\n\t\t\t\tif (!isTransient || attempt === this.maxRetries) {\n\t\t\t\t\tthrow lastError;\n\t\t\t\t}\n\n\t\t\t\t// Log retry attempt\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t`[MCPActionExecutor] Execution error (attempt ${attempt + 1}/${this.maxRetries + 1}): ${lastError.message}. Retrying in ${this.retryDelayMs}ms...`\n\t\t\t\t);\n\n\t\t\t\t// Wait before retrying\n\t\t\t\tawait this.delay(this.retryDelayMs);\n\t\t\t}\n\t\t}\n\n\t\t// All retries exhausted\n\t\tthrow lastError ?? new Error(\"Execution failed after all retry attempts\");\n\t}\n\n\t/**\n\t * T092: Check if error is transient (retryable)\n\t * Transient errors: timeout, network, server temporarily unavailable\n\t * Non-transient: validation errors, server not found, tool not found\n\t */\n\tprivate isTransientError(error: Error): boolean {\n\t\treturn (\n\t\t\terror instanceof MCPTimeoutError ||\n\t\t\terror instanceof MCPServerUnavailableError ||\n\t\t\terror.message.includes(\"timeout\") ||\n\t\t\terror.message.includes(\"network\") ||\n\t\t\terror.message.includes(\"ETIMEDOUT\") ||\n\t\t\terror.message.includes(\"ECONNREFUSED\")\n\t\t);\n\t}\n\n\t/**\n\t * T092: Delay helper for retry logic\n\t */\n\tprivate delay(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n\n\t/**\n\t * T093: Handle large MCP output payloads\n\t * Truncates output if size exceeds 1MB to prevent memory issues\n\t */\n\tprivate handleLargeOutput(output: unknown): {\n\t\toutput: unknown;\n\t\ttruncated: boolean;\n\t} {\n\t\tconst MAX_OUTPUT_SIZE = 1024 * 1024; // 1MB\n\n\t\ttry {\n\t\t\tconst outputStr = JSON.stringify(output);\n\t\t\tconst sizeBytes = new TextEncoder().encode(outputStr).length;\n\n\t\t\tif (sizeBytes > MAX_OUTPUT_SIZE) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t`[MCPActionExecutor] Output truncated: ${sizeBytes} bytes exceeds maximum ${MAX_OUTPUT_SIZE} bytes`\n\t\t\t\t);\n\n\t\t\t\t// Truncate to max size\n\t\t\t\tconst truncated = outputStr.substring(\n\t\t\t\t\t0,\n\t\t\t\t\tMath.floor(MAX_OUTPUT_SIZE / 2)\n\t\t\t\t); // Use half to account for encoding\n\t\t\t\treturn {\n\t\t\t\t\toutput: `${truncated}... [TRUNCATED - Original size: ${sizeBytes} bytes]`,\n\t\t\t\t\ttruncated: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn { output, truncated: false };\n\t\t} catch (error) {\n\t\t\t// If serialization fails, return as-is\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Failed to measure output size: ${error}`\n\t\t\t);\n\t\t\treturn { output, truncated: false };\n\t\t}\n\t}\n\n\t/**\n\t * Convert MCP execution error to standard Error object\n\t */\n\tprivate convertToError(mcpError: {\n\t\tcode: string;\n\t\tmessage: string;\n\t\tdetails?: unknown;\n\t}): Error {\n\t\t// Check if it's one of our known error types\n\t\tif (mcpError.code === \"MCPTimeoutError\") {\n\t\t\tconst timeout =\n\t\t\t\ttypeof mcpError.details === \"object\" &&\n\t\t\t\tmcpError.details !== null &&\n\t\t\t\t\"timeout\" in mcpError.details\n\t\t\t\t\t? (mcpError.details.timeout as number)\n\t\t\t\t\t: MCP_DEFAULT_TIMEOUT;\n\t\t\treturn new MCPTimeoutError(timeout);\n\t\t}\n\n\t\tif (mcpError.code === \"MCPServerNotFoundError\") {\n\t\t\tconst serverId =\n\t\t\t\ttypeof mcpError.details === \"string\"\n\t\t\t\t\t? mcpError.details\n\t\t\t\t\t: \"unknown server\";\n\t\t\treturn new MCPServerNotFoundError(serverId);\n\t\t}\n\n\t\tif (mcpError.code === \"MCPToolNotFoundError\") {\n\t\t\tconst parts = mcpError.message.split(\"'\");\n\t\t\tconst toolName = parts[1] ?? \"unknown tool\";\n\t\t\tconst serverId = parts[3] ?? \"unknown server\";\n\t\t\treturn new MCPToolNotFoundError(serverId, toolName);\n\t\t}\n\n\t\tif (mcpError.code === \"MCPServerUnavailableError\") {\n\t\t\tconst serverId =\n\t\t\t\ttypeof mcpError.details === \"string\"\n\t\t\t\t\t? mcpError.details\n\t\t\t\t\t: \"unknown server\";\n\t\t\treturn new MCPServerUnavailableError(serverId);\n\t\t}\n\n\t\t// Generic error\n\t\tconst error = new Error(mcpError.message);\n\t\terror.name = mcpError.code;\n\t\treturn error;\n\t}\n}",
    "start_line": 72,
    "end_line": 447,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPActionExecutor",
    "component_id": "src.features.hooks.actions.mcp-action.MCPActionExecutor"
  },
  "src.features.hooks.actions.mcp-action.execute": {
    "id": "src.features.hooks.actions.mcp-action.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "async execute(\n\t\tparams: MCPActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Promise<MCPActionExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// T059: Validate action parameters\n\t\t\tthis.validateActionParameters(params);\n\n\t\t\t// T081-T082: Check server availability with graceful degradation\n\t\t\tawait this.checkServerAvailability(params.serverId);\n\n\t\t\t// T060: Resolve parameter mappings from context\n\t\t\tconst resolvedParams = this.resolveParameters(params, templateContext);\n\n\t\t\t// T090: Detailed logging for parameter resolution\n\t\t\tthis.logger.log?.(\n\t\t\t\t`[MCPActionExecutor] Resolved parameters for ${params.toolName}:`,\n\t\t\t\tJSON.stringify(resolvedParams)\n\t\t\t);\n\n\t\t\t// T061: Validate resolved parameters against tool schema\n\t\t\tawait this.validateResolvedParameters(\n\t\t\t\tparams.serverId,\n\t\t\t\tparams.toolName,\n\t\t\t\tresolvedParams\n\t\t\t);\n\n\t\t\t// T062 + T063: Execute tool with concurrency control\n\t\t\tconst timeout = params.timeout ?? MCP_DEFAULT_TIMEOUT;\n\t\t\tconst result = await this.executeToolWithPool(\n\t\t\t\tparams.serverId,\n\t\t\t\tparams.toolName,\n\t\t\t\tresolvedParams,\n\t\t\t\ttimeout\n\t\t\t);\n\n\t\t\t// T093: Handle large output payloads (truncate if >1MB)\n\t\t\tconst { output, truncated } = this.handleLargeOutput(result.output);\n\n\t\t\t// T065: Return execution result\n\t\t\treturn {\n\t\t\t\tsuccess: result.success,\n\t\t\t\toutput,\n\t\t\t\ttruncated,\n\t\t\t\terror: result.error ? this.convertToError(result.error) : undefined,\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// T090: Detailed error logging for MCP failures\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Execution failed for ${params.serverId}/${params.toolName}: ${err.name} - ${err.message}`\n\t\t\t);\n\n\t\t\t// Log additional error details\n\t\t\tif (err instanceof MCPServerNotFoundError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Server not found. Verify server ID and Copilot configuration.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPServerUnavailableError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Server is currently unavailable. Check server status.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPToolNotFoundError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Tool not found. Verify tool name in server configuration.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPParameterValidationError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Parameter validation failed. Check parameter mappings.\"\n\t\t\t\t);\n\t\t\t} else if (err instanceof MCPTimeoutError) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\"[MCPActionExecutor] Execution timed out. Consider increasing timeout value.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: err,\n\t\t\t\tduration,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 98,
    "end_line": 185,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "src.features.hooks.actions.mcp-action.execute"
  },
  "src.features.hooks.actions.mcp-action.validateActionParameters": {
    "id": "src.features.hooks.actions.mcp-action.validateActionParameters",
    "name": "validateActionParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private validateActionParameters(params: MCPActionParams): void {\n\t\tif (!isValidMCPParams(params)) {\n\t\t\tthrow new MCPActionValidationError(\n\t\t\t\t\"Invalid MCP action parameters structure\"\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 190,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateActionParameters",
    "component_id": "src.features.hooks.actions.mcp-action.validateActionParameters"
  },
  "src.features.hooks.actions.mcp-action.checkServerAvailability": {
    "id": "src.features.hooks.actions.mcp-action.checkServerAvailability",
    "name": "checkServerAvailability",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private async checkServerAvailability(serverId: string): Promise<void> {\n\t\tconst server = await this.discoveryService.getServer(serverId);\n\n\t\tif (!server) {\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Server not found: ${serverId}. Hook execution will be skipped.`\n\t\t\t);\n\t\t\tthrow new MCPServerNotFoundError(serverId);\n\t\t}\n\n\t\tif (server.status === \"unavailable\") {\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Server unavailable: ${serverId}. Hook execution will be skipped.`\n\t\t\t);\n\t\t\tthrow new MCPServerUnavailableError(serverId);\n\t\t}\n\n\t\tthis.logger.log?.(\n\t\t\t`[MCPActionExecutor] Server available: ${serverId} (${server.name})`\n\t\t);\n\t}",
    "start_line": 203,
    "end_line": 223,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkServerAvailability",
    "component_id": "src.features.hooks.actions.mcp-action.checkServerAvailability"
  },
  "src.features.hooks.actions.mcp-action.resolveParameters": {
    "id": "src.features.hooks.actions.mcp-action.resolveParameters",
    "name": "resolveParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private resolveParameters(\n\t\tparams: MCPActionParams,\n\t\ttemplateContext: TemplateContext\n\t): Record<string, unknown> {\n\t\treturn this.parameterResolver.resolve(\n\t\t\tparams.parameterMappings,\n\t\t\ttemplateContext\n\t\t);\n\t}",
    "start_line": 228,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveParameters",
    "component_id": "src.features.hooks.actions.mcp-action.resolveParameters"
  },
  "src.features.hooks.actions.mcp-action.validateResolvedParameters": {
    "id": "src.features.hooks.actions.mcp-action.validateResolvedParameters",
    "name": "validateResolvedParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private async validateResolvedParameters(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tresolvedParams: Record<string, unknown>\n\t): Promise<void> {\n\t\tconst validation = await this.clientService.validateParameters(\n\t\t\tserverId,\n\t\t\ttoolName,\n\t\t\tresolvedParams\n\t\t);\n\n\t\tif (!validation.valid) {\n\t\t\tthrow new MCPParameterValidationError(validation.errors);\n\t\t}\n\t}",
    "start_line": 241,
    "end_line": 255,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName",
      "resolvedParams"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateResolvedParameters",
    "component_id": "src.features.hooks.actions.mcp-action.validateResolvedParameters"
  },
  "src.features.hooks.actions.mcp-action.executeToolWithPool": {
    "id": "src.features.hooks.actions.mcp-action.executeToolWithPool",
    "name": "executeToolWithPool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private async executeToolWithPool(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tresolvedParams: Record<string, unknown>,\n\t\ttimeout: number\n\t): Promise<MCPToolExecutionResult> {\n\t\tlet lastError: Error | undefined;\n\n\t\t// T092: Retry loop (1 initial attempt + maxRetries retries)\n\t\tfor (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n\t\t\ttry {\n\t\t\t\t// Wrap execution in pool to enforce concurrency limit\n\t\t\t\tconst result = await this.executionPool.execute(() =>\n\t\t\t\t\tthis.clientService.executeTool(\n\t\t\t\t\t\tserverId,\n\t\t\t\t\t\ttoolName,\n\t\t\t\t\t\tresolvedParams,\n\t\t\t\t\t\ttimeout\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// Success - return immediately\n\t\t\t\tif (result.success || attempt === this.maxRetries) {\n\t\t\t\t\tif (attempt > 0) {\n\t\t\t\t\t\tthis.logger.log?.(\n\t\t\t\t\t\t\t`[MCPActionExecutor] Execution succeeded after ${attempt} retries`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// If not successful and not last attempt, prepare for retry\n\t\t\t\tlastError = result.error\n\t\t\t\t\t? this.convertToError(result.error)\n\t\t\t\t\t: new Error(\"Execution failed\");\n\n\t\t\t\t// Check if error is transient (retryable)\n\t\t\t\tconst isTransient = this.isTransientError(lastError);\n\t\t\t\tif (!isTransient) {\n\t\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t\t`[MCPActionExecutor] Non-transient error, skipping retries: ${lastError.name}`\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Log retry attempt\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t`[MCPActionExecutor] Execution failed (attempt ${attempt + 1}/${this.maxRetries + 1}): ${lastError.message}. Retrying in ${this.retryDelayMs}ms...`\n\t\t\t\t);\n\n\t\t\t\t// Wait before retrying (T092: 2s delay)\n\t\t\t\tawait this.delay(this.retryDelayMs);\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error as Error;\n\n\t\t\t\t// Check if error is transient\n\t\t\t\tconst isTransient = this.isTransientError(lastError);\n\t\t\t\tif (!isTransient || attempt === this.maxRetries) {\n\t\t\t\t\tthrow lastError;\n\t\t\t\t}\n\n\t\t\t\t// Log retry attempt\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t`[MCPActionExecutor] Execution error (attempt ${attempt + 1}/${this.maxRetries + 1}): ${lastError.message}. Retrying in ${this.retryDelayMs}ms...`\n\t\t\t\t);\n\n\t\t\t\t// Wait before retrying\n\t\t\t\tawait this.delay(this.retryDelayMs);\n\t\t\t}\n\t\t}\n\n\t\t// All retries exhausted\n\t\tthrow lastError ?? new Error(\"Execution failed after all retry attempts\");\n\t}",
    "start_line": 262,
    "end_line": 335,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName",
      "resolvedParams",
      "timeout"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeToolWithPool",
    "component_id": "src.features.hooks.actions.mcp-action.executeToolWithPool"
  },
  "src.features.hooks.actions.mcp-action.isTransientError": {
    "id": "src.features.hooks.actions.mcp-action.isTransientError",
    "name": "isTransientError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private isTransientError(error: Error): boolean {\n\t\treturn (\n\t\t\terror instanceof MCPTimeoutError ||\n\t\t\terror instanceof MCPServerUnavailableError ||\n\t\t\terror.message.includes(\"timeout\") ||\n\t\t\terror.message.includes(\"network\") ||\n\t\t\terror.message.includes(\"ETIMEDOUT\") ||\n\t\t\terror.message.includes(\"ECONNREFUSED\")\n\t\t);\n\t}",
    "start_line": 342,
    "end_line": 351,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isTransientError",
    "component_id": "src.features.hooks.actions.mcp-action.isTransientError"
  },
  "src.features.hooks.actions.mcp-action.delay": {
    "id": "src.features.hooks.actions.mcp-action.delay",
    "name": "delay",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private delay(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}",
    "start_line": 356,
    "end_line": 358,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ms"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method delay",
    "component_id": "src.features.hooks.actions.mcp-action.delay"
  },
  "src.features.hooks.actions.mcp-action.handleLargeOutput": {
    "id": "src.features.hooks.actions.mcp-action.handleLargeOutput",
    "name": "handleLargeOutput",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private handleLargeOutput(output: unknown): {\n\t\toutput: unknown;\n\t\ttruncated: boolean;\n\t} {\n\t\tconst MAX_OUTPUT_SIZE = 1024 * 1024; // 1MB\n\n\t\ttry {\n\t\t\tconst outputStr = JSON.stringify(output);\n\t\t\tconst sizeBytes = new TextEncoder().encode(outputStr).length;\n\n\t\t\tif (sizeBytes > MAX_OUTPUT_SIZE) {\n\t\t\t\tthis.logger.warn?.(\n\t\t\t\t\t`[MCPActionExecutor] Output truncated: ${sizeBytes} bytes exceeds maximum ${MAX_OUTPUT_SIZE} bytes`\n\t\t\t\t);\n\n\t\t\t\t// Truncate to max size\n\t\t\t\tconst truncated = outputStr.substring(\n\t\t\t\t\t0,\n\t\t\t\t\tMath.floor(MAX_OUTPUT_SIZE / 2)\n\t\t\t\t); // Use half to account for encoding\n\t\t\t\treturn {\n\t\t\t\t\toutput: `${truncated}... [TRUNCATED - Original size: ${sizeBytes} bytes]`,\n\t\t\t\t\ttruncated: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn { output, truncated: false };\n\t\t} catch (error) {\n\t\t\t// If serialization fails, return as-is\n\t\t\tthis.logger.warn?.(\n\t\t\t\t`[MCPActionExecutor] Failed to measure output size: ${error}`\n\t\t\t);\n\t\t\treturn { output, truncated: false };\n\t\t}\n\t}",
    "start_line": 364,
    "end_line": 398,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "output"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleLargeOutput",
    "component_id": "src.features.hooks.actions.mcp-action.handleLargeOutput"
  },
  "src.features.hooks.actions.mcp-action.convertToError": {
    "id": "src.features.hooks.actions.mcp-action.convertToError",
    "name": "convertToError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/actions/mcp-action.ts",
    "relative_path": "src/features/hooks/actions/mcp-action.ts",
    "depends_on": [],
    "source_code": "private convertToError(mcpError: {\n\t\tcode: string;\n\t\tmessage: string;\n\t\tdetails?: unknown;\n\t}): Error {\n\t\t// Check if it's one of our known error types\n\t\tif (mcpError.code === \"MCPTimeoutError\") {\n\t\t\tconst timeout =\n\t\t\t\ttypeof mcpError.details === \"object\" &&\n\t\t\t\tmcpError.details !== null &&\n\t\t\t\t\"timeout\" in mcpError.details\n\t\t\t\t\t? (mcpError.details.timeout as number)\n\t\t\t\t\t: MCP_DEFAULT_TIMEOUT;\n\t\t\treturn new MCPTimeoutError(timeout);\n\t\t}\n\n\t\tif (mcpError.code === \"MCPServerNotFoundError\") {\n\t\t\tconst serverId =\n\t\t\t\ttypeof mcpError.details === \"string\"\n\t\t\t\t\t? mcpError.details\n\t\t\t\t\t: \"unknown server\";\n\t\t\treturn new MCPServerNotFoundError(serverId);\n\t\t}\n\n\t\tif (mcpError.code === \"MCPToolNotFoundError\") {\n\t\t\tconst parts = mcpError.message.split(\"'\");\n\t\t\tconst toolName = parts[1] ?? \"unknown tool\";\n\t\t\tconst serverId = parts[3] ?? \"unknown server\";\n\t\t\treturn new MCPToolNotFoundError(serverId, toolName);\n\t\t}\n\n\t\tif (mcpError.code === \"MCPServerUnavailableError\") {\n\t\t\tconst serverId =\n\t\t\t\ttypeof mcpError.details === \"string\"\n\t\t\t\t\t? mcpError.details\n\t\t\t\t\t: \"unknown server\";\n\t\t\treturn new MCPServerUnavailableError(serverId);\n\t\t}\n\n\t\t// Generic error\n\t\tconst error = new Error(mcpError.message);\n\t\terror.name = mcpError.code;\n\t\treturn error;\n\t}",
    "start_line": 403,
    "end_line": 446,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mcpError"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method convertToError",
    "component_id": "src.features.hooks.actions.mcp-action.convertToError"
  },
  "src.features.hooks.agent-discovery-service.IAgentDiscoveryService": {
    "id": "src.features.hooks.agent-discovery-service.IAgentDiscoveryService",
    "name": "IAgentDiscoveryService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-discovery-service.ts",
    "relative_path": "src/features/hooks/agent-discovery-service.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentSourceEnum",
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult"
    ],
    "source_code": "interface IAgentDiscoveryService {\n\t/**\n\t * Discover agents from all configured sources\n\t * @returns Promise resolving to array of discovery results (one per source)\n\t */\n\tdiscoverAll(): Promise<AgentDiscoveryResult[]>;\n\n\t/**\n\t * Discover agents from a specific source\n\t * @param source Source to discover from\n\t * @returns Promise resolving to discovery result\n\t */\n\tdiscoverFromSource(source: AgentSourceEnum): Promise<AgentDiscoveryResult>;\n}",
    "start_line": 29,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IAgentDiscoveryService",
    "component_id": "src.features.hooks.agent-discovery-service.IAgentDiscoveryService"
  },
  "src.features.hooks.agent-registry-types.AgentTypeEnum": {
    "id": "src.features.hooks.agent-registry-types.AgentTypeEnum",
    "name": "AgentTypeEnum",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "type AgentTypeEnum = \"local\" | \"background\";",
    "start_line": 19,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentTypeEnum",
    "component_id": "src.features.hooks.agent-registry-types.AgentTypeEnum"
  },
  "src.features.hooks.agent-registry-types.AgentSourceEnum": {
    "id": "src.features.hooks.agent-registry-types.AgentSourceEnum",
    "name": "AgentSourceEnum",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "type AgentSourceEnum = \"file\" | \"extension\";",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentSourceEnum",
    "component_id": "src.features.hooks.agent-registry-types.AgentSourceEnum"
  },
  "src.features.hooks.agent-registry-types.AgentErrorCode": {
    "id": "src.features.hooks.agent-registry-types.AgentErrorCode",
    "name": "AgentErrorCode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "type AgentErrorCode =\n\t| \"PARSE_ERROR\" // Failed to parse .agent.md file\n\t| \"INVALID_SCHEMA\" // Schema validation failed\n\t| \"DUPLICATE_ID\" // Agent ID already exists\n\t| \"FILE_NOT_FOUND\" // Agent file missing\n\t| \"EXTENSION_ERROR\";",
    "start_line": 29,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentErrorCode",
    "component_id": "src.features.hooks.agent-registry-types.AgentErrorCode"
  },
  "src.features.hooks.agent-registry-types.AgentUnavailableReason": {
    "id": "src.features.hooks.agent-registry-types.AgentUnavailableReason",
    "name": "AgentUnavailableReason",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "type AgentUnavailableReason =\n\t| \"FILE_DELETED\" // .agent.md file no longer exists\n\t| \"EXTENSION_UNINSTALLED\" // Extension was removed\n\t| \"CLI_NOT_INSTALLED\" // Background CLI tool not found in PATH\n\t| \"INVALID_SCHEMA\" // Agent schema became invalid\n\t| \"UNKNOWN\";",
    "start_line": 39,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentUnavailableReason",
    "component_id": "src.features.hooks.agent-registry-types.AgentUnavailableReason"
  },
  "src.features.hooks.agent-registry-types.AgentRegistryEntry": {
    "id": "src.features.hooks.agent-registry-types.AgentRegistryEntry",
    "name": "AgentRegistryEntry",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentSourceEnum",
      "src.features.hooks.agent-registry-types.AgentTypeEnum",
      "src.features.hooks.agent-registry-types.AgentConfigSchema"
    ],
    "source_code": "interface AgentRegistryEntry {\n\t// Identity (unique composite key)\n\tid: string; // Format: \"{source}:{name}\" (e.g., \"local:code-reviewer\", \"extension:copilot\")\n\n\t// Display Information\n\tname: string; // Base agent name (e.g., \"Code Reviewer\")\n\tdisplayName: string; // Name with source indicator if duplicate (e.g., \"Code Reviewer (Local)\")\n\tdescription?: string; // Short description of agent purpose\n\n\t// Classification\n\ttype: AgentTypeEnum; // \"local\" | \"background\"\n\tsource: AgentSourceEnum; // \"file\" | \"extension\"\n\n\t// Source-Specific Data\n\tsourcePath?: string; // Absolute file path (for source=\"file\")\n\textensionId?: string; // VS Code extension identifier (for source=\"extension\")\n\n\t// Agent Configuration Schema (from .agent.md frontmatter)\n\tschema?: AgentConfigSchema;\n\n\t// Metadata\n\tdiscoveredAt: number; // Unix timestamp (milliseconds)\n\tlastValidated?: number; // Unix timestamp (milliseconds)\n\tavailable: boolean; // Runtime availability status\n}",
    "start_line": 57,
    "end_line": 81,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentRegistryEntry",
    "component_id": "src.features.hooks.agent-registry-types.AgentRegistryEntry"
  },
  "src.features.hooks.agent-registry-types.AgentConfigSchema": {
    "id": "src.features.hooks.agent-registry-types.AgentConfigSchema",
    "name": "AgentConfigSchema",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentCommand",
      "src.features.hooks.agent-registry-types.AgentResources"
    ],
    "source_code": "interface AgentConfigSchema {\n\t// From YAML frontmatter\n\tid: string; // Agent identifier (lowercase-with-hyphens)\n\tname: string; // Short name\n\tfullName: string; // Full display name\n\tdescription: string; // Purpose and capabilities\n\ticon?: string; // Icon identifier (optional)\n\n\t// Commands supported by agent\n\tcommands: AgentCommand[];\n\n\t// Resources available to agent\n\tresources: AgentResources;\n\n\t// Raw markdown content (below frontmatter)\n\tcontent: string;\n}",
    "start_line": 86,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentConfigSchema",
    "component_id": "src.features.hooks.agent-registry-types.AgentConfigSchema"
  },
  "src.features.hooks.agent-registry-types.AgentCommand": {
    "id": "src.features.hooks.agent-registry-types.AgentCommand",
    "name": "AgentCommand",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "interface AgentCommand {\n\tname: string; // Command name (e.g., \"review\", \"help\")\n\tdescription: string; // What the command does\n\ttool: string; // Tool identifier (e.g., \"agent.review\")\n\tparameters?: Record<string, unknown>[]; // Optional parameter definitions\n}",
    "start_line": 107,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentCommand",
    "component_id": "src.features.hooks.agent-registry-types.AgentCommand"
  },
  "src.features.hooks.agent-registry-types.AgentResources": {
    "id": "src.features.hooks.agent-registry-types.AgentResources",
    "name": "AgentResources",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "interface AgentResources {\n\tprompts?: string[]; // Available prompt templates\n\tskills?: string[]; // Available skill modules\n\tinstructions?: string[]; // Additional instruction files\n}",
    "start_line": 117,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentResources",
    "component_id": "src.features.hooks.agent-registry-types.AgentResources"
  },
  "src.features.hooks.agent-registry-types.AgentDiscoveryResult": {
    "id": "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
    "name": "AgentDiscoveryResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentSourceEnum",
      "src.features.hooks.agent-registry-types.AgentDiscoveryError",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface AgentDiscoveryResult {\n\tsource: AgentSourceEnum; // Where agents were discovered\n\tagents: AgentRegistryEntry[]; // Discovered agents\n\terrors: AgentDiscoveryError[]; // Any errors encountered\n\tdiscoveredAt: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 130,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentDiscoveryResult",
    "component_id": "src.features.hooks.agent-registry-types.AgentDiscoveryResult"
  },
  "src.features.hooks.agent-registry-types.AgentDiscoveryError": {
    "id": "src.features.hooks.agent-registry-types.AgentDiscoveryError",
    "name": "AgentDiscoveryError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentErrorCode"
    ],
    "source_code": "interface AgentDiscoveryError {\n\tfilePath?: string; // File that caused error (if applicable)\n\textensionId?: string; // Extension that caused error (if applicable)\n\tcode: AgentErrorCode; // Error type\n\tmessage: string; // Human-readable error message\n}",
    "start_line": 140,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentDiscoveryError",
    "component_id": "src.features.hooks.agent-registry-types.AgentDiscoveryError"
  },
  "src.features.hooks.agent-registry-types.AgentAvailabilityCheck": {
    "id": "src.features.hooks.agent-registry-types.AgentAvailabilityCheck",
    "name": "AgentAvailabilityCheck",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentUnavailableReason"
    ],
    "source_code": "interface AgentAvailabilityCheck {\n\tagentId: string; // Reference to AgentRegistryEntry.id\n\tavailable: boolean; // Can agent be invoked?\n\treason?: AgentUnavailableReason; // Why unavailable (if applicable)\n\tcheckedAt: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 154,
    "end_line": 159,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentAvailabilityCheck",
    "component_id": "src.features.hooks.agent-registry-types.AgentAvailabilityCheck"
  },
  "src.features.hooks.agent-registry-types.GroupedAgents": {
    "id": "src.features.hooks.agent-registry-types.GroupedAgents",
    "name": "GroupedAgents",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface GroupedAgents {\n\tlocal: AgentRegistryEntry[]; // Local agents from .agent.md files\n\tbackground: AgentRegistryEntry[]; // Background CLI/extension agents\n}",
    "start_line": 168,
    "end_line": 171,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupedAgents",
    "component_id": "src.features.hooks.agent-registry-types.GroupedAgents"
  },
  "src.features.hooks.agent-registry-types.isAgentType": {
    "id": "src.features.hooks.agent-registry-types.isAgentType",
    "name": "isAgentType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "function isAgentType(value: unknown): value is AgentTypeEnum {\n\treturn value === \"local\" || value === \"background\";\n}",
    "start_line": 180,
    "end_line": 182,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isAgentType",
    "component_id": "src.features.hooks.agent-registry-types.isAgentType"
  },
  "src.features.hooks.agent-registry-types.isAgentSource": {
    "id": "src.features.hooks.agent-registry-types.isAgentSource",
    "name": "isAgentSource",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "function isAgentSource(value: unknown): value is AgentSourceEnum {\n\treturn value === \"file\" || value === \"extension\";\n}",
    "start_line": 187,
    "end_line": 189,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isAgentSource",
    "component_id": "src.features.hooks.agent-registry-types.isAgentSource"
  },
  "src.features.hooks.agent-registry-types.isValidAgentRegistryEntry": {
    "id": "src.features.hooks.agent-registry-types.isValidAgentRegistryEntry",
    "name": "isValidAgentRegistryEntry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.isAgentType",
      "src.features.hooks.agent-registry-types.isAgentSource"
    ],
    "source_code": "function isValidAgentRegistryEntry(\n\tobj: unknown\n): obj is AgentRegistryEntry {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst entry = obj as AgentRegistryEntry;\n\n\treturn (\n\t\ttypeof entry.id === \"string\" &&\n\t\tentry.id.length > 0 &&\n\t\ttypeof entry.name === \"string\" &&\n\t\tentry.name.length > 0 &&\n\t\ttypeof entry.displayName === \"string\" &&\n\t\tentry.displayName.length > 0 &&\n\t\tisAgentType(entry.type) &&\n\t\tisAgentSource(entry.source) &&\n\t\ttypeof entry.discoveredAt === \"number\" &&\n\t\tentry.discoveredAt > 0 &&\n\t\ttypeof entry.available === \"boolean\"\n\t);\n}",
    "start_line": 194,
    "end_line": 215,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidAgentRegistryEntry",
    "component_id": "src.features.hooks.agent-registry-types.isValidAgentRegistryEntry"
  },
  "src.features.hooks.agent-registry-types.isValidAgentDiscoveryResult": {
    "id": "src.features.hooks.agent-registry-types.isValidAgentDiscoveryResult",
    "name": "isValidAgentDiscoveryResult",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.isAgentSource"
    ],
    "source_code": "function isValidAgentDiscoveryResult(\n\tobj: unknown\n): obj is AgentDiscoveryResult {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst result = obj as AgentDiscoveryResult;\n\n\treturn (\n\t\tisAgentSource(result.source) &&\n\t\tArray.isArray(result.agents) &&\n\t\tArray.isArray(result.errors) &&\n\t\ttypeof result.discoveredAt === \"number\" &&\n\t\tresult.discoveredAt > 0\n\t);\n}",
    "start_line": 220,
    "end_line": 235,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidAgentDiscoveryResult",
    "component_id": "src.features.hooks.agent-registry-types.isValidAgentDiscoveryResult"
  },
  "src.features.hooks.agent-registry-types.isValidAgentAvailabilityCheck": {
    "id": "src.features.hooks.agent-registry-types.isValidAgentAvailabilityCheck",
    "name": "isValidAgentAvailabilityCheck",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry-types.ts",
    "relative_path": "src/features/hooks/agent-registry-types.ts",
    "depends_on": [],
    "source_code": "function isValidAgentAvailabilityCheck(\n\tobj: unknown\n): obj is AgentAvailabilityCheck {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst check = obj as AgentAvailabilityCheck;\n\n\treturn (\n\t\ttypeof check.agentId === \"string\" &&\n\t\tcheck.agentId.length > 0 &&\n\t\ttypeof check.available === \"boolean\" &&\n\t\ttypeof check.checkedAt === \"number\" &&\n\t\tcheck.checkedAt > 0\n\t);\n}",
    "start_line": 240,
    "end_line": 255,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidAgentAvailabilityCheck",
    "component_id": "src.features.hooks.agent-registry-types.isValidAgentAvailabilityCheck"
  },
  "src.features.hooks.agent-registry.AgentFilter": {
    "id": "src.features.hooks.agent-registry.AgentFilter",
    "name": "AgentFilter",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentSourceEnum"
    ],
    "source_code": "interface AgentFilter {\n\ttype?: \"local\" | \"background\"; // Filter by agent type\n\tsource?: AgentSourceEnum; // Filter by discovery source\n\tavailable?: boolean; // Filter by availability status\n\tsearchTerm?: string; // Filter by name/description text match\n}",
    "start_line": 36,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentFilter",
    "component_id": "src.features.hooks.agent-registry.AgentFilter"
  },
  "src.features.hooks.agent-registry.GroupedAgents": {
    "id": "src.features.hooks.agent-registry.GroupedAgents",
    "name": "GroupedAgents",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [
      "src.features.hooks.agent-registry-types.AgentRegistryEntry"
    ],
    "source_code": "interface GroupedAgents {\n\tlocal: AgentRegistryEntry[]; // Local agents from .agent.md files\n\tbackground: AgentRegistryEntry[]; // Background CLI/extension agents\n}",
    "start_line": 46,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupedAgents",
    "component_id": "src.features.hooks.agent-registry.GroupedAgents"
  },
  "src.features.hooks.agent-registry.RegistryChangeEvent": {
    "id": "src.features.hooks.agent-registry.RegistryChangeEvent",
    "name": "RegistryChangeEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [
      "src.features.hooks.agent-registry.RegistryChangeType"
    ],
    "source_code": "interface RegistryChangeEvent {\n\ttype: RegistryChangeType;\n\tagentIds: string[]; // Affected agent IDs\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 54,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RegistryChangeEvent",
    "component_id": "src.features.hooks.agent-registry.RegistryChangeEvent"
  },
  "src.features.hooks.agent-registry.RegistryChangeType": {
    "id": "src.features.hooks.agent-registry.RegistryChangeType",
    "name": "RegistryChangeType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "type RegistryChangeType =\n\t| \"agents-added\" // New agents discovered\n\t| \"agents-removed\" // Agents removed (file deleted, extension uninstalled)\n\t| \"agents-updated\" // Agent metadata or availability changed\n\t| \"registry-cleared\";",
    "start_line": 63,
    "end_line": 67,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RegistryChangeType",
    "component_id": "src.features.hooks.agent-registry.RegistryChangeType"
  },
  "src.features.hooks.agent-registry.AgentRegistry": {
    "id": "src.features.hooks.agent-registry.AgentRegistry",
    "name": "AgentRegistry",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [
      "src.features.hooks.agent-registry.discoverExtensionAgents",
      "src.features.hooks.agent-registry.refresh",
      "src.features.hooks.agent-registry.discoverLocalAgents",
      "src.features.hooks.file-watcher-service.onDidChangeFiles",
      "src.features.hooks.agent-registry.dispose",
      "src.utils.spec-kit-adapter.initialize",
      "src.features.hooks.agent-registry.onDidChangeRegistry",
      "src.features.hooks.agent-registry.emitChange",
      "src.features.hooks.extension-agent-discovery.isAgentExtension",
      "src.features.hooks.agent-registry-types.AgentAvailabilityCheck",
      "src.features.hooks.extension-monitor-service.onDidChangeExtensions",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry",
      "src.features.hooks.file-agent-discovery.FileAgentDiscovery",
      "src.features.hooks.file-watcher-service.startWatching",
      "src.features.hooks.file-watcher-service.FileWatcherService",
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
      "src.features.hooks.agent-registry.resolveDuplicateNames",
      "src.features.hooks.agent-registry.AgentFilter",
      "src.features.hooks.agent-registry.RegistryChangeEvent",
      "src.services.agent-service.dispose",
      "src.features.agents.resource-cache.get",
      "src.features.hooks.extension-monitor-service.ExtensionMonitorService",
      "src.features.hooks.file-agent-discovery.discoverFromDirectory",
      "src.features.hooks.extension-agent-discovery.discoverAgents",
      "src.providers.steering-explorer-provider.refresh",
      "src.features.hooks.agent-registry.getAllAgents",
      "src.utils.telemetry.clear",
      "src.features.hooks.agent-registry.GroupedAgents",
      "src.features.hooks.extension-monitor-service.startMonitoring",
      "src.features.hooks.agent-registry.initialize",
      "src.features.hooks.extension-agent-discovery.ExtensionAgentDiscovery"
    ],
    "source_code": "class AgentRegistry {\n\t// Internal state\n\tprivate readonly agents: Map<string, AgentRegistryEntry> = new Map();\n\tprivate readonly changeListeners: Array<\n\t\t(event: RegistryChangeEvent) => void\n\t> = [];\n\tprivate readonly fileDiscovery: FileAgentDiscovery;\n\tprivate readonly extensionDiscovery: ExtensionAgentDiscovery;\n\tprivate readonly fileWatcher: FileWatcherService;\n\tprivate readonly extensionMonitor: ExtensionMonitorService;\n\tprivate readonly workspaceRoot: string;\n\n\tconstructor(workspaceRoot: string) {\n\t\tthis.workspaceRoot = workspaceRoot;\n\t\tthis.fileDiscovery = new FileAgentDiscovery();\n\t\tthis.extensionDiscovery = new ExtensionAgentDiscovery();\n\t\tthis.fileWatcher = new FileWatcherService();\n\t\tthis.extensionMonitor = new ExtensionMonitorService();\n\t}\n\n\t/**\n\t * Initialize the registry by discovering all available agents\n\t * @returns Promise resolving to initial discovery result\n\t */\n\tasync initialize(): Promise<AgentDiscoveryResult[]> {\n\t\t// T083: Track agent discovery performance\n\t\tconst discoveryStartTime = Date.now();\n\t\tconst results: AgentDiscoveryResult[] = [];\n\n\t\t// Discover local agents from .github/agents/\n\t\tconst localResult = await this.discoverLocalAgents();\n\t\tresults.push(localResult);\n\n\t\t// Phase 7 (T074) - Discover extension agents\n\t\tconst extensionResult = await this.discoverExtensionAgents();\n\t\tresults.push(extensionResult);\n\n\t\t// Populate internal registry with all discovered agents\n\t\tconst allAgents: AgentRegistryEntry[] = [];\n\t\tfor (const result of results) {\n\t\t\tallAgents.push(...result.agents);\n\t\t}\n\n\t\t// Resolve duplicate names and populate registry\n\t\tconst disambiguatedAgents = this.resolveDuplicateNames(allAgents);\n\t\tfor (const agent of disambiguatedAgents) {\n\t\t\tthis.agents.set(agent.id, agent);\n\t\t}\n\n\t\t// T083: Log discovery telemetry\n\t\tconst discoveryDuration = Date.now() - discoveryStartTime;\n\t\tconst totalAgents = this.agents.size;\n\t\tconst fileAgents = Array.from(this.agents.values()).filter(\n\t\t\t(a) => a.source === \"file\"\n\t\t).length;\n\t\tconst extensionAgents = Array.from(this.agents.values()).filter(\n\t\t\t(a) => a.source === \"extension\"\n\t\t).length;\n\n\t\tconsole.log(\"[AgentRegistry] Discovery complete\", {\n\t\t\tduration: `${discoveryDuration}ms`,\n\t\t\ttotalAgents,\n\t\t\tfileAgents,\n\t\t\textensionAgents,\n\t\t\tresults: results.map((r) => ({\n\t\t\t\tsource: r.source,\n\t\t\t\tcount: r.agents.length,\n\t\t\t\terrors: r.errors.length,\n\t\t\t})),\n\t\t});\n\n\t\t// Start file watcher to detect agent file changes\n\t\tconst agentsDir = `${this.workspaceRoot}/${AGENTS_DIR_RELATIVE_PATH}`;\n\t\tthis.fileWatcher.startWatching(agentsDir);\n\n\t\t// Subscribe to file change events to trigger refresh\n\t\tthis.fileWatcher.onDidChangeFiles(async () => {\n\t\t\tawait this.refresh();\n\t\t});\n\n\t\t// Start extension monitor to detect extension install/uninstall\n\t\tthis.extensionMonitor.startMonitoring();\n\n\t\t// Subscribe to extension change events to trigger refresh\n\t\tthis.extensionMonitor.onDidChangeExtensions(async () => {\n\t\t\tawait this.refresh();\n\t\t});\n\n\t\t// Emit registry-changed event\n\t\tthis.emitChange({\n\t\t\ttype: \"registry-cleared\",\n\t\t\tagentIds: disambiguatedAgents.map((a) => a.id),\n\t\t\ttimestamp: Date.now(),\n\t\t});\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get all registered agents\n\t * @param filter Optional filter criteria\n\t * @returns Array of agent registry entries\n\t */\n\tgetAllAgents(filter?: AgentFilter): AgentRegistryEntry[] {\n\t\tlet agents = Array.from(this.agents.values());\n\n\t\t// Apply filters if provided\n\t\tif (filter) {\n\t\t\tif (filter.type !== undefined) {\n\t\t\t\tagents = agents.filter((a) => a.type === filter.type);\n\t\t\t}\n\t\t\tif (filter.source !== undefined) {\n\t\t\t\tagents = agents.filter((a) => a.source === filter.source);\n\t\t\t}\n\t\t\tif (filter.available !== undefined) {\n\t\t\t\tagents = agents.filter((a) => a.available === filter.available);\n\t\t\t}\n\t\t\tif (filter.searchTerm !== undefined) {\n\t\t\t\tconst searchLower = filter.searchTerm.toLowerCase();\n\t\t\t\tagents = agents.filter(\n\t\t\t\t\t(a) =>\n\t\t\t\t\t\ta.name.toLowerCase().includes(searchLower) ||\n\t\t\t\t\t\ta.description?.toLowerCase().includes(searchLower)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn agents;\n\t}\n\n\t/**\n\t * Get a single agent by ID\n\t * @param agentId Unique agent identifier (format: \"source:name\")\n\t * @returns Agent entry or undefined if not found\n\t */\n\tgetAgentById(agentId: string): AgentRegistryEntry | undefined {\n\t\t// TODO: Implement in Phase 3 (T019)\n\t\t// 1. Lookup agent in internal registry by ID\n\t\t// 2. Return agent or undefined\n\t\treturn this.agents.get(agentId);\n\t}\n\n\t/**\n\t * Get agents grouped by type (local vs background)\n\t * @returns Grouped agents for UI dropdown rendering\n\t */\n\tgetAgentsGroupedByType(): GroupedAgents {\n\t\tconst all = this.getAllAgents();\n\t\tconst local = all.filter((a) => a.type === \"local\");\n\t\tconst background = all.filter((a) => a.type === \"background\");\n\n\t\treturn {\n\t\t\tlocal,\n\t\t\tbackground,\n\t\t};\n\t}\n\n\t/**\n\t * Check if an agent is currently available for invocation\n\t * @param agentId Unique agent identifier\n\t * @returns Availability check result with reason if unavailable\n\t */\n\tasync checkAgentAvailability(\n\t\tagentId: string\n\t): Promise<AgentAvailabilityCheck> {\n\t\tconst agent = this.agents.get(agentId);\n\n\t\tif (!agent) {\n\t\t\treturn {\n\t\t\t\tagentId,\n\t\t\t\tavailable: false,\n\t\t\t\treason: \"UNKNOWN\",\n\t\t\t\tcheckedAt: Date.now(),\n\t\t\t};\n\t\t}\n\n\t\t// For file-based agents, check if the file still exists\n\t\tif (agent.source === \"file\" && agent.sourcePath) {\n\t\t\ttry {\n\t\t\t\tconst { existsSync } = await import(\"node:fs\");\n\t\t\t\tconst fileExists = existsSync(agent.sourcePath);\n\n\t\t\t\tif (!fileExists) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tagentId,\n\t\t\t\t\t\tavailable: false,\n\t\t\t\t\t\treason: \"FILE_DELETED\",\n\t\t\t\t\t\tcheckedAt: Date.now(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tagentId,\n\t\t\t\t\tavailable: false,\n\t\t\t\t\treason: \"UNKNOWN\",\n\t\t\t\t\tcheckedAt: Date.now(),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// T075: For extension-based agents, check if extension is still installed\n\t\tif (agent.source === \"extension\") {\n\t\t\tconst extensionId = agent.extensionId;\n\t\t\tif (extensionId) {\n\t\t\t\tconst isStillAgent =\n\t\t\t\t\tthis.extensionDiscovery.isAgentExtension(extensionId);\n\t\t\t\tif (!isStillAgent) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tagentId,\n\t\t\t\t\t\tavailable: false,\n\t\t\t\t\t\treason: \"EXTENSION_UNINSTALLED\",\n\t\t\t\t\t\tcheckedAt: Date.now(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Agent exists and is accessible\n\t\treturn {\n\t\t\tagentId,\n\t\t\tavailable: true,\n\t\t\tcheckedAt: Date.now(),\n\t\t};\n\t}\n\n\t/**\n\t * Force refresh of agent registry from all sources\n\t * @returns Promise resolving to new discovery results\n\t */\n\tasync refresh(): Promise<AgentDiscoveryResult[]> {\n\t\t// Clear internal registry\n\t\tthis.agents.clear();\n\n\t\t// Re-run discovery from all sources\n\t\tconst results = await this.initialize();\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Register callback for registry changes (new agents, removals, updates)\n\t * @param callback Function to call when registry changes\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeRegistry(callback: (event: RegistryChangeEvent) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\t// TODO: Implement in Phase 6 (T063)\n\t\t// 1. Add callback to internal listener list\n\t\t// 2. Return disposable that removes callback\n\t\tthis.changeListeners.push(callback);\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this.changeListeners.indexOf(callback);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tthis.changeListeners.splice(index, 1);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Convenience method to subscribe to agent list changes\n\t * Similar to onDidChangeRegistry but provides the full agent list in the callback\n\t * @param callback Function to call with updated agent list when registry changes\n\t * @returns Disposable to unregister callback\n\t */\n\tonAgentsChanged(callback: (agents: AgentRegistryEntry[]) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\treturn this.onDidChangeRegistry(() => {\n\t\t\tconst agents = this.getAllAgents();\n\t\t\tcallback(agents);\n\t\t});\n\t}\n\n\t/**\n\t * Dispose of all resources and stop watching for changes\n\t * Called when the extension is deactivated\n\t */\n\tdispose(): void {\n\t\t// Stop file watcher\n\t\tthis.fileWatcher.dispose();\n\n\t\t// Stop extension monitor\n\t\tthis.extensionMonitor.dispose();\n\n\t\t// Clear all listeners\n\t\tthis.changeListeners.length = 0;\n\n\t\t// Clear registry\n\t\tthis.agents.clear();\n\t}\n\n\t// ========================================================================\n\t// Internal Methods (to be implemented in later phases)\n\t// ========================================================================\n\n\t/**\n\t * Discover local agents from .github/agents/ directory\n\t * @returns Discovery result with local agents\n\t */\n\tprivate async discoverLocalAgents(): Promise<AgentDiscoveryResult> {\n\t\tconst agentsDir = `${this.workspaceRoot}/${AGENTS_DIR_RELATIVE_PATH}`;\n\t\treturn await this.fileDiscovery.discoverFromDirectory(agentsDir);\n\t}\n\n\t/**\n\t * Discover extension agents from VS Code extensions\n\t * @returns Discovery result with extension agents\n\t */\n\tprivate async discoverExtensionAgents(): Promise<AgentDiscoveryResult> {\n\t\treturn await this.extensionDiscovery.discoverAgents();\n\t}\n\n\t/**\n\t * Emit a registry change event to all listeners\n\t * @param event Event to emit\n\t */\n\tprivate emitChange(event: RegistryChangeEvent): void {\n\t\tfor (const listener of this.changeListeners) {\n\t\t\tlistener(event);\n\t\t}\n\t}\n\n\t/**\n\t * Detect and resolve duplicate agent names\n\t * @param agents List of agents to check for duplicates\n\t * @returns Agents with disambiguated display names\n\t */\n\tprivate resolveDuplicateNames(\n\t\tagents: AgentRegistryEntry[]\n\t): AgentRegistryEntry[] {\n\t\t// Group agents by name to find duplicates\n\t\tconst nameGroups = new Map<string, AgentRegistryEntry[]>();\n\n\t\tfor (const agent of agents) {\n\t\t\tconst existing = nameGroups.get(agent.name);\n\t\t\tif (existing) {\n\t\t\t\texisting.push(agent);\n\t\t\t} else {\n\t\t\t\tnameGroups.set(agent.name, [agent]);\n\t\t\t}\n\t\t}\n\n\t\t// Process each group\n\t\tconst result: AgentRegistryEntry[] = [];\n\n\t\tfor (const [name, group] of nameGroups.entries()) {\n\t\t\tif (group.length === 1) {\n\t\t\t\t// No duplicates - keep original name\n\t\t\t\tresult.push(group[0]);\n\t\t\t} else {\n\t\t\t\t// Duplicates found - append source indicators\n\t\t\t\tfor (const agent of group) {\n\t\t\t\t\tconst suffix = agent.source === \"file\" ? \" (Local)\" : \" (Extension)\";\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\t...agent,\n\t\t\t\t\t\tdisplayName: agent.name + suffix,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}",
    "start_line": 79,
    "end_line": 446,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AgentRegistry",
    "component_id": "src.features.hooks.agent-registry.AgentRegistry"
  },
  "src.features.hooks.agent-registry.initialize": {
    "id": "src.features.hooks.agent-registry.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "async initialize(): Promise<AgentDiscoveryResult[]> {\n\t\t// T083: Track agent discovery performance\n\t\tconst discoveryStartTime = Date.now();\n\t\tconst results: AgentDiscoveryResult[] = [];\n\n\t\t// Discover local agents from .github/agents/\n\t\tconst localResult = await this.discoverLocalAgents();\n\t\tresults.push(localResult);\n\n\t\t// Phase 7 (T074) - Discover extension agents\n\t\tconst extensionResult = await this.discoverExtensionAgents();\n\t\tresults.push(extensionResult);\n\n\t\t// Populate internal registry with all discovered agents\n\t\tconst allAgents: AgentRegistryEntry[] = [];\n\t\tfor (const result of results) {\n\t\t\tallAgents.push(...result.agents);\n\t\t}\n\n\t\t// Resolve duplicate names and populate registry\n\t\tconst disambiguatedAgents = this.resolveDuplicateNames(allAgents);\n\t\tfor (const agent of disambiguatedAgents) {\n\t\t\tthis.agents.set(agent.id, agent);\n\t\t}\n\n\t\t// T083: Log discovery telemetry\n\t\tconst discoveryDuration = Date.now() - discoveryStartTime;\n\t\tconst totalAgents = this.agents.size;\n\t\tconst fileAgents = Array.from(this.agents.values()).filter(\n\t\t\t(a) => a.source === \"file\"\n\t\t).length;\n\t\tconst extensionAgents = Array.from(this.agents.values()).filter(\n\t\t\t(a) => a.source === \"extension\"\n\t\t).length;\n\n\t\tconsole.log(\"[AgentRegistry] Discovery complete\", {\n\t\t\tduration: `${discoveryDuration}ms`,\n\t\t\ttotalAgents,\n\t\t\tfileAgents,\n\t\t\textensionAgents,\n\t\t\tresults: results.map((r) => ({\n\t\t\t\tsource: r.source,\n\t\t\t\tcount: r.agents.length,\n\t\t\t\terrors: r.errors.length,\n\t\t\t})),\n\t\t});\n\n\t\t// Start file watcher to detect agent file changes\n\t\tconst agentsDir = `${this.workspaceRoot}/${AGENTS_DIR_RELATIVE_PATH}`;\n\t\tthis.fileWatcher.startWatching(agentsDir);\n\n\t\t// Subscribe to file change events to trigger refresh\n\t\tthis.fileWatcher.onDidChangeFiles(async () => {\n\t\t\tawait this.refresh();\n\t\t});\n\n\t\t// Start extension monitor to detect extension install/uninstall\n\t\tthis.extensionMonitor.startMonitoring();\n\n\t\t// Subscribe to extension change events to trigger refresh\n\t\tthis.extensionMonitor.onDidChangeExtensions(async () => {\n\t\t\tawait this.refresh();\n\t\t});\n\n\t\t// Emit registry-changed event\n\t\tthis.emitChange({\n\t\t\ttype: \"registry-cleared\",\n\t\t\tagentIds: disambiguatedAgents.map((a) => a.id),\n\t\t\ttimestamp: Date.now(),\n\t\t});\n\n\t\treturn results;\n\t}",
    "start_line": 103,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method initialize",
    "component_id": "src.features.hooks.agent-registry.initialize"
  },
  "src.features.hooks.agent-registry.getAllAgents": {
    "id": "src.features.hooks.agent-registry.getAllAgents",
    "name": "getAllAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "getAllAgents(filter?: AgentFilter): AgentRegistryEntry[] {\n\t\tlet agents = Array.from(this.agents.values());\n\n\t\t// Apply filters if provided\n\t\tif (filter) {\n\t\t\tif (filter.type !== undefined) {\n\t\t\t\tagents = agents.filter((a) => a.type === filter.type);\n\t\t\t}\n\t\t\tif (filter.source !== undefined) {\n\t\t\t\tagents = agents.filter((a) => a.source === filter.source);\n\t\t\t}\n\t\t\tif (filter.available !== undefined) {\n\t\t\t\tagents = agents.filter((a) => a.available === filter.available);\n\t\t\t}\n\t\t\tif (filter.searchTerm !== undefined) {\n\t\t\t\tconst searchLower = filter.searchTerm.toLowerCase();\n\t\t\t\tagents = agents.filter(\n\t\t\t\t\t(a) =>\n\t\t\t\t\t\ta.name.toLowerCase().includes(searchLower) ||\n\t\t\t\t\t\ta.description?.toLowerCase().includes(searchLower)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn agents;\n\t}",
    "start_line": 182,
    "end_line": 207,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filter"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAllAgents",
    "component_id": "src.features.hooks.agent-registry.getAllAgents"
  },
  "src.features.hooks.agent-registry.getAgentById": {
    "id": "src.features.hooks.agent-registry.getAgentById",
    "name": "getAgentById",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "getAgentById(agentId: string): AgentRegistryEntry | undefined {\n\t\t// TODO: Implement in Phase 3 (T019)\n\t\t// 1. Lookup agent in internal registry by ID\n\t\t// 2. Return agent or undefined\n\t\treturn this.agents.get(agentId);\n\t}",
    "start_line": 214,
    "end_line": 219,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAgentById",
    "component_id": "src.features.hooks.agent-registry.getAgentById"
  },
  "src.features.hooks.agent-registry.getAgentsGroupedByType": {
    "id": "src.features.hooks.agent-registry.getAgentsGroupedByType",
    "name": "getAgentsGroupedByType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "getAgentsGroupedByType(): GroupedAgents {\n\t\tconst all = this.getAllAgents();\n\t\tconst local = all.filter((a) => a.type === \"local\");\n\t\tconst background = all.filter((a) => a.type === \"background\");\n\n\t\treturn {\n\t\t\tlocal,\n\t\t\tbackground,\n\t\t};\n\t}",
    "start_line": 225,
    "end_line": 234,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAgentsGroupedByType",
    "component_id": "src.features.hooks.agent-registry.getAgentsGroupedByType"
  },
  "src.features.hooks.agent-registry.checkAgentAvailability": {
    "id": "src.features.hooks.agent-registry.checkAgentAvailability",
    "name": "checkAgentAvailability",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "async checkAgentAvailability(\n\t\tagentId: string\n\t): Promise<AgentAvailabilityCheck> {\n\t\tconst agent = this.agents.get(agentId);\n\n\t\tif (!agent) {\n\t\t\treturn {\n\t\t\t\tagentId,\n\t\t\t\tavailable: false,\n\t\t\t\treason: \"UNKNOWN\",\n\t\t\t\tcheckedAt: Date.now(),\n\t\t\t};\n\t\t}\n\n\t\t// For file-based agents, check if the file still exists\n\t\tif (agent.source === \"file\" && agent.sourcePath) {\n\t\t\ttry {\n\t\t\t\tconst { existsSync } = await import(\"node:fs\");\n\t\t\t\tconst fileExists = existsSync(agent.sourcePath);\n\n\t\t\t\tif (!fileExists) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tagentId,\n\t\t\t\t\t\tavailable: false,\n\t\t\t\t\t\treason: \"FILE_DELETED\",\n\t\t\t\t\t\tcheckedAt: Date.now(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tagentId,\n\t\t\t\t\tavailable: false,\n\t\t\t\t\treason: \"UNKNOWN\",\n\t\t\t\t\tcheckedAt: Date.now(),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// T075: For extension-based agents, check if extension is still installed\n\t\tif (agent.source === \"extension\") {\n\t\t\tconst extensionId = agent.extensionId;\n\t\t\tif (extensionId) {\n\t\t\t\tconst isStillAgent =\n\t\t\t\t\tthis.extensionDiscovery.isAgentExtension(extensionId);\n\t\t\t\tif (!isStillAgent) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tagentId,\n\t\t\t\t\t\tavailable: false,\n\t\t\t\t\t\treason: \"EXTENSION_UNINSTALLED\",\n\t\t\t\t\t\tcheckedAt: Date.now(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Agent exists and is accessible\n\t\treturn {\n\t\t\tagentId,\n\t\t\tavailable: true,\n\t\t\tcheckedAt: Date.now(),\n\t\t};\n\t}",
    "start_line": 241,
    "end_line": 302,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkAgentAvailability",
    "component_id": "src.features.hooks.agent-registry.checkAgentAvailability"
  },
  "src.features.hooks.agent-registry.refresh": {
    "id": "src.features.hooks.agent-registry.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "async refresh(): Promise<AgentDiscoveryResult[]> {\n\t\t// Clear internal registry\n\t\tthis.agents.clear();\n\n\t\t// Re-run discovery from all sources\n\t\tconst results = await this.initialize();\n\n\t\treturn results;\n\t}",
    "start_line": 308,
    "end_line": 316,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method refresh",
    "component_id": "src.features.hooks.agent-registry.refresh"
  },
  "src.features.hooks.agent-registry.onDidChangeRegistry": {
    "id": "src.features.hooks.agent-registry.onDidChangeRegistry",
    "name": "onDidChangeRegistry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "onDidChangeRegistry(callback: (event: RegistryChangeEvent) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\t// TODO: Implement in Phase 6 (T063)\n\t\t// 1. Add callback to internal listener list\n\t\t// 2. Return disposable that removes callback\n\t\tthis.changeListeners.push(callback);\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this.changeListeners.indexOf(callback);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tthis.changeListeners.splice(index, 1);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}",
    "start_line": 323,
    "end_line": 339,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "callback"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method onDidChangeRegistry",
    "component_id": "src.features.hooks.agent-registry.onDidChangeRegistry"
  },
  "src.features.hooks.agent-registry.onAgentsChanged": {
    "id": "src.features.hooks.agent-registry.onAgentsChanged",
    "name": "onAgentsChanged",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "onAgentsChanged(callback: (agents: AgentRegistryEntry[]) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\treturn this.onDidChangeRegistry(() => {\n\t\t\tconst agents = this.getAllAgents();\n\t\t\tcallback(agents);\n\t\t});\n\t}",
    "start_line": 347,
    "end_line": 354,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "callback"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method onAgentsChanged",
    "component_id": "src.features.hooks.agent-registry.onAgentsChanged"
  },
  "src.features.hooks.agent-registry.dispose": {
    "id": "src.features.hooks.agent-registry.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\t// Stop file watcher\n\t\tthis.fileWatcher.dispose();\n\n\t\t// Stop extension monitor\n\t\tthis.extensionMonitor.dispose();\n\n\t\t// Clear all listeners\n\t\tthis.changeListeners.length = 0;\n\n\t\t// Clear registry\n\t\tthis.agents.clear();\n\t}",
    "start_line": 360,
    "end_line": 372,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.agent-registry.dispose"
  },
  "src.features.hooks.agent-registry.discoverLocalAgents": {
    "id": "src.features.hooks.agent-registry.discoverLocalAgents",
    "name": "discoverLocalAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "private async discoverLocalAgents(): Promise<AgentDiscoveryResult> {\n\t\tconst agentsDir = `${this.workspaceRoot}/${AGENTS_DIR_RELATIVE_PATH}`;\n\t\treturn await this.fileDiscovery.discoverFromDirectory(agentsDir);\n\t}",
    "start_line": 382,
    "end_line": 385,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method discoverLocalAgents",
    "component_id": "src.features.hooks.agent-registry.discoverLocalAgents"
  },
  "src.features.hooks.agent-registry.discoverExtensionAgents": {
    "id": "src.features.hooks.agent-registry.discoverExtensionAgents",
    "name": "discoverExtensionAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "private async discoverExtensionAgents(): Promise<AgentDiscoveryResult> {\n\t\treturn await this.extensionDiscovery.discoverAgents();\n\t}",
    "start_line": 391,
    "end_line": 393,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method discoverExtensionAgents",
    "component_id": "src.features.hooks.agent-registry.discoverExtensionAgents"
  },
  "src.features.hooks.agent-registry.emitChange": {
    "id": "src.features.hooks.agent-registry.emitChange",
    "name": "emitChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "private emitChange(event: RegistryChangeEvent): void {\n\t\tfor (const listener of this.changeListeners) {\n\t\t\tlistener(event);\n\t\t}\n\t}",
    "start_line": 399,
    "end_line": 403,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method emitChange",
    "component_id": "src.features.hooks.agent-registry.emitChange"
  },
  "src.features.hooks.agent-registry.resolveDuplicateNames": {
    "id": "src.features.hooks.agent-registry.resolveDuplicateNames",
    "name": "resolveDuplicateNames",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/agent-registry.ts",
    "relative_path": "src/features/hooks/agent-registry.ts",
    "depends_on": [],
    "source_code": "private resolveDuplicateNames(\n\t\tagents: AgentRegistryEntry[]\n\t): AgentRegistryEntry[] {\n\t\t// Group agents by name to find duplicates\n\t\tconst nameGroups = new Map<string, AgentRegistryEntry[]>();\n\n\t\tfor (const agent of agents) {\n\t\t\tconst existing = nameGroups.get(agent.name);\n\t\t\tif (existing) {\n\t\t\t\texisting.push(agent);\n\t\t\t} else {\n\t\t\t\tnameGroups.set(agent.name, [agent]);\n\t\t\t}\n\t\t}\n\n\t\t// Process each group\n\t\tconst result: AgentRegistryEntry[] = [];\n\n\t\tfor (const [name, group] of nameGroups.entries()) {\n\t\t\tif (group.length === 1) {\n\t\t\t\t// No duplicates - keep original name\n\t\t\t\tresult.push(group[0]);\n\t\t\t} else {\n\t\t\t\t// Duplicates found - append source indicators\n\t\t\t\tfor (const agent of group) {\n\t\t\t\t\tconst suffix = agent.source === \"file\" ? \" (Local)\" : \" (Extension)\";\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\t...agent,\n\t\t\t\t\t\tdisplayName: agent.name + suffix,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}",
    "start_line": 410,
    "end_line": 445,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agents"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveDuplicateNames",
    "component_id": "src.features.hooks.agent-registry.resolveDuplicateNames"
  },
  "src.features.hooks.extension-agent-discovery.ChatParticipant": {
    "id": "src.features.hooks.extension-agent-discovery.ChatParticipant",
    "name": "ChatParticipant",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [
      "src.features.hooks.extension-agent-discovery.ChatParticipantCommand"
    ],
    "source_code": "interface ChatParticipant {\n\tid: string;\n\tname: string;\n\tdescription?: string;\n\tisSticky?: boolean;\n\tcommands?: ChatParticipantCommand[];\n}",
    "start_line": 37,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChatParticipant",
    "component_id": "src.features.hooks.extension-agent-discovery.ChatParticipant"
  },
  "src.features.hooks.extension-agent-discovery.ChatParticipantCommand": {
    "id": "src.features.hooks.extension-agent-discovery.ChatParticipantCommand",
    "name": "ChatParticipantCommand",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [],
    "source_code": "interface ChatParticipantCommand {\n\tname: string;\n\tdescription?: string;\n}",
    "start_line": 48,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChatParticipantCommand",
    "component_id": "src.features.hooks.extension-agent-discovery.ChatParticipantCommand"
  },
  "src.features.hooks.extension-agent-discovery.ExtensionAgentDiscovery": {
    "id": "src.features.hooks.extension-agent-discovery.ExtensionAgentDiscovery",
    "name": "ExtensionAgentDiscovery",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [
      "src.features.hooks.extension-agent-discovery.ChatParticipant",
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry",
      "src.features.hooks.extension-agent-discovery.convertParticipantToAgent",
      "src.features.hooks.extension-agent-discovery.extractChatParticipants"
    ],
    "source_code": "class ExtensionAgentDiscovery {\n\t/**\n\t/**\n\t * Discover all agents registered by VS Code extensions\n\t * @returns Discovery result with agents and errors\n\t */\n\tdiscoverAgents(): AgentDiscoveryResult {\n\t\tconst agents: AgentRegistryEntry[] = [];\n\t\tconst errors: Array<{ extensionId: string; error: Error }> = [];\n\n\t\ttry {\n\t\t\t// Scan all installed extensions\n\t\t\tconst allExtensions = vscode.extensions.all;\n\n\t\t\tfor (const extension of allExtensions) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check if extension has chatParticipants contribution\n\t\t\t\t\tconst participants = this.extractChatParticipants(extension);\n\n\t\t\t\t\tif (participants.length > 0) {\n\t\t\t\t\t\t// Convert each participant to AgentRegistryEntry\n\t\t\t\t\t\tfor (const participant of participants) {\n\t\t\t\t\t\t\tconst agent = this.convertParticipantToAgent(\n\t\t\t\t\t\t\t\textension,\n\t\t\t\t\t\t\t\tparticipant\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (agent) {\n\t\t\t\t\t\t\t\tagents.push(agent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Log error but continue processing other extensions\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\textensionId: extension.id,\n\t\t\t\t\t\terror: error as Error,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Log error but return whatever we discovered\n\t\t\terrors.push({\n\t\t\t\textensionId: \"unknown\",\n\t\t\t\terror: error as Error,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tsource: \"extension\",\n\t\t\tagents,\n\t\t\terrors: errors.map((e) => ({\n\t\t\t\textensionId: e.extensionId,\n\t\t\t\tcode: \"EXTENSION_ERROR\",\n\t\t\t\tmessage: e.error.message,\n\t\t\t})),\n\t\t\tdiscoveredAt: Date.now(),\n\t\t};\n\t}\n\n\t/**\n\t/**\n\t * Get agent metadata from a specific extension\n\t * @param extensionId VS Code extension identifier\n\t * @returns Agent registry entry or undefined\n\t */\n\tgetAgentFromExtension(extensionId: string): AgentRegistryEntry | undefined {\n\t\ttry {\n\t\t\tconst extension = vscode.extensions.getExtension(extensionId);\n\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst participants = this.extractChatParticipants(extension);\n\n\t\t\tif (participants.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return first participant\n\t\t\treturn this.convertParticipantToAgent(extension, participants[0]);\n\t\t} catch (error) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Check if an extension provides chat participants\n\t * @param extensionId VS Code extension identifier\n\t * @returns True if extension has chatParticipants contribution\n\t */\n\tisAgentExtension(extensionId: string): boolean {\n\t\ttry {\n\t\t\tconst extension = vscode.extensions.getExtension(extensionId);\n\n\t\t\tif (!extension) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst participants = this.extractChatParticipants(extension);\n\t\t\treturn participants.length > 0;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// ========================================================================\n\t// Internal Methods\n\t// ========================================================================\n\n\t/**\n\t * Extract chatParticipants from extension manifest\n\t * @param extension VS Code extension\n\t * @returns Array of chat participants\n\t */\n\tprivate extractChatParticipants(\n\t\textension: vscode.Extension<any>\n\t): ChatParticipant[] {\n\t\ttry {\n\t\t\t// Access package.json contributes.chatParticipants\n\t\t\tconst packageJSON = extension.packageJSON;\n\n\t\t\tif (!packageJSON || typeof packageJSON !== \"object\") {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst contributes = packageJSON.contributes;\n\n\t\t\tif (!contributes || typeof contributes !== \"object\") {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst chatParticipants = contributes.chatParticipants;\n\n\t\t\t// Validate chatParticipants is an array\n\t\t\tif (!Array.isArray(chatParticipants)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Filter out invalid participants\n\t\t\treturn chatParticipants.filter(\n\t\t\t\t(participant) =>\n\t\t\t\t\tparticipant &&\n\t\t\t\t\ttypeof participant === \"object\" &&\n\t\t\t\t\ttypeof participant.id === \"string\" &&\n\t\t\t\t\ttypeof participant.name === \"string\" &&\n\t\t\t\t\tparticipant.id.length > 0 &&\n\t\t\t\t\tparticipant.name.length > 0\n\t\t\t);\n\t\t} catch (error) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Convert chat participant to AgentRegistryEntry\n\t * @param extension VS Code extension\n\t * @param participant Chat participant from manifest\n\t * @returns AgentRegistryEntry or undefined if conversion fails\n\t */\n\tprivate convertParticipantToAgent(\n\t\textension: vscode.Extension<any>,\n\t\tparticipant: ChatParticipant\n\t): AgentRegistryEntry | undefined {\n\t\ttry {\n\t\t\t// Validate required fields\n\t\t\tif (!(participant.id && participant.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Generate agent ID: extension:{extensionId}:{participantId}\n\t\t\tconst agentId = `extension:${extension.id}:${participant.id}`;\n\n\t\t\t// Get description or use fallback\n\t\t\tconst description =\n\t\t\t\tparticipant.description ||\n\t\t\t\t`Chat participant from ${extension.packageJSON.displayName || extension.id}`;\n\n\t\t\t// Create agent registry entry\n\t\t\tconst agent: AgentRegistryEntry = {\n\t\t\t\tid: agentId,\n\t\t\t\tname: participant.name,\n\t\t\t\tdisplayName: participant.name,\n\t\t\t\tdescription,\n\t\t\t\ttype: \"background\", // All extension agents are background agents\n\t\t\t\tsource: \"extension\",\n\t\t\t\tavailable: true,\n\t\t\t\tdiscoveredAt: Date.now(),\n\t\t\t\textensionId: extension.id, // Store extension ID at top level\n\t\t\t};\n\n\t\t\treturn agent;\n\t\t} catch (error) {\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "start_line": 62,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ExtensionAgentDiscovery",
    "component_id": "src.features.hooks.extension-agent-discovery.ExtensionAgentDiscovery"
  },
  "src.features.hooks.extension-agent-discovery.discoverAgents": {
    "id": "src.features.hooks.extension-agent-discovery.discoverAgents",
    "name": "discoverAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [],
    "source_code": "discoverAgents(): AgentDiscoveryResult {\n\t\tconst agents: AgentRegistryEntry[] = [];\n\t\tconst errors: Array<{ extensionId: string; error: Error }> = [];\n\n\t\ttry {\n\t\t\t// Scan all installed extensions\n\t\t\tconst allExtensions = vscode.extensions.all;\n\n\t\t\tfor (const extension of allExtensions) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check if extension has chatParticipants contribution\n\t\t\t\t\tconst participants = this.extractChatParticipants(extension);\n\n\t\t\t\t\tif (participants.length > 0) {\n\t\t\t\t\t\t// Convert each participant to AgentRegistryEntry\n\t\t\t\t\t\tfor (const participant of participants) {\n\t\t\t\t\t\t\tconst agent = this.convertParticipantToAgent(\n\t\t\t\t\t\t\t\textension,\n\t\t\t\t\t\t\t\tparticipant\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (agent) {\n\t\t\t\t\t\t\t\tagents.push(agent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Log error but continue processing other extensions\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\textensionId: extension.id,\n\t\t\t\t\t\terror: error as Error,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Log error but return whatever we discovered\n\t\t\terrors.push({\n\t\t\t\textensionId: \"unknown\",\n\t\t\t\terror: error as Error,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tsource: \"extension\",\n\t\t\tagents,\n\t\t\terrors: errors.map((e) => ({\n\t\t\t\textensionId: e.extensionId,\n\t\t\t\tcode: \"EXTENSION_ERROR\",\n\t\t\t\tmessage: e.error.message,\n\t\t\t})),\n\t\t\tdiscoveredAt: Date.now(),\n\t\t};\n\t}",
    "start_line": 68,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method discoverAgents",
    "component_id": "src.features.hooks.extension-agent-discovery.discoverAgents"
  },
  "src.features.hooks.extension-agent-discovery.getAgentFromExtension": {
    "id": "src.features.hooks.extension-agent-discovery.getAgentFromExtension",
    "name": "getAgentFromExtension",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [],
    "source_code": "getAgentFromExtension(extensionId: string): AgentRegistryEntry | undefined {\n\t\ttry {\n\t\t\tconst extension = vscode.extensions.getExtension(extensionId);\n\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst participants = this.extractChatParticipants(extension);\n\n\t\t\tif (participants.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return first participant\n\t\t\treturn this.convertParticipantToAgent(extension, participants[0]);\n\t\t} catch (error) {\n\t\t\treturn;\n\t\t}\n\t}",
    "start_line": 127,
    "end_line": 146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extensionId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAgentFromExtension",
    "component_id": "src.features.hooks.extension-agent-discovery.getAgentFromExtension"
  },
  "src.features.hooks.extension-agent-discovery.isAgentExtension": {
    "id": "src.features.hooks.extension-agent-discovery.isAgentExtension",
    "name": "isAgentExtension",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [],
    "source_code": "isAgentExtension(extensionId: string): boolean {\n\t\ttry {\n\t\t\tconst extension = vscode.extensions.getExtension(extensionId);\n\n\t\t\tif (!extension) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst participants = this.extractChatParticipants(extension);\n\t\t\treturn participants.length > 0;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 153,
    "end_line": 166,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extensionId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isAgentExtension",
    "component_id": "src.features.hooks.extension-agent-discovery.isAgentExtension"
  },
  "src.features.hooks.extension-agent-discovery.extractChatParticipants": {
    "id": "src.features.hooks.extension-agent-discovery.extractChatParticipants",
    "name": "extractChatParticipants",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [],
    "source_code": "private extractChatParticipants(\n\t\textension: vscode.Extension<any>\n\t): ChatParticipant[] {\n\t\ttry {\n\t\t\t// Access package.json contributes.chatParticipants\n\t\t\tconst packageJSON = extension.packageJSON;\n\n\t\t\tif (!packageJSON || typeof packageJSON !== \"object\") {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst contributes = packageJSON.contributes;\n\n\t\t\tif (!contributes || typeof contributes !== \"object\") {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst chatParticipants = contributes.chatParticipants;\n\n\t\t\t// Validate chatParticipants is an array\n\t\t\tif (!Array.isArray(chatParticipants)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Filter out invalid participants\n\t\t\treturn chatParticipants.filter(\n\t\t\t\t(participant) =>\n\t\t\t\t\tparticipant &&\n\t\t\t\t\ttypeof participant === \"object\" &&\n\t\t\t\t\ttypeof participant.id === \"string\" &&\n\t\t\t\t\ttypeof participant.name === \"string\" &&\n\t\t\t\t\tparticipant.id.length > 0 &&\n\t\t\t\t\tparticipant.name.length > 0\n\t\t\t);\n\t\t} catch (error) {\n\t\t\treturn [];\n\t\t}\n\t}",
    "start_line": 177,
    "end_line": 214,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extension"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractChatParticipants",
    "component_id": "src.features.hooks.extension-agent-discovery.extractChatParticipants"
  },
  "src.features.hooks.extension-agent-discovery.convertParticipantToAgent": {
    "id": "src.features.hooks.extension-agent-discovery.convertParticipantToAgent",
    "name": "convertParticipantToAgent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-agent-discovery.ts",
    "relative_path": "src/features/hooks/extension-agent-discovery.ts",
    "depends_on": [],
    "source_code": "private convertParticipantToAgent(\n\t\textension: vscode.Extension<any>,\n\t\tparticipant: ChatParticipant\n\t): AgentRegistryEntry | undefined {\n\t\ttry {\n\t\t\t// Validate required fields\n\t\t\tif (!(participant.id && participant.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Generate agent ID: extension:{extensionId}:{participantId}\n\t\t\tconst agentId = `extension:${extension.id}:${participant.id}`;\n\n\t\t\t// Get description or use fallback\n\t\t\tconst description =\n\t\t\t\tparticipant.description ||\n\t\t\t\t`Chat participant from ${extension.packageJSON.displayName || extension.id}`;\n\n\t\t\t// Create agent registry entry\n\t\t\tconst agent: AgentRegistryEntry = {\n\t\t\t\tid: agentId,\n\t\t\t\tname: participant.name,\n\t\t\t\tdisplayName: participant.name,\n\t\t\t\tdescription,\n\t\t\t\ttype: \"background\", // All extension agents are background agents\n\t\t\t\tsource: \"extension\",\n\t\t\t\tavailable: true,\n\t\t\t\tdiscoveredAt: Date.now(),\n\t\t\t\textensionId: extension.id, // Store extension ID at top level\n\t\t\t};\n\n\t\t\treturn agent;\n\t\t} catch (error) {\n\t\t\treturn;\n\t\t}\n\t}",
    "start_line": 222,
    "end_line": 257,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extension",
      "participant"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method convertParticipantToAgent",
    "component_id": "src.features.hooks.extension-agent-discovery.convertParticipantToAgent"
  },
  "src.features.hooks.extension-monitor-service.ExtensionChangeEvent": {
    "id": "src.features.hooks.extension-monitor-service.ExtensionChangeEvent",
    "name": "ExtensionChangeEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [],
    "source_code": "interface ExtensionChangeEvent {\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 24,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExtensionChangeEvent",
    "component_id": "src.features.hooks.extension-monitor-service.ExtensionChangeEvent"
  },
  "src.features.hooks.extension-monitor-service.IExtensionMonitorService": {
    "id": "src.features.hooks.extension-monitor-service.IExtensionMonitorService",
    "name": "IExtensionMonitorService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [
      "src.features.hooks.extension-monitor-service.ExtensionChangeEvent"
    ],
    "source_code": "interface IExtensionMonitorService {\n\t/**\n\t * Start monitoring extension changes\n\t */\n\tstartMonitoring(): void;\n\n\t/**\n\t * Stop monitoring extension changes\n\t */\n\tstopMonitoring(): void;\n\n\t/**\n\t * Register callback for extension change events\n\t * @param callback Function to call when extensions change\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeExtensions(callback: (event: ExtensionChangeEvent) => void): {\n\t\tdispose: () => void;\n\t};\n}",
    "start_line": 35,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IExtensionMonitorService",
    "component_id": "src.features.hooks.extension-monitor-service.IExtensionMonitorService"
  },
  "src.features.hooks.extension-monitor-service.ExtensionMonitorService": {
    "id": "src.features.hooks.extension-monitor-service.ExtensionMonitorService",
    "name": "ExtensionMonitorService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [
      "src.features.hooks.extension-monitor-service.handleExtensionChange",
      "src.features.hooks.extension-monitor-service.stopMonitoring",
      "src.services.agent-service.dispose",
      "src.features.hooks.extension-monitor-service.ExtensionChangeEvent",
      "src.features.hooks.extension-monitor-service.IExtensionMonitorService",
      "src.features.hooks.extension-monitor-service.dispose"
    ],
    "source_code": "class ExtensionMonitorService implements IExtensionMonitorService {\n\t// Internal state\n\tprivate readonly changeListeners: Array<\n\t\t(event: ExtensionChangeEvent) => void\n\t> = [];\n\tprivate extensionWatcher: Disposable | undefined = undefined;\n\tprivate isMonitoring = false;\n\n\t// ============================================================================\n\t// Public API\n\t// ============================================================================\n\n\t/**\n\t * Start monitoring extension changes\n\t */\n\tstartMonitoring(): void {\n\t\t// Dispose existing watcher if present\n\t\tif (this.extensionWatcher) {\n\t\t\tthis.extensionWatcher.dispose();\n\t\t}\n\n\t\t// Mark as monitoring\n\t\tthis.isMonitoring = true;\n\n\t\t// Register extension change listener\n\t\ttry {\n\t\t\tthis.extensionWatcher = extensions.onDidChange(() => {\n\t\t\t\tthis.handleExtensionChange();\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// Graceful degradation if extensions API not available\n\t\t\tconsole.error(\"Failed to start extension monitoring:\", error);\n\t\t}\n\t}\n\n\t/**\n\t * Stop monitoring extension changes\n\t */\n\tstopMonitoring(): void {\n\t\t// Mark as not monitoring\n\t\tthis.isMonitoring = false;\n\n\t\t// Dispose watcher\n\t\tif (this.extensionWatcher) {\n\t\t\tthis.extensionWatcher.dispose();\n\t\t\tthis.extensionWatcher = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Register callback for extension change events\n\t *\n\t * @param callback Function to call when extensions change\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeExtensions(callback: (event: ExtensionChangeEvent) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\t// Add callback to listener list\n\t\tthis.changeListeners.push(callback);\n\n\t\t// Return disposable that removes callback\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this.changeListeners.indexOf(callback);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis.changeListeners.splice(index, 1);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\t// ============================================================================\n\t// Private Methods\n\t// ============================================================================\n\n\t/**\n\t * Handle extension change event\n\t */\n\tprivate handleExtensionChange(): void {\n\t\t// Ignore if not monitoring\n\t\tif (!this.isMonitoring) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create change event\n\t\tconst event: ExtensionChangeEvent = {\n\t\t\ttimestamp: Date.now(),\n\t\t};\n\n\t\t// Emit event to all listeners\n\t\tfor (const listener of this.changeListeners) {\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (error) {\n\t\t\t\t// Log error but don't interrupt other listeners\n\t\t\t\tconsole.error(\"Extension monitor listener error:\", error);\n\t\t\t}\n\t\t}\n\t}\n\n\t// ============================================================================\n\t// Disposal\n\t// ============================================================================\n\n\t/**\n\t * Dispose of all resources\n\t *\n\t * Called when extension is deactivated\n\t */\n\tdispose(): void {\n\t\tthis.stopMonitoring();\n\t\tthis.changeListeners.length = 0;\n\t}\n}",
    "start_line": 72,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ExtensionMonitorService",
    "component_id": "src.features.hooks.extension-monitor-service.ExtensionMonitorService"
  },
  "src.features.hooks.extension-monitor-service.startMonitoring": {
    "id": "src.features.hooks.extension-monitor-service.startMonitoring",
    "name": "startMonitoring",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [],
    "source_code": "startMonitoring(): void {\n\t\t// Dispose existing watcher if present\n\t\tif (this.extensionWatcher) {\n\t\t\tthis.extensionWatcher.dispose();\n\t\t}\n\n\t\t// Mark as monitoring\n\t\tthis.isMonitoring = true;\n\n\t\t// Register extension change listener\n\t\ttry {\n\t\t\tthis.extensionWatcher = extensions.onDidChange(() => {\n\t\t\t\tthis.handleExtensionChange();\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// Graceful degradation if extensions API not available\n\t\t\tconsole.error(\"Failed to start extension monitoring:\", error);\n\t\t}\n\t}",
    "start_line": 87,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method startMonitoring",
    "component_id": "src.features.hooks.extension-monitor-service.startMonitoring"
  },
  "src.features.hooks.extension-monitor-service.stopMonitoring": {
    "id": "src.features.hooks.extension-monitor-service.stopMonitoring",
    "name": "stopMonitoring",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [],
    "source_code": "stopMonitoring(): void {\n\t\t// Mark as not monitoring\n\t\tthis.isMonitoring = false;\n\n\t\t// Dispose watcher\n\t\tif (this.extensionWatcher) {\n\t\t\tthis.extensionWatcher.dispose();\n\t\t\tthis.extensionWatcher = undefined;\n\t\t}\n\t}",
    "start_line": 110,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method stopMonitoring",
    "component_id": "src.features.hooks.extension-monitor-service.stopMonitoring"
  },
  "src.features.hooks.extension-monitor-service.onDidChangeExtensions": {
    "id": "src.features.hooks.extension-monitor-service.onDidChangeExtensions",
    "name": "onDidChangeExtensions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [],
    "source_code": "onDidChangeExtensions(callback: (event: ExtensionChangeEvent) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\t// Add callback to listener list\n\t\tthis.changeListeners.push(callback);\n\n\t\t// Return disposable that removes callback\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this.changeListeners.indexOf(callback);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis.changeListeners.splice(index, 1);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}",
    "start_line": 127,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "callback"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method onDidChangeExtensions",
    "component_id": "src.features.hooks.extension-monitor-service.onDidChangeExtensions"
  },
  "src.features.hooks.extension-monitor-service.handleExtensionChange": {
    "id": "src.features.hooks.extension-monitor-service.handleExtensionChange",
    "name": "handleExtensionChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [],
    "source_code": "private handleExtensionChange(): void {\n\t\t// Ignore if not monitoring\n\t\tif (!this.isMonitoring) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create change event\n\t\tconst event: ExtensionChangeEvent = {\n\t\t\ttimestamp: Date.now(),\n\t\t};\n\n\t\t// Emit event to all listeners\n\t\tfor (const listener of this.changeListeners) {\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (error) {\n\t\t\t\t// Log error but don't interrupt other listeners\n\t\t\t\tconsole.error(\"Extension monitor listener error:\", error);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 151,
    "end_line": 171,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleExtensionChange",
    "component_id": "src.features.hooks.extension-monitor-service.handleExtensionChange"
  },
  "src.features.hooks.extension-monitor-service.dispose": {
    "id": "src.features.hooks.extension-monitor-service.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/extension-monitor-service.ts",
    "relative_path": "src/features/hooks/extension-monitor-service.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.stopMonitoring();\n\t\tthis.changeListeners.length = 0;\n\t}",
    "start_line": 182,
    "end_line": 185,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.extension-monitor-service.dispose"
  },
  "src.features.hooks.file-agent-discovery.FileAgentDiscovery": {
    "id": "src.features.hooks.file-agent-discovery.FileAgentDiscovery",
    "name": "FileAgentDiscovery",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-agent-discovery.ts",
    "relative_path": "src/features/hooks/file-agent-discovery.ts",
    "depends_on": [
      "src.features.hooks.file-agent-discovery.validateAndExtractSchema",
      "src.features.hooks.agent-registry-types.AgentDiscoveryError",
      "src.features.hooks.agent-registry-types.AgentDiscoveryResult",
      "src.features.hooks.agent-registry-types.AgentRegistryEntry",
      "src.features.hooks.file-agent-discovery.SchemaValidationError",
      "src.features.hooks.agent-registry-types.AgentConfigSchema",
      "src.features.hooks.file-agent-discovery.extractResources",
      "src.features.hooks.file-agent-discovery.parseAgentFile"
    ],
    "source_code": "class FileAgentDiscovery {\n\t/**\n\t * Discover all agents from a directory\n\t *\n\t * @param agentsDir Absolute path to .github/agents/ directory\n\t * @returns Discovery result with agents and errors\n\t */\n\tasync discoverFromDirectory(\n\t\tagentsDir: string\n\t): Promise<AgentDiscoveryResult> {\n\t\tconst agents: AgentRegistryEntry[] = [];\n\t\tconst errors: AgentDiscoveryError[] = [];\n\t\tconst discoveredAt = Date.now();\n\n\t\ttry {\n\t\t\t// Check if directory exists\n\t\t\tconst dirStats = await fs.stat(agentsDir).catch(() => null);\n\t\t\tif (!dirStats?.isDirectory()) {\n\t\t\t\t// Directory doesn't exist or isn't a directory - return empty result\n\t\t\t\treturn {\n\t\t\t\t\tsource: \"file\",\n\t\t\t\t\tagents: [],\n\t\t\t\t\terrors: [],\n\t\t\t\t\tdiscoveredAt,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Read all files in directory\n\t\t\tconst files = await fs.readdir(agentsDir);\n\n\t\t\t// Filter for .agent.md files only\n\t\t\tconst agentFiles = files.filter(\n\t\t\t\t(file) => file.endsWith(\".agent.md\") && !file.startsWith(\".\")\n\t\t\t);\n\n\t\t\t// Process each agent file\n\t\t\tfor (const filename of agentFiles) {\n\t\t\t\tconst filePath = join(agentsDir, filename);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst agent = await this.parseAgentFile(filePath, discoveredAt);\n\t\t\t\t\tagents.push(agent);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Record error and continue with other files\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\tcode:\n\t\t\t\t\t\t\terror instanceof SchemaValidationError\n\t\t\t\t\t\t\t\t? \"INVALID_SCHEMA\"\n\t\t\t\t\t\t\t\t: \"PARSE_ERROR\",\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t\t\t: \"Unknown error parsing file\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Directory read failed - record error\n\t\t\terrors.push({\n\t\t\t\tcode: \"FILE_NOT_FOUND\",\n\t\t\t\tmessage:\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? `Failed to read directory: ${error.message}`\n\t\t\t\t\t\t: \"Failed to read directory\",\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tsource: \"file\",\n\t\t\tagents,\n\t\t\terrors,\n\t\t\tdiscoveredAt,\n\t\t};\n\t}\n\n\t/**\n\t * Parse a single .agent.md file\n\t *\n\t * @param filePath Absolute path to agent file\n\t * @param discoveredAt Timestamp for discovery\n\t * @returns Parsed agent registry entry\n\t * @throws Error if file cannot be parsed or validated\n\t */\n\tprivate async parseAgentFile(\n\t\tfilePath: string,\n\t\tdiscoveredAt: number\n\t): Promise<AgentRegistryEntry> {\n\t\t// Read file content\n\t\tconst content = await fs.readFile(filePath, \"utf-8\");\n\n\t\t// Parse YAML frontmatter\n\t\tconst parsed = matter(content);\n\n\t\tif (!parsed.data || Object.keys(parsed.data).length === 0) {\n\t\t\tthrow new SchemaValidationError(\"No YAML frontmatter found in file\");\n\t\t}\n\n\t\t// Extract filename without extension as fallback ID\n\t\tconst filename = filePath.split(\"/\").pop()?.replace(\".agent.md\", \"\") || \"\";\n\n\t\t// Validate required fields (uses filename as fallback for id)\n\t\tconst schema = this.validateAndExtractSchema(parsed.data, filename);\n\n\t\t// Generate agent ID: \"local:{agent-id}\"\n\t\tconst agentId = `${AGENT_ID_PREFIX.FILE}:${schema.id}`;\n\n\t\t// Create agent registry entry\n\t\tconst agent: AgentRegistryEntry = {\n\t\t\t// Identity\n\t\t\tid: agentId,\n\t\t\tname: schema.name,\n\t\t\tdisplayName: schema.name, // Will be updated by AgentRegistry if duplicates exist\n\t\t\tdescription: schema.description,\n\n\t\t\t// Classification\n\t\t\ttype: \"local\", // All file-based agents are local\n\t\t\tsource: \"file\",\n\n\t\t\t// Source-specific data\n\t\t\tsourcePath: filePath,\n\n\t\t\t// Agent configuration schema\n\t\t\tschema,\n\n\t\t\t// Metadata\n\t\t\tdiscoveredAt,\n\t\t\tavailable: true, // Assume available since file exists\n\t\t};\n\n\t\treturn agent;\n\t}\n\n\t/**\n\t * Validate agent schema from YAML frontmatter\n\t *\n\t * @param data Parsed YAML data\n\t * @param fallbackId Filename to use as fallback ID if not in frontmatter\n\t * @returns Validated agent config schema\n\t * @throws SchemaValidationError if validation fails\n\t */\n\tprivate validateAndExtractSchema(\n\t\tdata: Record<string, unknown>,\n\t\tfallbackId: string\n\t): AgentConfigSchema {\n\t\t// Extract ID from frontmatter or use filename as fallback\n\t\tconst id = typeof data.id === \"string\" && data.id ? data.id : fallbackId;\n\n\t\tif (!id) {\n\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\"Missing 'id' field and no valid filename fallback\"\n\t\t\t);\n\t\t}\n\n\t\t// Extract name from frontmatter or use ID as fallback\n\t\tconst name = typeof data.name === \"string\" && data.name ? data.name : id;\n\n\t\tif (typeof data.description !== \"string\" || !data.description) {\n\t\t\tthrow new SchemaValidationError(\"Missing or invalid 'description' field\");\n\t\t}\n\n\t\t// Validate ID format (lowercase-with-hyphens)\n\t\tif (!AGENT_ID_FORMAT_REGEX.test(id)) {\n\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\"Invalid 'id' format. Must be lowercase-with-hyphens (e.g., 'code-reviewer')\"\n\t\t\t);\n\t\t}\n\n\t\t// Extract schema with optional fields\n\t\tconst schema: AgentConfigSchema = {\n\t\t\tid,\n\t\t\tname,\n\t\t\tfullName: typeof data.fullName === \"string\" ? data.fullName : name,\n\t\t\tdescription: data.description,\n\t\t\ticon: typeof data.icon === \"string\" ? data.icon : undefined,\n\t\t\tcommands: Array.isArray(data.commands) ? data.commands : [],\n\t\t\tresources: this.extractResources(data.resources),\n\t\t\tcontent: \"\", // Will be populated if needed\n\t\t};\n\n\t\treturn schema;\n\t}\n\n\t/**\n\t * Extract and validate resources from YAML data\n\t *\n\t * @param resources Raw resources data from YAML\n\t * @returns Validated AgentResources object\n\t */\n\tprivate extractResources(resources: unknown): AgentConfigSchema[\"resources\"] {\n\t\tif (typeof resources !== \"object\" || resources === null) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst res = resources as Record<string, unknown>;\n\t\tconst extracted: AgentConfigSchema[\"resources\"] = {};\n\n\t\t// Extract optional fields if they're arrays of strings\n\t\tif (Array.isArray(res.prompts)) {\n\t\t\textracted.prompts = res.prompts.filter(\n\t\t\t\t(p): p is string => typeof p === \"string\"\n\t\t\t);\n\t\t}\n\n\t\tif (Array.isArray(res.skills)) {\n\t\t\textracted.skills = res.skills.filter(\n\t\t\t\t(s): s is string => typeof s === \"string\"\n\t\t\t);\n\t\t}\n\n\t\tif (Array.isArray(res.instructions)) {\n\t\t\textracted.instructions = res.instructions.filter(\n\t\t\t\t(i): i is string => typeof i === \"string\"\n\t\t\t);\n\t\t}\n\n\t\treturn extracted;\n\t}\n}",
    "start_line": 44,
    "end_line": 262,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class FileAgentDiscovery",
    "component_id": "src.features.hooks.file-agent-discovery.FileAgentDiscovery"
  },
  "src.features.hooks.file-agent-discovery.discoverFromDirectory": {
    "id": "src.features.hooks.file-agent-discovery.discoverFromDirectory",
    "name": "discoverFromDirectory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-agent-discovery.ts",
    "relative_path": "src/features/hooks/file-agent-discovery.ts",
    "depends_on": [],
    "source_code": "async discoverFromDirectory(\n\t\tagentsDir: string\n\t): Promise<AgentDiscoveryResult> {\n\t\tconst agents: AgentRegistryEntry[] = [];\n\t\tconst errors: AgentDiscoveryError[] = [];\n\t\tconst discoveredAt = Date.now();\n\n\t\ttry {\n\t\t\t// Check if directory exists\n\t\t\tconst dirStats = await fs.stat(agentsDir).catch(() => null);\n\t\t\tif (!dirStats?.isDirectory()) {\n\t\t\t\t// Directory doesn't exist or isn't a directory - return empty result\n\t\t\t\treturn {\n\t\t\t\t\tsource: \"file\",\n\t\t\t\t\tagents: [],\n\t\t\t\t\terrors: [],\n\t\t\t\t\tdiscoveredAt,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Read all files in directory\n\t\t\tconst files = await fs.readdir(agentsDir);\n\n\t\t\t// Filter for .agent.md files only\n\t\t\tconst agentFiles = files.filter(\n\t\t\t\t(file) => file.endsWith(\".agent.md\") && !file.startsWith(\".\")\n\t\t\t);\n\n\t\t\t// Process each agent file\n\t\t\tfor (const filename of agentFiles) {\n\t\t\t\tconst filePath = join(agentsDir, filename);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst agent = await this.parseAgentFile(filePath, discoveredAt);\n\t\t\t\t\tagents.push(agent);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Record error and continue with other files\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\tcode:\n\t\t\t\t\t\t\terror instanceof SchemaValidationError\n\t\t\t\t\t\t\t\t? \"INVALID_SCHEMA\"\n\t\t\t\t\t\t\t\t: \"PARSE_ERROR\",\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t\t\t: \"Unknown error parsing file\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Directory read failed - record error\n\t\t\terrors.push({\n\t\t\t\tcode: \"FILE_NOT_FOUND\",\n\t\t\t\tmessage:\n\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t? `Failed to read directory: ${error.message}`\n\t\t\t\t\t\t: \"Failed to read directory\",\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tsource: \"file\",\n\t\t\tagents,\n\t\t\terrors,\n\t\t\tdiscoveredAt,\n\t\t};\n\t}",
    "start_line": 51,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentsDir"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method discoverFromDirectory",
    "component_id": "src.features.hooks.file-agent-discovery.discoverFromDirectory"
  },
  "src.features.hooks.file-agent-discovery.parseAgentFile": {
    "id": "src.features.hooks.file-agent-discovery.parseAgentFile",
    "name": "parseAgentFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-agent-discovery.ts",
    "relative_path": "src/features/hooks/file-agent-discovery.ts",
    "depends_on": [],
    "source_code": "private async parseAgentFile(\n\t\tfilePath: string,\n\t\tdiscoveredAt: number\n\t): Promise<AgentRegistryEntry> {\n\t\t// Read file content\n\t\tconst content = await fs.readFile(filePath, \"utf-8\");\n\n\t\t// Parse YAML frontmatter\n\t\tconst parsed = matter(content);\n\n\t\tif (!parsed.data || Object.keys(parsed.data).length === 0) {\n\t\t\tthrow new SchemaValidationError(\"No YAML frontmatter found in file\");\n\t\t}\n\n\t\t// Extract filename without extension as fallback ID\n\t\tconst filename = filePath.split(\"/\").pop()?.replace(\".agent.md\", \"\") || \"\";\n\n\t\t// Validate required fields (uses filename as fallback for id)\n\t\tconst schema = this.validateAndExtractSchema(parsed.data, filename);\n\n\t\t// Generate agent ID: \"local:{agent-id}\"\n\t\tconst agentId = `${AGENT_ID_PREFIX.FILE}:${schema.id}`;\n\n\t\t// Create agent registry entry\n\t\tconst agent: AgentRegistryEntry = {\n\t\t\t// Identity\n\t\t\tid: agentId,\n\t\t\tname: schema.name,\n\t\t\tdisplayName: schema.name, // Will be updated by AgentRegistry if duplicates exist\n\t\t\tdescription: schema.description,\n\n\t\t\t// Classification\n\t\t\ttype: \"local\", // All file-based agents are local\n\t\t\tsource: \"file\",\n\n\t\t\t// Source-specific data\n\t\t\tsourcePath: filePath,\n\n\t\t\t// Agent configuration schema\n\t\t\tschema,\n\n\t\t\t// Metadata\n\t\t\tdiscoveredAt,\n\t\t\tavailable: true, // Assume available since file exists\n\t\t};\n\n\t\treturn agent;\n\t}",
    "start_line": 128,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath",
      "discoveredAt"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method parseAgentFile",
    "component_id": "src.features.hooks.file-agent-discovery.parseAgentFile"
  },
  "src.features.hooks.file-agent-discovery.validateAndExtractSchema": {
    "id": "src.features.hooks.file-agent-discovery.validateAndExtractSchema",
    "name": "validateAndExtractSchema",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-agent-discovery.ts",
    "relative_path": "src/features/hooks/file-agent-discovery.ts",
    "depends_on": [],
    "source_code": "private validateAndExtractSchema(\n\t\tdata: Record<string, unknown>,\n\t\tfallbackId: string\n\t): AgentConfigSchema {\n\t\t// Extract ID from frontmatter or use filename as fallback\n\t\tconst id = typeof data.id === \"string\" && data.id ? data.id : fallbackId;\n\n\t\tif (!id) {\n\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\"Missing 'id' field and no valid filename fallback\"\n\t\t\t);\n\t\t}\n\n\t\t// Extract name from frontmatter or use ID as fallback\n\t\tconst name = typeof data.name === \"string\" && data.name ? data.name : id;\n\n\t\tif (typeof data.description !== \"string\" || !data.description) {\n\t\t\tthrow new SchemaValidationError(\"Missing or invalid 'description' field\");\n\t\t}\n\n\t\t// Validate ID format (lowercase-with-hyphens)\n\t\tif (!AGENT_ID_FORMAT_REGEX.test(id)) {\n\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\"Invalid 'id' format. Must be lowercase-with-hyphens (e.g., 'code-reviewer')\"\n\t\t\t);\n\t\t}\n\n\t\t// Extract schema with optional fields\n\t\tconst schema: AgentConfigSchema = {\n\t\t\tid,\n\t\t\tname,\n\t\t\tfullName: typeof data.fullName === \"string\" ? data.fullName : name,\n\t\t\tdescription: data.description,\n\t\t\ticon: typeof data.icon === \"string\" ? data.icon : undefined,\n\t\t\tcommands: Array.isArray(data.commands) ? data.commands : [],\n\t\t\tresources: this.extractResources(data.resources),\n\t\t\tcontent: \"\", // Will be populated if needed\n\t\t};\n\n\t\treturn schema;\n\t}",
    "start_line": 185,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data",
      "fallbackId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateAndExtractSchema",
    "component_id": "src.features.hooks.file-agent-discovery.validateAndExtractSchema"
  },
  "src.features.hooks.file-agent-discovery.extractResources": {
    "id": "src.features.hooks.file-agent-discovery.extractResources",
    "name": "extractResources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-agent-discovery.ts",
    "relative_path": "src/features/hooks/file-agent-discovery.ts",
    "depends_on": [],
    "source_code": "private extractResources(resources: unknown): AgentConfigSchema[\"resources\"] {\n\t\tif (typeof resources !== \"object\" || resources === null) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst res = resources as Record<string, unknown>;\n\t\tconst extracted: AgentConfigSchema[\"resources\"] = {};\n\n\t\t// Extract optional fields if they're arrays of strings\n\t\tif (Array.isArray(res.prompts)) {\n\t\t\textracted.prompts = res.prompts.filter(\n\t\t\t\t(p): p is string => typeof p === \"string\"\n\t\t\t);\n\t\t}\n\n\t\tif (Array.isArray(res.skills)) {\n\t\t\textracted.skills = res.skills.filter(\n\t\t\t\t(s): s is string => typeof s === \"string\"\n\t\t\t);\n\t\t}\n\n\t\tif (Array.isArray(res.instructions)) {\n\t\t\textracted.instructions = res.instructions.filter(\n\t\t\t\t(i): i is string => typeof i === \"string\"\n\t\t\t);\n\t\t}\n\n\t\treturn extracted;\n\t}",
    "start_line": 233,
    "end_line": 261,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "resources"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractResources",
    "component_id": "src.features.hooks.file-agent-discovery.extractResources"
  },
  "src.features.hooks.file-agent-discovery.SchemaValidationError": {
    "id": "src.features.hooks.file-agent-discovery.SchemaValidationError",
    "name": "SchemaValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-agent-discovery.ts",
    "relative_path": "src/features/hooks/file-agent-discovery.ts",
    "depends_on": [],
    "source_code": "class SchemaValidationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"SchemaValidationError\";\n\t}\n}",
    "start_line": 267,
    "end_line": 272,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SchemaValidationError",
    "component_id": "src.features.hooks.file-agent-discovery.SchemaValidationError"
  },
  "src.features.hooks.file-watcher-service.FileChangeEvent": {
    "id": "src.features.hooks.file-watcher-service.FileChangeEvent",
    "name": "FileChangeEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "interface FileChangeEvent {\n\ttype: \"created\" | \"modified\" | \"deleted\";\n\tfilePath: string; // Absolute path\n\taffectedAgentIds: string[]; // Agent IDs that need refresh\n\ttimestamp: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 32,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FileChangeEvent",
    "component_id": "src.features.hooks.file-watcher-service.FileChangeEvent"
  },
  "src.features.hooks.file-watcher-service.IFileWatcherService": {
    "id": "src.features.hooks.file-watcher-service.IFileWatcherService",
    "name": "IFileWatcherService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [
      "src.features.hooks.file-watcher-service.FileChangeEvent"
    ],
    "source_code": "interface IFileWatcherService {\n\t/**\n\t * Start watching the agents directory\n\t * @param agentsDir Absolute path to agents directory\n\t */\n\tstartWatching(agentsDir: string): void;\n\n\t/**\n\t * Stop watching the agents directory\n\t */\n\tstopWatching(): void;\n\n\t/**\n\t * Register callback for file change events\n\t * @param callback Function to call when files change\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeFiles(callback: (event: FileChangeEvent) => void): {\n\t\tdispose: () => void;\n\t};\n}",
    "start_line": 46,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IFileWatcherService",
    "component_id": "src.features.hooks.file-watcher-service.IFileWatcherService"
  },
  "src.features.hooks.file-watcher-service.FileWatcherService": {
    "id": "src.features.hooks.file-watcher-service.FileWatcherService",
    "name": "FileWatcherService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "src.features.hooks.services.command-completion-detector.handleFileChange",
      "src.features.hooks.file-watcher-service.dispose",
      "src.features.hooks.file-watcher-service.FileChangeEvent",
      "src.features.hooks.file-watcher-service.IFileWatcherService",
      "src.features.hooks.file-watcher-service.stopWatching",
      "src.services.agent-service.dispose",
      "src.features.hooks.file-watcher-service.handleFileChange",
      "src.features.hooks.file-watcher-service.flushPendingChanges",
      "src.features.hooks.file-watcher-service.extractAgentIdFromPath"
    ],
    "source_code": "class FileWatcherService implements IFileWatcherService {\n\t// Internal state\n\tprivate readonly changeListeners: Array<(event: FileChangeEvent) => void> =\n\t\t[];\n\tprivate watcher: FileSystemWatcher | undefined = undefined;\n\tprivate debounceTimer: NodeJS.Timeout | undefined = undefined;\n\tprivate readonly pendingChanges: Map<string, FileChangeEvent> = new Map();\n\tprivate isWatching = false;\n\n\t// ============================================================================\n\t// Public API\n\t// ============================================================================\n\n\t/**\n\t * Start watching the agents directory\n\t *\n\t * @param agentsDir Absolute path to agents directory\n\t */\n\tstartWatching(agentsDir: string): void {\n\t\t// Dispose existing watcher if present\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.dispose();\n\t\t}\n\n\t\t// Mark as watching\n\t\tthis.isWatching = true;\n\n\t\t// Create RelativePattern for *.agent.md files in the agents directory\n\t\tconst pattern = new RelativePattern(agentsDir, \"**/*.agent.md\");\n\n\t\t// Create file system watcher\n\t\tthis.watcher = workspace.createFileSystemWatcher(pattern);\n\n\t\t// Register event handlers\n\t\tthis.watcher.onDidCreate((uri: Uri) =>\n\t\t\tthis.handleFileChange(\"created\", uri.fsPath)\n\t\t);\n\t\tthis.watcher.onDidChange((uri: Uri) =>\n\t\t\tthis.handleFileChange(\"modified\", uri.fsPath)\n\t\t);\n\t\tthis.watcher.onDidDelete((uri: Uri) =>\n\t\t\tthis.handleFileChange(\"deleted\", uri.fsPath)\n\t\t);\n\t}\n\n\t/**\n\t * Stop watching the agents directory\n\t */\n\tstopWatching(): void {\n\t\t// Mark as not watching\n\t\tthis.isWatching = false;\n\n\t\t// Dispose watcher\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.dispose();\n\t\t\tthis.watcher = undefined;\n\t\t}\n\n\t\t// Clear debounce timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t\tthis.debounceTimer = undefined;\n\t\t}\n\n\t\t// Clear pending changes\n\t\tthis.pendingChanges.clear();\n\t}\n\n\t/**\n\t * Register callback for file change events\n\t *\n\t * @param callback Function to call when files change\n\t * @returns Disposable to unregister callback\n\t */\n\tonDidChangeFiles(callback: (event: FileChangeEvent) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\t// Add callback to listener list\n\t\tthis.changeListeners.push(callback);\n\n\t\t// Return disposable that removes callback\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this.changeListeners.indexOf(callback);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis.changeListeners.splice(index, 1);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\t// ============================================================================\n\t// Private Methods (Stubs for Future Implementation)\n\t// ============================================================================\n\n\t/**\n\t * Handle file system change event with debouncing\n\t *\n\t * @param type Change type (created/modified/deleted)\n\t * @param filePath Absolute path to changed file\n\t */\n\tprivate handleFileChange(\n\t\ttype: \"created\" | \"modified\" | \"deleted\",\n\t\tfilePath: string\n\t): void {\n\t\t// Ignore if not watching\n\t\tif (!this.isWatching) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract agent ID from file path\n\t\tconst agentId = this.extractAgentIdFromPath(filePath);\n\n\t\t// Add change event to pending changes (overwrites existing for same file)\n\t\tthis.pendingChanges.set(filePath, {\n\t\t\ttype,\n\t\t\tfilePath,\n\t\t\taffectedAgentIds: [agentId],\n\t\t\ttimestamp: Date.now(),\n\t\t});\n\n\t\t// Clear existing debounce timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t}\n\n\t\t// Set new debounce timer\n\t\tthis.debounceTimer = setTimeout(() => {\n\t\t\tthis.flushPendingChanges();\n\t\t}, FILE_WATCH_DEBOUNCE_MS);\n\t}\n\n\t/**\n\t * Flush pending changes and emit events to listeners\n\t */\n\tprivate flushPendingChanges(): void {\n\t\t// Get all pending changes\n\t\tconst changes = Array.from(this.pendingChanges.values());\n\n\t\t// Clear pending changes map\n\t\tthis.pendingChanges.clear();\n\n\t\t// Clear debounce timer\n\t\tthis.debounceTimer = undefined;\n\n\t\t// Emit each change to all listeners\n\t\tfor (const change of changes) {\n\t\t\tfor (const listener of this.changeListeners) {\n\t\t\t\ttry {\n\t\t\t\t\tlistener(change);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Log error but don't interrupt other listeners\n\t\t\t\t\tconsole.error(\"File watcher listener error:\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Extract agent ID from file path\n\t *\n\t * @param filePath Absolute path to agent file\n\t * @returns Agent ID (format: \"local:agent-name\")\n\t */\n\tprivate extractAgentIdFromPath(filePath: string): string {\n\t\t// Extract filename from path\n\t\tconst filename =\n\t\t\tfilePath.split(\"/\").pop() || filePath.split(\"\\\\\").pop() || \"\";\n\n\t\t// Remove .agent.md extension\n\t\tconst agentName = filename.replace(AGENT_FILE_EXTENSION_PATTERN, \"\");\n\n\t\t// Return agent ID in format \"local:{name}\"\n\t\treturn `local:${agentName}`;\n\t}\n\n\t// ============================================================================\n\t// Disposal\n\t// ============================================================================\n\n\t/**\n\t * Dispose of all resources\n\t *\n\t * Called when extension is deactivated\n\t */\n\tdispose(): void {\n\t\tthis.stopWatching();\n\t\tthis.changeListeners.length = 0;\n\t}\n}",
    "start_line": 85,
    "end_line": 274,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class FileWatcherService",
    "component_id": "src.features.hooks.file-watcher-service.FileWatcherService"
  },
  "src.features.hooks.file-watcher-service.startWatching": {
    "id": "src.features.hooks.file-watcher-service.startWatching",
    "name": "startWatching",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "startWatching(agentsDir: string): void {\n\t\t// Dispose existing watcher if present\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.dispose();\n\t\t}\n\n\t\t// Mark as watching\n\t\tthis.isWatching = true;\n\n\t\t// Create RelativePattern for *.agent.md files in the agents directory\n\t\tconst pattern = new RelativePattern(agentsDir, \"**/*.agent.md\");\n\n\t\t// Create file system watcher\n\t\tthis.watcher = workspace.createFileSystemWatcher(pattern);\n\n\t\t// Register event handlers\n\t\tthis.watcher.onDidCreate((uri: Uri) =>\n\t\t\tthis.handleFileChange(\"created\", uri.fsPath)\n\t\t);\n\t\tthis.watcher.onDidChange((uri: Uri) =>\n\t\t\tthis.handleFileChange(\"modified\", uri.fsPath)\n\t\t);\n\t\tthis.watcher.onDidDelete((uri: Uri) =>\n\t\t\tthis.handleFileChange(\"deleted\", uri.fsPath)\n\t\t);\n\t}",
    "start_line": 103,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentsDir"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method startWatching",
    "component_id": "src.features.hooks.file-watcher-service.startWatching"
  },
  "src.features.hooks.file-watcher-service.stopWatching": {
    "id": "src.features.hooks.file-watcher-service.stopWatching",
    "name": "stopWatching",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "stopWatching(): void {\n\t\t// Mark as not watching\n\t\tthis.isWatching = false;\n\n\t\t// Dispose watcher\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.dispose();\n\t\t\tthis.watcher = undefined;\n\t\t}\n\n\t\t// Clear debounce timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t\tthis.debounceTimer = undefined;\n\t\t}\n\n\t\t// Clear pending changes\n\t\tthis.pendingChanges.clear();\n\t}",
    "start_line": 133,
    "end_line": 151,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method stopWatching",
    "component_id": "src.features.hooks.file-watcher-service.stopWatching"
  },
  "src.features.hooks.file-watcher-service.onDidChangeFiles": {
    "id": "src.features.hooks.file-watcher-service.onDidChangeFiles",
    "name": "onDidChangeFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "onDidChangeFiles(callback: (event: FileChangeEvent) => void): {\n\t\tdispose: () => void;\n\t} {\n\t\t// Add callback to listener list\n\t\tthis.changeListeners.push(callback);\n\n\t\t// Return disposable that removes callback\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tconst index = this.changeListeners.indexOf(callback);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tthis.changeListeners.splice(index, 1);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}",
    "start_line": 159,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "callback"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method onDidChangeFiles",
    "component_id": "src.features.hooks.file-watcher-service.onDidChangeFiles"
  },
  "src.features.hooks.file-watcher-service.handleFileChange": {
    "id": "src.features.hooks.file-watcher-service.handleFileChange",
    "name": "handleFileChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "private handleFileChange(\n\t\ttype: \"created\" | \"modified\" | \"deleted\",\n\t\tfilePath: string\n\t): void {\n\t\t// Ignore if not watching\n\t\tif (!this.isWatching) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract agent ID from file path\n\t\tconst agentId = this.extractAgentIdFromPath(filePath);\n\n\t\t// Add change event to pending changes (overwrites existing for same file)\n\t\tthis.pendingChanges.set(filePath, {\n\t\t\ttype,\n\t\t\tfilePath,\n\t\t\taffectedAgentIds: [agentId],\n\t\t\ttimestamp: Date.now(),\n\t\t});\n\n\t\t// Clear existing debounce timer\n\t\tif (this.debounceTimer) {\n\t\t\tclearTimeout(this.debounceTimer);\n\t\t}\n\n\t\t// Set new debounce timer\n\t\tthis.debounceTimer = setTimeout(() => {\n\t\t\tthis.flushPendingChanges();\n\t\t}, FILE_WATCH_DEBOUNCE_MS);\n\t}",
    "start_line": 186,
    "end_line": 215,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type",
      "filePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleFileChange",
    "component_id": "src.features.hooks.file-watcher-service.handleFileChange"
  },
  "src.features.hooks.file-watcher-service.flushPendingChanges": {
    "id": "src.features.hooks.file-watcher-service.flushPendingChanges",
    "name": "flushPendingChanges",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "private flushPendingChanges(): void {\n\t\t// Get all pending changes\n\t\tconst changes = Array.from(this.pendingChanges.values());\n\n\t\t// Clear pending changes map\n\t\tthis.pendingChanges.clear();\n\n\t\t// Clear debounce timer\n\t\tthis.debounceTimer = undefined;\n\n\t\t// Emit each change to all listeners\n\t\tfor (const change of changes) {\n\t\t\tfor (const listener of this.changeListeners) {\n\t\t\t\ttry {\n\t\t\t\t\tlistener(change);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Log error but don't interrupt other listeners\n\t\t\t\t\tconsole.error(\"File watcher listener error:\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 220,
    "end_line": 241,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flushPendingChanges",
    "component_id": "src.features.hooks.file-watcher-service.flushPendingChanges"
  },
  "src.features.hooks.file-watcher-service.extractAgentIdFromPath": {
    "id": "src.features.hooks.file-watcher-service.extractAgentIdFromPath",
    "name": "extractAgentIdFromPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "private extractAgentIdFromPath(filePath: string): string {\n\t\t// Extract filename from path\n\t\tconst filename =\n\t\t\tfilePath.split(\"/\").pop() || filePath.split(\"\\\\\").pop() || \"\";\n\n\t\t// Remove .agent.md extension\n\t\tconst agentName = filename.replace(AGENT_FILE_EXTENSION_PATTERN, \"\");\n\n\t\t// Return agent ID in format \"local:{name}\"\n\t\treturn `local:${agentName}`;\n\t}",
    "start_line": 249,
    "end_line": 259,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractAgentIdFromPath",
    "component_id": "src.features.hooks.file-watcher-service.extractAgentIdFromPath"
  },
  "src.features.hooks.file-watcher-service.dispose": {
    "id": "src.features.hooks.file-watcher-service.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/file-watcher-service.ts",
    "relative_path": "src/features/hooks/file-watcher-service.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.stopWatching();\n\t\tthis.changeListeners.length = 0;\n\t}",
    "start_line": 270,
    "end_line": 273,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.file-watcher-service.dispose"
  },
  "src.features.hooks.git-utils.GitRemote": {
    "id": "src.features.hooks.git-utils.GitRemote",
    "name": "GitRemote",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [],
    "source_code": "interface GitRemote {\n\tname?: string;\n\tfetchUrl?: string;\n\tpushUrl?: string;\n}",
    "start_line": 24,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitRemote",
    "component_id": "src.features.hooks.git-utils.GitRemote"
  },
  "src.features.hooks.git-utils.GitRepositoryState": {
    "id": "src.features.hooks.git-utils.GitRepositoryState",
    "name": "GitRepositoryState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [
      "src.features.hooks.git-utils.GitRemote"
    ],
    "source_code": "interface GitRepositoryState {\n\tremotes: GitRemote[];\n}",
    "start_line": 30,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitRepositoryState",
    "component_id": "src.features.hooks.git-utils.GitRepositoryState"
  },
  "src.features.hooks.git-utils.GitRepository": {
    "id": "src.features.hooks.git-utils.GitRepository",
    "name": "GitRepository",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [
      "src.features.hooks.git-utils.CommitOptions",
      "src.features.hooks.git-utils.GitRepositoryState"
    ],
    "source_code": "interface GitRepository {\n\tstate: GitRepositoryState;\n\tcommit(message: string, options?: CommitOptions): Promise<void>;\n\tpush(remote?: string, branch?: string, setUpstream?: boolean): Promise<void>;\n}",
    "start_line": 34,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitRepository",
    "component_id": "src.features.hooks.git-utils.GitRepository"
  },
  "src.features.hooks.git-utils.CommitOptions": {
    "id": "src.features.hooks.git-utils.CommitOptions",
    "name": "CommitOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [],
    "source_code": "interface CommitOptions {\n\tall?: boolean;\n\tamend?: boolean;\n\tstage?: string[];\n}",
    "start_line": 40,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CommitOptions",
    "component_id": "src.features.hooks.git-utils.CommitOptions"
  },
  "src.features.hooks.git-utils.GitAPI": {
    "id": "src.features.hooks.git-utils.GitAPI",
    "name": "GitAPI",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [
      "src.features.hooks.git-utils.GitRepository"
    ],
    "source_code": "interface GitAPI {\n\trepositories: GitRepository[];\n}",
    "start_line": 46,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitAPI",
    "component_id": "src.features.hooks.git-utils.GitAPI"
  },
  "src.features.hooks.git-utils.GitExtension": {
    "id": "src.features.hooks.git-utils.GitExtension",
    "name": "GitExtension",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [
      "src.features.hooks.git-utils.GitAPI"
    ],
    "source_code": "interface GitExtension {\n\tgetAPI(version: number): GitAPI;\n}",
    "start_line": 50,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitExtension",
    "component_id": "src.features.hooks.git-utils.GitExtension"
  },
  "src.features.hooks.git-utils.GitExtensionNotFoundError": {
    "id": "src.features.hooks.git-utils.GitExtensionNotFoundError",
    "name": "GitExtensionNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [],
    "source_code": "class GitExtensionNotFoundError extends Error {\n\tconstructor() {\n\t\tsuper(\n\t\t\t\"VS Code Git extension not found. Install/enable the Git extension to run Git operations.\"\n\t\t);\n\t\tthis.name = \"GitExtensionNotFoundError\";\n\t}\n}",
    "start_line": 54,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitExtensionNotFoundError",
    "component_id": "src.features.hooks.git-utils.GitExtensionNotFoundError"
  },
  "src.features.hooks.git-utils.GitRepositoryNotFoundError": {
    "id": "src.features.hooks.git-utils.GitRepositoryNotFoundError",
    "name": "GitRepositoryNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [],
    "source_code": "class GitRepositoryNotFoundError extends Error {\n\tconstructor() {\n\t\tsuper(\"No Git repository found in the current workspace.\");\n\t\tthis.name = \"GitRepositoryNotFoundError\";\n\t}\n}",
    "start_line": 63,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class GitRepositoryNotFoundError",
    "component_id": "src.features.hooks.git-utils.GitRepositoryNotFoundError"
  },
  "src.features.hooks.git-utils.getGitApi": {
    "id": "src.features.hooks.git-utils.getGitApi",
    "name": "getGitApi",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [
      "src.features.hooks.git-utils.GitAPI",
      "src.features.hooks.git-utils.GitExtension"
    ],
    "source_code": "function getGitApi(): GitAPI | undefined {\n\tconst gitExtension = extensions.getExtension<GitExtension>(\"vscode.git\");\n\treturn gitExtension?.exports?.getAPI?.(1);\n}",
    "start_line": 70,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGitApi",
    "component_id": "src.features.hooks.git-utils.getGitApi"
  },
  "src.features.hooks.git-utils.getPrimaryRepository": {
    "id": "src.features.hooks.git-utils.getPrimaryRepository",
    "name": "getPrimaryRepository",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [
      "src.features.hooks.git-utils.GitExtensionNotFoundError",
      "src.features.hooks.git-utils.getGitApi",
      "src.features.hooks.git-utils.GitRepository",
      "src.features.hooks.git-utils.GitRepositoryNotFoundError"
    ],
    "source_code": "function getPrimaryRepository(): GitRepository {\n\tconst git = getGitApi();\n\tif (!git) {\n\t\tthrow new GitExtensionNotFoundError();\n\t}\n\n\tconst repository = git.repositories[0];\n\tif (!repository) {\n\t\tthrow new GitRepositoryNotFoundError();\n\t}\n\n\treturn repository;\n}",
    "start_line": 75,
    "end_line": 87,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getPrimaryRepository",
    "component_id": "src.features.hooks.git-utils.getPrimaryRepository"
  },
  "src.features.hooks.git-utils.extractGitHubSlugFromRemote": {
    "id": "src.features.hooks.git-utils.extractGitHubSlugFromRemote",
    "name": "extractGitHubSlugFromRemote",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/git-utils.ts",
    "relative_path": "src/features/hooks/git-utils.ts",
    "depends_on": [],
    "source_code": "function extractGitHubSlugFromRemote(\n\tremoteUrl: string\n): string | undefined {\n\tif (!remoteUrl) {\n\t\treturn;\n\t}\n\n\t// Support SSH and HTTPS formats\n\tconst match = remoteUrl.match(GITHUB_SLUG_REGEX);\n\treturn match?.[1];\n}",
    "start_line": 89,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "remoteUrl"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractGitHubSlugFromRemote",
    "component_id": "src.features.hooks.git-utils.extractGitHubSlugFromRemote"
  },
  "src.features.hooks.hook-executor.ExecutionStatus": {
    "id": "src.features.hooks.hook-executor.ExecutionStatus",
    "name": "ExecutionStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "type ExecutionStatus = \"success\" | \"failure\" | \"skipped\" | \"timeout\";",
    "start_line": 88,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExecutionStatus",
    "component_id": "src.features.hooks.hook-executor.ExecutionStatus"
  },
  "src.features.hooks.hook-executor.ExecutionError": {
    "id": "src.features.hooks.hook-executor.ExecutionError",
    "name": "ExecutionError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "interface ExecutionError {\n\tmessage: string;\n\tcode: string;\n\tdetails?: unknown;\n}",
    "start_line": 93,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionError",
    "component_id": "src.features.hooks.hook-executor.ExecutionError"
  },
  "src.features.hooks.hook-executor.ExecutionResult": {
    "id": "src.features.hooks.hook-executor.ExecutionResult",
    "name": "ExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [
      "src.features.hooks.hook-executor.ExecutionStatus",
      "src.features.hooks.hook-executor.ExecutionError"
    ],
    "source_code": "interface ExecutionResult {\n\thookId: string;\n\thookName: string;\n\tstatus: ExecutionStatus;\n\tduration?: number;\n\terror?: ExecutionError;\n}",
    "start_line": 102,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionResult",
    "component_id": "src.features.hooks.hook-executor.ExecutionResult"
  },
  "src.features.hooks.hook-executor.ExecutionEvent": {
    "id": "src.features.hooks.hook-executor.ExecutionEvent",
    "name": "ExecutionEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook",
      "src.features.hooks.types.ExecutionContext",
      "src.features.hooks.hook-executor.ExecutionResult"
    ],
    "source_code": "interface ExecutionEvent {\n\thook: Hook;\n\tcontext: ExecutionContext;\n\tresult?: ExecutionResult;\n}",
    "start_line": 113,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionEvent",
    "component_id": "src.features.hooks.hook-executor.ExecutionEvent"
  },
  "src.features.hooks.hook-executor.CircularDependencyError": {
    "id": "src.features.hooks.hook-executor.CircularDependencyError",
    "name": "CircularDependencyError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "class CircularDependencyError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"CircularDependencyError\";\n\t}\n}",
    "start_line": 122,
    "end_line": 127,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CircularDependencyError",
    "component_id": "src.features.hooks.hook-executor.CircularDependencyError"
  },
  "src.features.hooks.hook-executor.MaxDepthExceededError": {
    "id": "src.features.hooks.hook-executor.MaxDepthExceededError",
    "name": "MaxDepthExceededError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "class MaxDepthExceededError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"MaxDepthExceededError\";\n\t}\n}",
    "start_line": 129,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MaxDepthExceededError",
    "component_id": "src.features.hooks.hook-executor.MaxDepthExceededError"
  },
  "src.features.hooks.hook-executor.ExecutionTimeoutError": {
    "id": "src.features.hooks.hook-executor.ExecutionTimeoutError",
    "name": "ExecutionTimeoutError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "class ExecutionTimeoutError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"ExecutionTimeoutError\";\n\t}\n}",
    "start_line": 136,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ExecutionTimeoutError",
    "component_id": "src.features.hooks.hook-executor.ExecutionTimeoutError"
  },
  "src.features.hooks.hook-executor.HookExecutor": {
    "id": "src.features.hooks.hook-executor.HookExecutor",
    "name": "HookExecutor",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      "src.features.hooks.template-utils.expandTemplate",
      "src.features.hooks.hook-executor.buildCopilotCliArgs",
      "src.features.hooks.trigger-registry.TriggerRegistry",
      "src.features.hooks.actions.mcp-action.MCPActionExecutor",
      "src.features.hooks.template-variable-parser.TemplateVariableParser",
      "src.features.hooks.hook-executor.ExecutionEvent",
      "src.features.hooks.types.ExecutionContext",
      "src.features.hooks.hook-executor.ExecutionResult",
      "src.features.hooks.hook-executor.MaxDepthExceededError",
      "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
      "src.features.hooks.agent-registry.checkAgentAvailability",
      "src.features.hooks.hook-executor.CircularDependencyError",
      "src.utils.spec-kit-adapter.getConfig",
      "ui.src.features.hooks-view.types.CustomActionParams",
      "src.features.hooks.hook-executor.createExecutionContext",
      "src.features.hooks.hook-executor.parseGitRemoteUrl",
      "src.features.hooks.hook-executor.isMaxDepthExceeded",
      "src.features.hooks.agent-registry.AgentRegistry",
      "src.features.hooks.services.mcp-execution-pool.execute",
      "src.features.hooks.hook-executor.addMcpServerOptions",
      "src.features.hooks.hook-executor.buildMinimalContext",
      "src.features.hooks.hook-executor.addPathOptions",
      "src.features.hooks.hook-executor.executeLocalAgent",
      "src.features.hooks.hook-executor.addUrlPermissions",
      "src.features.hooks.hook-executor.executeBackgroundAgent",
      "src.features.hooks.hook-executor.addExecutionOptions",
      "ui.src.features.hooks-view.types.HookExecutionLog",
      "src.features.hooks.hook-executor.addArtifactVariables",
      "src.features.hooks.hook-executor.buildGitContext",
      "src.features.hooks.actions.agent-action.AgentActionExecutor",
      "src.features.hooks.actions.github-action.GitHubActionExecutor",
      "src.features.hooks.hook-manager.getAllHooks",
      "src.features.hooks.agent-registry.getAgentById",
      "src.features.hooks.services.mcp-parameter-resolver.MCPParameterResolver",
      "src.features.hooks.hook-executor.addAgentMetadata",
      "src.features.hooks.template-variable-parser.extractVariables",
      "src.features.hooks.services.mcp-execution-pool.MCPExecutionPool",
      "src.features.hooks.hook-executor.expandTemplate",
      "src.features.hooks.actions.git-action.GitActionExecutor",
      "src.features.hooks.hook-manager.deleteHook",
      "src.features.hooks.hook-executor.buildTemplateContext",
      "src.features.hooks.hook-executor.addOutputVariables",
      "src.features.hooks.hook-executor.addSpecVariables",
      "src.features.hooks.hook-executor.extractFeatureName",
      "src.features.hooks.services.mcp-client.MCPClientService",
      "src.services.agent-service.dispose",
      "ui.src.services.spec-explorer.on",
      "ui.src.features.hooks-view.types.Hook",
      "src.features.hooks.hook-executor.addSessionOptions",
      "src.features.hooks.hook-executor.isCircularDependency",
      "src.features.hooks.hook-executor.enrichContextWithTriggerData",
      "src.features.hooks.hook-executor.addToolPermissions",
      "src.features.hooks.hook-executor.addConfigOptions",
      "src.features.hooks.hook-executor.recordExecutionLog",
      "src.features.hooks.hook-executor.executeHooksForTrigger",
      "src.features.hooks.hook-manager.HookManager",
      "src.features.hooks.hook-executor.dispose",
      "src.features.hooks.hook-executor.ExecutionTimeoutError",
      "src.features.hooks.template-variable-parser.substitute",
      "src.providers.welcome-screen-provider.executeCommand",
      "src.features.hooks.hook-executor.addGithubMcpOptions",
      "src.features.hooks.types.TriggerEvent",
      "src.features.hooks.hook-executor.executeHook",
      "src.features.hooks.hook-executor.executeWithTimeout",
      "src.utils.chat-prompt-runner.sendPromptToChat",
      "src.features.hooks.hook-executor.addOutputOptions",
      "src.features.hooks.hook-manager.validateHook"
    ],
    "source_code": "class HookExecutor {\n\tprivate readonly hookManager: HookManager;\n\tprivate readonly triggerRegistry: TriggerRegistry;\n\tprivate readonly agentRegistry: AgentRegistry;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly agentExecutor: AgentActionExecutor;\n\tprivate readonly gitExecutor: GitActionExecutor;\n\tprivate readonly githubExecutor: GitHubActionExecutor;\n\tprivate readonly mcpExecutor: MCPActionExecutor;\n\tprivate readonly templateParser: TemplateVariableParser;\n\tprivate executionLogs: HookExecutionLog[] = [];\n\n\t// Event emitters\n\tprivate readonly _onExecutionStarted = new EventEmitter<ExecutionEvent>();\n\tprivate readonly _onExecutionCompleted = new EventEmitter<ExecutionEvent>();\n\tprivate readonly _onExecutionFailed = new EventEmitter<ExecutionEvent>();\n\n\t// Public events\n\treadonly onExecutionStarted: Event<ExecutionEvent> =\n\t\tthis._onExecutionStarted.event;\n\treadonly onExecutionCompleted: Event<ExecutionEvent> =\n\t\tthis._onExecutionCompleted.event;\n\treadonly onExecutionFailed: Event<ExecutionEvent> =\n\t\tthis._onExecutionFailed.event;\n\n\t// biome-ignore lint/nursery/useMaxParams: Dependency injection pattern requires multiple constructor parameters\n\tconstructor(\n\t\thookManager: HookManager,\n\t\ttriggerRegistry: TriggerRegistry,\n\t\toutputChannel: OutputChannel,\n\t\tmcpDiscoveryService: IMCPDiscoveryService,\n\t\tagentRegistry: AgentRegistry\n\t) {\n\t\tthis.hookManager = hookManager;\n\t\tthis.triggerRegistry = triggerRegistry;\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.agentRegistry = agentRegistry;\n\t\tthis.agentExecutor = new AgentActionExecutor();\n\t\tthis.gitExecutor = new GitActionExecutor();\n\t\tthis.githubExecutor = new GitHubActionExecutor();\n\t\tthis.templateParser = new TemplateVariableParser();\n\n\t\t// Initialize MCP executor with all required services\n\t\tconst clientService = new MCPClientService(mcpDiscoveryService);\n\t\tconst parameterResolver = new MCPParameterResolver();\n\t\tconst executionPool = new MCPExecutionPool(5); // Concurrency limit of 5\n\n\t\tthis.mcpExecutor = new MCPActionExecutor({\n\t\t\tdiscoveryService: mcpDiscoveryService,\n\t\t\tclientService,\n\t\t\tparameterResolver,\n\t\t\texecutionPool,\n\t\t\tlogger: outputChannel,\n\t\t});\n\t}\n\n\t/**\n\t * Initialize the hook executor\n\t * Subscribes to trigger events\n\t */\n\tinitialize(): void {\n\t\t// Subscribe to trigger events\n\t\tthis.triggerRegistry.onTrigger(async (event) => {\n\t\t\tconst timing = event.timing || \"after\";\n\t\t\tawait this.executeHooksForTrigger(\n\t\t\t\tevent.agent,\n\t\t\t\tevent.operation,\n\t\t\t\ttiming,\n\t\t\t\tevent\n\t\t\t);\n\t\t});\n\n\t\tthis.outputChannel.appendLine(\"[HookExecutor] Initialized\");\n\t}\n\n\t/**\n\t * Dispose of resources\n\t */\n\tdispose(): void {\n\t\tthis._onExecutionStarted.dispose();\n\t\tthis._onExecutionCompleted.dispose();\n\t\tthis._onExecutionFailed.dispose();\n\t\tthis.outputChannel.appendLine(\"[HookExecutor] Disposed\");\n\t}\n\n\t/**\n\t * Execute a single hook\n\t * T087: Prevent execution of invalid hooks\n\t */\n\t// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: The hook pipeline coordinates validation, execution, logging, and retries within a single flow.\n\tasync executeHook(\n\t\thook: Hook,\n\t\tcontext?: ExecutionContext,\n\t\ttriggerEvent?: TriggerEvent\n\t): Promise<ExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\t// Check if hook is enabled\n\t\tif (!hook.enabled) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Skipping disabled hook: ${hook.name} (${hook.id})`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\thookId: hook.id,\n\t\t\t\thookName: hook.name,\n\t\t\t\tstatus: \"skipped\",\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\n\t\t// T087: Validate MCP hooks before execution\n\t\tif (hook.action.type === \"mcp\") {\n\t\t\ttry {\n\t\t\t\tconst validation = await this.hookManager.validateHook(hook);\n\t\t\t\tif (!validation.valid) {\n\t\t\t\t\tconst errorMessages = validation.errors\n\t\t\t\t\t\t.map((e) => `${e.field}: ${e.message}`)\n\t\t\t\t\t\t.join(\", \");\n\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Skipping invalid MCP hook: ${hook.name} - ${errorMessages}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// T088-T089: Show error notification with actions\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tconst action = await window.showErrorMessage(\n\t\t\t\t\t\t`Hook \"${hook.name}\" has invalid MCP configuration: ${validation.errors[0]?.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\"Update Hook\",\n\t\t\t\t\t\t\"Remove Hook\",\n\t\t\t\t\t\t\"Cancel\"\n\t\t\t\t\t);\n\n\t\t\t\t\tif (action === \"Update Hook\") {\n\t\t\t\t\t\t// Trigger hook edit (command will be implemented in hook view)\n\t\t\t\t\t\tawait commands.executeCommand(\"gatomia.hooks.editHook\", hook.id);\n\t\t\t\t\t} else if (action === \"Remove Hook\") {\n\t\t\t\t\t\tawait this.hookManager.deleteHook(hook.id);\n\t\t\t\t\t\twindow.showInformationMessage(`Hook \"${hook.name}\" removed`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\thookId: hook.id,\n\t\t\t\t\t\thookName: hook.name,\n\t\t\t\t\t\tstatus: \"skipped\",\n\t\t\t\t\t\tduration: Date.now() - startTime,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: errorMessages,\n\t\t\t\t\t\t\tcode: \"InvalidMCPConfiguration\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Graceful degradation - log error and continue\n\t\t\t\tconst err = error as Error;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Warning: Failed to validate MCP hook: ${err.message}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// T081: Check agent availability before execution for custom hooks\n\t\tif (hook.action.type === \"custom\") {\n\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\t\tconst agentId = customParams.agentId || customParams.agentName;\n\n\t\t\tif (agentId && this.agentRegistry) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check agent availability\n\t\t\t\t\tconst availability =\n\t\t\t\t\t\tawait this.agentRegistry.checkAgentAvailability(agentId);\n\n\t\t\t\t\tif (!availability.available) {\n\t\t\t\t\t\t// Determine reason text\n\t\t\t\t\t\tlet reasonText: string;\n\t\t\t\t\t\tif (availability.reason === \"FILE_DELETED\") {\n\t\t\t\t\t\t\treasonText = \"agent file was deleted\";\n\t\t\t\t\t\t} else if (availability.reason === \"EXTENSION_UNINSTALLED\") {\n\t\t\t\t\t\t\treasonText = \"extension is uninstalled\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treasonText = \"agent is unavailable\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst errorMessage = `Agent \"${agentId}\" is not available: ${reasonText}`;\n\n\t\t\t\t\t\t// T082: Log detailed error information\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Agent unavailable - Hook: ${hook.name} (${hook.id})`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Agent ID: ${agentId}, Reason: ${availability.reason}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Trigger: ${hook.trigger.agent}.${hook.trigger.operation} (${hook.trigger.timing})`\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Emit execution failed event\n\t\t\t\t\t\tconst errorResult: ExecutionResult = {\n\t\t\t\t\t\t\thookId: hook.id,\n\t\t\t\t\t\t\thookName: hook.name,\n\t\t\t\t\t\t\tstatus: \"failure\",\n\t\t\t\t\t\t\tduration: Date.now() - startTime,\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tmessage: errorMessage,\n\t\t\t\t\t\t\t\tcode: \"AgentUnavailable\",\n\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\tagentId,\n\t\t\t\t\t\t\t\t\treason: availability.reason,\n\t\t\t\t\t\t\t\t\tcheckedAt: availability.checkedAt,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._onExecutionFailed.fire({\n\t\t\t\t\t\t\thook,\n\t\t\t\t\t\t\tcontext: context || this.createExecutionContext(),\n\t\t\t\t\t\t\tresult: errorResult,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Show error notification with retry option\n\t\t\t\t\t\tconst action = await window.showErrorMessage(\n\t\t\t\t\t\t\t`Hook \"${hook.name}\" failed: ${errorMessage}`,\n\t\t\t\t\t\t\t\"Retry\",\n\t\t\t\t\t\t\t\"Update Hook\",\n\t\t\t\t\t\t\t\"Cancel\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (action === \"Retry\") {\n\t\t\t\t\t\t\t// Retry execution\n\t\t\t\t\t\t\treturn await this.executeHook(hook, context, triggerEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (action === \"Update Hook\") {\n\t\t\t\t\t\t\tawait commands.executeCommand(\"gatomia.hooks.editHook\", hook.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn errorResult;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Graceful degradation - log error and continue\n\t\t\t\t\tconst err = error as Error;\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Warning: Failed to check agent availability: ${err.message}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create or use existing context\n\t\tconst execContext = context || this.createExecutionContext();\n\n\t\ttry {\n\t\t\t// Check for circular dependency\n\t\t\tif (this.isCircularDependency(hook.id, execContext)) {\n\t\t\t\tthrow new CircularDependencyError(\n\t\t\t\t\t`Circular dependency detected: ${hook.name}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check max depth\n\t\t\tif (this.isMaxDepthExceeded(execContext)) {\n\t\t\t\tthrow new MaxDepthExceededError(\n\t\t\t\t\t`Maximum chain depth (${MAX_CHAIN_DEPTH}) exceeded`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Add hook to executed set\n\t\t\texecContext.executedHooks.add(hook.id);\n\t\t\texecContext.chainDepth += 1;\n\n\t\t\t// Build template context\n\t\t\t// Extract trigger type from hook's trigger configuration\n\t\t\tconst templateContext = await this.buildTemplateContext(\n\t\t\t\thook.trigger.operation,\n\t\t\t\tundefined,\n\t\t\t\ttriggerEvent\n\t\t\t);\n\n\t\t\t// Emit execution started event\n\t\t\tthis._onExecutionStarted.fire({\n\t\t\t\thook,\n\t\t\t\tcontext: execContext,\n\t\t\t});\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Executing hook: ${hook.name} (${hook.id})`\n\t\t\t);\n\n\t\t\t// Execute action based on type\n\t\t\tlet actionResult: { success: boolean; error?: Error };\n\n\t\t\t// T074: Add detailed logging for MCP actions\n\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] MCP Action: ${mcpParams.serverId}/${mcpParams.toolName}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tswitch (hook.action.type) {\n\t\t\t\tcase \"agent\": {\n\t\t\t\t\t// Expand templates in command\n\t\t\t\t\tconst agentParams = hook.action.parameters as AgentActionParams;\n\t\t\t\t\tconst command = this.expandTemplate(\n\t\t\t\t\t\tagentParams.command,\n\t\t\t\t\t\ttemplateContext\n\t\t\t\t\t);\n\n\t\t\t\t\t// Execute with timeout\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.agentExecutor.execute({\n\t\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"git\": {\n\t\t\t\t\tconst gitParams = hook.action.parameters as GitActionParams;\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() => this.gitExecutor.execute(gitParams, templateContext),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"github\": {\n\t\t\t\t\tconst githubParams = hook.action.parameters as GitHubActionParams;\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() => this.githubExecutor.execute(githubParams, templateContext),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"mcp\": {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() => this.mcpExecutor.execute(mcpParams, templateContext),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"custom\": {\n\t\t\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\n\t\t\t\t\t// Determine agent type (override or default from registry)\n\t\t\t\t\tlet agentType = customParams.agentType;\n\t\t\t\t\tif (!agentType && customParams.agentId) {\n\t\t\t\t\t\tconst agent = this.agentRegistry.getAgentById(customParams.agentId);\n\t\t\t\t\t\tagentType = agent?.type;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Custom action - Agent type: ${agentType || \"unknown\"}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Route based on agent type\n\t\t\t\t\tif (agentType === \"local\") {\n\t\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t\t() => this.executeLocalAgent(customParams, templateContext),\n\t\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (agentType === \"background\") {\n\t\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t\t() => this.executeBackgroundAgent(customParams, templateContext),\n\t\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown agent type: ${agentType}. Agent ID: ${customParams.agentId}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported action type: ${hook.action.type}`);\n\t\t\t}\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// Create execution result\n\t\t\tconst result: ExecutionResult = {\n\t\t\t\thookId: hook.id,\n\t\t\t\thookName: hook.name,\n\t\t\t\tstatus: actionResult.success ? \"success\" : \"failure\",\n\t\t\t\tduration,\n\t\t\t\terror: actionResult.error\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tmessage: actionResult.error.message,\n\t\t\t\t\t\t\tcode: actionResult.error.name || \"UnknownError\",\n\t\t\t\t\t\t\tdetails: actionResult.error,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\t// Record execution log\n\t\t\tthis.recordExecutionLog({\n\t\t\t\tid: randomUUID(),\n\t\t\t\thookId: hook.id,\n\t\t\t\texecutionId: execContext.executionId,\n\t\t\t\tchainDepth: execContext.chainDepth,\n\t\t\t\ttriggeredAt: startTime,\n\t\t\t\tcompletedAt: Date.now(),\n\t\t\t\tduration,\n\t\t\t\tstatus: result.status,\n\t\t\t\terror: result.error,\n\t\t\t\tcontextSnapshot: templateContext,\n\t\t\t});\n\n\t\t\t// Emit appropriate event\n\t\t\tif (result.status === \"success\") {\n\t\t\t\tthis._onExecutionCompleted.fire({\n\t\t\t\t\thook,\n\t\t\t\t\tcontext: execContext,\n\t\t\t\t\tresult,\n\t\t\t\t});\n\n\t\t\t\t// T076: Show success notification for MCP actions\n\t\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\twindow.showInformationMessage(\n\t\t\t\t\t\t`MCP Tool \"${mcpParams.toolName}\" executed successfully (${duration}ms)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor]  Hook execution success: ${hook.name} (${duration}ms)`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// T084: Enhanced failure logging with full context\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[HookExecutor] ==================== HOOK EXECUTION FAILURE ====================\"\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Hook: ${hook.name} (${hook.id})`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Trigger: ${hook.trigger.agent}.${hook.trigger.operation} (${hook.trigger.timing})`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Action Type: ${hook.action.type}`\n\t\t\t\t);\n\n\t\t\t\t// Add action-specific context\n\t\t\t\tif (hook.action.type === \"custom\") {\n\t\t\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Agent ID: ${customParams.agentId || customParams.agentName || \"unknown\"}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Agent Type: ${customParams.agentType || \"unknown\"}`\n\t\t\t\t\t);\n\t\t\t\t} else if (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] MCP Server: ${mcpParams.serverId}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] MCP Tool: ${mcpParams.toolName}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (result.error) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Error Code: ${result.error.code}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Error Message: ${result.error.message}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Log stack trace if available in details\n\t\t\t\t\tconst errorDetails = result.error.details as any;\n\t\t\t\t\tif (errorDetails?.stack) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Stack Trace:\\n${errorDetails.stack}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Duration: ${duration}ms`);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Execution ID: ${execContext.executionId}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Chain Depth: ${execContext.chainDepth}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[HookExecutor] ================================================================\"\n\t\t\t\t);\n\n\t\t\t\tthis._onExecutionFailed.fire({\n\t\t\t\t\thook,\n\t\t\t\t\tcontext: execContext,\n\t\t\t\t\tresult,\n\t\t\t\t});\n\n\t\t\t\t// T077: Show error notification for MCP actions\n\t\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tconst errorMsg = result.error?.message ?? \"Unknown error\";\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`MCP Tool \"${mcpParams.toolName}\" failed: ${errorMsg}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\t\t\tconst err = error as Error;\n\n\t\t\t// T084: Enhanced error logging with full context\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[HookExecutor] ==================== HOOK EXECUTION ERROR ====================\"\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Hook: ${hook.name} (${hook.id})`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Trigger: ${hook.trigger.agent}.${hook.trigger.operation} (${hook.trigger.timing})`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Action Type: ${hook.action.type}`\n\t\t\t);\n\n\t\t\t// Add action-specific context\n\t\t\tif (hook.action.type === \"custom\") {\n\t\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Agent ID: ${customParams.agentId || customParams.agentName || \"unknown\"}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Agent Type: ${customParams.agentType || \"unknown\"}`\n\t\t\t\t);\n\t\t\t} else if (hook.action.type === \"mcp\") {\n\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] MCP Server: ${mcpParams.serverId}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] MCP Tool: ${mcpParams.toolName}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Error: ${err.name}`);\n\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Message: ${err.message}`);\n\n\t\t\t// Include stack trace for debugging\n\t\t\tif (err.stack) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Stack Trace:\\n${err.stack}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Duration: ${duration}ms`);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Execution ID: ${execContext.executionId}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Chain Depth: ${execContext.chainDepth}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[HookExecutor] ================================================================\"\n\t\t\t);\n\n\t\t\tconst result: ExecutionResult = {\n\t\t\t\thookId: hook.id,\n\t\t\t\thookName: hook.name,\n\t\t\t\tstatus: \"failure\",\n\t\t\t\tduration,\n\t\t\t\terror: {\n\t\t\t\t\tmessage: err.message,\n\t\t\t\t\tcode: err.name || \"UnknownError\",\n\t\t\t\t\tdetails: err,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Record execution log\n\t\t\tthis.recordExecutionLog({\n\t\t\t\tid: randomUUID(),\n\t\t\t\thookId: hook.id,\n\t\t\t\texecutionId: execContext.executionId,\n\t\t\t\tchainDepth: execContext.chainDepth,\n\t\t\t\ttriggeredAt: startTime,\n\t\t\t\tcompletedAt: Date.now(),\n\t\t\t\tduration,\n\t\t\t\tstatus: \"failure\",\n\t\t\t\terror: result.error,\n\t\t\t\tcontextSnapshot: {}, // Empty context on early failure\n\t\t\t});\n\n\t\t\t// Emit failed event\n\t\t\tthis._onExecutionFailed.fire({\n\t\t\t\thook,\n\t\t\t\tcontext: execContext,\n\t\t\t\tresult,\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Execute all hooks matching a trigger\n\t */\n\tasync executeHooksForTrigger(\n\t\tagent: string,\n\t\toperation: string,\n\t\ttiming: \"before\" | \"after\" = \"after\",\n\t\ttriggerEvent?: TriggerEvent\n\t): Promise<ExecutionResult[]> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executing hooks for trigger: ${agent}.${operation} (${timing})`\n\t\t);\n\n\t\t// Get all enabled hooks matching trigger and timing\n\t\tconst allHooks = await this.hookManager.getAllHooks();\n\t\tconst matchingHooks = allHooks\n\t\t\t.filter(\n\t\t\t\t(h) =>\n\t\t\t\t\th.enabled &&\n\t\t\t\t\th.trigger.agent === agent &&\n\t\t\t\t\th.trigger.operation === operation &&\n\t\t\t\t\th.trigger.timing === timing\n\t\t\t)\n\t\t\t.sort((a, b) => a.createdAt - b.createdAt); // Deterministic order\n\n\t\tif (matchingHooks.length === 0) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] No enabled hooks found for trigger: ${agent}.${operation} (${timing})`\n\t\t\t);\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create shared execution context\n\t\tconst context = this.createExecutionContext();\n\n\t\t// Execute hooks based on waitForCompletion setting\n\t\tconst results: ExecutionResult[] = [];\n\t\tfor (const hook of matchingHooks) {\n\t\t\tif (timing === \"before\" && hook.trigger.waitForCompletion) {\n\t\t\t\t// Blocking execution: wait for hook to complete\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Executing blocking before hook: ${hook.name}`\n\t\t\t\t);\n\t\t\t\tconst result = await this.executeHook(hook, context, triggerEvent);\n\t\t\t\tresults.push(result);\n\t\t\t} else {\n\t\t\t\t// Non-blocking execution: execute in parallel\n\t\t\t\tconst result = await this.executeHook(hook, context, triggerEvent);\n\t\t\t\tresults.push(result);\n\t\t\t}\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executed ${results.length} hooks for trigger: ${agent}.${operation} (${timing})`\n\t\t);\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Create a new execution context\n\t */\n\tcreateExecutionContext(): ExecutionContext {\n\t\treturn {\n\t\t\texecutionId: randomUUID(),\n\t\t\tchainDepth: 0,\n\t\t\texecutedHooks: new Set<string>(),\n\t\t\tstartedAt: Date.now(),\n\t\t};\n\t}\n\n\t/**\n\t * Check if executing a hook would create a circular dependency\n\t */\n\tisCircularDependency(hookId: string, context: ExecutionContext): boolean {\n\t\treturn context.executedHooks.has(hookId);\n\t}\n\n\t/**\n\t * Check if max chain depth has been exceeded\n\t */\n\tisMaxDepthExceeded(context: ExecutionContext): boolean {\n\t\treturn context.chainDepth >= MAX_CHAIN_DEPTH;\n\t}\n\n\t/**\n\t * Build template context with runtime variables\n\t */\n\tasync buildTemplateContext(\n\t\ttriggerOperation: string,\n\t\ttriggerData?: Record<string, unknown>,\n\t\ttriggerEvent?: TriggerEvent\n\t): Promise<ParserTemplateContext> {\n\t\ttry {\n\t\t\tconst gitContext = await this.buildGitContext();\n\t\t\tconst workspacePath = workspace.workspaceFolders?.[0]?.uri.fsPath || \"\";\n\n\t\t\t// Build base context with standard variables\n\t\t\tconst baseContext: ParserTemplateContext = {\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\ttriggerType: triggerOperation as OperationType,\n\t\t\t\t...gitContext,\n\t\t\t\tworkspacePath,\n\t\t\t};\n\n\t\t\t// Add trigger-specific data if available\n\t\t\tif (triggerData) {\n\t\t\t\tthis.enrichContextWithTriggerData(baseContext, triggerData);\n\t\t\t}\n\n\t\t\t// Add output capture variables\n\t\t\tif (triggerEvent) {\n\t\t\t\tawait this.addOutputVariables(baseContext, triggerEvent);\n\t\t\t}\n\n\t\t\treturn baseContext;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Warning: Failed to build template context: ${error}`\n\t\t\t);\n\n\t\t\t// Return minimal context on error\n\t\t\treturn this.buildMinimalContext(triggerOperation);\n\t\t}\n\t}\n\n\t/**\n\t * Build Git-related context variables\n\t */\n\tprivate async buildGitContext(): Promise<Partial<ParserTemplateContext>> {\n\t\tconst gitExtension = extensions.getExtension(\"vscode.git\");\n\t\tconst git = gitExtension?.exports.getAPI(1);\n\t\tconst repository = git?.repositories[0];\n\n\t\tif (!repository) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst branch = repository.state.HEAD?.name;\n\t\tconst user = await repository.getConfig(\"user.name\");\n\t\tconst feature = branch ? this.extractFeatureName(branch) : undefined;\n\n\t\t// Extract repository info from remote URL\n\t\tconst remoteUrl = await repository.getConfig(\"remote.origin.url\");\n\t\tconst repoInfo = this.parseGitRemoteUrl(remoteUrl || \"\");\n\n\t\treturn {\n\t\t\tbranch,\n\t\t\tuser,\n\t\t\tfeature,\n\t\t\trepoOwner: repoInfo.owner,\n\t\t\trepoName: repoInfo.name,\n\t\t};\n\t}\n\n\t/**\n\t * Enrich context with trigger-specific data\n\t */\n\tprivate enrichContextWithTriggerData(\n\t\tcontext: ParserTemplateContext,\n\t\ttriggerData: Record<string, unknown>\n\t): void {\n\t\t// Spec-related variables\n\t\tthis.addSpecVariables(context, triggerData);\n\n\t\t// Spec artifact variables\n\t\tthis.addArtifactVariables(context, triggerData);\n\n\t\t// Agent metadata\n\t\tthis.addAgentMetadata(context, triggerData);\n\t}\n\n\t/**\n\t * Add spec-related variables to context\n\t */\n\tprivate addSpecVariables(\n\t\tcontext: ParserTemplateContext,\n\t\tdata: Record<string, unknown>\n\t): void {\n\t\tconst specFields = [\n\t\t\t\"specId\",\n\t\t\t\"specPath\",\n\t\t\t\"oldStatus\",\n\t\t\t\"newStatus\",\n\t\t\t\"changeAuthor\",\n\t\t] as const;\n\n\t\tfor (const field of specFields) {\n\t\t\tif (data[field]) {\n\t\t\t\tcontext[field] = data[field] as string;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add spec artifact variables to context\n\t */\n\tprivate addArtifactVariables(\n\t\tcontext: ParserTemplateContext,\n\t\tdata: Record<string, unknown>\n\t): void {\n\t\tconst artifactFields = [\"useCaseId\", \"taskId\", \"requirementId\"] as const;\n\n\t\tfor (const field of artifactFields) {\n\t\t\tif (data[field]) {\n\t\t\t\tcontext[field] = data[field] as string;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add agent metadata to context\n\t */\n\tprivate addAgentMetadata(\n\t\tcontext: ParserTemplateContext,\n\t\tdata: Record<string, unknown>\n\t): void {\n\t\tif (data.agentId) {\n\t\t\tcontext.agentId = data.agentId as string;\n\t\t}\n\t\tif (data.agentType) {\n\t\t\tcontext.agentType = data.agentType as string;\n\t\t}\n\t}\n\n\t/**\n\t * Build minimal fallback context\n\t */\n\tprivate buildMinimalContext(triggerOperation: string): ParserTemplateContext {\n\t\treturn {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\ttriggerType: triggerOperation as OperationType,\n\t\t\tworkspacePath: workspace.workspaceFolders?.[0]?.uri.fsPath || \"\",\n\t\t};\n\t}\n\n\t/**\n\t * Add output capture variables to context\n\t */\n\tprivate async addOutputVariables(\n\t\tcontext: ParserTemplateContext,\n\t\tevent: TriggerEvent\n\t): Promise<void> {\n\t\t// 1. Add clipboard content\n\t\ttry {\n\t\t\tconst clipboardText = await env.clipboard.readText();\n\t\t\tcontext.clipboardContent = clipboardText;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Captured clipboard content (${clipboardText.length} chars)`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Failed to read clipboard: ${error}`\n\t\t\t);\n\t\t\tcontext.clipboardContent = \"\";\n\t\t}\n\n\t\t// 2. Add agent output from file (if available)\n\t\tif (event.outputPath) {\n\t\t\ttry {\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\tconst content = await fs.readFile(event.outputPath, \"utf-8\");\n\t\t\t\tcontext.agentOutput = content;\n\t\t\t\tcontext.outputPath = event.outputPath;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Captured agent output from file: ${event.outputPath} (${content.length} chars)`\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Failed to read output file ${event.outputPath}: ${error}`\n\t\t\t\t);\n\t\t\t\tcontext.agentOutput = \"\";\n\t\t\t}\n\t\t} else if (event.outputContent) {\n\t\t\t// Use pre-loaded content if provided\n\t\t\tcontext.agentOutput = event.outputContent;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Using pre-loaded agent output (${event.outputContent.length} chars)`\n\t\t\t);\n\t\t} else {\n\t\t\t// No output available\n\t\t\tcontext.agentOutput = \"\";\n\t\t}\n\t}\n\n\t/**\n\t * Parse Git remote URL to extract owner and repo name\n\t * Supports both HTTPS and SSH formats\n\t */\n\tprivate parseGitRemoteUrl(url: string): { owner: string; name: string } {\n\t\t// HTTPS: https://github.com/owner/repo.git\n\t\tconst httpsMatch = url.match(GIT_HTTPS_REMOTE_PATTERN);\n\t\tif (httpsMatch) {\n\t\t\treturn { owner: httpsMatch[1], name: httpsMatch[2] };\n\t\t}\n\n\t\t// SSH: git@github.com:owner/repo.git\n\t\tconst sshMatch = url.match(GIT_SSH_REMOTE_PATTERN);\n\t\tif (sshMatch) {\n\t\t\treturn { owner: sshMatch[1], name: sshMatch[2] };\n\t\t}\n\n\t\treturn { owner: \"\", name: \"\" };\n\t}\n\n\t/**\n\t * Extract feature name from branch name\n\t * Pattern: NNN-feature-name  'feature-name'\n\t */\n\tprivate extractFeatureName(branch: string): string | undefined {\n\t\tconst match = branch.match(FEATURE_NAME_PATTERN);\n\t\treturn match ? match[1] : undefined;\n\t}\n\n\t/**\n\t * Expand template variables in a string\n\t * Uses TemplateVariableParser to replace $variable with values from context\n\t */\n\texpandTemplate(template: string, context: ParserTemplateContext): string {\n\t\t// Log template expansion for debugging\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Expanding template: \"${template}\"`\n\t\t);\n\n\t\t// Extract and log variables found\n\t\tconst variables = this.templateParser.extractVariables(template);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Variables found: ${variables.length > 0 ? variables.join(\", \") : \"(none)\"}`\n\t\t);\n\n\t\t// Log context values for found variables\n\t\tif (variables.length > 0) {\n\t\t\tconst contextValues = variables\n\t\t\t\t.map((varName) => {\n\t\t\t\t\tconst value = context[varName];\n\t\t\t\t\treturn `${varName}=${value !== undefined ? JSON.stringify(value) : \"(undefined)\"}`;\n\t\t\t\t})\n\t\t\t\t.join(\", \");\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Context values: ${contextValues}`\n\t\t\t);\n\t\t}\n\n\t\t// Perform substitution\n\t\tconst result = this.templateParser.substitute(template, context);\n\n\t\t// Log final result\n\t\tthis.outputChannel.appendLine(`[HookExecutor] Result: \"${result}\"`);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Execute a function with timeout\n\t */\n\tprivate executeWithTimeout<T>(\n\t\tfn: () => Promise<T>,\n\t\ttimeoutMs: number\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\treject(\n\t\t\t\t\tnew ExecutionTimeoutError(`Execution timed out after ${timeoutMs}ms`)\n\t\t\t\t);\n\t\t\t}, timeoutMs);\n\n\t\t\tfn()\n\t\t\t\t.then((result) => {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\tresolve(result);\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Record an execution log\n\t */\n\tprivate recordExecutionLog(log: HookExecutionLog): void {\n\t\tthis.executionLogs.push(log);\n\n\t\t// Prune old logs (FIFO)\n\t\tif (this.executionLogs.length > MAX_EXECUTION_LOGS) {\n\t\t\tthis.executionLogs.shift();\n\t\t}\n\t}\n\n\t/**\n\t * Get all execution logs\n\t */\n\tgetExecutionLogs(): HookExecutionLog[] {\n\t\treturn [...this.executionLogs]; // Return copy\n\t}\n\n\t/**\n\t * Get execution logs for a specific hook\n\t */\n\tgetExecutionLogsForHook(hookId: string): HookExecutionLog[] {\n\t\treturn this.executionLogs.filter((log) => log.hookId === hookId);\n\t}\n\n\t/**\n\t * Clear all execution logs\n\t */\n\tclearExecutionLogs(): void {\n\t\tthis.executionLogs = [];\n\t\tthis.outputChannel.appendLine(\"[HookExecutor] Execution logs cleared\");\n\t}\n\n\t/**\n\t * Execute a local agent (in-process via sendPromptToChat)\n\t * T053: Implement local agent execution path\n\t */\n\tprivate executeLocalAgent(\n\t\tparams: CustomActionParams,\n\t\ttemplateContext: ParserTemplateContext\n\t): Promise<{ success: boolean; error?: Error }> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executing local agent: ${params.agentId}`\n\t\t);\n\n\t\treturn (async () => {\n\t\t\ttry {\n\t\t\t\t// Extract agent name from agentId (format: \"local:agent-name\")\n\t\t\t\tconst agentName =\n\t\t\t\t\tparams.agentId?.replace(AGENT_ID_PREFIX_PATTERN, \"\") ||\n\t\t\t\t\tparams.agentName;\n\t\t\t\tif (!agentName) {\n\t\t\t\t\tthrow new Error(\"Agent name is required for local execution\");\n\t\t\t\t}\n\n\t\t\t\t// Read the agent file from .github/agents/\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\tconst { join } = await import(\"node:path\");\n\n\t\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\t\tif (!workspaceRoot) {\n\t\t\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t\t\t}\n\n\t\t\t\tconst agentFilePath = join(\n\t\t\t\t\tworkspaceRoot,\n\t\t\t\t\t\".github\",\n\t\t\t\t\t\"agents\",\n\t\t\t\t\t`${agentName}.agent.md`\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Reading agent file: ${agentFilePath}`\n\t\t\t\t);\n\n\t\t\t\tconst agentContent = await fs.readFile(agentFilePath, \"utf-8\");\n\n\t\t\t\t// Expand template variables in prompt and arguments\n\t\t\t\tconst userPrompt = params.prompt\n\t\t\t\t\t? this.expandTemplate(params.prompt, templateContext)\n\t\t\t\t\t: \"\";\n\t\t\t\tconst userArgs = params.arguments\n\t\t\t\t\t? this.expandTemplate(params.arguments, templateContext)\n\t\t\t\t\t: \"\";\n\n\t\t\t\t// Combine agent content with user input\n\t\t\t\t// Format: Agent content + user prompt + arguments\n\t\t\t\tlet finalPrompt = agentContent;\n\t\t\t\tif (userPrompt) {\n\t\t\t\t\tfinalPrompt += `\\n\\n${userPrompt}`;\n\t\t\t\t}\n\t\t\t\tif (userArgs) {\n\t\t\t\t\tfinalPrompt += `\\n\\nArguments: ${userArgs}`;\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Sending agent prompt to Copilot Chat (length: ${finalPrompt.length} chars)`\n\t\t\t\t);\n\n\t\t\t\t// Send prompt to GitHub Copilot Chat (in-process execution)\n\t\t\t\tawait sendPromptToChat(finalPrompt);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[HookExecutor] Local agent execution completed successfully\"\n\t\t\t\t);\n\n\t\t\t\treturn { success: true };\n\t\t\t} catch (error) {\n\t\t\t\tconst err = error as Error;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Local agent execution failed: ${err.message}`\n\t\t\t\t);\n\t\t\t\treturn { success: false, error: err };\n\t\t\t}\n\t\t})();\n\t}\n\n\t/**\n\t * Execute a background agent (external CLI process)\n\t * T054: Implement background agent execution path\n\t */\n\tprivate executeBackgroundAgent(\n\t\tparams: CustomActionParams,\n\t\ttemplateContext: ParserTemplateContext\n\t): Promise<{ success: boolean; error?: Error }> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executing background agent: ${params.agentId}`\n\t\t);\n\n\t\treturn (async () => {\n\t\t\ttry {\n\t\t\t\t// Extract agent name from agentId (format: \"local:agent-name\")\n\t\t\t\tconst agentName =\n\t\t\t\t\tparams.agentId?.replace(AGENT_ID_PREFIX_PATTERN, \"\") ||\n\t\t\t\t\tparams.agentName;\n\t\t\t\tif (!agentName) {\n\t\t\t\t\tthrow new Error(\"Agent name is required for background execution\");\n\t\t\t\t}\n\n\t\t\t\t// Read the agent file from .github/agents/\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\tconst { join } = await import(\"node:path\");\n\n\t\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\t\tif (!workspaceRoot) {\n\t\t\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t\t\t}\n\n\t\t\t\tconst agentFilePath = join(\n\t\t\t\t\tworkspaceRoot,\n\t\t\t\t\t\".github\",\n\t\t\t\t\t\"agents\",\n\t\t\t\t\t`${agentName}.agent.md`\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Reading agent file: ${agentFilePath}`\n\t\t\t\t);\n\n\t\t\t\t// Verify agent file exists\n\t\t\t\tawait fs.access(agentFilePath);\n\n\t\t\t\t// Expand template variables in prompt and arguments\n\t\t\t\tconst userPrompt = params.prompt\n\t\t\t\t\t? this.expandTemplate(params.prompt, templateContext)\n\t\t\t\t\t: \"\";\n\t\t\t\tconst userArgs = params.arguments\n\t\t\t\t\t? this.expandTemplate(params.arguments, templateContext)\n\t\t\t\t\t: \"\";\n\n\t\t\t\t// Build the gh copilot command with CLI options\n\t\t\t\tconst commandArgs = this.buildCopilotCliArgs(\n\t\t\t\t\tparams,\n\t\t\t\t\tagentFilePath,\n\t\t\t\t\tuserPrompt,\n\t\t\t\t\tuserArgs\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Executing: gh ${commandArgs.slice(1).join(\" \")}`\n\t\t\t\t);\n\n\t\t\t\t// Execute gh copilot command\n\t\t\t\tconst proc = spawn(\"gh\", commandArgs, {\n\t\t\t\t\tcwd: workspaceRoot,\n\t\t\t\t\tshell: true,\n\t\t\t\t});\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tlet stdout = \"\";\n\t\t\t\t\tlet stderr = \"\";\n\n\t\t\t\t\tproc.stdout.on(\"data\", (data: Buffer) => {\n\t\t\t\t\t\tconst text = data.toString();\n\t\t\t\t\t\tstdout += text;\n\t\t\t\t\t\tthis.outputChannel.append(text);\n\t\t\t\t\t});\n\n\t\t\t\t\tproc.stderr.on(\"data\", (data: Buffer) => {\n\t\t\t\t\t\tconst text = data.toString();\n\t\t\t\t\t\tstderr += text;\n\t\t\t\t\t\tthis.outputChannel.append(text);\n\t\t\t\t\t});\n\n\t\t\t\t\tproc.on(\"exit\", (code: number | null) => {\n\t\t\t\t\t\tif (code === 0) {\n\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\"[HookExecutor] Background agent execution completed successfully\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t`[HookExecutor] Output: ${stdout.trim()}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Background agent failed with exit code ${code}: ${stderr.trim()}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t`[HookExecutor] Background agent execution failed: ${error.message}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve({ success: false, error });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tproc.on(\"error\", (error: Error) => {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Background agent execution error: ${error.message}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if it's a \"command not found\" error\n\t\t\t\t\t\tif (error.message.includes(\"ENOENT\")) {\n\t\t\t\t\t\t\tconst enhancedError = new Error(\n\t\t\t\t\t\t\t\t\"GitHub CLI (gh) not found. Please install it: https://cli.github.com/\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve({ success: false, error: enhancedError });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve({ success: false, error });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconst err = error as Error;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Background agent execution failed: ${err.message}`\n\t\t\t\t);\n\t\t\t\treturn { success: false, error: err };\n\t\t\t}\n\t\t})();\n\t}\n\n\t/**\n\t * Build GitHub Copilot CLI arguments with all supported options\n\t */\n\tprivate buildCopilotCliArgs(\n\t\tparams: CustomActionParams,\n\t\tagentFilePath: string,\n\t\tuserPrompt: string,\n\t\tuserArgs: string\n\t): string[] {\n\t\tconst args = [\"copilot\", \"-p\"];\n\n\t\t// Start with prompt\n\t\tif (userPrompt) {\n\t\t\targs.push(userPrompt);\n\t\t}\n\n\t\t// Add agent file\n\t\targs.push(\"--agent\", agentFilePath);\n\n\t\t// Add user arguments\n\t\tif (userArgs) {\n\t\t\targs.push(userArgs);\n\t\t}\n\n\t\t// Add CLI options if provided\n\t\tconst opts = params.cliOptions;\n\t\tif (!opts) {\n\t\t\treturn args;\n\t\t}\n\n\t\t// Combined flags (--allow-all / --yolo)\n\t\tif (opts.allowAll) {\n\t\t\targs.push(\"--allow-all\");\n\t\t\treturn args; // No need to add individual permissions\n\t\t}\n\n\t\t// Add all option groups\n\t\tthis.addPathOptions(args, opts);\n\t\tthis.addToolPermissions(args, opts);\n\t\tthis.addUrlPermissions(args, opts);\n\t\tthis.addGithubMcpOptions(args, opts);\n\t\tthis.addMcpServerOptions(args, opts);\n\t\tthis.addExecutionOptions(args, opts);\n\t\tthis.addOutputOptions(args, opts);\n\t\tthis.addSessionOptions(args, opts);\n\t\tthis.addConfigOptions(args, opts);\n\n\t\treturn args;\n\t}\n\n\tprivate addPathOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.addDir) {\n\t\t\tfor (const dir of opts.addDir) {\n\t\t\t\targs.push(\"--add-dir\", dir);\n\t\t\t}\n\t\t}\n\t\tif (opts.allowAllPaths) {\n\t\t\targs.push(\"--allow-all-paths\");\n\t\t}\n\t\tif (opts.disallowTempDir) {\n\t\t\targs.push(\"--disallow-temp-dir\");\n\t\t}\n\t}\n\n\tprivate addToolPermissions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.allowAllTools) {\n\t\t\targs.push(\"--allow-all-tools\");\n\t\t}\n\t\tif (opts.allowTool) {\n\t\t\targs.push(\"--allow-tool\", ...opts.allowTool);\n\t\t}\n\t\tif (opts.availableTools) {\n\t\t\targs.push(\"--available-tools\", ...opts.availableTools);\n\t\t}\n\t\tif (opts.excludedTools) {\n\t\t\targs.push(\"--excluded-tools\", ...opts.excludedTools);\n\t\t}\n\t\tif (opts.denyTool) {\n\t\t\targs.push(\"--deny-tool\", ...opts.denyTool);\n\t\t}\n\t}\n\n\tprivate addUrlPermissions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.allowAllUrls) {\n\t\t\targs.push(\"--allow-all-urls\");\n\t\t}\n\t\tif (opts.allowUrl) {\n\t\t\targs.push(\"--allow-url\", ...opts.allowUrl);\n\t\t}\n\t\tif (opts.denyUrl) {\n\t\t\targs.push(\"--deny-url\", ...opts.denyUrl);\n\t\t}\n\t}\n\n\tprivate addGithubMcpOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.enableAllGithubMcpTools) {\n\t\t\targs.push(\"--enable-all-github-mcp-tools\");\n\t\t}\n\t\tif (opts.addGithubMcpTool) {\n\t\t\tfor (const tool of opts.addGithubMcpTool) {\n\t\t\t\targs.push(\"--add-github-mcp-tool\", tool);\n\t\t\t}\n\t\t}\n\t\tif (opts.addGithubMcpToolset) {\n\t\t\tfor (const toolset of opts.addGithubMcpToolset) {\n\t\t\t\targs.push(\"--add-github-mcp-toolset\", toolset);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate addMcpServerOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.additionalMcpConfig) {\n\t\t\tfor (const config of opts.additionalMcpConfig) {\n\t\t\t\targs.push(\"--additional-mcp-config\", config);\n\t\t\t}\n\t\t}\n\t\tif (opts.disableBuiltinMcps) {\n\t\t\targs.push(\"--disable-builtin-mcps\");\n\t\t}\n\t\tif (opts.disableMcpServer) {\n\t\t\tfor (const server of opts.disableMcpServer) {\n\t\t\t\targs.push(\"--disable-mcp-server\", server);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate addExecutionOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.agent) {\n\t\t\targs.push(\"--agent\", opts.agent);\n\t\t}\n\t\tif (opts.model) {\n\t\t\targs.push(\"--model\", opts.model);\n\t\t}\n\t\tif (opts.noAskUser) {\n\t\t\targs.push(\"--no-ask-user\");\n\t\t}\n\t\tif (opts.disableParallelToolsExecution) {\n\t\t\targs.push(\"--disable-parallel-tools-execution\");\n\t\t}\n\t\tif (opts.noCustomInstructions) {\n\t\t\targs.push(\"--no-custom-instructions\");\n\t\t}\n\t}\n\n\tprivate addOutputOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.silent) {\n\t\t\targs.push(\"--silent\");\n\t\t}\n\t\tif (opts.logLevel) {\n\t\t\targs.push(\"--log-level\", opts.logLevel);\n\t\t}\n\t\tif (opts.logDir) {\n\t\t\targs.push(\"--log-dir\", opts.logDir);\n\t\t}\n\t\tif (opts.noColor) {\n\t\t\targs.push(\"--no-color\");\n\t\t}\n\t\tif (opts.plainDiff) {\n\t\t\targs.push(\"--plain-diff\");\n\t\t}\n\t\tif (opts.screenReader) {\n\t\t\targs.push(\"--screen-reader\");\n\t\t}\n\t\tif (opts.stream) {\n\t\t\targs.push(\"--stream\", opts.stream);\n\t\t}\n\t}\n\n\tprivate addSessionOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.resume) {\n\t\t\tif (typeof opts.resume === \"string\") {\n\t\t\t\targs.push(\"--resume\", opts.resume);\n\t\t\t} else {\n\t\t\t\targs.push(\"--resume\");\n\t\t\t}\n\t\t}\n\t\tif (opts.continue) {\n\t\t\targs.push(\"--continue\");\n\t\t}\n\t\tif (opts.share) {\n\t\t\tif (typeof opts.share === \"string\") {\n\t\t\t\targs.push(\"--share\", opts.share);\n\t\t\t} else {\n\t\t\t\targs.push(\"--share\");\n\t\t\t}\n\t\t}\n\t\tif (opts.shareGist) {\n\t\t\targs.push(\"--share-gist\");\n\t\t}\n\t}\n\n\tprivate addConfigOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.configDir) {\n\t\t\targs.push(\"--config-dir\", opts.configDir);\n\t\t}\n\t\tif (opts.banner) {\n\t\t\targs.push(\"--banner\");\n\t\t}\n\t\tif (opts.noAutoUpdate) {\n\t\t\targs.push(\"--no-auto-update\");\n\t\t}\n\t}\n}",
    "start_line": 149,
    "end_line": 1608,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HookExecutor",
    "component_id": "src.features.hooks.hook-executor.HookExecutor"
  },
  "src.features.hooks.hook-executor.initialize": {
    "id": "src.features.hooks.hook-executor.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "initialize(): void {\n\t\t// Subscribe to trigger events\n\t\tthis.triggerRegistry.onTrigger(async (event) => {\n\t\t\tconst timing = event.timing || \"after\";\n\t\t\tawait this.executeHooksForTrigger(\n\t\t\t\tevent.agent,\n\t\t\t\tevent.operation,\n\t\t\t\ttiming,\n\t\t\t\tevent\n\t\t\t);\n\t\t});\n\n\t\tthis.outputChannel.appendLine(\"[HookExecutor] Initialized\");\n\t}",
    "start_line": 209,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method initialize",
    "component_id": "src.features.hooks.hook-executor.initialize"
  },
  "src.features.hooks.hook-executor.dispose": {
    "id": "src.features.hooks.hook-executor.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis._onExecutionStarted.dispose();\n\t\tthis._onExecutionCompleted.dispose();\n\t\tthis._onExecutionFailed.dispose();\n\t\tthis.outputChannel.appendLine(\"[HookExecutor] Disposed\");\n\t}",
    "start_line": 227,
    "end_line": 232,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.hook-executor.dispose"
  },
  "src.features.hooks.hook-executor.executeHook": {
    "id": "src.features.hooks.hook-executor.executeHook",
    "name": "executeHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "async executeHook(\n\t\thook: Hook,\n\t\tcontext?: ExecutionContext,\n\t\ttriggerEvent?: TriggerEvent\n\t): Promise<ExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\t// Check if hook is enabled\n\t\tif (!hook.enabled) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Skipping disabled hook: ${hook.name} (${hook.id})`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\thookId: hook.id,\n\t\t\t\thookName: hook.name,\n\t\t\t\tstatus: \"skipped\",\n\t\t\t\tduration: Date.now() - startTime,\n\t\t\t};\n\t\t}\n\n\t\t// T087: Validate MCP hooks before execution\n\t\tif (hook.action.type === \"mcp\") {\n\t\t\ttry {\n\t\t\t\tconst validation = await this.hookManager.validateHook(hook);\n\t\t\t\tif (!validation.valid) {\n\t\t\t\t\tconst errorMessages = validation.errors\n\t\t\t\t\t\t.map((e) => `${e.field}: ${e.message}`)\n\t\t\t\t\t\t.join(\", \");\n\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Skipping invalid MCP hook: ${hook.name} - ${errorMessages}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// T088-T089: Show error notification with actions\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tconst action = await window.showErrorMessage(\n\t\t\t\t\t\t`Hook \"${hook.name}\" has invalid MCP configuration: ${validation.errors[0]?.message ?? \"Unknown error\"}`,\n\t\t\t\t\t\t\"Update Hook\",\n\t\t\t\t\t\t\"Remove Hook\",\n\t\t\t\t\t\t\"Cancel\"\n\t\t\t\t\t);\n\n\t\t\t\t\tif (action === \"Update Hook\") {\n\t\t\t\t\t\t// Trigger hook edit (command will be implemented in hook view)\n\t\t\t\t\t\tawait commands.executeCommand(\"gatomia.hooks.editHook\", hook.id);\n\t\t\t\t\t} else if (action === \"Remove Hook\") {\n\t\t\t\t\t\tawait this.hookManager.deleteHook(hook.id);\n\t\t\t\t\t\twindow.showInformationMessage(`Hook \"${hook.name}\" removed`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\thookId: hook.id,\n\t\t\t\t\t\thookName: hook.name,\n\t\t\t\t\t\tstatus: \"skipped\",\n\t\t\t\t\t\tduration: Date.now() - startTime,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: errorMessages,\n\t\t\t\t\t\t\tcode: \"InvalidMCPConfiguration\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Graceful degradation - log error and continue\n\t\t\t\tconst err = error as Error;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Warning: Failed to validate MCP hook: ${err.message}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// T081: Check agent availability before execution for custom hooks\n\t\tif (hook.action.type === \"custom\") {\n\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\t\tconst agentId = customParams.agentId || customParams.agentName;\n\n\t\t\tif (agentId && this.agentRegistry) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check agent availability\n\t\t\t\t\tconst availability =\n\t\t\t\t\t\tawait this.agentRegistry.checkAgentAvailability(agentId);\n\n\t\t\t\t\tif (!availability.available) {\n\t\t\t\t\t\t// Determine reason text\n\t\t\t\t\t\tlet reasonText: string;\n\t\t\t\t\t\tif (availability.reason === \"FILE_DELETED\") {\n\t\t\t\t\t\t\treasonText = \"agent file was deleted\";\n\t\t\t\t\t\t} else if (availability.reason === \"EXTENSION_UNINSTALLED\") {\n\t\t\t\t\t\t\treasonText = \"extension is uninstalled\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treasonText = \"agent is unavailable\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst errorMessage = `Agent \"${agentId}\" is not available: ${reasonText}`;\n\n\t\t\t\t\t\t// T082: Log detailed error information\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Agent unavailable - Hook: ${hook.name} (${hook.id})`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Agent ID: ${agentId}, Reason: ${availability.reason}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Trigger: ${hook.trigger.agent}.${hook.trigger.operation} (${hook.trigger.timing})`\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Emit execution failed event\n\t\t\t\t\t\tconst errorResult: ExecutionResult = {\n\t\t\t\t\t\t\thookId: hook.id,\n\t\t\t\t\t\t\thookName: hook.name,\n\t\t\t\t\t\t\tstatus: \"failure\",\n\t\t\t\t\t\t\tduration: Date.now() - startTime,\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\tmessage: errorMessage,\n\t\t\t\t\t\t\t\tcode: \"AgentUnavailable\",\n\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\tagentId,\n\t\t\t\t\t\t\t\t\treason: availability.reason,\n\t\t\t\t\t\t\t\t\tcheckedAt: availability.checkedAt,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._onExecutionFailed.fire({\n\t\t\t\t\t\t\thook,\n\t\t\t\t\t\t\tcontext: context || this.createExecutionContext(),\n\t\t\t\t\t\t\tresult: errorResult,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Show error notification with retry option\n\t\t\t\t\t\tconst action = await window.showErrorMessage(\n\t\t\t\t\t\t\t`Hook \"${hook.name}\" failed: ${errorMessage}`,\n\t\t\t\t\t\t\t\"Retry\",\n\t\t\t\t\t\t\t\"Update Hook\",\n\t\t\t\t\t\t\t\"Cancel\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (action === \"Retry\") {\n\t\t\t\t\t\t\t// Retry execution\n\t\t\t\t\t\t\treturn await this.executeHook(hook, context, triggerEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (action === \"Update Hook\") {\n\t\t\t\t\t\t\tawait commands.executeCommand(\"gatomia.hooks.editHook\", hook.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn errorResult;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Graceful degradation - log error and continue\n\t\t\t\t\tconst err = error as Error;\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Warning: Failed to check agent availability: ${err.message}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create or use existing context\n\t\tconst execContext = context || this.createExecutionContext();\n\n\t\ttry {\n\t\t\t// Check for circular dependency\n\t\t\tif (this.isCircularDependency(hook.id, execContext)) {\n\t\t\t\tthrow new CircularDependencyError(\n\t\t\t\t\t`Circular dependency detected: ${hook.name}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check max depth\n\t\t\tif (this.isMaxDepthExceeded(execContext)) {\n\t\t\t\tthrow new MaxDepthExceededError(\n\t\t\t\t\t`Maximum chain depth (${MAX_CHAIN_DEPTH}) exceeded`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Add hook to executed set\n\t\t\texecContext.executedHooks.add(hook.id);\n\t\t\texecContext.chainDepth += 1;\n\n\t\t\t// Build template context\n\t\t\t// Extract trigger type from hook's trigger configuration\n\t\t\tconst templateContext = await this.buildTemplateContext(\n\t\t\t\thook.trigger.operation,\n\t\t\t\tundefined,\n\t\t\t\ttriggerEvent\n\t\t\t);\n\n\t\t\t// Emit execution started event\n\t\t\tthis._onExecutionStarted.fire({\n\t\t\t\thook,\n\t\t\t\tcontext: execContext,\n\t\t\t});\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Executing hook: ${hook.name} (${hook.id})`\n\t\t\t);\n\n\t\t\t// Execute action based on type\n\t\t\tlet actionResult: { success: boolean; error?: Error };\n\n\t\t\t// T074: Add detailed logging for MCP actions\n\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] MCP Action: ${mcpParams.serverId}/${mcpParams.toolName}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tswitch (hook.action.type) {\n\t\t\t\tcase \"agent\": {\n\t\t\t\t\t// Expand templates in command\n\t\t\t\t\tconst agentParams = hook.action.parameters as AgentActionParams;\n\t\t\t\t\tconst command = this.expandTemplate(\n\t\t\t\t\t\tagentParams.command,\n\t\t\t\t\t\ttemplateContext\n\t\t\t\t\t);\n\n\t\t\t\t\t// Execute with timeout\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.agentExecutor.execute({\n\t\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"git\": {\n\t\t\t\t\tconst gitParams = hook.action.parameters as GitActionParams;\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() => this.gitExecutor.execute(gitParams, templateContext),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"github\": {\n\t\t\t\t\tconst githubParams = hook.action.parameters as GitHubActionParams;\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() => this.githubExecutor.execute(githubParams, templateContext),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"mcp\": {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t() => this.mcpExecutor.execute(mcpParams, templateContext),\n\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"custom\": {\n\t\t\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\n\t\t\t\t\t// Determine agent type (override or default from registry)\n\t\t\t\t\tlet agentType = customParams.agentType;\n\t\t\t\t\tif (!agentType && customParams.agentId) {\n\t\t\t\t\t\tconst agent = this.agentRegistry.getAgentById(customParams.agentId);\n\t\t\t\t\t\tagentType = agent?.type;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Custom action - Agent type: ${agentType || \"unknown\"}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Route based on agent type\n\t\t\t\t\tif (agentType === \"local\") {\n\t\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t\t() => this.executeLocalAgent(customParams, templateContext),\n\t\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (agentType === \"background\") {\n\t\t\t\t\t\tactionResult = await this.executeWithTimeout(\n\t\t\t\t\t\t\t() => this.executeBackgroundAgent(customParams, templateContext),\n\t\t\t\t\t\t\tACTION_TIMEOUT_MS\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown agent type: ${agentType}. Agent ID: ${customParams.agentId}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported action type: ${hook.action.type}`);\n\t\t\t}\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// Create execution result\n\t\t\tconst result: ExecutionResult = {\n\t\t\t\thookId: hook.id,\n\t\t\t\thookName: hook.name,\n\t\t\t\tstatus: actionResult.success ? \"success\" : \"failure\",\n\t\t\t\tduration,\n\t\t\t\terror: actionResult.error\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tmessage: actionResult.error.message,\n\t\t\t\t\t\t\tcode: actionResult.error.name || \"UnknownError\",\n\t\t\t\t\t\t\tdetails: actionResult.error,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\t// Record execution log\n\t\t\tthis.recordExecutionLog({\n\t\t\t\tid: randomUUID(),\n\t\t\t\thookId: hook.id,\n\t\t\t\texecutionId: execContext.executionId,\n\t\t\t\tchainDepth: execContext.chainDepth,\n\t\t\t\ttriggeredAt: startTime,\n\t\t\t\tcompletedAt: Date.now(),\n\t\t\t\tduration,\n\t\t\t\tstatus: result.status,\n\t\t\t\terror: result.error,\n\t\t\t\tcontextSnapshot: templateContext,\n\t\t\t});\n\n\t\t\t// Emit appropriate event\n\t\t\tif (result.status === \"success\") {\n\t\t\t\tthis._onExecutionCompleted.fire({\n\t\t\t\t\thook,\n\t\t\t\t\tcontext: execContext,\n\t\t\t\t\tresult,\n\t\t\t\t});\n\n\t\t\t\t// T076: Show success notification for MCP actions\n\t\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\twindow.showInformationMessage(\n\t\t\t\t\t\t`MCP Tool \"${mcpParams.toolName}\" executed successfully (${duration}ms)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor]  Hook execution success: ${hook.name} (${duration}ms)`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// T084: Enhanced failure logging with full context\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[HookExecutor] ==================== HOOK EXECUTION FAILURE ====================\"\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Hook: ${hook.name} (${hook.id})`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Trigger: ${hook.trigger.agent}.${hook.trigger.operation} (${hook.trigger.timing})`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Action Type: ${hook.action.type}`\n\t\t\t\t);\n\n\t\t\t\t// Add action-specific context\n\t\t\t\tif (hook.action.type === \"custom\") {\n\t\t\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Agent ID: ${customParams.agentId || customParams.agentName || \"unknown\"}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Agent Type: ${customParams.agentType || \"unknown\"}`\n\t\t\t\t\t);\n\t\t\t\t} else if (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] MCP Server: ${mcpParams.serverId}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] MCP Tool: ${mcpParams.toolName}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (result.error) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Error Code: ${result.error.code}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookExecutor] Error Message: ${result.error.message}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Log stack trace if available in details\n\t\t\t\t\tconst errorDetails = result.error.details as any;\n\t\t\t\t\tif (errorDetails?.stack) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Stack Trace:\\n${errorDetails.stack}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Duration: ${duration}ms`);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Execution ID: ${execContext.executionId}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Chain Depth: ${execContext.chainDepth}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[HookExecutor] ================================================================\"\n\t\t\t\t);\n\n\t\t\t\tthis._onExecutionFailed.fire({\n\t\t\t\t\thook,\n\t\t\t\t\tcontext: execContext,\n\t\t\t\t\tresult,\n\t\t\t\t});\n\n\t\t\t\t// T077: Show error notification for MCP actions\n\t\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\t\tconst errorMsg = result.error?.message ?? \"Unknown error\";\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`MCP Tool \"${mcpParams.toolName}\" failed: ${errorMsg}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\t\t\tconst err = error as Error;\n\n\t\t\t// T084: Enhanced error logging with full context\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[HookExecutor] ==================== HOOK EXECUTION ERROR ====================\"\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Hook: ${hook.name} (${hook.id})`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Trigger: ${hook.trigger.agent}.${hook.trigger.operation} (${hook.trigger.timing})`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Action Type: ${hook.action.type}`\n\t\t\t);\n\n\t\t\t// Add action-specific context\n\t\t\tif (hook.action.type === \"custom\") {\n\t\t\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Agent ID: ${customParams.agentId || customParams.agentName || \"unknown\"}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Agent Type: ${customParams.agentType || \"unknown\"}`\n\t\t\t\t);\n\t\t\t} else if (hook.action.type === \"mcp\") {\n\t\t\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] MCP Server: ${mcpParams.serverId}`\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] MCP Tool: ${mcpParams.toolName}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Error: ${err.name}`);\n\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Message: ${err.message}`);\n\n\t\t\t// Include stack trace for debugging\n\t\t\tif (err.stack) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Stack Trace:\\n${err.stack}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(`[HookExecutor] Duration: ${duration}ms`);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Execution ID: ${execContext.executionId}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Chain Depth: ${execContext.chainDepth}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[HookExecutor] ================================================================\"\n\t\t\t);\n\n\t\t\tconst result: ExecutionResult = {\n\t\t\t\thookId: hook.id,\n\t\t\t\thookName: hook.name,\n\t\t\t\tstatus: \"failure\",\n\t\t\t\tduration,\n\t\t\t\terror: {\n\t\t\t\t\tmessage: err.message,\n\t\t\t\t\tcode: err.name || \"UnknownError\",\n\t\t\t\t\tdetails: err,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Record execution log\n\t\t\tthis.recordExecutionLog({\n\t\t\t\tid: randomUUID(),\n\t\t\t\thookId: hook.id,\n\t\t\t\texecutionId: execContext.executionId,\n\t\t\t\tchainDepth: execContext.chainDepth,\n\t\t\t\ttriggeredAt: startTime,\n\t\t\t\tcompletedAt: Date.now(),\n\t\t\t\tduration,\n\t\t\t\tstatus: \"failure\",\n\t\t\t\terror: result.error,\n\t\t\t\tcontextSnapshot: {}, // Empty context on early failure\n\t\t\t});\n\n\t\t\t// Emit failed event\n\t\t\tthis._onExecutionFailed.fire({\n\t\t\t\thook,\n\t\t\t\tcontext: execContext,\n\t\t\t\tresult,\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\t}",
    "start_line": 239,
    "end_line": 749,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook",
      "context",
      "triggerEvent"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeHook",
    "component_id": "src.features.hooks.hook-executor.executeHook"
  },
  "src.features.hooks.hook-executor.executeHooksForTrigger": {
    "id": "src.features.hooks.hook-executor.executeHooksForTrigger",
    "name": "executeHooksForTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "async executeHooksForTrigger(\n\t\tagent: string,\n\t\toperation: string,\n\t\ttiming: \"before\" | \"after\" = \"after\",\n\t\ttriggerEvent?: TriggerEvent\n\t): Promise<ExecutionResult[]> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executing hooks for trigger: ${agent}.${operation} (${timing})`\n\t\t);\n\n\t\t// Get all enabled hooks matching trigger and timing\n\t\tconst allHooks = await this.hookManager.getAllHooks();\n\t\tconst matchingHooks = allHooks\n\t\t\t.filter(\n\t\t\t\t(h) =>\n\t\t\t\t\th.enabled &&\n\t\t\t\t\th.trigger.agent === agent &&\n\t\t\t\t\th.trigger.operation === operation &&\n\t\t\t\t\th.trigger.timing === timing\n\t\t\t)\n\t\t\t.sort((a, b) => a.createdAt - b.createdAt); // Deterministic order\n\n\t\tif (matchingHooks.length === 0) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] No enabled hooks found for trigger: ${agent}.${operation} (${timing})`\n\t\t\t);\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create shared execution context\n\t\tconst context = this.createExecutionContext();\n\n\t\t// Execute hooks based on waitForCompletion setting\n\t\tconst results: ExecutionResult[] = [];\n\t\tfor (const hook of matchingHooks) {\n\t\t\tif (timing === \"before\" && hook.trigger.waitForCompletion) {\n\t\t\t\t// Blocking execution: wait for hook to complete\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Executing blocking before hook: ${hook.name}`\n\t\t\t\t);\n\t\t\t\tconst result = await this.executeHook(hook, context, triggerEvent);\n\t\t\t\tresults.push(result);\n\t\t\t} else {\n\t\t\t\t// Non-blocking execution: execute in parallel\n\t\t\t\tconst result = await this.executeHook(hook, context, triggerEvent);\n\t\t\t\tresults.push(result);\n\t\t\t}\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executed ${results.length} hooks for trigger: ${agent}.${operation} (${timing})`\n\t\t);\n\n\t\treturn results;\n\t}",
    "start_line": 754,
    "end_line": 808,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "operation",
      "timing",
      "triggerEvent"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeHooksForTrigger",
    "component_id": "src.features.hooks.hook-executor.executeHooksForTrigger"
  },
  "src.features.hooks.hook-executor.createExecutionContext": {
    "id": "src.features.hooks.hook-executor.createExecutionContext",
    "name": "createExecutionContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "createExecutionContext(): ExecutionContext {\n\t\treturn {\n\t\t\texecutionId: randomUUID(),\n\t\t\tchainDepth: 0,\n\t\t\texecutedHooks: new Set<string>(),\n\t\t\tstartedAt: Date.now(),\n\t\t};\n\t}",
    "start_line": 813,
    "end_line": 820,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createExecutionContext",
    "component_id": "src.features.hooks.hook-executor.createExecutionContext"
  },
  "src.features.hooks.hook-executor.isCircularDependency": {
    "id": "src.features.hooks.hook-executor.isCircularDependency",
    "name": "isCircularDependency",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "isCircularDependency(hookId: string, context: ExecutionContext): boolean {\n\t\treturn context.executedHooks.has(hookId);\n\t}",
    "start_line": 825,
    "end_line": 827,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isCircularDependency",
    "component_id": "src.features.hooks.hook-executor.isCircularDependency"
  },
  "src.features.hooks.hook-executor.isMaxDepthExceeded": {
    "id": "src.features.hooks.hook-executor.isMaxDepthExceeded",
    "name": "isMaxDepthExceeded",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "isMaxDepthExceeded(context: ExecutionContext): boolean {\n\t\treturn context.chainDepth >= MAX_CHAIN_DEPTH;\n\t}",
    "start_line": 832,
    "end_line": 834,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isMaxDepthExceeded",
    "component_id": "src.features.hooks.hook-executor.isMaxDepthExceeded"
  },
  "src.features.hooks.hook-executor.buildTemplateContext": {
    "id": "src.features.hooks.hook-executor.buildTemplateContext",
    "name": "buildTemplateContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "async buildTemplateContext(\n\t\ttriggerOperation: string,\n\t\ttriggerData?: Record<string, unknown>,\n\t\ttriggerEvent?: TriggerEvent\n\t): Promise<ParserTemplateContext> {\n\t\ttry {\n\t\t\tconst gitContext = await this.buildGitContext();\n\t\t\tconst workspacePath = workspace.workspaceFolders?.[0]?.uri.fsPath || \"\";\n\n\t\t\t// Build base context with standard variables\n\t\t\tconst baseContext: ParserTemplateContext = {\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\ttriggerType: triggerOperation as OperationType,\n\t\t\t\t...gitContext,\n\t\t\t\tworkspacePath,\n\t\t\t};\n\n\t\t\t// Add trigger-specific data if available\n\t\t\tif (triggerData) {\n\t\t\t\tthis.enrichContextWithTriggerData(baseContext, triggerData);\n\t\t\t}\n\n\t\t\t// Add output capture variables\n\t\t\tif (triggerEvent) {\n\t\t\t\tawait this.addOutputVariables(baseContext, triggerEvent);\n\t\t\t}\n\n\t\t\treturn baseContext;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Warning: Failed to build template context: ${error}`\n\t\t\t);\n\n\t\t\t// Return minimal context on error\n\t\t\treturn this.buildMinimalContext(triggerOperation);\n\t\t}\n\t}",
    "start_line": 839,
    "end_line": 875,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "triggerOperation",
      "triggerData",
      "triggerEvent"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method buildTemplateContext",
    "component_id": "src.features.hooks.hook-executor.buildTemplateContext"
  },
  "src.features.hooks.hook-executor.buildGitContext": {
    "id": "src.features.hooks.hook-executor.buildGitContext",
    "name": "buildGitContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private async buildGitContext(): Promise<Partial<ParserTemplateContext>> {\n\t\tconst gitExtension = extensions.getExtension(\"vscode.git\");\n\t\tconst git = gitExtension?.exports.getAPI(1);\n\t\tconst repository = git?.repositories[0];\n\n\t\tif (!repository) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst branch = repository.state.HEAD?.name;\n\t\tconst user = await repository.getConfig(\"user.name\");\n\t\tconst feature = branch ? this.extractFeatureName(branch) : undefined;\n\n\t\t// Extract repository info from remote URL\n\t\tconst remoteUrl = await repository.getConfig(\"remote.origin.url\");\n\t\tconst repoInfo = this.parseGitRemoteUrl(remoteUrl || \"\");\n\n\t\treturn {\n\t\t\tbranch,\n\t\t\tuser,\n\t\t\tfeature,\n\t\t\trepoOwner: repoInfo.owner,\n\t\t\trepoName: repoInfo.name,\n\t\t};\n\t}",
    "start_line": 880,
    "end_line": 904,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method buildGitContext",
    "component_id": "src.features.hooks.hook-executor.buildGitContext"
  },
  "src.features.hooks.hook-executor.enrichContextWithTriggerData": {
    "id": "src.features.hooks.hook-executor.enrichContextWithTriggerData",
    "name": "enrichContextWithTriggerData",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private enrichContextWithTriggerData(\n\t\tcontext: ParserTemplateContext,\n\t\ttriggerData: Record<string, unknown>\n\t): void {\n\t\t// Spec-related variables\n\t\tthis.addSpecVariables(context, triggerData);\n\n\t\t// Spec artifact variables\n\t\tthis.addArtifactVariables(context, triggerData);\n\n\t\t// Agent metadata\n\t\tthis.addAgentMetadata(context, triggerData);\n\t}",
    "start_line": 909,
    "end_line": 921,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "triggerData"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method enrichContextWithTriggerData",
    "component_id": "src.features.hooks.hook-executor.enrichContextWithTriggerData"
  },
  "src.features.hooks.hook-executor.addSpecVariables": {
    "id": "src.features.hooks.hook-executor.addSpecVariables",
    "name": "addSpecVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addSpecVariables(\n\t\tcontext: ParserTemplateContext,\n\t\tdata: Record<string, unknown>\n\t): void {\n\t\tconst specFields = [\n\t\t\t\"specId\",\n\t\t\t\"specPath\",\n\t\t\t\"oldStatus\",\n\t\t\t\"newStatus\",\n\t\t\t\"changeAuthor\",\n\t\t] as const;\n\n\t\tfor (const field of specFields) {\n\t\t\tif (data[field]) {\n\t\t\t\tcontext[field] = data[field] as string;\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 926,
    "end_line": 943,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "data"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addSpecVariables",
    "component_id": "src.features.hooks.hook-executor.addSpecVariables"
  },
  "src.features.hooks.hook-executor.addArtifactVariables": {
    "id": "src.features.hooks.hook-executor.addArtifactVariables",
    "name": "addArtifactVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addArtifactVariables(\n\t\tcontext: ParserTemplateContext,\n\t\tdata: Record<string, unknown>\n\t): void {\n\t\tconst artifactFields = [\"useCaseId\", \"taskId\", \"requirementId\"] as const;\n\n\t\tfor (const field of artifactFields) {\n\t\t\tif (data[field]) {\n\t\t\t\tcontext[field] = data[field] as string;\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 948,
    "end_line": 959,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "data"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addArtifactVariables",
    "component_id": "src.features.hooks.hook-executor.addArtifactVariables"
  },
  "src.features.hooks.hook-executor.addAgentMetadata": {
    "id": "src.features.hooks.hook-executor.addAgentMetadata",
    "name": "addAgentMetadata",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addAgentMetadata(\n\t\tcontext: ParserTemplateContext,\n\t\tdata: Record<string, unknown>\n\t): void {\n\t\tif (data.agentId) {\n\t\t\tcontext.agentId = data.agentId as string;\n\t\t}\n\t\tif (data.agentType) {\n\t\t\tcontext.agentType = data.agentType as string;\n\t\t}\n\t}",
    "start_line": 964,
    "end_line": 974,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "data"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addAgentMetadata",
    "component_id": "src.features.hooks.hook-executor.addAgentMetadata"
  },
  "src.features.hooks.hook-executor.buildMinimalContext": {
    "id": "src.features.hooks.hook-executor.buildMinimalContext",
    "name": "buildMinimalContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private buildMinimalContext(triggerOperation: string): ParserTemplateContext {\n\t\treturn {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\ttriggerType: triggerOperation as OperationType,\n\t\t\tworkspacePath: workspace.workspaceFolders?.[0]?.uri.fsPath || \"\",\n\t\t};\n\t}",
    "start_line": 979,
    "end_line": 985,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "triggerOperation"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method buildMinimalContext",
    "component_id": "src.features.hooks.hook-executor.buildMinimalContext"
  },
  "src.features.hooks.hook-executor.addOutputVariables": {
    "id": "src.features.hooks.hook-executor.addOutputVariables",
    "name": "addOutputVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private async addOutputVariables(\n\t\tcontext: ParserTemplateContext,\n\t\tevent: TriggerEvent\n\t): Promise<void> {\n\t\t// 1. Add clipboard content\n\t\ttry {\n\t\t\tconst clipboardText = await env.clipboard.readText();\n\t\t\tcontext.clipboardContent = clipboardText;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Captured clipboard content (${clipboardText.length} chars)`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Failed to read clipboard: ${error}`\n\t\t\t);\n\t\t\tcontext.clipboardContent = \"\";\n\t\t}\n\n\t\t// 2. Add agent output from file (if available)\n\t\tif (event.outputPath) {\n\t\t\ttry {\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\tconst content = await fs.readFile(event.outputPath, \"utf-8\");\n\t\t\t\tcontext.agentOutput = content;\n\t\t\t\tcontext.outputPath = event.outputPath;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Captured agent output from file: ${event.outputPath} (${content.length} chars)`\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Failed to read output file ${event.outputPath}: ${error}`\n\t\t\t\t);\n\t\t\t\tcontext.agentOutput = \"\";\n\t\t\t}\n\t\t} else if (event.outputContent) {\n\t\t\t// Use pre-loaded content if provided\n\t\t\tcontext.agentOutput = event.outputContent;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Using pre-loaded agent output (${event.outputContent.length} chars)`\n\t\t\t);\n\t\t} else {\n\t\t\t// No output available\n\t\t\tcontext.agentOutput = \"\";\n\t\t}\n\t}",
    "start_line": 990,
    "end_line": 1034,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "event"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method addOutputVariables",
    "component_id": "src.features.hooks.hook-executor.addOutputVariables"
  },
  "src.features.hooks.hook-executor.parseGitRemoteUrl": {
    "id": "src.features.hooks.hook-executor.parseGitRemoteUrl",
    "name": "parseGitRemoteUrl",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private parseGitRemoteUrl(url: string): { owner: string; name: string } {\n\t\t// HTTPS: https://github.com/owner/repo.git\n\t\tconst httpsMatch = url.match(GIT_HTTPS_REMOTE_PATTERN);\n\t\tif (httpsMatch) {\n\t\t\treturn { owner: httpsMatch[1], name: httpsMatch[2] };\n\t\t}\n\n\t\t// SSH: git@github.com:owner/repo.git\n\t\tconst sshMatch = url.match(GIT_SSH_REMOTE_PATTERN);\n\t\tif (sshMatch) {\n\t\t\treturn { owner: sshMatch[1], name: sshMatch[2] };\n\t\t}\n\n\t\treturn { owner: \"\", name: \"\" };\n\t}",
    "start_line": 1040,
    "end_line": 1054,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method parseGitRemoteUrl",
    "component_id": "src.features.hooks.hook-executor.parseGitRemoteUrl"
  },
  "src.features.hooks.hook-executor.extractFeatureName": {
    "id": "src.features.hooks.hook-executor.extractFeatureName",
    "name": "extractFeatureName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private extractFeatureName(branch: string): string | undefined {\n\t\tconst match = branch.match(FEATURE_NAME_PATTERN);\n\t\treturn match ? match[1] : undefined;\n\t}",
    "start_line": 1060,
    "end_line": 1063,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "branch"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractFeatureName",
    "component_id": "src.features.hooks.hook-executor.extractFeatureName"
  },
  "src.features.hooks.hook-executor.expandTemplate": {
    "id": "src.features.hooks.hook-executor.expandTemplate",
    "name": "expandTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "expandTemplate(template: string, context: ParserTemplateContext): string {\n\t\t// Log template expansion for debugging\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Expanding template: \"${template}\"`\n\t\t);\n\n\t\t// Extract and log variables found\n\t\tconst variables = this.templateParser.extractVariables(template);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Variables found: ${variables.length > 0 ? variables.join(\", \") : \"(none)\"}`\n\t\t);\n\n\t\t// Log context values for found variables\n\t\tif (variables.length > 0) {\n\t\t\tconst contextValues = variables\n\t\t\t\t.map((varName) => {\n\t\t\t\t\tconst value = context[varName];\n\t\t\t\t\treturn `${varName}=${value !== undefined ? JSON.stringify(value) : \"(undefined)\"}`;\n\t\t\t\t})\n\t\t\t\t.join(\", \");\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookExecutor] Context values: ${contextValues}`\n\t\t\t);\n\t\t}\n\n\t\t// Perform substitution\n\t\tconst result = this.templateParser.substitute(template, context);\n\n\t\t// Log final result\n\t\tthis.outputChannel.appendLine(`[HookExecutor] Result: \"${result}\"`);\n\n\t\treturn result;\n\t}",
    "start_line": 1069,
    "end_line": 1101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method expandTemplate",
    "component_id": "src.features.hooks.hook-executor.expandTemplate"
  },
  "src.features.hooks.hook-executor.executeWithTimeout": {
    "id": "src.features.hooks.hook-executor.executeWithTimeout",
    "name": "executeWithTimeout",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private executeWithTimeout<T>(\n\t\tfn: () => Promise<T>,\n\t\ttimeoutMs: number\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\treject(\n\t\t\t\t\tnew ExecutionTimeoutError(`Execution timed out after ${timeoutMs}ms`)\n\t\t\t\t);\n\t\t\t}, timeoutMs);\n\n\t\t\tfn()\n\t\t\t\t.then((result) => {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\tresolve(result);\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t});\n\t}",
    "start_line": 1106,
    "end_line": 1127,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fn",
      "timeoutMs"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method executeWithTimeout",
    "component_id": "src.features.hooks.hook-executor.executeWithTimeout"
  },
  "src.features.hooks.hook-executor.recordExecutionLog": {
    "id": "src.features.hooks.hook-executor.recordExecutionLog",
    "name": "recordExecutionLog",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private recordExecutionLog(log: HookExecutionLog): void {\n\t\tthis.executionLogs.push(log);\n\n\t\t// Prune old logs (FIFO)\n\t\tif (this.executionLogs.length > MAX_EXECUTION_LOGS) {\n\t\t\tthis.executionLogs.shift();\n\t\t}\n\t}",
    "start_line": 1132,
    "end_line": 1139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "log"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method recordExecutionLog",
    "component_id": "src.features.hooks.hook-executor.recordExecutionLog"
  },
  "src.features.hooks.hook-executor.getExecutionLogs": {
    "id": "src.features.hooks.hook-executor.getExecutionLogs",
    "name": "getExecutionLogs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "getExecutionLogs(): HookExecutionLog[] {\n\t\treturn [...this.executionLogs]; // Return copy\n\t}",
    "start_line": 1144,
    "end_line": 1146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getExecutionLogs",
    "component_id": "src.features.hooks.hook-executor.getExecutionLogs"
  },
  "src.features.hooks.hook-executor.getExecutionLogsForHook": {
    "id": "src.features.hooks.hook-executor.getExecutionLogsForHook",
    "name": "getExecutionLogsForHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "getExecutionLogsForHook(hookId: string): HookExecutionLog[] {\n\t\treturn this.executionLogs.filter((log) => log.hookId === hookId);\n\t}",
    "start_line": 1151,
    "end_line": 1153,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getExecutionLogsForHook",
    "component_id": "src.features.hooks.hook-executor.getExecutionLogsForHook"
  },
  "src.features.hooks.hook-executor.clearExecutionLogs": {
    "id": "src.features.hooks.hook-executor.clearExecutionLogs",
    "name": "clearExecutionLogs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "clearExecutionLogs(): void {\n\t\tthis.executionLogs = [];\n\t\tthis.outputChannel.appendLine(\"[HookExecutor] Execution logs cleared\");\n\t}",
    "start_line": 1158,
    "end_line": 1161,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearExecutionLogs",
    "component_id": "src.features.hooks.hook-executor.clearExecutionLogs"
  },
  "src.features.hooks.hook-executor.executeLocalAgent": {
    "id": "src.features.hooks.hook-executor.executeLocalAgent",
    "name": "executeLocalAgent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private executeLocalAgent(\n\t\tparams: CustomActionParams,\n\t\ttemplateContext: ParserTemplateContext\n\t): Promise<{ success: boolean; error?: Error }> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executing local agent: ${params.agentId}`\n\t\t);\n\n\t\treturn (async () => {\n\t\t\ttry {\n\t\t\t\t// Extract agent name from agentId (format: \"local:agent-name\")\n\t\t\t\tconst agentName =\n\t\t\t\t\tparams.agentId?.replace(AGENT_ID_PREFIX_PATTERN, \"\") ||\n\t\t\t\t\tparams.agentName;\n\t\t\t\tif (!agentName) {\n\t\t\t\t\tthrow new Error(\"Agent name is required for local execution\");\n\t\t\t\t}\n\n\t\t\t\t// Read the agent file from .github/agents/\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\tconst { join } = await import(\"node:path\");\n\n\t\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\t\tif (!workspaceRoot) {\n\t\t\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t\t\t}\n\n\t\t\t\tconst agentFilePath = join(\n\t\t\t\t\tworkspaceRoot,\n\t\t\t\t\t\".github\",\n\t\t\t\t\t\"agents\",\n\t\t\t\t\t`${agentName}.agent.md`\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Reading agent file: ${agentFilePath}`\n\t\t\t\t);\n\n\t\t\t\tconst agentContent = await fs.readFile(agentFilePath, \"utf-8\");\n\n\t\t\t\t// Expand template variables in prompt and arguments\n\t\t\t\tconst userPrompt = params.prompt\n\t\t\t\t\t? this.expandTemplate(params.prompt, templateContext)\n\t\t\t\t\t: \"\";\n\t\t\t\tconst userArgs = params.arguments\n\t\t\t\t\t? this.expandTemplate(params.arguments, templateContext)\n\t\t\t\t\t: \"\";\n\n\t\t\t\t// Combine agent content with user input\n\t\t\t\t// Format: Agent content + user prompt + arguments\n\t\t\t\tlet finalPrompt = agentContent;\n\t\t\t\tif (userPrompt) {\n\t\t\t\t\tfinalPrompt += `\\n\\n${userPrompt}`;\n\t\t\t\t}\n\t\t\t\tif (userArgs) {\n\t\t\t\t\tfinalPrompt += `\\n\\nArguments: ${userArgs}`;\n\t\t\t\t}\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Sending agent prompt to Copilot Chat (length: ${finalPrompt.length} chars)`\n\t\t\t\t);\n\n\t\t\t\t// Send prompt to GitHub Copilot Chat (in-process execution)\n\t\t\t\tawait sendPromptToChat(finalPrompt);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[HookExecutor] Local agent execution completed successfully\"\n\t\t\t\t);\n\n\t\t\t\treturn { success: true };\n\t\t\t} catch (error) {\n\t\t\t\tconst err = error as Error;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Local agent execution failed: ${err.message}`\n\t\t\t\t);\n\t\t\t\treturn { success: false, error: err };\n\t\t\t}\n\t\t})();\n\t}",
    "start_line": 1167,
    "end_line": 1245,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeLocalAgent",
    "component_id": "src.features.hooks.hook-executor.executeLocalAgent"
  },
  "src.features.hooks.hook-executor.executeBackgroundAgent": {
    "id": "src.features.hooks.hook-executor.executeBackgroundAgent",
    "name": "executeBackgroundAgent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private executeBackgroundAgent(\n\t\tparams: CustomActionParams,\n\t\ttemplateContext: ParserTemplateContext\n\t): Promise<{ success: boolean; error?: Error }> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookExecutor] Executing background agent: ${params.agentId}`\n\t\t);\n\n\t\treturn (async () => {\n\t\t\ttry {\n\t\t\t\t// Extract agent name from agentId (format: \"local:agent-name\")\n\t\t\t\tconst agentName =\n\t\t\t\t\tparams.agentId?.replace(AGENT_ID_PREFIX_PATTERN, \"\") ||\n\t\t\t\t\tparams.agentName;\n\t\t\t\tif (!agentName) {\n\t\t\t\t\tthrow new Error(\"Agent name is required for background execution\");\n\t\t\t\t}\n\n\t\t\t\t// Read the agent file from .github/agents/\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\tconst { join } = await import(\"node:path\");\n\n\t\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\t\tif (!workspaceRoot) {\n\t\t\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t\t\t}\n\n\t\t\t\tconst agentFilePath = join(\n\t\t\t\t\tworkspaceRoot,\n\t\t\t\t\t\".github\",\n\t\t\t\t\t\"agents\",\n\t\t\t\t\t`${agentName}.agent.md`\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Reading agent file: ${agentFilePath}`\n\t\t\t\t);\n\n\t\t\t\t// Verify agent file exists\n\t\t\t\tawait fs.access(agentFilePath);\n\n\t\t\t\t// Expand template variables in prompt and arguments\n\t\t\t\tconst userPrompt = params.prompt\n\t\t\t\t\t? this.expandTemplate(params.prompt, templateContext)\n\t\t\t\t\t: \"\";\n\t\t\t\tconst userArgs = params.arguments\n\t\t\t\t\t? this.expandTemplate(params.arguments, templateContext)\n\t\t\t\t\t: \"\";\n\n\t\t\t\t// Build the gh copilot command with CLI options\n\t\t\t\tconst commandArgs = this.buildCopilotCliArgs(\n\t\t\t\t\tparams,\n\t\t\t\t\tagentFilePath,\n\t\t\t\t\tuserPrompt,\n\t\t\t\t\tuserArgs\n\t\t\t\t);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Executing: gh ${commandArgs.slice(1).join(\" \")}`\n\t\t\t\t);\n\n\t\t\t\t// Execute gh copilot command\n\t\t\t\tconst proc = spawn(\"gh\", commandArgs, {\n\t\t\t\t\tcwd: workspaceRoot,\n\t\t\t\t\tshell: true,\n\t\t\t\t});\n\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tlet stdout = \"\";\n\t\t\t\t\tlet stderr = \"\";\n\n\t\t\t\t\tproc.stdout.on(\"data\", (data: Buffer) => {\n\t\t\t\t\t\tconst text = data.toString();\n\t\t\t\t\t\tstdout += text;\n\t\t\t\t\t\tthis.outputChannel.append(text);\n\t\t\t\t\t});\n\n\t\t\t\t\tproc.stderr.on(\"data\", (data: Buffer) => {\n\t\t\t\t\t\tconst text = data.toString();\n\t\t\t\t\t\tstderr += text;\n\t\t\t\t\t\tthis.outputChannel.append(text);\n\t\t\t\t\t});\n\n\t\t\t\t\tproc.on(\"exit\", (code: number | null) => {\n\t\t\t\t\t\tif (code === 0) {\n\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\"[HookExecutor] Background agent execution completed successfully\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t`[HookExecutor] Output: ${stdout.trim()}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Background agent failed with exit code ${code}: ${stderr.trim()}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t`[HookExecutor] Background agent execution failed: ${error.message}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve({ success: false, error });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tproc.on(\"error\", (error: Error) => {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookExecutor] Background agent execution error: ${error.message}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if it's a \"command not found\" error\n\t\t\t\t\t\tif (error.message.includes(\"ENOENT\")) {\n\t\t\t\t\t\t\tconst enhancedError = new Error(\n\t\t\t\t\t\t\t\t\"GitHub CLI (gh) not found. Please install it: https://cli.github.com/\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve({ success: false, error: enhancedError });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve({ success: false, error });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconst err = error as Error;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookExecutor] Background agent execution failed: ${err.message}`\n\t\t\t\t);\n\t\t\t\treturn { success: false, error: err };\n\t\t\t}\n\t\t})();\n\t}",
    "start_line": 1251,
    "end_line": 1377,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "templateContext"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeBackgroundAgent",
    "component_id": "src.features.hooks.hook-executor.executeBackgroundAgent"
  },
  "src.features.hooks.hook-executor.buildCopilotCliArgs": {
    "id": "src.features.hooks.hook-executor.buildCopilotCliArgs",
    "name": "buildCopilotCliArgs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private buildCopilotCliArgs(\n\t\tparams: CustomActionParams,\n\t\tagentFilePath: string,\n\t\tuserPrompt: string,\n\t\tuserArgs: string\n\t): string[] {\n\t\tconst args = [\"copilot\", \"-p\"];\n\n\t\t// Start with prompt\n\t\tif (userPrompt) {\n\t\t\targs.push(userPrompt);\n\t\t}\n\n\t\t// Add agent file\n\t\targs.push(\"--agent\", agentFilePath);\n\n\t\t// Add user arguments\n\t\tif (userArgs) {\n\t\t\targs.push(userArgs);\n\t\t}\n\n\t\t// Add CLI options if provided\n\t\tconst opts = params.cliOptions;\n\t\tif (!opts) {\n\t\t\treturn args;\n\t\t}\n\n\t\t// Combined flags (--allow-all / --yolo)\n\t\tif (opts.allowAll) {\n\t\t\targs.push(\"--allow-all\");\n\t\t\treturn args; // No need to add individual permissions\n\t\t}\n\n\t\t// Add all option groups\n\t\tthis.addPathOptions(args, opts);\n\t\tthis.addToolPermissions(args, opts);\n\t\tthis.addUrlPermissions(args, opts);\n\t\tthis.addGithubMcpOptions(args, opts);\n\t\tthis.addMcpServerOptions(args, opts);\n\t\tthis.addExecutionOptions(args, opts);\n\t\tthis.addOutputOptions(args, opts);\n\t\tthis.addSessionOptions(args, opts);\n\t\tthis.addConfigOptions(args, opts);\n\n\t\treturn args;\n\t}",
    "start_line": 1382,
    "end_line": 1427,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params",
      "agentFilePath",
      "userPrompt",
      "userArgs"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method buildCopilotCliArgs",
    "component_id": "src.features.hooks.hook-executor.buildCopilotCliArgs"
  },
  "src.features.hooks.hook-executor.addPathOptions": {
    "id": "src.features.hooks.hook-executor.addPathOptions",
    "name": "addPathOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addPathOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.addDir) {\n\t\t\tfor (const dir of opts.addDir) {\n\t\t\t\targs.push(\"--add-dir\", dir);\n\t\t\t}\n\t\t}\n\t\tif (opts.allowAllPaths) {\n\t\t\targs.push(\"--allow-all-paths\");\n\t\t}\n\t\tif (opts.disallowTempDir) {\n\t\t\targs.push(\"--disallow-temp-dir\");\n\t\t}\n\t}",
    "start_line": 1429,
    "end_line": 1444,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addPathOptions",
    "component_id": "src.features.hooks.hook-executor.addPathOptions"
  },
  "src.features.hooks.hook-executor.addToolPermissions": {
    "id": "src.features.hooks.hook-executor.addToolPermissions",
    "name": "addToolPermissions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addToolPermissions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.allowAllTools) {\n\t\t\targs.push(\"--allow-all-tools\");\n\t\t}\n\t\tif (opts.allowTool) {\n\t\t\targs.push(\"--allow-tool\", ...opts.allowTool);\n\t\t}\n\t\tif (opts.availableTools) {\n\t\t\targs.push(\"--available-tools\", ...opts.availableTools);\n\t\t}\n\t\tif (opts.excludedTools) {\n\t\t\targs.push(\"--excluded-tools\", ...opts.excludedTools);\n\t\t}\n\t\tif (opts.denyTool) {\n\t\t\targs.push(\"--deny-tool\", ...opts.denyTool);\n\t\t}\n\t}",
    "start_line": 1446,
    "end_line": 1465,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addToolPermissions",
    "component_id": "src.features.hooks.hook-executor.addToolPermissions"
  },
  "src.features.hooks.hook-executor.addUrlPermissions": {
    "id": "src.features.hooks.hook-executor.addUrlPermissions",
    "name": "addUrlPermissions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addUrlPermissions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.allowAllUrls) {\n\t\t\targs.push(\"--allow-all-urls\");\n\t\t}\n\t\tif (opts.allowUrl) {\n\t\t\targs.push(\"--allow-url\", ...opts.allowUrl);\n\t\t}\n\t\tif (opts.denyUrl) {\n\t\t\targs.push(\"--deny-url\", ...opts.denyUrl);\n\t\t}\n\t}",
    "start_line": 1467,
    "end_line": 1480,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addUrlPermissions",
    "component_id": "src.features.hooks.hook-executor.addUrlPermissions"
  },
  "src.features.hooks.hook-executor.addGithubMcpOptions": {
    "id": "src.features.hooks.hook-executor.addGithubMcpOptions",
    "name": "addGithubMcpOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addGithubMcpOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.enableAllGithubMcpTools) {\n\t\t\targs.push(\"--enable-all-github-mcp-tools\");\n\t\t}\n\t\tif (opts.addGithubMcpTool) {\n\t\t\tfor (const tool of opts.addGithubMcpTool) {\n\t\t\t\targs.push(\"--add-github-mcp-tool\", tool);\n\t\t\t}\n\t\t}\n\t\tif (opts.addGithubMcpToolset) {\n\t\t\tfor (const toolset of opts.addGithubMcpToolset) {\n\t\t\t\targs.push(\"--add-github-mcp-toolset\", toolset);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 1482,
    "end_line": 1499,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addGithubMcpOptions",
    "component_id": "src.features.hooks.hook-executor.addGithubMcpOptions"
  },
  "src.features.hooks.hook-executor.addMcpServerOptions": {
    "id": "src.features.hooks.hook-executor.addMcpServerOptions",
    "name": "addMcpServerOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addMcpServerOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.additionalMcpConfig) {\n\t\t\tfor (const config of opts.additionalMcpConfig) {\n\t\t\t\targs.push(\"--additional-mcp-config\", config);\n\t\t\t}\n\t\t}\n\t\tif (opts.disableBuiltinMcps) {\n\t\t\targs.push(\"--disable-builtin-mcps\");\n\t\t}\n\t\tif (opts.disableMcpServer) {\n\t\t\tfor (const server of opts.disableMcpServer) {\n\t\t\t\targs.push(\"--disable-mcp-server\", server);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 1501,
    "end_line": 1518,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addMcpServerOptions",
    "component_id": "src.features.hooks.hook-executor.addMcpServerOptions"
  },
  "src.features.hooks.hook-executor.addExecutionOptions": {
    "id": "src.features.hooks.hook-executor.addExecutionOptions",
    "name": "addExecutionOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addExecutionOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.agent) {\n\t\t\targs.push(\"--agent\", opts.agent);\n\t\t}\n\t\tif (opts.model) {\n\t\t\targs.push(\"--model\", opts.model);\n\t\t}\n\t\tif (opts.noAskUser) {\n\t\t\targs.push(\"--no-ask-user\");\n\t\t}\n\t\tif (opts.disableParallelToolsExecution) {\n\t\t\targs.push(\"--disable-parallel-tools-execution\");\n\t\t}\n\t\tif (opts.noCustomInstructions) {\n\t\t\targs.push(\"--no-custom-instructions\");\n\t\t}\n\t}",
    "start_line": 1520,
    "end_line": 1539,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addExecutionOptions",
    "component_id": "src.features.hooks.hook-executor.addExecutionOptions"
  },
  "src.features.hooks.hook-executor.addOutputOptions": {
    "id": "src.features.hooks.hook-executor.addOutputOptions",
    "name": "addOutputOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addOutputOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.silent) {\n\t\t\targs.push(\"--silent\");\n\t\t}\n\t\tif (opts.logLevel) {\n\t\t\targs.push(\"--log-level\", opts.logLevel);\n\t\t}\n\t\tif (opts.logDir) {\n\t\t\targs.push(\"--log-dir\", opts.logDir);\n\t\t}\n\t\tif (opts.noColor) {\n\t\t\targs.push(\"--no-color\");\n\t\t}\n\t\tif (opts.plainDiff) {\n\t\t\targs.push(\"--plain-diff\");\n\t\t}\n\t\tif (opts.screenReader) {\n\t\t\targs.push(\"--screen-reader\");\n\t\t}\n\t\tif (opts.stream) {\n\t\t\targs.push(\"--stream\", opts.stream);\n\t\t}\n\t}",
    "start_line": 1541,
    "end_line": 1566,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addOutputOptions",
    "component_id": "src.features.hooks.hook-executor.addOutputOptions"
  },
  "src.features.hooks.hook-executor.addSessionOptions": {
    "id": "src.features.hooks.hook-executor.addSessionOptions",
    "name": "addSessionOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addSessionOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.resume) {\n\t\t\tif (typeof opts.resume === \"string\") {\n\t\t\t\targs.push(\"--resume\", opts.resume);\n\t\t\t} else {\n\t\t\t\targs.push(\"--resume\");\n\t\t\t}\n\t\t}\n\t\tif (opts.continue) {\n\t\t\targs.push(\"--continue\");\n\t\t}\n\t\tif (opts.share) {\n\t\t\tif (typeof opts.share === \"string\") {\n\t\t\t\targs.push(\"--share\", opts.share);\n\t\t\t} else {\n\t\t\t\targs.push(\"--share\");\n\t\t\t}\n\t\t}\n\t\tif (opts.shareGist) {\n\t\t\targs.push(\"--share-gist\");\n\t\t}\n\t}",
    "start_line": 1568,
    "end_line": 1592,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addSessionOptions",
    "component_id": "src.features.hooks.hook-executor.addSessionOptions"
  },
  "src.features.hooks.hook-executor.addConfigOptions": {
    "id": "src.features.hooks.hook-executor.addConfigOptions",
    "name": "addConfigOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-executor.ts",
    "relative_path": "src/features/hooks/hook-executor.ts",
    "depends_on": [],
    "source_code": "private addConfigOptions(\n\t\targs: string[],\n\t\topts: NonNullable<CustomActionParams[\"cliOptions\"]>\n\t): void {\n\t\tif (opts.configDir) {\n\t\t\targs.push(\"--config-dir\", opts.configDir);\n\t\t}\n\t\tif (opts.banner) {\n\t\t\targs.push(\"--banner\");\n\t\t}\n\t\tif (opts.noAutoUpdate) {\n\t\t\targs.push(\"--no-auto-update\");\n\t\t}\n\t}",
    "start_line": 1594,
    "end_line": 1607,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "args",
      "opts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addConfigOptions",
    "component_id": "src.features.hooks.hook-executor.addConfigOptions"
  },
  "src.features.hooks.hook-manager.ValidationError": {
    "id": "src.features.hooks.hook-manager.ValidationError",
    "name": "ValidationError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "interface ValidationError {\n\tfield: string;\n\tmessage: string;\n}",
    "start_line": 23,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ValidationError",
    "component_id": "src.features.hooks.hook-manager.ValidationError"
  },
  "src.features.hooks.hook-manager.ValidationResult": {
    "id": "src.features.hooks.hook-manager.ValidationResult",
    "name": "ValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [
      "src.features.hooks.hook-manager.ValidationError"
    ],
    "source_code": "interface ValidationResult {\n\tvalid: boolean;\n\terrors: ValidationError[];\n}",
    "start_line": 31,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ValidationResult",
    "component_id": "src.features.hooks.hook-manager.ValidationResult"
  },
  "src.features.hooks.hook-manager.HookValidationError": {
    "id": "src.features.hooks.hook-manager.HookValidationError",
    "name": "HookValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [
      "src.features.hooks.hook-manager.ValidationError"
    ],
    "source_code": "class HookValidationError extends Error {\n\terrors: ValidationError[];\n\n\tconstructor(message: string, errors: ValidationError[]) {\n\t\tsuper(message);\n\t\tthis.name = \"HookValidationError\";\n\t\tthis.errors = errors;\n\t}\n}",
    "start_line": 39,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HookValidationError",
    "component_id": "src.features.hooks.hook-manager.HookValidationError"
  },
  "src.features.hooks.hook-manager.DuplicateHookNameError": {
    "id": "src.features.hooks.hook-manager.DuplicateHookNameError",
    "name": "DuplicateHookNameError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "class DuplicateHookNameError extends Error {\n\tconstructor(name: string) {\n\t\tsuper(`Hook with name \"${name}\" already exists`);\n\t\tthis.name = \"DuplicateHookNameError\";\n\t}\n}",
    "start_line": 49,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DuplicateHookNameError",
    "component_id": "src.features.hooks.hook-manager.DuplicateHookNameError"
  },
  "src.features.hooks.hook-manager.HookNotFoundError": {
    "id": "src.features.hooks.hook-manager.HookNotFoundError",
    "name": "HookNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "class HookNotFoundError extends Error {\n\tconstructor(id: string) {\n\t\tsuper(`Hook with ID \"${id}\" not found`);\n\t\tthis.name = \"HookNotFoundError\";\n\t}\n}",
    "start_line": 56,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HookNotFoundError",
    "component_id": "src.features.hooks.hook-manager.HookNotFoundError"
  },
  "src.features.hooks.hook-manager.PersistenceError": {
    "id": "src.features.hooks.hook-manager.PersistenceError",
    "name": "PersistenceError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "class PersistenceError extends Error {\n\tcause?: Error;\n\n\tconstructor(message: string, cause?: Error) {\n\t\tsuper(message);\n\t\tthis.name = \"PersistenceError\";\n\t\tthis.cause = cause;\n\t}\n}",
    "start_line": 63,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class PersistenceError",
    "component_id": "src.features.hooks.hook-manager.PersistenceError"
  },
  "src.features.hooks.hook-manager.HookManager": {
    "id": "src.features.hooks.hook-manager.HookManager",
    "name": "HookManager",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [
      "src.features.hooks.hook-manager.saveHooks",
      "src.features.hooks.hook-manager.validateHookId",
      "src.features.hooks.hook-manager.dispose",
      "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
      "src.features.hooks.agent-registry.checkAgentAvailability",
      "src.features.hooks.agent-registry.AgentRegistry",
      "src.features.hooks.hook-manager.PersistenceError",
      "src.features.hooks.hook-manager.validateMCPServer",
      "src.features.hooks.hook-manager.HookValidationError",
      "src.features.hooks.hook-manager.performAsyncValidations",
      "src.features.hooks.hook-manager.validateMCPServerRef",
      "src.features.hooks.types.isValidAction",
      "src.features.hooks.hook-manager.validateCustomAgent",
      "src.features.hooks.agent-registry.getAgentById",
      "src.features.hooks.hook-manager.ValidationError",
      "src.features.hooks.types.isValidHook",
      "src.features.hooks.hook-manager.validateActionParameters",
      "src.features.hooks.hook-manager.validateCustomAgentRef",
      "src.features.hooks.hook-manager.validateHookName",
      "src.services.agent-service.dispose",
      "src.features.hooks.hook-manager.validateHookStructure",
      "ui.src.features.hooks-view.types.Hook",
      "src.features.agents.resource-cache.get",
      "src.features.hooks.services.mcp-discovery.getServer",
      "src.features.hooks.hook-manager.ValidationResult",
      "src.features.hooks.hook-manager.validateAgentTypeParam",
      "src.features.hooks.hook-manager.validateHookAction",
      "src.features.hooks.hook-manager.isHookNameUnique",
      "src.features.hooks.hook-manager.HookNotFoundError",
      "src.features.hooks.hook-manager.loadHooks",
      "src.features.hooks.services.mcp-discovery.getTool",
      "src.features.hooks.hook-manager.DuplicateHookNameError",
      "src.features.hooks.hook-manager.validateHookTrigger",
      "src.features.hooks.hook-manager.validateHook"
    ],
    "source_code": "class HookManager {\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly mcpDiscoveryService?: IMCPDiscoveryService;\n\tprivate readonly agentRegistry?: AgentRegistry;\n\tprivate hooks: Hook[] = [];\n\n\t// Event emitters\n\tprivate readonly _onHookCreated = new EventEmitter<Hook>();\n\tprivate readonly _onHookUpdated = new EventEmitter<Hook>();\n\tprivate readonly _onHookDeleted = new EventEmitter<string>();\n\tprivate readonly _onHooksChanged = new EventEmitter<void>();\n\n\t// Public events\n\treadonly onHookCreated: Event<Hook> = this._onHookCreated.event;\n\treadonly onHookUpdated: Event<Hook> = this._onHookUpdated.event;\n\treadonly onHookDeleted: Event<string> = this._onHookDeleted.event;\n\treadonly onHooksChanged: Event<void> = this._onHooksChanged.event;\n\n\tconstructor(\n\t\tcontext: ExtensionContext,\n\t\toutputChannel: OutputChannel,\n\t\tmcpDiscoveryService?: IMCPDiscoveryService,\n\t\tagentRegistry?: AgentRegistry\n\t) {\n\t\tthis.context = context;\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.mcpDiscoveryService = mcpDiscoveryService;\n\t\tthis.agentRegistry = agentRegistry;\n\t}\n\n\t/**\n\t * Initialize the hook manager - loads hooks from workspace state\n\t */\n\tasync initialize(): Promise<void> {\n\t\tawait this.loadHooks();\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Initialized with ${this.hooks.length} hooks`\n\t\t);\n\t}\n\n\t/**\n\t * Dispose of resources\n\t */\n\tdispose(): void {\n\t\tthis._onHookCreated.dispose();\n\t\tthis._onHookUpdated.dispose();\n\t\tthis._onHookDeleted.dispose();\n\t\tthis._onHooksChanged.dispose();\n\t\tthis.outputChannel.appendLine(\"[HookManager] Disposed\");\n\t}\n\n\t/**\n\t * Create a new hook\n\t */\n\tasync createHook(\n\t\thook: Omit<Hook, \"id\" | \"createdAt\" | \"modifiedAt\" | \"executionCount\">\n\t): Promise<Hook> {\n\t\t// Check name uniqueness\n\t\tconst nameExists = await this.isHookNameUnique(hook.name);\n\t\tif (!nameExists) {\n\t\t\tthrow new DuplicateHookNameError(hook.name);\n\t\t}\n\n\t\t// Create full hook with generated fields\n\t\tconst now = Date.now();\n\t\tconst newHook: Hook = {\n\t\t\t...hook,\n\t\t\tid: randomUUID(),\n\t\t\tcreatedAt: now,\n\t\t\tmodifiedAt: now,\n\t\t\texecutionCount: 0,\n\t\t};\n\n\t\t// Validate (now async to support MCP validation)\n\t\tconst validation = await this.validateHook(newHook);\n\t\tif (!validation.valid) {\n\t\t\tthrow new HookValidationError(\n\t\t\t\t\"Hook validation failed\",\n\t\t\t\tvalidation.errors\n\t\t\t);\n\t\t}\n\n\t\t// Add to collection\n\t\tthis.hooks.push(newHook);\n\n\t\t// Persist\n\t\tawait this.saveHooks();\n\n\t\t// Emit events\n\t\tthis._onHookCreated.fire(newHook);\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Created hook: ${newHook.name} (${newHook.id})`\n\t\t);\n\n\t\treturn newHook;\n\t}\n\n\t/**\n\t * Get a hook by ID\n\t */\n\tgetHook(id: string): Hook | undefined {\n\t\treturn this.hooks.find((h) => h.id === id);\n\t}\n\n\t/**\n\t * Get all hooks\n\t */\n\tgetAllHooks(): Hook[] {\n\t\treturn [...this.hooks]; // Return copy\n\t}\n\n\t/**\n\t * Update a hook\n\t */\n\tasync updateHook(id: string, updates: Partial<Hook>): Promise<Hook> {\n\t\tconst index = this.hooks.findIndex((h) => h.id === id);\n\t\tif (index === -1) {\n\t\t\tthrow new HookNotFoundError(id);\n\t\t}\n\n\t\tconst existingHook = this.hooks[index];\n\n\t\t// Prevent updating immutable fields\n\t\tconst {\n\t\t\tid: _id,\n\t\t\tcreatedAt: _createdAt,\n\t\t\texecutionCount: _execCount,\n\t\t\t...allowedUpdates\n\t\t} = updates;\n\n\t\t// Check name uniqueness if name is being changed\n\t\tif (allowedUpdates.name && allowedUpdates.name !== existingHook.name) {\n\t\t\tconst nameExists = await this.isHookNameUnique(allowedUpdates.name, id);\n\t\t\tif (!nameExists) {\n\t\t\t\tthrow new DuplicateHookNameError(allowedUpdates.name);\n\t\t\t}\n\t\t}\n\n\t\t// Merge updates\n\t\tconst updatedHook: Hook = {\n\t\t\t...existingHook,\n\t\t\t...allowedUpdates,\n\t\t\tmodifiedAt: Date.now(),\n\t\t};\n\n\t\t// Validate (now async to support MCP validation)\n\t\tconst validation = await this.validateHook(updatedHook);\n\t\tif (!validation.valid) {\n\t\t\tthrow new HookValidationError(\n\t\t\t\t\"Hook validation failed\",\n\t\t\t\tvalidation.errors\n\t\t\t);\n\t\t}\n\n\t\t// Update in collection\n\t\tthis.hooks[index] = updatedHook;\n\n\t\t// Persist\n\t\tawait this.saveHooks();\n\n\t\t// Emit events\n\t\tthis._onHookUpdated.fire(updatedHook);\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Updated hook: ${updatedHook.name} (${id})`\n\t\t);\n\n\t\treturn updatedHook;\n\t}\n\n\t/**\n\t * Delete a hook\n\t */\n\tasync deleteHook(id: string): Promise<boolean> {\n\t\tconst index = this.hooks.findIndex((h) => h.id === id);\n\t\tif (index === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst deletedHook = this.hooks[index];\n\t\tthis.hooks.splice(index, 1);\n\n\t\t// Persist\n\t\tawait this.saveHooks();\n\n\t\t// Emit events\n\t\tthis._onHookDeleted.fire(id);\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Deleted hook: ${deletedHook.name} (${id})`\n\t\t);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get all enabled hooks\n\t */\n\tgetEnabledHooks(): Hook[] {\n\t\treturn this.hooks.filter((h) => h.enabled);\n\t}\n\n\t/**\n\t * Get hooks by trigger condition\n\t */\n\tgetHooksByTrigger(agent: string, operation: string): Hook[] {\n\t\treturn this.hooks.filter(\n\t\t\t(h) => h.trigger.agent === agent && h.trigger.operation === operation\n\t\t);\n\t}\n\n\t/**\n\t * Disable all hooks\n\t */\n\tasync disableAllHooks(): Promise<void> {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.enabled = false;\n\t\t\thook.modifiedAt = Date.now();\n\t\t}\n\n\t\tawait this.saveHooks();\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\"[HookManager] Disabled all hooks\");\n\t}\n\n\t/**\n\t * Enable all hooks\n\t */\n\tasync enableAllHooks(): Promise<void> {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.enabled = true;\n\t\t\thook.modifiedAt = Date.now();\n\t\t}\n\n\t\tawait this.saveHooks();\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\"[HookManager] Enabled all hooks\");\n\t}\n\n\t/**\n\t * Save hooks to workspace state\n\t */\n\tasync saveHooks(): Promise<void> {\n\t\ttry {\n\t\t\tawait this.context.workspaceState.update(HOOKS_STORAGE_KEY, this.hooks);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Saved ${this.hooks.length} hooks to workspace state`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Error saving hooks: ${err.message}`\n\t\t\t);\n\t\t\tthrow new PersistenceError(\"Failed to save hooks\", err);\n\t\t}\n\t}\n\n\t/**\n\t * Load hooks from workspace state\n\t */\n\tloadHooks(): void {\n\t\ttry {\n\t\t\tconst stored = this.context.workspaceState.get<Hook[]>(\n\t\t\t\tHOOKS_STORAGE_KEY,\n\t\t\t\t[]\n\t\t\t);\n\n\t\t\t// Validate all loaded hooks and migrate old hooks\n\t\t\tconst validHooks: Hook[] = [];\n\t\t\tfor (const hook of stored) {\n\t\t\t\t// Migration: Add default timing \"after\" for hooks created before timing feature\n\t\t\t\tif (!hook.trigger.timing) {\n\t\t\t\t\thook.trigger.timing = \"after\";\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Migration: Set default timing \"after\" for hook: ${hook.name}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Migration: Rename agentId to modelId in MCP actions\n\t\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as any;\n\t\t\t\t\tif (mcpParams.agentId && !mcpParams.modelId) {\n\t\t\t\t\t\tmcpParams.modelId = mcpParams.agentId;\n\t\t\t\t\t\tmcpParams.agentId = undefined;\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookManager] Migration: Renamed agentId to modelId for MCP hook: ${hook.name}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isValidHook(hook)) {\n\t\t\t\t\tvalidHooks.push(hook);\n\t\t\t\t} else {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Warning: Invalid hook found in storage, skipping: ${JSON.stringify(hook)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.hooks = validHooks;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Loaded ${this.hooks.length} hooks from workspace state`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Error loading hooks: ${err.message}`\n\t\t\t);\n\t\t\tthis.hooks = [];\n\t\t}\n\t}\n\n\t/**\n\t * Export hooks to JSON string\n\t */\n\texportHooks(): string {\n\t\treturn JSON.stringify(this.hooks, null, 2);\n\t}\n\n\t/**\n\t * Import hooks from JSON string\n\t */\n\tasync importHooks(json: string): Promise<number> {\n\t\ttry {\n\t\t\tconst imported = JSON.parse(json) as Hook[];\n\n\t\t\tif (!Array.isArray(imported)) {\n\t\t\t\tthrow new Error(\"Invalid JSON: expected array of hooks\");\n\t\t\t}\n\n\t\t\tlet importedCount = 0;\n\n\t\t\tfor (const hook of imported) {\n\t\t\t\t// Validate hook structure\n\t\t\t\tif (!isValidHook(hook)) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Warning: Skipping invalid hook: ${JSON.stringify(hook)}`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Skip duplicates by name\n\t\t\t\tconst nameExists = await this.isHookNameUnique(hook.name);\n\t\t\t\tif (!nameExists) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Warning: Skipping duplicate hook: ${hook.name}`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Add hook (regenerate ID to avoid conflicts)\n\t\t\t\tconst newHook: Hook = {\n\t\t\t\t\t...hook,\n\t\t\t\t\tid: randomUUID(),\n\t\t\t\t\tcreatedAt: Date.now(),\n\t\t\t\t\tmodifiedAt: Date.now(),\n\t\t\t\t};\n\n\t\t\t\tthis.hooks.push(newHook);\n\t\t\t\timportedCount += 1;\n\t\t\t}\n\n\t\t\tif (importedCount > 0) {\n\t\t\t\tawait this.saveHooks();\n\t\t\t\tthis._onHooksChanged.fire();\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Imported ${importedCount} hooks`\n\t\t\t);\n\n\t\t\treturn importedCount;\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Error importing hooks: ${err.message}`\n\t\t\t);\n\t\t\tthrow new Error(`Failed to import hooks: ${err.message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Validate a hook\n\t * T085: Add MCP server validation check\n\t */\n\tasync validateHook(hook: Hook): Promise<ValidationResult> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\t// Basic structure validation - early return for invalid structure\n\t\tif (!hook || typeof hook !== \"object\") {\n\t\t\terrors.push({\n\t\t\t\tfield: \"hook\",\n\t\t\t\tmessage: \"Hook must be an object\",\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\n\t\t// Collect all validation errors\n\t\terrors.push(...this.validateHookName(hook.name));\n\t\terrors.push(...this.validateAgentTypeParam(hook));\n\t\terrors.push(...this.validateHookStructure(hook));\n\n\t\t// Async validations\n\t\tconst asyncErrors = await this.performAsyncValidations(hook);\n\t\terrors.push(...asyncErrors);\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t};\n\t}\n\n\t/**\n\t * Validate hook structure using type guards\n\t */\n\tprivate validateHookStructure(hook: Hook): ValidationError[] {\n\t\tif (isValidHook(hook)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst errors: ValidationError[] = [];\n\t\terrors.push(...this.validateHookId(hook));\n\t\terrors.push(...this.validateHookTrigger(hook));\n\t\terrors.push(...this.validateHookAction(hook));\n\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Validate hook ID field\n\t */\n\tprivate validateHookId(hook: Hook): ValidationError[] {\n\t\tif (!hook.id || typeof hook.id !== \"string\") {\n\t\t\treturn [{ field: \"id\", message: \"Hook ID is missing or invalid\" }];\n\t\t}\n\t\treturn [];\n\t}\n\n\t/**\n\t * Validate hook trigger configuration\n\t */\n\tprivate validateHookTrigger(hook: Hook): ValidationError[] {\n\t\tif (!hook.trigger || typeof hook.trigger !== \"object\") {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tfield: \"trigger\",\n\t\t\t\t\tmessage: \"Trigger configuration is invalid\",\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\treturn [];\n\t}\n\n\t/**\n\t * Validate hook action configuration\n\t */\n\tprivate validateHookAction(hook: Hook): ValidationError[] {\n\t\tif (!hook.action || typeof hook.action !== \"object\") {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tfield: \"action\",\n\t\t\t\t\tmessage: \"Action configuration is invalid\",\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\tif (!isValidAction(hook.action)) {\n\t\t\treturn this.validateActionParameters(hook.action);\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t/**\n\t * Validate action parameters for specific action types\n\t */\n\tprivate validateActionParameters(action: HookAction): ValidationError[] {\n\t\tif (action.type === \"custom\") {\n\t\t\tconst params = action.parameters as any;\n\t\t\tif (!(params?.agentId || params?.agentName)) {\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\t\t\tmessage: \"Agent ID or agent name is required\",\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn [\n\t\t\t{\n\t\t\t\tfield: \"action\",\n\t\t\t\tmessage: \"Action parameters are invalid\",\n\t\t\t},\n\t\t];\n\t}\n\n\t/**\n\t * Perform all async validations (MCP and custom agents)\n\t */\n\tprivate async performAsyncValidations(\n\t\thook: Hook\n\t): Promise<ValidationError[]> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\t// T085: Validate MCP server references\n\t\tif (hook.action.type === \"mcp\" && this.mcpDiscoveryService) {\n\t\t\tconst mcpErrors = await this.validateMCPServerRef(hook);\n\t\t\terrors.push(...mcpErrors);\n\t\t}\n\n\t\t// T025: Validate custom agent references\n\t\tif (hook.action.type === \"custom\" && this.agentRegistry) {\n\t\t\tconst customErrors = await this.validateCustomAgentRef(hook);\n\t\t\terrors.push(...customErrors);\n\t\t}\n\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Validate hook name field\n\t */\n\tprivate validateHookName(name: string | undefined): ValidationError[] {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tif (!name || name.length === 0) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"name\",\n\t\t\t\tmessage: \"Hook name cannot be empty\",\n\t\t\t});\n\t\t\treturn errors;\n\t\t}\n\n\t\tif (name.length > MAX_HOOK_NAME_LENGTH) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"name\",\n\t\t\t\tmessage: `Hook name must be ${MAX_HOOK_NAME_LENGTH} characters or less`,\n\t\t\t});\n\t\t}\n\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Validate agent type parameter (T051)\n\t */\n\tprivate validateAgentTypeParam(hook: Hook): ValidationError[] {\n\t\tif (hook.action?.type !== \"custom\") {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst customParams = hook.action.parameters as any;\n\t\tif (!customParams?.agentType) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst validTypes: string[] = [\"local\", \"background\"];\n\t\tif (!validTypes.includes(customParams.agentType)) {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tfield: \"action.parameters.agentType\",\n\t\t\t\t\tmessage: `Invalid agent type \"${customParams.agentType}\". Must be \"local\" or \"background\".`,\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t/**\n\t * Validate MCP server reference (T085)\n\t */\n\tprivate async validateMCPServerRef(hook: Hook): Promise<ValidationError[]> {\n\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\tconst serverId = mcpParams.serverId;\n\t\tconst toolName = mcpParams.toolName;\n\n\t\t// Skip validation if legacy fields not present\n\t\tif (!(serverId && toolName)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst serverValid = await this.validateMCPServer(serverId, toolName);\n\t\treturn serverValid.valid ? [] : serverValid.errors;\n\t}\n\n\t/**\n\t * Validate custom agent reference (T025)\n\t */\n\tprivate async validateCustomAgentRef(hook: Hook): Promise<ValidationError[]> {\n\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\tconst agentId = customParams.agentId || customParams.agentName;\n\t\tconst agentValid = await this.validateCustomAgent(agentId);\n\t\treturn agentValid.valid ? [] : agentValid.errors;\n\t}\n\n\t/**\n\t * T025: Validate custom agent references\n\t * Checks if the referenced agent exists and is available\n\t */\n\tasync validateCustomAgent(agentId?: string): Promise<ValidationResult> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tif (!this.agentRegistry) {\n\t\t\t// If no registry, skip validation (graceful degradation)\n\t\t\treturn { valid: true, errors };\n\t\t}\n\n\t\tif (!agentId) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\tmessage: \"Agent ID is required for custom actions\",\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if agent exists\n\t\t\tconst agent = this.agentRegistry.getAgentById(agentId);\n\n\t\t\tif (!agent) {\n\t\t\t\terrors.push({\n\t\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\t\tmessage: `Agent \"${agentId}\" not found. Please select a valid agent.`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\t// T025.5: Check if agent is available (warn but don't fail)\n\t\t\t// TypeScript: agentId is guaranteed non-undefined here due to check above\n\t\t\tconst availCheck = await this.agentRegistry.checkAgentAvailability(\n\t\t\t\tagentId as string\n\t\t\t);\n\t\t\tif (!availCheck.available) {\n\t\t\t\t// Warning - allow saving but notify\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookManager] Warning: Agent \"${agentId}\" is not currently available: ${availCheck.reason}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn { valid: true, errors };\n\t\t} catch (error) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\tmessage: `Failed to validate agent: ${(error as Error).message}`,\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\t}\n\n\t/**\n\t * T085: Validate MCP server and tool references\n\t * Checks if the referenced MCP server exists and if the tool is available\n\t */\n\tasync validateMCPServer(\n\t\tserverId: string,\n\t\ttoolName: string\n\t): Promise<ValidationResult> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tif (!this.mcpDiscoveryService) {\n\t\t\t// If no discovery service, skip validation (graceful degradation)\n\t\t\treturn { valid: true, errors };\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if server exists\n\t\t\tconst server = await this.mcpDiscoveryService.getServer(serverId);\n\n\t\t\tif (!server) {\n\t\t\t\terrors.push({\n\t\t\t\t\tfield: \"action.parameters.serverId\",\n\t\t\t\t\tmessage: `MCP server \"${serverId}\" not found. Please verify the server ID or update the hook configuration.`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\t// T086: Check if server is available (warn but don't fail validation)\n\t\t\tif (server.status === \"unavailable\") {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookManager] Warning: MCP server \"${serverId}\" is currently unavailable`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check if tool exists in server\n\t\t\tconst tool = await this.mcpDiscoveryService.getTool(serverId, toolName);\n\n\t\t\tif (!tool) {\n\t\t\t\terrors.push({\n\t\t\t\t\tfield: \"action.parameters.toolName\",\n\t\t\t\t\tmessage: `MCP tool \"${toolName}\" not found in server \"${serverId}\". Please verify the tool name or update the hook configuration.`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\treturn { valid: true, errors };\n\t\t} catch (error) {\n\t\t\t// Graceful degradation - log error but don't fail validation\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Warning: Failed to validate MCP server: ${err.message}`\n\t\t\t);\n\n\t\t\t// Return valid to allow hook to be saved (execution will fail gracefully)\n\t\t\treturn { valid: true, errors };\n\t\t}\n\t}\n\n\t/**\n\t * T085: Get all hooks with invalid MCP server references\n\t */\n\tasync getInvalidMCPHooks(): Promise<\n\t\tArray<{ hook: Hook; errors: ValidationError[] }>\n\t> {\n\t\tconst invalidHooks: Array<{ hook: Hook; errors: ValidationError[] }> = [];\n\n\t\tfor (const hook of this.hooks) {\n\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\tconst validation = await this.validateHook(hook);\n\t\t\t\tif (!validation.valid) {\n\t\t\t\t\tinvalidHooks.push({\n\t\t\t\t\t\thook,\n\t\t\t\t\t\terrors: validation.errors,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invalidHooks;\n\t}\n\n\t/**\n\t * Check if a hook name is unique\n\t */\n\tisHookNameUnique(name: string, excludeId?: string): boolean {\n\t\tconst existing = this.hooks.find(\n\t\t\t(h) => h.name === name && h.id !== excludeId\n\t\t);\n\t\treturn !existing;\n\t}\n}",
    "start_line": 76,
    "end_line": 823,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HookManager",
    "component_id": "src.features.hooks.hook-manager.HookManager"
  },
  "src.features.hooks.hook-manager.initialize": {
    "id": "src.features.hooks.hook-manager.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async initialize(): Promise<void> {\n\t\tawait this.loadHooks();\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Initialized with ${this.hooks.length} hooks`\n\t\t);\n\t}",
    "start_line": 110,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method initialize",
    "component_id": "src.features.hooks.hook-manager.initialize"
  },
  "src.features.hooks.hook-manager.dispose": {
    "id": "src.features.hooks.hook-manager.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis._onHookCreated.dispose();\n\t\tthis._onHookUpdated.dispose();\n\t\tthis._onHookDeleted.dispose();\n\t\tthis._onHooksChanged.dispose();\n\t\tthis.outputChannel.appendLine(\"[HookManager] Disposed\");\n\t}",
    "start_line": 120,
    "end_line": 126,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.hook-manager.dispose"
  },
  "src.features.hooks.hook-manager.createHook": {
    "id": "src.features.hooks.hook-manager.createHook",
    "name": "createHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async createHook(\n\t\thook: Omit<Hook, \"id\" | \"createdAt\" | \"modifiedAt\" | \"executionCount\">\n\t): Promise<Hook> {\n\t\t// Check name uniqueness\n\t\tconst nameExists = await this.isHookNameUnique(hook.name);\n\t\tif (!nameExists) {\n\t\t\tthrow new DuplicateHookNameError(hook.name);\n\t\t}\n\n\t\t// Create full hook with generated fields\n\t\tconst now = Date.now();\n\t\tconst newHook: Hook = {\n\t\t\t...hook,\n\t\t\tid: randomUUID(),\n\t\t\tcreatedAt: now,\n\t\t\tmodifiedAt: now,\n\t\t\texecutionCount: 0,\n\t\t};\n\n\t\t// Validate (now async to support MCP validation)\n\t\tconst validation = await this.validateHook(newHook);\n\t\tif (!validation.valid) {\n\t\t\tthrow new HookValidationError(\n\t\t\t\t\"Hook validation failed\",\n\t\t\t\tvalidation.errors\n\t\t\t);\n\t\t}\n\n\t\t// Add to collection\n\t\tthis.hooks.push(newHook);\n\n\t\t// Persist\n\t\tawait this.saveHooks();\n\n\t\t// Emit events\n\t\tthis._onHookCreated.fire(newHook);\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Created hook: ${newHook.name} (${newHook.id})`\n\t\t);\n\n\t\treturn newHook;\n\t}",
    "start_line": 131,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createHook",
    "component_id": "src.features.hooks.hook-manager.createHook"
  },
  "src.features.hooks.hook-manager.getHook": {
    "id": "src.features.hooks.hook-manager.getHook",
    "name": "getHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "getHook(id: string): Hook | undefined {\n\t\treturn this.hooks.find((h) => h.id === id);\n\t}",
    "start_line": 179,
    "end_line": 181,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getHook",
    "component_id": "src.features.hooks.hook-manager.getHook"
  },
  "src.features.hooks.hook-manager.getAllHooks": {
    "id": "src.features.hooks.hook-manager.getAllHooks",
    "name": "getAllHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "getAllHooks(): Hook[] {\n\t\treturn [...this.hooks]; // Return copy\n\t}",
    "start_line": 186,
    "end_line": 188,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAllHooks",
    "component_id": "src.features.hooks.hook-manager.getAllHooks"
  },
  "src.features.hooks.hook-manager.updateHook": {
    "id": "src.features.hooks.hook-manager.updateHook",
    "name": "updateHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async updateHook(id: string, updates: Partial<Hook>): Promise<Hook> {\n\t\tconst index = this.hooks.findIndex((h) => h.id === id);\n\t\tif (index === -1) {\n\t\t\tthrow new HookNotFoundError(id);\n\t\t}\n\n\t\tconst existingHook = this.hooks[index];\n\n\t\t// Prevent updating immutable fields\n\t\tconst {\n\t\t\tid: _id,\n\t\t\tcreatedAt: _createdAt,\n\t\t\texecutionCount: _execCount,\n\t\t\t...allowedUpdates\n\t\t} = updates;\n\n\t\t// Check name uniqueness if name is being changed\n\t\tif (allowedUpdates.name && allowedUpdates.name !== existingHook.name) {\n\t\t\tconst nameExists = await this.isHookNameUnique(allowedUpdates.name, id);\n\t\t\tif (!nameExists) {\n\t\t\t\tthrow new DuplicateHookNameError(allowedUpdates.name);\n\t\t\t}\n\t\t}\n\n\t\t// Merge updates\n\t\tconst updatedHook: Hook = {\n\t\t\t...existingHook,\n\t\t\t...allowedUpdates,\n\t\t\tmodifiedAt: Date.now(),\n\t\t};\n\n\t\t// Validate (now async to support MCP validation)\n\t\tconst validation = await this.validateHook(updatedHook);\n\t\tif (!validation.valid) {\n\t\t\tthrow new HookValidationError(\n\t\t\t\t\"Hook validation failed\",\n\t\t\t\tvalidation.errors\n\t\t\t);\n\t\t}\n\n\t\t// Update in collection\n\t\tthis.hooks[index] = updatedHook;\n\n\t\t// Persist\n\t\tawait this.saveHooks();\n\n\t\t// Emit events\n\t\tthis._onHookUpdated.fire(updatedHook);\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Updated hook: ${updatedHook.name} (${id})`\n\t\t);\n\n\t\treturn updatedHook;\n\t}",
    "start_line": 193,
    "end_line": 248,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id",
      "updates"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method updateHook",
    "component_id": "src.features.hooks.hook-manager.updateHook"
  },
  "src.features.hooks.hook-manager.deleteHook": {
    "id": "src.features.hooks.hook-manager.deleteHook",
    "name": "deleteHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async deleteHook(id: string): Promise<boolean> {\n\t\tconst index = this.hooks.findIndex((h) => h.id === id);\n\t\tif (index === -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst deletedHook = this.hooks[index];\n\t\tthis.hooks.splice(index, 1);\n\n\t\t// Persist\n\t\tawait this.saveHooks();\n\n\t\t// Emit events\n\t\tthis._onHookDeleted.fire(id);\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookManager] Deleted hook: ${deletedHook.name} (${id})`\n\t\t);\n\n\t\treturn true;\n\t}",
    "start_line": 253,
    "end_line": 274,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method deleteHook",
    "component_id": "src.features.hooks.hook-manager.deleteHook"
  },
  "src.features.hooks.hook-manager.getEnabledHooks": {
    "id": "src.features.hooks.hook-manager.getEnabledHooks",
    "name": "getEnabledHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "getEnabledHooks(): Hook[] {\n\t\treturn this.hooks.filter((h) => h.enabled);\n\t}",
    "start_line": 279,
    "end_line": 281,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getEnabledHooks",
    "component_id": "src.features.hooks.hook-manager.getEnabledHooks"
  },
  "src.features.hooks.hook-manager.getHooksByTrigger": {
    "id": "src.features.hooks.hook-manager.getHooksByTrigger",
    "name": "getHooksByTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "getHooksByTrigger(agent: string, operation: string): Hook[] {\n\t\treturn this.hooks.filter(\n\t\t\t(h) => h.trigger.agent === agent && h.trigger.operation === operation\n\t\t);\n\t}",
    "start_line": 286,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "operation"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getHooksByTrigger",
    "component_id": "src.features.hooks.hook-manager.getHooksByTrigger"
  },
  "src.features.hooks.hook-manager.disableAllHooks": {
    "id": "src.features.hooks.hook-manager.disableAllHooks",
    "name": "disableAllHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async disableAllHooks(): Promise<void> {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.enabled = false;\n\t\t\thook.modifiedAt = Date.now();\n\t\t}\n\n\t\tawait this.saveHooks();\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\"[HookManager] Disabled all hooks\");\n\t}",
    "start_line": 295,
    "end_line": 305,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method disableAllHooks",
    "component_id": "src.features.hooks.hook-manager.disableAllHooks"
  },
  "src.features.hooks.hook-manager.enableAllHooks": {
    "id": "src.features.hooks.hook-manager.enableAllHooks",
    "name": "enableAllHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async enableAllHooks(): Promise<void> {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.enabled = true;\n\t\t\thook.modifiedAt = Date.now();\n\t\t}\n\n\t\tawait this.saveHooks();\n\t\tthis._onHooksChanged.fire();\n\n\t\tthis.outputChannel.appendLine(\"[HookManager] Enabled all hooks\");\n\t}",
    "start_line": 310,
    "end_line": 320,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method enableAllHooks",
    "component_id": "src.features.hooks.hook-manager.enableAllHooks"
  },
  "src.features.hooks.hook-manager.saveHooks": {
    "id": "src.features.hooks.hook-manager.saveHooks",
    "name": "saveHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async saveHooks(): Promise<void> {\n\t\ttry {\n\t\t\tawait this.context.workspaceState.update(HOOKS_STORAGE_KEY, this.hooks);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Saved ${this.hooks.length} hooks to workspace state`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Error saving hooks: ${err.message}`\n\t\t\t);\n\t\t\tthrow new PersistenceError(\"Failed to save hooks\", err);\n\t\t}\n\t}",
    "start_line": 325,
    "end_line": 338,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method saveHooks",
    "component_id": "src.features.hooks.hook-manager.saveHooks"
  },
  "src.features.hooks.hook-manager.loadHooks": {
    "id": "src.features.hooks.hook-manager.loadHooks",
    "name": "loadHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "loadHooks(): void {\n\t\ttry {\n\t\t\tconst stored = this.context.workspaceState.get<Hook[]>(\n\t\t\t\tHOOKS_STORAGE_KEY,\n\t\t\t\t[]\n\t\t\t);\n\n\t\t\t// Validate all loaded hooks and migrate old hooks\n\t\t\tconst validHooks: Hook[] = [];\n\t\t\tfor (const hook of stored) {\n\t\t\t\t// Migration: Add default timing \"after\" for hooks created before timing feature\n\t\t\t\tif (!hook.trigger.timing) {\n\t\t\t\t\thook.trigger.timing = \"after\";\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Migration: Set default timing \"after\" for hook: ${hook.name}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Migration: Rename agentId to modelId in MCP actions\n\t\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\t\tconst mcpParams = hook.action.parameters as any;\n\t\t\t\t\tif (mcpParams.agentId && !mcpParams.modelId) {\n\t\t\t\t\t\tmcpParams.modelId = mcpParams.agentId;\n\t\t\t\t\t\tmcpParams.agentId = undefined;\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookManager] Migration: Renamed agentId to modelId for MCP hook: ${hook.name}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isValidHook(hook)) {\n\t\t\t\t\tvalidHooks.push(hook);\n\t\t\t\t} else {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Warning: Invalid hook found in storage, skipping: ${JSON.stringify(hook)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.hooks = validHooks;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Loaded ${this.hooks.length} hooks from workspace state`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Error loading hooks: ${err.message}`\n\t\t\t);\n\t\t\tthis.hooks = [];\n\t\t}\n\t}",
    "start_line": 343,
    "end_line": 392,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadHooks",
    "component_id": "src.features.hooks.hook-manager.loadHooks"
  },
  "src.features.hooks.hook-manager.exportHooks": {
    "id": "src.features.hooks.hook-manager.exportHooks",
    "name": "exportHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "exportHooks(): string {\n\t\treturn JSON.stringify(this.hooks, null, 2);\n\t}",
    "start_line": 397,
    "end_line": 399,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method exportHooks",
    "component_id": "src.features.hooks.hook-manager.exportHooks"
  },
  "src.features.hooks.hook-manager.importHooks": {
    "id": "src.features.hooks.hook-manager.importHooks",
    "name": "importHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async importHooks(json: string): Promise<number> {\n\t\ttry {\n\t\t\tconst imported = JSON.parse(json) as Hook[];\n\n\t\t\tif (!Array.isArray(imported)) {\n\t\t\t\tthrow new Error(\"Invalid JSON: expected array of hooks\");\n\t\t\t}\n\n\t\t\tlet importedCount = 0;\n\n\t\t\tfor (const hook of imported) {\n\t\t\t\t// Validate hook structure\n\t\t\t\tif (!isValidHook(hook)) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Warning: Skipping invalid hook: ${JSON.stringify(hook)}`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Skip duplicates by name\n\t\t\t\tconst nameExists = await this.isHookNameUnique(hook.name);\n\t\t\t\tif (!nameExists) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookManager] Warning: Skipping duplicate hook: ${hook.name}`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Add hook (regenerate ID to avoid conflicts)\n\t\t\t\tconst newHook: Hook = {\n\t\t\t\t\t...hook,\n\t\t\t\t\tid: randomUUID(),\n\t\t\t\t\tcreatedAt: Date.now(),\n\t\t\t\t\tmodifiedAt: Date.now(),\n\t\t\t\t};\n\n\t\t\t\tthis.hooks.push(newHook);\n\t\t\t\timportedCount += 1;\n\t\t\t}\n\n\t\t\tif (importedCount > 0) {\n\t\t\t\tawait this.saveHooks();\n\t\t\t\tthis._onHooksChanged.fire();\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Imported ${importedCount} hooks`\n\t\t\t);\n\n\t\t\treturn importedCount;\n\t\t} catch (error) {\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Error importing hooks: ${err.message}`\n\t\t\t);\n\t\t\tthrow new Error(`Failed to import hooks: ${err.message}`);\n\t\t}\n\t}",
    "start_line": 404,
    "end_line": 461,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "json"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method importHooks",
    "component_id": "src.features.hooks.hook-manager.importHooks"
  },
  "src.features.hooks.hook-manager.validateHook": {
    "id": "src.features.hooks.hook-manager.validateHook",
    "name": "validateHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async validateHook(hook: Hook): Promise<ValidationResult> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\t// Basic structure validation - early return for invalid structure\n\t\tif (!hook || typeof hook !== \"object\") {\n\t\t\terrors.push({\n\t\t\t\tfield: \"hook\",\n\t\t\t\tmessage: \"Hook must be an object\",\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\n\t\t// Collect all validation errors\n\t\terrors.push(...this.validateHookName(hook.name));\n\t\terrors.push(...this.validateAgentTypeParam(hook));\n\t\terrors.push(...this.validateHookStructure(hook));\n\n\t\t// Async validations\n\t\tconst asyncErrors = await this.performAsyncValidations(hook);\n\t\terrors.push(...asyncErrors);\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t};\n\t}",
    "start_line": 467,
    "end_line": 492,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateHook",
    "component_id": "src.features.hooks.hook-manager.validateHook"
  },
  "src.features.hooks.hook-manager.validateHookStructure": {
    "id": "src.features.hooks.hook-manager.validateHookStructure",
    "name": "validateHookStructure",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateHookStructure(hook: Hook): ValidationError[] {\n\t\tif (isValidHook(hook)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst errors: ValidationError[] = [];\n\t\terrors.push(...this.validateHookId(hook));\n\t\terrors.push(...this.validateHookTrigger(hook));\n\t\terrors.push(...this.validateHookAction(hook));\n\n\t\treturn errors;\n\t}",
    "start_line": 497,
    "end_line": 508,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateHookStructure",
    "component_id": "src.features.hooks.hook-manager.validateHookStructure"
  },
  "src.features.hooks.hook-manager.validateHookId": {
    "id": "src.features.hooks.hook-manager.validateHookId",
    "name": "validateHookId",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateHookId(hook: Hook): ValidationError[] {\n\t\tif (!hook.id || typeof hook.id !== \"string\") {\n\t\t\treturn [{ field: \"id\", message: \"Hook ID is missing or invalid\" }];\n\t\t}\n\t\treturn [];\n\t}",
    "start_line": 513,
    "end_line": 518,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateHookId",
    "component_id": "src.features.hooks.hook-manager.validateHookId"
  },
  "src.features.hooks.hook-manager.validateHookTrigger": {
    "id": "src.features.hooks.hook-manager.validateHookTrigger",
    "name": "validateHookTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateHookTrigger(hook: Hook): ValidationError[] {\n\t\tif (!hook.trigger || typeof hook.trigger !== \"object\") {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tfield: \"trigger\",\n\t\t\t\t\tmessage: \"Trigger configuration is invalid\",\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t\treturn [];\n\t}",
    "start_line": 523,
    "end_line": 533,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateHookTrigger",
    "component_id": "src.features.hooks.hook-manager.validateHookTrigger"
  },
  "src.features.hooks.hook-manager.validateHookAction": {
    "id": "src.features.hooks.hook-manager.validateHookAction",
    "name": "validateHookAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateHookAction(hook: Hook): ValidationError[] {\n\t\tif (!hook.action || typeof hook.action !== \"object\") {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tfield: \"action\",\n\t\t\t\t\tmessage: \"Action configuration is invalid\",\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\tif (!isValidAction(hook.action)) {\n\t\t\treturn this.validateActionParameters(hook.action);\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 538,
    "end_line": 553,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateHookAction",
    "component_id": "src.features.hooks.hook-manager.validateHookAction"
  },
  "src.features.hooks.hook-manager.validateActionParameters": {
    "id": "src.features.hooks.hook-manager.validateActionParameters",
    "name": "validateActionParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateActionParameters(action: HookAction): ValidationError[] {\n\t\tif (action.type === \"custom\") {\n\t\t\tconst params = action.parameters as any;\n\t\t\tif (!(params?.agentId || params?.agentName)) {\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\t\t\tmessage: \"Agent ID or agent name is required\",\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn [\n\t\t\t{\n\t\t\t\tfield: \"action\",\n\t\t\t\tmessage: \"Action parameters are invalid\",\n\t\t\t},\n\t\t];\n\t}",
    "start_line": 558,
    "end_line": 577,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "action"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateActionParameters",
    "component_id": "src.features.hooks.hook-manager.validateActionParameters"
  },
  "src.features.hooks.hook-manager.performAsyncValidations": {
    "id": "src.features.hooks.hook-manager.performAsyncValidations",
    "name": "performAsyncValidations",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private async performAsyncValidations(\n\t\thook: Hook\n\t): Promise<ValidationError[]> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\t// T085: Validate MCP server references\n\t\tif (hook.action.type === \"mcp\" && this.mcpDiscoveryService) {\n\t\t\tconst mcpErrors = await this.validateMCPServerRef(hook);\n\t\t\terrors.push(...mcpErrors);\n\t\t}\n\n\t\t// T025: Validate custom agent references\n\t\tif (hook.action.type === \"custom\" && this.agentRegistry) {\n\t\t\tconst customErrors = await this.validateCustomAgentRef(hook);\n\t\t\terrors.push(...customErrors);\n\t\t}\n\n\t\treturn errors;\n\t}",
    "start_line": 582,
    "end_line": 600,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method performAsyncValidations",
    "component_id": "src.features.hooks.hook-manager.performAsyncValidations"
  },
  "src.features.hooks.hook-manager.validateHookName": {
    "id": "src.features.hooks.hook-manager.validateHookName",
    "name": "validateHookName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateHookName(name: string | undefined): ValidationError[] {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tif (!name || name.length === 0) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"name\",\n\t\t\t\tmessage: \"Hook name cannot be empty\",\n\t\t\t});\n\t\t\treturn errors;\n\t\t}\n\n\t\tif (name.length > MAX_HOOK_NAME_LENGTH) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"name\",\n\t\t\t\tmessage: `Hook name must be ${MAX_HOOK_NAME_LENGTH} characters or less`,\n\t\t\t});\n\t\t}\n\n\t\treturn errors;\n\t}",
    "start_line": 605,
    "end_line": 624,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateHookName",
    "component_id": "src.features.hooks.hook-manager.validateHookName"
  },
  "src.features.hooks.hook-manager.validateAgentTypeParam": {
    "id": "src.features.hooks.hook-manager.validateAgentTypeParam",
    "name": "validateAgentTypeParam",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private validateAgentTypeParam(hook: Hook): ValidationError[] {\n\t\tif (hook.action?.type !== \"custom\") {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst customParams = hook.action.parameters as any;\n\t\tif (!customParams?.agentType) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst validTypes: string[] = [\"local\", \"background\"];\n\t\tif (!validTypes.includes(customParams.agentType)) {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tfield: \"action.parameters.agentType\",\n\t\t\t\t\tmessage: `Invalid agent type \"${customParams.agentType}\". Must be \"local\" or \"background\".`,\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 629,
    "end_line": 650,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateAgentTypeParam",
    "component_id": "src.features.hooks.hook-manager.validateAgentTypeParam"
  },
  "src.features.hooks.hook-manager.validateMCPServerRef": {
    "id": "src.features.hooks.hook-manager.validateMCPServerRef",
    "name": "validateMCPServerRef",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private async validateMCPServerRef(hook: Hook): Promise<ValidationError[]> {\n\t\tconst mcpParams = hook.action.parameters as MCPActionParams;\n\t\tconst serverId = mcpParams.serverId;\n\t\tconst toolName = mcpParams.toolName;\n\n\t\t// Skip validation if legacy fields not present\n\t\tif (!(serverId && toolName)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst serverValid = await this.validateMCPServer(serverId, toolName);\n\t\treturn serverValid.valid ? [] : serverValid.errors;\n\t}",
    "start_line": 655,
    "end_line": 667,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateMCPServerRef",
    "component_id": "src.features.hooks.hook-manager.validateMCPServerRef"
  },
  "src.features.hooks.hook-manager.validateCustomAgentRef": {
    "id": "src.features.hooks.hook-manager.validateCustomAgentRef",
    "name": "validateCustomAgentRef",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "private async validateCustomAgentRef(hook: Hook): Promise<ValidationError[]> {\n\t\tconst customParams = hook.action.parameters as CustomActionParams;\n\t\tconst agentId = customParams.agentId || customParams.agentName;\n\t\tconst agentValid = await this.validateCustomAgent(agentId);\n\t\treturn agentValid.valid ? [] : agentValid.errors;\n\t}",
    "start_line": 672,
    "end_line": 677,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateCustomAgentRef",
    "component_id": "src.features.hooks.hook-manager.validateCustomAgentRef"
  },
  "src.features.hooks.hook-manager.validateCustomAgent": {
    "id": "src.features.hooks.hook-manager.validateCustomAgent",
    "name": "validateCustomAgent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async validateCustomAgent(agentId?: string): Promise<ValidationResult> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tif (!this.agentRegistry) {\n\t\t\t// If no registry, skip validation (graceful degradation)\n\t\t\treturn { valid: true, errors };\n\t\t}\n\n\t\tif (!agentId) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\tmessage: \"Agent ID is required for custom actions\",\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if agent exists\n\t\t\tconst agent = this.agentRegistry.getAgentById(agentId);\n\n\t\t\tif (!agent) {\n\t\t\t\terrors.push({\n\t\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\t\tmessage: `Agent \"${agentId}\" not found. Please select a valid agent.`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\t// T025.5: Check if agent is available (warn but don't fail)\n\t\t\t// TypeScript: agentId is guaranteed non-undefined here due to check above\n\t\t\tconst availCheck = await this.agentRegistry.checkAgentAvailability(\n\t\t\t\tagentId as string\n\t\t\t);\n\t\t\tif (!availCheck.available) {\n\t\t\t\t// Warning - allow saving but notify\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookManager] Warning: Agent \"${agentId}\" is not currently available: ${availCheck.reason}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn { valid: true, errors };\n\t\t} catch (error) {\n\t\t\terrors.push({\n\t\t\t\tfield: \"action.parameters.agentId\",\n\t\t\t\tmessage: `Failed to validate agent: ${(error as Error).message}`,\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\t}",
    "start_line": 683,
    "end_line": 731,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateCustomAgent",
    "component_id": "src.features.hooks.hook-manager.validateCustomAgent"
  },
  "src.features.hooks.hook-manager.validateMCPServer": {
    "id": "src.features.hooks.hook-manager.validateMCPServer",
    "name": "validateMCPServer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async validateMCPServer(\n\t\tserverId: string,\n\t\ttoolName: string\n\t): Promise<ValidationResult> {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tif (!this.mcpDiscoveryService) {\n\t\t\t// If no discovery service, skip validation (graceful degradation)\n\t\t\treturn { valid: true, errors };\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if server exists\n\t\t\tconst server = await this.mcpDiscoveryService.getServer(serverId);\n\n\t\t\tif (!server) {\n\t\t\t\terrors.push({\n\t\t\t\t\tfield: \"action.parameters.serverId\",\n\t\t\t\t\tmessage: `MCP server \"${serverId}\" not found. Please verify the server ID or update the hook configuration.`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\t// T086: Check if server is available (warn but don't fail validation)\n\t\t\tif (server.status === \"unavailable\") {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookManager] Warning: MCP server \"${serverId}\" is currently unavailable`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check if tool exists in server\n\t\t\tconst tool = await this.mcpDiscoveryService.getTool(serverId, toolName);\n\n\t\t\tif (!tool) {\n\t\t\t\terrors.push({\n\t\t\t\t\tfield: \"action.parameters.toolName\",\n\t\t\t\t\tmessage: `MCP tool \"${toolName}\" not found in server \"${serverId}\". Please verify the tool name or update the hook configuration.`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\treturn { valid: true, errors };\n\t\t} catch (error) {\n\t\t\t// Graceful degradation - log error but don't fail validation\n\t\t\tconst err = error as Error;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookManager] Warning: Failed to validate MCP server: ${err.message}`\n\t\t\t);\n\n\t\t\t// Return valid to allow hook to be saved (execution will fail gracefully)\n\t\t\treturn { valid: true, errors };\n\t\t}\n\t}",
    "start_line": 737,
    "end_line": 789,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateMCPServer",
    "component_id": "src.features.hooks.hook-manager.validateMCPServer"
  },
  "src.features.hooks.hook-manager.getInvalidMCPHooks": {
    "id": "src.features.hooks.hook-manager.getInvalidMCPHooks",
    "name": "getInvalidMCPHooks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "async getInvalidMCPHooks(): Promise<\n\t\tArray<{ hook: Hook; errors: ValidationError[] }>\n\t> {\n\t\tconst invalidHooks: Array<{ hook: Hook; errors: ValidationError[] }> = [];\n\n\t\tfor (const hook of this.hooks) {\n\t\t\tif (hook.action.type === \"mcp\") {\n\t\t\t\tconst validation = await this.validateHook(hook);\n\t\t\t\tif (!validation.valid) {\n\t\t\t\t\tinvalidHooks.push({\n\t\t\t\t\t\thook,\n\t\t\t\t\t\terrors: validation.errors,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invalidHooks;\n\t}",
    "start_line": 794,
    "end_line": 812,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getInvalidMCPHooks",
    "component_id": "src.features.hooks.hook-manager.getInvalidMCPHooks"
  },
  "src.features.hooks.hook-manager.isHookNameUnique": {
    "id": "src.features.hooks.hook-manager.isHookNameUnique",
    "name": "isHookNameUnique",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/hook-manager.ts",
    "relative_path": "src/features/hooks/hook-manager.ts",
    "depends_on": [],
    "source_code": "isHookNameUnique(name: string, excludeId?: string): boolean {\n\t\tconst existing = this.hooks.find(\n\t\t\t(h) => h.name === name && h.id !== excludeId\n\t\t);\n\t\treturn !existing;\n\t}",
    "start_line": 817,
    "end_line": 822,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "excludeId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isHookNameUnique",
    "component_id": "src.features.hooks.hook-manager.isHookNameUnique"
  },
  "src.features.hooks.services.command-completion-detector.CommandCompletionDetector": {
    "id": "src.features.hooks.services.command-completion-detector.CommandCompletionDetector",
    "name": "CommandCompletionDetector",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "ui.src.features.hooks-view.types.OperationType",
      "src.features.hooks.trigger-registry.fireTrigger",
      "src.utils.task-parser.parseTasksFromFile",
      "src.features.hooks.services.command-completion-detector.validateFileProcessing",
      "src.features.hooks.services.command-completion-detector.handleFileChange",
      "src.features.hooks.trigger-registry.TriggerRegistry",
      "src.services.agent-service.dispose",
      "src.features.hooks.services.command-completion-detector.dispose",
      "src.features.agents.resource-cache.get",
      "src.features.spec.spec-manager.delete"
    ],
    "source_code": "class CommandCompletionDetector {\n\tprivate readonly triggerRegistry: TriggerRegistry;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate watchers: FileSystemWatcher[] = [];\n\tprivate readonly debounceTimers: Map<string, NodeJS.Timeout> = new Map();\n\tprivate readonly lastTriggered: Map<string, number> = new Map();\n\n\tconstructor(triggerRegistry: TriggerRegistry, outputChannel: OutputChannel) {\n\t\tthis.triggerRegistry = triggerRegistry;\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Initialize file watchers for all operations\n\t */\n\tinitialize(): void {\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[CommandCompletionDetector] Initializing file watchers...\"\n\t\t);\n\n\t\t// Create watchers for each operation\n\t\tfor (const [operation, patterns] of Object.entries(\n\t\t\tOPERATION_FILE_PATTERNS\n\t\t)) {\n\t\t\tfor (const pattern of patterns) {\n\t\t\t\tconst watcher = workspace.createFileSystemWatcher(pattern);\n\n\t\t\t\t// Watch for both create and change events\n\t\t\t\twatcher.onDidCreate((uri) =>\n\t\t\t\t\tthis.handleFileChange(uri, operation as OperationType)\n\t\t\t\t);\n\t\t\t\twatcher.onDidChange((uri) =>\n\t\t\t\t\tthis.handleFileChange(uri, operation as OperationType)\n\t\t\t\t);\n\n\t\t\t\tthis.watchers.push(watcher);\n\t\t\t}\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[CommandCompletionDetector] Initialized ${this.watchers.length} file watchers`\n\t\t);\n\t}\n\n\t/**\n\t * Handle file creation/modification\n\t */\n\tprivate handleFileChange(uri: Uri, operation: OperationType): void {\n\t\tconst key = `speckit.${operation}`;\n\t\tconst now = Date.now();\n\n\t\t// Check if we recently triggered this operation (avoid duplicates)\n\t\tconst lastTrigger = this.lastTriggered.get(key) || 0;\n\t\tif (now - lastTrigger < DEBOUNCE_DELAY_MS) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] Ignoring duplicate trigger for ${key} (too soon)`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear existing debounce timer\n\t\tconst existingTimer = this.debounceTimers.get(key);\n\t\tif (existingTimer) {\n\t\t\tclearTimeout(existingTimer);\n\t\t}\n\n\t\t// Create new debounce timer\n\t\tconst timer = setTimeout(async () => {\n\t\t\t// Validate that the file was successfully processed before triggering\n\t\t\tconst isValid = await this.validateFileProcessing(uri, operation);\n\n\t\t\tif (!isValid) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CommandCompletionDetector] Skipping trigger for ${key} - file not yet valid`\n\t\t\t\t);\n\t\t\t\tthis.debounceTimers.delete(key);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] Detected completion: ${key} (file: ${uri.fsPath})`\n\t\t\t);\n\n\t\t\t// Read file content for output capture\n\t\t\tlet outputContent = \"\";\n\t\t\ttry {\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\toutputContent = await fs.readFile(uri.fsPath, \"utf-8\");\n\t\t\t} catch (error) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CommandCompletionDetector] Warning: Failed to read output file: ${error}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Fire the trigger with output data\n\t\t\tthis.triggerRegistry.fireTrigger(\"speckit\", operation, \"after\", {\n\t\t\t\toutputPath: uri.fsPath,\n\t\t\t\toutputContent,\n\t\t\t});\n\n\t\t\t// Record trigger time\n\t\t\tthis.lastTriggered.set(key, Date.now());\n\n\t\t\t// Clean up timer\n\t\t\tthis.debounceTimers.delete(key);\n\t\t}, DEBOUNCE_DELAY_MS);\n\n\t\tthis.debounceTimers.set(key, timer);\n\t}\n\n\t/**\n\t * Validate that a file has been successfully processed\n\t *\n\t * This ensures we only trigger hooks when:\n\t * 1. The file exists and is readable\n\t * 2. The content is valid and parseable\n\t * 3. For tasks files, tasks are valid and processable\n\t */\n\tprivate async validateFileProcessing(\n\t\turi: Uri,\n\t\toperation: OperationType\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\t// Check if file exists and is readable\n\t\t\tconst stat = await workspace.fs.stat(uri);\n\t\t\tif (stat.size === 0) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CommandCompletionDetector] File is empty: ${uri.fsPath}`\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// For tasks operation, validate that tasks are parseable\n\t\t\tif (operation === \"tasks\" || operation === \"taskstoissues\") {\n\t\t\t\ttry {\n\t\t\t\t\tconst tasks = await parseTasksFromFile(uri.fsPath);\n\n\t\t\t\t\t// Check if we have valid tasks\n\t\t\t\t\tif (!tasks || tasks.length === 0) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[CommandCompletionDetector] No valid tasks found in: ${uri.fsPath}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[CommandCompletionDetector] Successfully parsed ${tasks.length} tasks from: ${uri.fsPath}`\n\t\t\t\t\t);\n\t\t\t\t} catch (parseError) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[CommandCompletionDetector] Failed to parse tasks: ${parseError}`\n\t\t\t\t\t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For other operations, just check the file exists and has content\n\t\t\t// In the future, we could add specific validators for each operation type\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] File validated successfully: ${uri.fsPath}`\n\t\t\t);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] Error validating file: ${error}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Dispose of all watchers\n\t */\n\tdispose(): void {\n\t\t// Clear all debounce timers\n\t\tfor (const timer of this.debounceTimers.values()) {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t\tthis.debounceTimers.clear();\n\n\t\t// Dispose all watchers\n\t\tfor (const watcher of this.watchers) {\n\t\t\twatcher.dispose();\n\t\t}\n\t\tthis.watchers = [];\n\n\t\tthis.outputChannel.appendLine(\"[CommandCompletionDetector] Disposed\");\n\t}\n\n\t/**\n\t * Manually trigger completion for an operation\n\t * (useful for testing or manual triggers)\n\t */\n\tmanualTrigger(operation: OperationType): void {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[CommandCompletionDetector] Manual trigger: speckit.${operation}`\n\t\t);\n\t\t// Manual triggers don't have output capture\n\t\tthis.triggerRegistry.fireTrigger(\"speckit\", operation, \"after\");\n\t\tthis.lastTriggered.set(`speckit.${operation}`, Date.now());\n\t}\n\n\t/**\n\t * Clear trigger history (useful for testing)\n\t */\n\tclearHistory(): void {\n\t\tthis.lastTriggered.clear();\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[CommandCompletionDetector] Trigger history cleared\"\n\t\t);\n\t}\n}",
    "start_line": 77,
    "end_line": 289,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CommandCompletionDetector",
    "component_id": "src.features.hooks.services.command-completion-detector.CommandCompletionDetector"
  },
  "src.features.hooks.services.command-completion-detector.initialize": {
    "id": "src.features.hooks.services.command-completion-detector.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [],
    "source_code": "initialize(): void {\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[CommandCompletionDetector] Initializing file watchers...\"\n\t\t);\n\n\t\t// Create watchers for each operation\n\t\tfor (const [operation, patterns] of Object.entries(\n\t\t\tOPERATION_FILE_PATTERNS\n\t\t)) {\n\t\t\tfor (const pattern of patterns) {\n\t\t\t\tconst watcher = workspace.createFileSystemWatcher(pattern);\n\n\t\t\t\t// Watch for both create and change events\n\t\t\t\twatcher.onDidCreate((uri) =>\n\t\t\t\t\tthis.handleFileChange(uri, operation as OperationType)\n\t\t\t\t);\n\t\t\t\twatcher.onDidChange((uri) =>\n\t\t\t\t\tthis.handleFileChange(uri, operation as OperationType)\n\t\t\t\t);\n\n\t\t\t\tthis.watchers.push(watcher);\n\t\t\t}\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[CommandCompletionDetector] Initialized ${this.watchers.length} file watchers`\n\t\t);\n\t}",
    "start_line": 92,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initialize",
    "component_id": "src.features.hooks.services.command-completion-detector.initialize"
  },
  "src.features.hooks.services.command-completion-detector.handleFileChange": {
    "id": "src.features.hooks.services.command-completion-detector.handleFileChange",
    "name": "handleFileChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [],
    "source_code": "private handleFileChange(uri: Uri, operation: OperationType): void {\n\t\tconst key = `speckit.${operation}`;\n\t\tconst now = Date.now();\n\n\t\t// Check if we recently triggered this operation (avoid duplicates)\n\t\tconst lastTrigger = this.lastTriggered.get(key) || 0;\n\t\tif (now - lastTrigger < DEBOUNCE_DELAY_MS) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] Ignoring duplicate trigger for ${key} (too soon)`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear existing debounce timer\n\t\tconst existingTimer = this.debounceTimers.get(key);\n\t\tif (existingTimer) {\n\t\t\tclearTimeout(existingTimer);\n\t\t}\n\n\t\t// Create new debounce timer\n\t\tconst timer = setTimeout(async () => {\n\t\t\t// Validate that the file was successfully processed before triggering\n\t\t\tconst isValid = await this.validateFileProcessing(uri, operation);\n\n\t\t\tif (!isValid) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CommandCompletionDetector] Skipping trigger for ${key} - file not yet valid`\n\t\t\t\t);\n\t\t\t\tthis.debounceTimers.delete(key);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] Detected completion: ${key} (file: ${uri.fsPath})`\n\t\t\t);\n\n\t\t\t// Read file content for output capture\n\t\t\tlet outputContent = \"\";\n\t\t\ttry {\n\t\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\t\toutputContent = await fs.readFile(uri.fsPath, \"utf-8\");\n\t\t\t} catch (error) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CommandCompletionDetector] Warning: Failed to read output file: ${error}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Fire the trigger with output data\n\t\t\tthis.triggerRegistry.fireTrigger(\"speckit\", operation, \"after\", {\n\t\t\t\toutputPath: uri.fsPath,\n\t\t\t\toutputContent,\n\t\t\t});\n\n\t\t\t// Record trigger time\n\t\t\tthis.lastTriggered.set(key, Date.now());\n\n\t\t\t// Clean up timer\n\t\t\tthis.debounceTimers.delete(key);\n\t\t}, DEBOUNCE_DELAY_MS);\n\n\t\tthis.debounceTimers.set(key, timer);\n\t}",
    "start_line": 124,
    "end_line": 185,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "operation"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleFileChange",
    "component_id": "src.features.hooks.services.command-completion-detector.handleFileChange"
  },
  "src.features.hooks.services.command-completion-detector.validateFileProcessing": {
    "id": "src.features.hooks.services.command-completion-detector.validateFileProcessing",
    "name": "validateFileProcessing",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [],
    "source_code": "private async validateFileProcessing(\n\t\turi: Uri,\n\t\toperation: OperationType\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\t// Check if file exists and is readable\n\t\t\tconst stat = await workspace.fs.stat(uri);\n\t\t\tif (stat.size === 0) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CommandCompletionDetector] File is empty: ${uri.fsPath}`\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// For tasks operation, validate that tasks are parseable\n\t\t\tif (operation === \"tasks\" || operation === \"taskstoissues\") {\n\t\t\t\ttry {\n\t\t\t\t\tconst tasks = await parseTasksFromFile(uri.fsPath);\n\n\t\t\t\t\t// Check if we have valid tasks\n\t\t\t\t\tif (!tasks || tasks.length === 0) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[CommandCompletionDetector] No valid tasks found in: ${uri.fsPath}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[CommandCompletionDetector] Successfully parsed ${tasks.length} tasks from: ${uri.fsPath}`\n\t\t\t\t\t);\n\t\t\t\t} catch (parseError) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[CommandCompletionDetector] Failed to parse tasks: ${parseError}`\n\t\t\t\t\t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For other operations, just check the file exists and has content\n\t\t\t// In the future, we could add specific validators for each operation type\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] File validated successfully: ${uri.fsPath}`\n\t\t\t);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CommandCompletionDetector] Error validating file: ${error}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 195,
    "end_line": 246,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "operation"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method validateFileProcessing",
    "component_id": "src.features.hooks.services.command-completion-detector.validateFileProcessing"
  },
  "src.features.hooks.services.command-completion-detector.dispose": {
    "id": "src.features.hooks.services.command-completion-detector.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\t// Clear all debounce timers\n\t\tfor (const timer of this.debounceTimers.values()) {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t\tthis.debounceTimers.clear();\n\n\t\t// Dispose all watchers\n\t\tfor (const watcher of this.watchers) {\n\t\t\twatcher.dispose();\n\t\t}\n\t\tthis.watchers = [];\n\n\t\tthis.outputChannel.appendLine(\"[CommandCompletionDetector] Disposed\");\n\t}",
    "start_line": 251,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.services.command-completion-detector.dispose"
  },
  "src.features.hooks.services.command-completion-detector.manualTrigger": {
    "id": "src.features.hooks.services.command-completion-detector.manualTrigger",
    "name": "manualTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [],
    "source_code": "manualTrigger(operation: OperationType): void {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[CommandCompletionDetector] Manual trigger: speckit.${operation}`\n\t\t);\n\t\t// Manual triggers don't have output capture\n\t\tthis.triggerRegistry.fireTrigger(\"speckit\", operation, \"after\");\n\t\tthis.lastTriggered.set(`speckit.${operation}`, Date.now());\n\t}",
    "start_line": 271,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operation"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method manualTrigger",
    "component_id": "src.features.hooks.services.command-completion-detector.manualTrigger"
  },
  "src.features.hooks.services.command-completion-detector.clearHistory": {
    "id": "src.features.hooks.services.command-completion-detector.clearHistory",
    "name": "clearHistory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/command-completion-detector.ts",
    "relative_path": "src/features/hooks/services/command-completion-detector.ts",
    "depends_on": [],
    "source_code": "clearHistory(): void {\n\t\tthis.lastTriggered.clear();\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[CommandCompletionDetector] Trigger history cleared\"\n\t\t);\n\t}",
    "start_line": 283,
    "end_line": 288,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearHistory",
    "component_id": "src.features.hooks.services.command-completion-detector.clearHistory"
  },
  "src.features.hooks.services.mcp-client.MCPClientService": {
    "id": "src.features.hooks.services.mcp-client.MCPClientService",
    "name": "MCPClientService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-discovery.getTool",
      "src.features.hooks.services.mcp-client.validateRequiredParameters",
      "src.features.hooks.services.mcp-contracts.ParameterValidationError",
      "src.features.hooks.services.mcp-contracts.MCPToolExecutionResult",
      "src.utils.copilot-mcp-utils.executeMCPTool",
      "src.features.hooks.services.mcp-client.validateParameters",
      "src.features.hooks.services.mcp-client.validateParameterEnum",
      "src.features.hooks.services.mcp-contracts.ParameterValidationResult",
      "src.features.hooks.services.mcp-contracts.MCPTimeoutError",
      "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
      "src.features.hooks.services.mcp-contracts.MCPParameterValidationError",
      "src.features.hooks.services.mcp-discovery.getServer",
      "src.features.hooks.services.mcp-client.validateParameterTypes",
      "src.features.hooks.services.mcp-contracts.MCPServerNotFoundError",
      "src.features.hooks.services.mcp-client.validateParameterType",
      "src.features.hooks.services.mcp-contracts.MCPToolNotFoundError"
    ],
    "source_code": "class MCPClientService implements IMCPClientService {\n\tprivate readonly discoveryService: IMCPDiscoveryService;\n\n\tconstructor(discoveryService: IMCPDiscoveryService) {\n\t\tthis.discoveryService = discoveryService;\n\t}\n\n\t/**\n\t * Execute an MCP tool with resolved parameters\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool to execute\n\t * @param parameters - Resolved parameter values (JSON object)\n\t * @param timeout - Execution timeout in milliseconds\n\t * @returns Promise resolving to execution result\n\t */\n\tasync executeTool(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>,\n\t\ttimeout = MCP_DEFAULT_TIMEOUT\n\t): Promise<MCPToolExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Verify server exists\n\t\t\tconst server = this.discoveryService.getServer(serverId);\n\t\t\tif (!server) {\n\t\t\t\tconst error: MCPServerNotFoundError = {\n\t\t\t\t\tname: \"MCPServerNotFoundError\",\n\t\t\t\t\tmessage: `MCP server not found: ${serverId}`,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Verify tool exists\n\t\t\tconst tool = this.discoveryService.getTool(serverId, toolName);\n\t\t\tif (!tool) {\n\t\t\t\tconst error: MCPToolNotFoundError = {\n\t\t\t\t\tname: \"MCPToolNotFoundError\",\n\t\t\t\t\tmessage: `MCP tool '${toolName}' not found on server '${serverId}'`,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Validate parameters\n\t\t\tconst validation = this.validateParameters(\n\t\t\t\tserverId,\n\t\t\t\ttoolName,\n\t\t\t\tparameters\n\t\t\t);\n\t\t\tif (!validation.valid) {\n\t\t\t\tconst error: MCPParameterValidationError = {\n\t\t\t\t\tname: \"MCPParameterValidationError\",\n\t\t\t\t\tmessage: `Parameter validation failed: ${validation.errors.map((e) => e.message).join(\", \")}`,\n\t\t\t\t\terrors: validation.errors,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Create timeout promise\n\t\t\tconst timeoutPromise = new Promise<never>((_, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst error: MCPTimeoutError = {\n\t\t\t\t\t\tname: \"MCPTimeoutError\",\n\t\t\t\t\t\tmessage: `MCP tool execution timed out after ${timeout}ms`,\n\t\t\t\t\t\ttimeout,\n\t\t\t\t\t};\n\t\t\t\t\treject(error);\n\t\t\t\t}, timeout);\n\t\t\t});\n\n\t\t\t// TODO: Implement actual MCP tool execution via Copilot API\n\t\t\t// For now, return mock success result\n\t\t\tconst executionPromise = (async () => {\n\t\t\t\tconst output = await executeMCPTool(serverId, toolName, parameters);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\toutput,\n\t\t\t\t\tduration: Date.now() - startTime,\n\t\t\t\t};\n\t\t\t})();\n\n\t\t\t// Race between execution and timeout\n\t\t\tconst result = await Promise.race([executionPromise, timeoutPromise]);\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// If error is already one of our custom types, wrap it in result\n\t\t\tif (\n\t\t\t\terror &&\n\t\t\t\ttypeof error === \"object\" &&\n\t\t\t\t\"name\" in error &&\n\t\t\t\t(error.name === \"MCPServerNotFoundError\" ||\n\t\t\t\t\terror.name === \"MCPToolNotFoundError\" ||\n\t\t\t\t\terror.name === \"MCPParameterValidationError\" ||\n\t\t\t\t\terror.name === \"MCPTimeoutError\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error as unknown as MCPExecutionError,\n\t\t\t\t\tduration,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Unknown error - wrap it\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: {\n\t\t\t\t\tcode: \"EXECUTION_ERROR\",\n\t\t\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\t\t\tdetails: error,\n\t\t\t\t},\n\t\t\t\tduration,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Validate parameters against tool's input schema\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool name\n\t * @param parameters - Parameters to validate\n\t * @returns Validation result with errors if invalid\n\t */\n\tvalidateParameters(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>\n\t): ParameterValidationResult {\n\t\tconst errors: ParameterValidationError[] = [];\n\n\t\ttry {\n\t\t\t// Get tool schema\n\t\t\tconst tool = this.discoveryService.getTool(serverId, toolName);\n\t\t\tif (!tool) {\n\t\t\t\terrors.push({\n\t\t\t\t\tparameter: \"_tool\",\n\t\t\t\t\tmessage: `Tool '${toolName}' not found on server '${serverId}'`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\tconst schema = tool.inputSchema;\n\n\t\t\t// Validate required parameters\n\t\t\tthis.validateRequiredParameters(schema, parameters, errors);\n\n\t\t\t// Validate parameter types\n\t\t\tthis.validateParameterTypes(schema, parameters, errors);\n\n\t\t\treturn {\n\t\t\t\tvalid: errors.length === 0,\n\t\t\t\terrors,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\terrors.push({\n\t\t\t\tparameter: \"_validation\",\n\t\t\t\tmessage: `Validation error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\t}\n\n\t/**\n\t * Validate required parameters are present\n\t */\n\tprivate validateRequiredParameters(\n\t\tschema: { required?: string[] },\n\t\tparameters: Record<string, unknown>,\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tif (!schema.required) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const requiredParam of schema.required) {\n\t\t\tif (!(requiredParam in parameters)) {\n\t\t\t\terrors.push({\n\t\t\t\t\tparameter: requiredParam,\n\t\t\t\t\tmessage: `Required parameter '${requiredParam}' is missing`,\n\t\t\t\t\texpected: \"defined\",\n\t\t\t\t\tactual: \"undefined\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate parameter types match schema\n\t */\n\tprivate validateParameterTypes(\n\t\tschema: {\n\t\t\tproperties?: Record<\n\t\t\t\tstring,\n\t\t\t\t{ type: string; enum?: unknown[]; default?: unknown }\n\t\t\t>;\n\t\t\trequired?: string[];\n\t\t},\n\t\tparameters: Record<string, unknown>,\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tif (!schema.properties) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [paramName, paramValue] of Object.entries(parameters)) {\n\t\t\tconst propSchema = schema.properties[paramName];\n\t\t\tif (!propSchema) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Handle null/undefined\n\t\t\tif (paramValue === null || paramValue === undefined) {\n\t\t\t\tif (schema.required?.includes(paramName)) {\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tparameter: paramName,\n\t\t\t\t\t\tmessage: `Required parameter '${paramName}' is null or undefined`,\n\t\t\t\t\t\texpected: propSchema.type,\n\t\t\t\t\t\tactual: String(paramValue),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Type validation\n\t\t\tthis.validateParameterType(paramName, paramValue, propSchema, errors);\n\n\t\t\t// Enum validation\n\t\t\tthis.validateParameterEnum(paramName, paramValue, propSchema, errors);\n\t\t}\n\t}\n\n\t/**\n\t * Validate a single parameter's type\n\t */\n\tprivate validateParameterType(\n\t\tparamName: string,\n\t\tparamValue: unknown,\n\t\tpropSchema: { type: string },\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tconst actualType = typeof paramValue;\n\t\tconst expectedType = propSchema.type;\n\n\t\tconst typeMatches =\n\t\t\t(expectedType === \"string\" && actualType === \"string\") ||\n\t\t\t(expectedType === \"number\" && actualType === \"number\") ||\n\t\t\t(expectedType === \"boolean\" && actualType === \"boolean\");\n\n\t\tif (\n\t\t\t!typeMatches &&\n\t\t\t[\"string\", \"number\", \"boolean\"].includes(expectedType)\n\t\t) {\n\t\t\terrors.push({\n\t\t\t\tparameter: paramName,\n\t\t\t\tmessage: `Parameter '${paramName}' has incorrect type`,\n\t\t\t\texpected: expectedType,\n\t\t\t\tactual: actualType,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Validate a parameter's value against enum constraints\n\t */\n\tprivate validateParameterEnum(\n\t\tparamName: string,\n\t\tparamValue: unknown,\n\t\tpropSchema: { enum?: unknown[] },\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tif (propSchema.enum && !propSchema.enum.includes(paramValue)) {\n\t\t\terrors.push({\n\t\t\t\tparameter: paramName,\n\t\t\t\tmessage: `Parameter '${paramName}' value not in allowed enum values`,\n\t\t\t\texpected: `one of [${propSchema.enum.join(\", \")}]`,\n\t\t\t\tactual: String(paramValue),\n\t\t\t});\n\t\t}\n\t}\n}",
    "start_line": 28,
    "end_line": 310,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPClientService",
    "component_id": "src.features.hooks.services.mcp-client.MCPClientService"
  },
  "src.features.hooks.services.mcp-client.executeTool": {
    "id": "src.features.hooks.services.mcp-client.executeTool",
    "name": "executeTool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [],
    "source_code": "async executeTool(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>,\n\t\ttimeout = MCP_DEFAULT_TIMEOUT\n\t): Promise<MCPToolExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Verify server exists\n\t\t\tconst server = this.discoveryService.getServer(serverId);\n\t\t\tif (!server) {\n\t\t\t\tconst error: MCPServerNotFoundError = {\n\t\t\t\t\tname: \"MCPServerNotFoundError\",\n\t\t\t\t\tmessage: `MCP server not found: ${serverId}`,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Verify tool exists\n\t\t\tconst tool = this.discoveryService.getTool(serverId, toolName);\n\t\t\tif (!tool) {\n\t\t\t\tconst error: MCPToolNotFoundError = {\n\t\t\t\t\tname: \"MCPToolNotFoundError\",\n\t\t\t\t\tmessage: `MCP tool '${toolName}' not found on server '${serverId}'`,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Validate parameters\n\t\t\tconst validation = this.validateParameters(\n\t\t\t\tserverId,\n\t\t\t\ttoolName,\n\t\t\t\tparameters\n\t\t\t);\n\t\t\tif (!validation.valid) {\n\t\t\t\tconst error: MCPParameterValidationError = {\n\t\t\t\t\tname: \"MCPParameterValidationError\",\n\t\t\t\t\tmessage: `Parameter validation failed: ${validation.errors.map((e) => e.message).join(\", \")}`,\n\t\t\t\t\terrors: validation.errors,\n\t\t\t\t};\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\t// Create timeout promise\n\t\t\tconst timeoutPromise = new Promise<never>((_, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst error: MCPTimeoutError = {\n\t\t\t\t\t\tname: \"MCPTimeoutError\",\n\t\t\t\t\t\tmessage: `MCP tool execution timed out after ${timeout}ms`,\n\t\t\t\t\t\ttimeout,\n\t\t\t\t\t};\n\t\t\t\t\treject(error);\n\t\t\t\t}, timeout);\n\t\t\t});\n\n\t\t\t// TODO: Implement actual MCP tool execution via Copilot API\n\t\t\t// For now, return mock success result\n\t\t\tconst executionPromise = (async () => {\n\t\t\t\tconst output = await executeMCPTool(serverId, toolName, parameters);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\toutput,\n\t\t\t\t\tduration: Date.now() - startTime,\n\t\t\t\t};\n\t\t\t})();\n\n\t\t\t// Race between execution and timeout\n\t\t\tconst result = await Promise.race([executionPromise, timeoutPromise]);\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// If error is already one of our custom types, wrap it in result\n\t\t\tif (\n\t\t\t\terror &&\n\t\t\t\ttypeof error === \"object\" &&\n\t\t\t\t\"name\" in error &&\n\t\t\t\t(error.name === \"MCPServerNotFoundError\" ||\n\t\t\t\t\terror.name === \"MCPToolNotFoundError\" ||\n\t\t\t\t\terror.name === \"MCPParameterValidationError\" ||\n\t\t\t\t\terror.name === \"MCPTimeoutError\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: error as unknown as MCPExecutionError,\n\t\t\t\t\tduration,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Unknown error - wrap it\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: {\n\t\t\t\t\tcode: \"EXECUTION_ERROR\",\n\t\t\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\t\t\tdetails: error,\n\t\t\t\t},\n\t\t\t\tduration,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 43,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName",
      "parameters",
      "timeout"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeTool",
    "component_id": "src.features.hooks.services.mcp-client.executeTool"
  },
  "src.features.hooks.services.mcp-client.validateParameters": {
    "id": "src.features.hooks.services.mcp-client.validateParameters",
    "name": "validateParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [],
    "source_code": "validateParameters(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>\n\t): ParameterValidationResult {\n\t\tconst errors: ParameterValidationError[] = [];\n\n\t\ttry {\n\t\t\t// Get tool schema\n\t\t\tconst tool = this.discoveryService.getTool(serverId, toolName);\n\t\t\tif (!tool) {\n\t\t\t\terrors.push({\n\t\t\t\t\tparameter: \"_tool\",\n\t\t\t\t\tmessage: `Tool '${toolName}' not found on server '${serverId}'`,\n\t\t\t\t});\n\t\t\t\treturn { valid: false, errors };\n\t\t\t}\n\n\t\t\tconst schema = tool.inputSchema;\n\n\t\t\t// Validate required parameters\n\t\t\tthis.validateRequiredParameters(schema, parameters, errors);\n\n\t\t\t// Validate parameter types\n\t\t\tthis.validateParameterTypes(schema, parameters, errors);\n\n\t\t\treturn {\n\t\t\t\tvalid: errors.length === 0,\n\t\t\t\terrors,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\terrors.push({\n\t\t\t\tparameter: \"_validation\",\n\t\t\t\tmessage: `Validation error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t});\n\t\t\treturn { valid: false, errors };\n\t\t}\n\t}",
    "start_line": 154,
    "end_line": 191,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName",
      "parameters"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateParameters",
    "component_id": "src.features.hooks.services.mcp-client.validateParameters"
  },
  "src.features.hooks.services.mcp-client.validateRequiredParameters": {
    "id": "src.features.hooks.services.mcp-client.validateRequiredParameters",
    "name": "validateRequiredParameters",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [],
    "source_code": "private validateRequiredParameters(\n\t\tschema: { required?: string[] },\n\t\tparameters: Record<string, unknown>,\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tif (!schema.required) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const requiredParam of schema.required) {\n\t\t\tif (!(requiredParam in parameters)) {\n\t\t\t\terrors.push({\n\t\t\t\t\tparameter: requiredParam,\n\t\t\t\t\tmessage: `Required parameter '${requiredParam}' is missing`,\n\t\t\t\t\texpected: \"defined\",\n\t\t\t\t\tactual: \"undefined\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 196,
    "end_line": 215,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "schema",
      "parameters",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateRequiredParameters",
    "component_id": "src.features.hooks.services.mcp-client.validateRequiredParameters"
  },
  "src.features.hooks.services.mcp-client.validateParameterTypes": {
    "id": "src.features.hooks.services.mcp-client.validateParameterTypes",
    "name": "validateParameterTypes",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [],
    "source_code": "private validateParameterTypes(\n\t\tschema: {\n\t\t\tproperties?: Record<\n\t\t\t\tstring,\n\t\t\t\t{ type: string; enum?: unknown[]; default?: unknown }\n\t\t\t>;\n\t\t\trequired?: string[];\n\t\t},\n\t\tparameters: Record<string, unknown>,\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tif (!schema.properties) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [paramName, paramValue] of Object.entries(parameters)) {\n\t\t\tconst propSchema = schema.properties[paramName];\n\t\t\tif (!propSchema) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Handle null/undefined\n\t\t\tif (paramValue === null || paramValue === undefined) {\n\t\t\t\tif (schema.required?.includes(paramName)) {\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tparameter: paramName,\n\t\t\t\t\t\tmessage: `Required parameter '${paramName}' is null or undefined`,\n\t\t\t\t\t\texpected: propSchema.type,\n\t\t\t\t\t\tactual: String(paramValue),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Type validation\n\t\t\tthis.validateParameterType(paramName, paramValue, propSchema, errors);\n\n\t\t\t// Enum validation\n\t\t\tthis.validateParameterEnum(paramName, paramValue, propSchema, errors);\n\t\t}\n\t}",
    "start_line": 220,
    "end_line": 260,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "schema",
      "parameters",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateParameterTypes",
    "component_id": "src.features.hooks.services.mcp-client.validateParameterTypes"
  },
  "src.features.hooks.services.mcp-client.validateParameterType": {
    "id": "src.features.hooks.services.mcp-client.validateParameterType",
    "name": "validateParameterType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [],
    "source_code": "private validateParameterType(\n\t\tparamName: string,\n\t\tparamValue: unknown,\n\t\tpropSchema: { type: string },\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tconst actualType = typeof paramValue;\n\t\tconst expectedType = propSchema.type;\n\n\t\tconst typeMatches =\n\t\t\t(expectedType === \"string\" && actualType === \"string\") ||\n\t\t\t(expectedType === \"number\" && actualType === \"number\") ||\n\t\t\t(expectedType === \"boolean\" && actualType === \"boolean\");\n\n\t\tif (\n\t\t\t!typeMatches &&\n\t\t\t[\"string\", \"number\", \"boolean\"].includes(expectedType)\n\t\t) {\n\t\t\terrors.push({\n\t\t\t\tparameter: paramName,\n\t\t\t\tmessage: `Parameter '${paramName}' has incorrect type`,\n\t\t\t\texpected: expectedType,\n\t\t\t\tactual: actualType,\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 265,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "paramName",
      "paramValue",
      "propSchema",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateParameterType",
    "component_id": "src.features.hooks.services.mcp-client.validateParameterType"
  },
  "src.features.hooks.services.mcp-client.validateParameterEnum": {
    "id": "src.features.hooks.services.mcp-client.validateParameterEnum",
    "name": "validateParameterEnum",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-client.ts",
    "relative_path": "src/features/hooks/services/mcp-client.ts",
    "depends_on": [],
    "source_code": "private validateParameterEnum(\n\t\tparamName: string,\n\t\tparamValue: unknown,\n\t\tpropSchema: { enum?: unknown[] },\n\t\terrors: ParameterValidationError[]\n\t): void {\n\t\tif (propSchema.enum && !propSchema.enum.includes(paramValue)) {\n\t\t\terrors.push({\n\t\t\t\tparameter: paramName,\n\t\t\t\tmessage: `Parameter '${paramName}' value not in allowed enum values`,\n\t\t\t\texpected: `one of [${propSchema.enum.join(\", \")}]`,\n\t\t\t\tactual: String(paramValue),\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 295,
    "end_line": 309,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "paramName",
      "paramValue",
      "propSchema",
      "errors"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateParameterEnum",
    "component_id": "src.features.hooks.services.mcp-client.validateParameterEnum"
  },
  "src.features.hooks.services.mcp-contracts.ServerStatus": {
    "id": "src.features.hooks.services.mcp-contracts.ServerStatus",
    "name": "ServerStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "type ServerStatus = \"available\" | \"unavailable\" | \"unknown\";",
    "start_line": 12,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ServerStatus",
    "component_id": "src.features.hooks.services.mcp-contracts.ServerStatus"
  },
  "src.features.hooks.services.mcp-contracts.MCPServer": {
    "id": "src.features.hooks.services.mcp-contracts.MCPServer",
    "name": "MCPServer",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.MCPTool",
      "src.features.hooks.services.mcp-contracts.ServerStatus"
    ],
    "source_code": "interface MCPServer {\n\tid: string;\n\tname: string;\n\tdescription?: string;\n\tstatus: ServerStatus;\n\ttools: MCPTool[];\n\tlastDiscovered: number;\n}",
    "start_line": 14,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServer",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPServer"
  },
  "src.features.hooks.services.mcp-contracts.MCPTool": {
    "id": "src.features.hooks.services.mcp-contracts.MCPTool",
    "name": "MCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.JSONSchema"
    ],
    "source_code": "interface MCPTool {\n\tname: string;\n\tdisplayName: string;\n\tdescription: string;\n\tinputSchema: JSONSchema;\n\tserverId: string;\n}",
    "start_line": 23,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPTool",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPTool"
  },
  "src.features.hooks.services.mcp-contracts.JSONSchema": {
    "id": "src.features.hooks.services.mcp-contracts.JSONSchema",
    "name": "JSONSchema",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.JSONSchemaProperty"
    ],
    "source_code": "interface JSONSchema {\n\ttype: string;\n\tproperties?: Record<string, JSONSchemaProperty>;\n\trequired?: string[];\n}",
    "start_line": 31,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchema",
    "component_id": "src.features.hooks.services.mcp-contracts.JSONSchema"
  },
  "src.features.hooks.services.mcp-contracts.JSONSchemaProperty": {
    "id": "src.features.hooks.services.mcp-contracts.JSONSchemaProperty",
    "name": "JSONSchemaProperty",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "interface JSONSchemaProperty {\n\ttype: string;\n\tdescription?: string;\n\tenum?: unknown[];\n\tdefault?: unknown;\n}",
    "start_line": 37,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchemaProperty",
    "component_id": "src.features.hooks.services.mcp-contracts.JSONSchemaProperty"
  },
  "src.features.hooks.services.mcp-contracts.ParameterMapping": {
    "id": "src.features.hooks.services.mcp-contracts.ParameterMapping",
    "name": "ParameterMapping",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "interface ParameterMapping {\n\ttoolParam: string;\n\tsource: \"context\" | \"literal\" | \"template\";\n\tvalue: string;\n}",
    "start_line": 44,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterMapping",
    "component_id": "src.features.hooks.services.mcp-contracts.ParameterMapping"
  },
  "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService": {
    "id": "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
    "name": "IMCPDiscoveryService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.MCPTool",
      "src.features.hooks.services.mcp-contracts.MCPServer"
    ],
    "source_code": "interface IMCPDiscoveryService {\n\t/**\n\t * Discover all MCP servers configured in Copilot\n\t * @param forceRefresh - Skip cache and force fresh discovery\n\t * @returns Promise resolving to array of MCP servers with their tools\n\t */\n\tdiscoverServers(forceRefresh?: boolean): Promise<MCPServer[]>;\n\n\t/**\n\t * Get a specific MCP server by ID\n\t * @param serverId - Server identifier\n\t * @returns Promise resolving to server or undefined if not found\n\t */\n\tgetServer(serverId: string): Promise<MCPServer | undefined>;\n\n\t/**\n\t * Get a specific tool from a server\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool name\n\t * @returns Promise resolving to tool or undefined if not found\n\t */\n\tgetTool(serverId: string, toolName: string): Promise<MCPTool | undefined>;\n\n\t/**\n\t * Clear the discovery cache\n\t */\n\tclearCache(): void;\n\n\t/**\n\t * Check if cache is fresh\n\t */\n\tisCacheFresh(): boolean;\n}",
    "start_line": 57,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPDiscoveryService",
    "component_id": "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService"
  },
  "src.features.hooks.services.mcp-contracts.IMCPClientService": {
    "id": "src.features.hooks.services.mcp-contracts.IMCPClientService",
    "name": "IMCPClientService",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.ParameterValidationResult",
      "src.features.hooks.services.mcp-contracts.MCPToolExecutionResult"
    ],
    "source_code": "interface IMCPClientService {\n\t/**\n\t * Execute an MCP tool with resolved parameters\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool to execute\n\t * @param parameters - Resolved parameter values (JSON object)\n\t * @param timeout - Execution timeout in milliseconds\n\t * @returns Promise resolving to execution result\n\t */\n\texecuteTool(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>,\n\t\ttimeout?: number\n\t): Promise<MCPToolExecutionResult>;\n\n\t/**\n\t * Validate parameters against tool's input schema\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool name\n\t * @param parameters - Parameters to validate\n\t * @returns Validation result with errors if invalid\n\t */\n\tvalidateParameters(\n\t\tserverId: string,\n\t\ttoolName: string,\n\t\tparameters: Record<string, unknown>\n\t): ParameterValidationResult;\n}",
    "start_line": 94,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPClientService",
    "component_id": "src.features.hooks.services.mcp-contracts.IMCPClientService"
  },
  "src.features.hooks.services.mcp-contracts.IMCPParameterResolver": {
    "id": "src.features.hooks.services.mcp-contracts.IMCPParameterResolver",
    "name": "IMCPParameterResolver",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.TemplateContext",
      "src.features.hooks.services.mcp-contracts.ParameterMapping"
    ],
    "source_code": "interface IMCPParameterResolver {\n\t/**\n\t * Resolve parameter mappings using template context\n\t * @param mappings - Parameter mapping definitions\n\t * @param context - Template context (feature, branch, etc.)\n\t * @returns Resolved parameters as key-value pairs\n\t */\n\tresolve(\n\t\tmappings: ParameterMapping[],\n\t\tcontext: TemplateContext\n\t): Record<string, unknown>;\n\n\t/**\n\t * Resolve a single parameter mapping\n\t * @param mapping - Single parameter mapping\n\t * @param context - Template context\n\t * @returns Resolved value (string, number, boolean, etc.)\n\t */\n\tresolveSingle(mapping: ParameterMapping, context: TemplateContext): unknown;\n}",
    "start_line": 127,
    "end_line": 146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPParameterResolver",
    "component_id": "src.features.hooks.services.mcp-contracts.IMCPParameterResolver"
  },
  "src.features.hooks.services.mcp-contracts.MCPToolExecutionResult": {
    "id": "src.features.hooks.services.mcp-contracts.MCPToolExecutionResult",
    "name": "MCPToolExecutionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.MCPExecutionError"
    ],
    "source_code": "interface MCPToolExecutionResult {\n\tsuccess: boolean;\n\toutput?: unknown;\n\terror?: MCPExecutionError;\n\tduration: number;\n}",
    "start_line": 152,
    "end_line": 157,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPToolExecutionResult",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPToolExecutionResult"
  },
  "src.features.hooks.services.mcp-contracts.MCPExecutionError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPExecutionError",
    "name": "MCPExecutionError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "interface MCPExecutionError {\n\tcode: string;\n\tmessage: string;\n\tdetails?: unknown;\n}",
    "start_line": 159,
    "end_line": 163,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPExecutionError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPExecutionError"
  },
  "src.features.hooks.services.mcp-contracts.ParameterValidationResult": {
    "id": "src.features.hooks.services.mcp-contracts.ParameterValidationResult",
    "name": "ParameterValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.ParameterValidationError"
    ],
    "source_code": "interface ParameterValidationResult {\n\tvalid: boolean;\n\terrors: ParameterValidationError[];\n}",
    "start_line": 165,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterValidationResult",
    "component_id": "src.features.hooks.services.mcp-contracts.ParameterValidationResult"
  },
  "src.features.hooks.services.mcp-contracts.ParameterValidationError": {
    "id": "src.features.hooks.services.mcp-contracts.ParameterValidationError",
    "name": "ParameterValidationError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "interface ParameterValidationError {\n\tparameter: string;\n\tmessage: string;\n\texpected?: string;\n\tactual?: string;\n}",
    "start_line": 170,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterValidationError",
    "component_id": "src.features.hooks.services.mcp-contracts.ParameterValidationError"
  },
  "src.features.hooks.services.mcp-contracts.TemplateContext": {
    "id": "src.features.hooks.services.mcp-contracts.TemplateContext",
    "name": "TemplateContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "interface TemplateContext {\n\tfeature?: string;\n\tbranch?: string;\n\ttimestamp?: string;\n\tuser?: string;\n}",
    "start_line": 181,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateContext",
    "component_id": "src.features.hooks.services.mcp-contracts.TemplateContext"
  },
  "src.features.hooks.services.mcp-contracts.IMCPExecutionPool": {
    "id": "src.features.hooks.services.mcp-contracts.IMCPExecutionPool",
    "name": "IMCPExecutionPool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.PoolStatus"
    ],
    "source_code": "interface IMCPExecutionPool {\n\t/**\n\t * Execute a task with concurrency control\n\t * @param task - Async task to execute\n\t * @returns Promise that resolves when task completes\n\t */\n\texecute<T>(task: () => Promise<T>): Promise<T>;\n\n\t/**\n\t * Get current pool status\n\t */\n\tgetStatus(): PoolStatus;\n\n\t/**\n\t * Wait for all queued tasks to complete\n\t */\n\tdrain(): Promise<void>;\n}",
    "start_line": 195,
    "end_line": 212,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IMCPExecutionPool",
    "component_id": "src.features.hooks.services.mcp-contracts.IMCPExecutionPool"
  },
  "src.features.hooks.services.mcp-contracts.PoolStatus": {
    "id": "src.features.hooks.services.mcp-contracts.PoolStatus",
    "name": "PoolStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "interface PoolStatus {\n\tactive: number;\n\tqueued: number;\n\tcapacity: number;\n}",
    "start_line": 214,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PoolStatus",
    "component_id": "src.features.hooks.services.mcp-contracts.PoolStatus"
  },
  "src.features.hooks.services.mcp-contracts.MCPServerNotFoundError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPServerNotFoundError",
    "name": "MCPServerNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "class MCPServerNotFoundError extends Error {\n\tconstructor(serverId: string) {\n\t\tsuper(`MCP server not found: ${serverId}`);\n\t\tthis.name = \"MCPServerNotFoundError\";\n\t}\n}",
    "start_line": 224,
    "end_line": 229,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPServerNotFoundError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPServerNotFoundError"
  },
  "src.features.hooks.services.mcp-contracts.MCPToolNotFoundError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPToolNotFoundError",
    "name": "MCPToolNotFoundError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "class MCPToolNotFoundError extends Error {\n\tconstructor(serverId: string, toolName: string) {\n\t\tsuper(`MCP tool '${toolName}' not found on server '${serverId}'`);\n\t\tthis.name = \"MCPToolNotFoundError\";\n\t}\n}",
    "start_line": 231,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPToolNotFoundError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPToolNotFoundError"
  },
  "src.features.hooks.services.mcp-contracts.MCPServerUnavailableError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPServerUnavailableError",
    "name": "MCPServerUnavailableError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "class MCPServerUnavailableError extends Error {\n\tconstructor(serverId: string) {\n\t\tsuper(`MCP server unavailable: ${serverId}`);\n\t\tthis.name = \"MCPServerUnavailableError\";\n\t}\n}",
    "start_line": 238,
    "end_line": 243,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPServerUnavailableError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPServerUnavailableError"
  },
  "src.features.hooks.services.mcp-contracts.MCPParameterValidationError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPParameterValidationError",
    "name": "MCPParameterValidationError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-contracts.ParameterValidationError"
    ],
    "source_code": "class MCPParameterValidationError extends Error {\n\terrors: ParameterValidationError[];\n\n\tconstructor(errors: ParameterValidationError[]) {\n\t\tsuper(\n\t\t\t`Parameter validation failed: ${errors.map((e) => e.message).join(\", \")}`\n\t\t);\n\t\tthis.name = \"MCPParameterValidationError\";\n\t\tthis.errors = errors;\n\t}\n}",
    "start_line": 245,
    "end_line": 255,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPParameterValidationError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPParameterValidationError"
  },
  "src.features.hooks.services.mcp-contracts.MCPTimeoutError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPTimeoutError",
    "name": "MCPTimeoutError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "class MCPTimeoutError extends Error {\n\ttimeout: number;\n\n\tconstructor(timeout: number) {\n\t\tsuper(`MCP tool execution timed out after ${timeout}ms`);\n\t\tthis.name = \"MCPTimeoutError\";\n\t\tthis.timeout = timeout;\n\t}\n}",
    "start_line": 257,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPTimeoutError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPTimeoutError"
  },
  "src.features.hooks.services.mcp-contracts.MCPDiscoveryError": {
    "id": "src.features.hooks.services.mcp-contracts.MCPDiscoveryError",
    "name": "MCPDiscoveryError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-contracts.ts",
    "relative_path": "src/features/hooks/services/mcp-contracts.ts",
    "depends_on": [],
    "source_code": "class MCPDiscoveryError extends Error {\n\tcause?: Error;\n\n\tconstructor(message: string, cause?: Error) {\n\t\tsuper(message);\n\t\tthis.name = \"MCPDiscoveryError\";\n\t\tthis.cause = cause;\n\t}\n}",
    "start_line": 267,
    "end_line": 275,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPDiscoveryError",
    "component_id": "src.features.hooks.services.mcp-contracts.MCPDiscoveryError"
  },
  "src.features.hooks.services.mcp-discovery.DiscoveryCache": {
    "id": "src.features.hooks.services.mcp-discovery.DiscoveryCache",
    "name": "DiscoveryCache",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer"
    ],
    "source_code": "interface DiscoveryCache {\n\tservers: MCPServer[];\n\ttimestamp: number;\n}",
    "start_line": 23,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DiscoveryCache",
    "component_id": "src.features.hooks.services.mcp-discovery.DiscoveryCache"
  },
  "src.features.hooks.services.mcp-discovery.MCPDiscoveryService": {
    "id": "src.features.hooks.services.mcp-discovery.MCPDiscoveryService",
    "name": "MCPDiscoveryService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-discovery.isCacheFresh",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryError",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer",
      "src.utils.copilot-mcp-utils.queryMCPTools",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool",
      "src.features.hooks.services.mcp-discovery.DiscoveryCache",
      "src.features.hooks.services.mcp-discovery.discoverServers",
      "src.features.hooks.services.mcp-discovery.getServer",
      "src.utils.copilot-mcp-utils.queryMCPServers"
    ],
    "source_code": "class MCPDiscoveryService implements IMCPDiscoveryService {\n\tprivate cache: DiscoveryCache | null = null;\n\n\t/**\n\t * Discover all MCP servers configured in Copilot\n\t * @param forceRefresh - Skip cache and force fresh discovery\n\t * @returns Promise resolving to array of MCP servers with their tools\n\t */\n\tasync discoverServers(forceRefresh = false): Promise<MCPServer[]> {\n\t\t// Return cached results if fresh and not forcing refresh\n\t\tif (!forceRefresh && this.isCacheFresh()) {\n\t\t\treturn this.cache!.servers;\n\t\t}\n\n\t\ttry {\n\t\t\t// Query MCP servers from Copilot (async to load mcp.json)\n\t\t\tconst servers = await queryMCPServers();\n\n\t\t\t// Enrich each server with its tools\n\t\t\tconst serversWithTools = await Promise.all(\n\t\t\t\tservers.map(async (server) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Query tools for this server (async)\n\t\t\t\t\t\tconst tools = await queryMCPTools(server.id);\n\n\t\t\t\t\t\t// Return server with populated tools array\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...server,\n\t\t\t\t\t\t\ttools,\n\t\t\t\t\t\t\tlastDiscovered: Date.now(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// If tool discovery fails, return server with empty tools\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...server,\n\t\t\t\t\t\t\ttools: [] as MCPTool[],\n\t\t\t\t\t\t\tstatus: \"unavailable\" as const,\n\t\t\t\t\t\t\tlastDiscovered: Date.now(),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Update cache with 5-minute TTL\n\t\t\tthis.cache = {\n\t\t\t\tservers: serversWithTools,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t};\n\n\t\t\treturn serversWithTools;\n\t\t} catch (error) {\n\t\t\tconst mcpError: MCPDiscoveryError = {\n\t\t\t\tname: \"MCPDiscoveryError\",\n\t\t\t\tmessage: `Failed to discover MCP servers: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t};\n\t\t\tthrow mcpError;\n\t\t}\n\t}\n\n\t/**\n\t * Get a specific MCP server by ID\n\t * @param serverId - Server identifier\n\t * @returns Promise resolving to server or undefined if not found\n\t */\n\tasync getServer(serverId: string): Promise<MCPServer | undefined> {\n\t\tconst servers = await this.discoverServers();\n\t\treturn servers.find((server) => server.id === serverId);\n\t}\n\n\t/**\n\t * Get a specific tool from a server\n\t * @param serverId - Server identifier\n\t * @param toolName - Tool name\n\t * @returns Promise resolving to tool or undefined if not found\n\t */\n\tasync getTool(\n\t\tserverId: string,\n\t\ttoolName: string\n\t): Promise<MCPTool | undefined> {\n\t\tconst server = await this.getServer(serverId);\n\t\tif (!server) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn server.tools.find((tool) => tool.name === toolName);\n\t}\n\n\t/**\n\t * Clear the discovery cache\n\t */\n\tclearCache(): void {\n\t\tthis.cache = null;\n\t}\n\n\t/**\n\t * Check if cache is fresh\n\t */\n\tisCacheFresh(): boolean {\n\t\tif (!this.cache) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst age = Date.now() - this.cache.timestamp;\n\t\treturn age < MCP_DISCOVERY_CACHE_TTL;\n\t}\n}",
    "start_line": 34,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPDiscoveryService",
    "component_id": "src.features.hooks.services.mcp-discovery.MCPDiscoveryService"
  },
  "src.features.hooks.services.mcp-discovery.discoverServers": {
    "id": "src.features.hooks.services.mcp-discovery.discoverServers",
    "name": "discoverServers",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [],
    "source_code": "async discoverServers(forceRefresh = false): Promise<MCPServer[]> {\n\t\t// Return cached results if fresh and not forcing refresh\n\t\tif (!forceRefresh && this.isCacheFresh()) {\n\t\t\treturn this.cache!.servers;\n\t\t}\n\n\t\ttry {\n\t\t\t// Query MCP servers from Copilot (async to load mcp.json)\n\t\t\tconst servers = await queryMCPServers();\n\n\t\t\t// Enrich each server with its tools\n\t\t\tconst serversWithTools = await Promise.all(\n\t\t\t\tservers.map(async (server) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Query tools for this server (async)\n\t\t\t\t\t\tconst tools = await queryMCPTools(server.id);\n\n\t\t\t\t\t\t// Return server with populated tools array\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...server,\n\t\t\t\t\t\t\ttools,\n\t\t\t\t\t\t\tlastDiscovered: Date.now(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// If tool discovery fails, return server with empty tools\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...server,\n\t\t\t\t\t\t\ttools: [] as MCPTool[],\n\t\t\t\t\t\t\tstatus: \"unavailable\" as const,\n\t\t\t\t\t\t\tlastDiscovered: Date.now(),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Update cache with 5-minute TTL\n\t\t\tthis.cache = {\n\t\t\t\tservers: serversWithTools,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t};\n\n\t\t\treturn serversWithTools;\n\t\t} catch (error) {\n\t\t\tconst mcpError: MCPDiscoveryError = {\n\t\t\t\tname: \"MCPDiscoveryError\",\n\t\t\t\tmessage: `Failed to discover MCP servers: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t};\n\t\t\tthrow mcpError;\n\t\t}\n\t}",
    "start_line": 42,
    "end_line": 92,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "forceRefresh"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method discoverServers",
    "component_id": "src.features.hooks.services.mcp-discovery.discoverServers"
  },
  "src.features.hooks.services.mcp-discovery.getServer": {
    "id": "src.features.hooks.services.mcp-discovery.getServer",
    "name": "getServer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [],
    "source_code": "async getServer(serverId: string): Promise<MCPServer | undefined> {\n\t\tconst servers = await this.discoverServers();\n\t\treturn servers.find((server) => server.id === serverId);\n\t}",
    "start_line": 99,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getServer",
    "component_id": "src.features.hooks.services.mcp-discovery.getServer"
  },
  "src.features.hooks.services.mcp-discovery.getTool": {
    "id": "src.features.hooks.services.mcp-discovery.getTool",
    "name": "getTool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [],
    "source_code": "async getTool(\n\t\tserverId: string,\n\t\ttoolName: string\n\t): Promise<MCPTool | undefined> {\n\t\tconst server = await this.getServer(serverId);\n\t\tif (!server) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn server.tools.find((tool) => tool.name === toolName);\n\t}",
    "start_line": 110,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getTool",
    "component_id": "src.features.hooks.services.mcp-discovery.getTool"
  },
  "src.features.hooks.services.mcp-discovery.clearCache": {
    "id": "src.features.hooks.services.mcp-discovery.clearCache",
    "name": "clearCache",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [],
    "source_code": "clearCache(): void {\n\t\tthis.cache = null;\n\t}",
    "start_line": 125,
    "end_line": 127,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearCache",
    "component_id": "src.features.hooks.services.mcp-discovery.clearCache"
  },
  "src.features.hooks.services.mcp-discovery.isCacheFresh": {
    "id": "src.features.hooks.services.mcp-discovery.isCacheFresh",
    "name": "isCacheFresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-discovery.ts",
    "relative_path": "src/features/hooks/services/mcp-discovery.ts",
    "depends_on": [],
    "source_code": "isCacheFresh(): boolean {\n\t\tif (!this.cache) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst age = Date.now() - this.cache.timestamp;\n\t\treturn age < MCP_DISCOVERY_CACHE_TTL;\n\t}",
    "start_line": 132,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isCacheFresh",
    "component_id": "src.features.hooks.services.mcp-discovery.isCacheFresh"
  },
  "src.features.hooks.services.mcp-execution-pool.QueuedTask": {
    "id": "src.features.hooks.services.mcp-execution-pool.QueuedTask",
    "name": "QueuedTask",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [],
    "source_code": "interface QueuedTask<T> {\n\ttask: () => Promise<T>;\n\tresolve: (value: T) => void;\n\treject: (error: unknown) => void;\n}",
    "start_line": 14,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface QueuedTask",
    "component_id": "src.features.hooks.services.mcp-execution-pool.QueuedTask"
  },
  "src.features.hooks.services.mcp-execution-pool.MCPExecutionPool": {
    "id": "src.features.hooks.services.mcp-execution-pool.MCPExecutionPool",
    "name": "MCPExecutionPool",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      "src.features.hooks.services.mcp-contracts.PoolStatus",
      "src.features.hooks.services.mcp-execution-pool.QueuedTask",
      "src.features.hooks.services.mcp-execution-pool.processQueue",
      "src.features.hooks.services.mcp-execution-pool.executeTask"
    ],
    "source_code": "class MCPExecutionPool implements IMCPExecutionPool {\n\tprivate readonly capacity: number;\n\tprivate activeCount = 0;\n\tprivate readonly queue: QueuedTask<unknown>[] = [];\n\n\tconstructor(capacity = MCP_MAX_CONCURRENT_ACTIONS) {\n\t\tthis.capacity = capacity;\n\t}\n\n\t/**\n\t * Execute a task with concurrency control\n\t * @param task - Async task to execute\n\t * @returns Promise that resolves when task completes\n\t */\n\texecute<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t// If we have available capacity, execute immediately\n\t\t\tif (this.activeCount < this.capacity) {\n\t\t\t\tthis.executeTask(task, resolve, reject);\n\t\t\t} else {\n\t\t\t\t// Queue the task for later execution\n\t\t\t\tthis.queue.push({\n\t\t\t\t\ttask,\n\t\t\t\t\tresolve: resolve as (value: unknown) => void,\n\t\t\t\t\treject,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get current pool status\n\t */\n\tgetStatus(): PoolStatus {\n\t\treturn {\n\t\t\tactive: this.activeCount,\n\t\t\tqueued: this.queue.length,\n\t\t\tcapacity: this.capacity,\n\t\t};\n\t}\n\n\t/**\n\t * Wait for all queued tasks to complete\n\t */\n\tasync drain(): Promise<void> {\n\t\t// Wait until both active count and queue are empty\n\t\twhile (this.activeCount > 0 || this.queue.length > 0) {\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t}\n\t}\n\n\t/**\n\t * Execute a task and manage pool state\n\t */\n\tprivate async executeTask<T>(\n\t\ttask: () => Promise<T>,\n\t\tresolve: (value: T) => void,\n\t\treject: (error: unknown) => void\n\t): Promise<void> {\n\t\tthis.activeCount += 1;\n\n\t\ttry {\n\t\t\tconst result = await task();\n\t\t\tresolve(result);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t} finally {\n\t\t\tthis.activeCount -= 1;\n\t\t\tthis.processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Process next task in queue if capacity is available\n\t */\n\tprivate processQueue(): void {\n\t\tif (this.queue.length > 0 && this.activeCount < this.capacity) {\n\t\t\tconst next = this.queue.shift();\n\t\t\tif (next) {\n\t\t\t\tthis.executeTask(next.task, next.resolve, next.reject);\n\t\t\t}\n\t\t}\n\t}\n}",
    "start_line": 26,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPExecutionPool",
    "component_id": "src.features.hooks.services.mcp-execution-pool.MCPExecutionPool"
  },
  "src.features.hooks.services.mcp-execution-pool.execute": {
    "id": "src.features.hooks.services.mcp-execution-pool.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [],
    "source_code": "execute<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t// If we have available capacity, execute immediately\n\t\t\tif (this.activeCount < this.capacity) {\n\t\t\t\tthis.executeTask(task, resolve, reject);\n\t\t\t} else {\n\t\t\t\t// Queue the task for later execution\n\t\t\t\tthis.queue.push({\n\t\t\t\t\ttask,\n\t\t\t\t\tresolve: resolve as (value: unknown) => void,\n\t\t\t\t\treject,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}",
    "start_line": 40,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "task"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method execute",
    "component_id": "src.features.hooks.services.mcp-execution-pool.execute"
  },
  "src.features.hooks.services.mcp-execution-pool.getStatus": {
    "id": "src.features.hooks.services.mcp-execution-pool.getStatus",
    "name": "getStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [],
    "source_code": "getStatus(): PoolStatus {\n\t\treturn {\n\t\t\tactive: this.activeCount,\n\t\t\tqueued: this.queue.length,\n\t\t\tcapacity: this.capacity,\n\t\t};\n\t}",
    "start_line": 59,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getStatus",
    "component_id": "src.features.hooks.services.mcp-execution-pool.getStatus"
  },
  "src.features.hooks.services.mcp-execution-pool.drain": {
    "id": "src.features.hooks.services.mcp-execution-pool.drain",
    "name": "drain",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [],
    "source_code": "async drain(): Promise<void> {\n\t\t// Wait until both active count and queue are empty\n\t\twhile (this.activeCount > 0 || this.queue.length > 0) {\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t}\n\t}",
    "start_line": 70,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method drain",
    "component_id": "src.features.hooks.services.mcp-execution-pool.drain"
  },
  "src.features.hooks.services.mcp-execution-pool.executeTask": {
    "id": "src.features.hooks.services.mcp-execution-pool.executeTask",
    "name": "executeTask",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [],
    "source_code": "private async executeTask<T>(\n\t\ttask: () => Promise<T>,\n\t\tresolve: (value: T) => void,\n\t\treject: (error: unknown) => void\n\t): Promise<void> {\n\t\tthis.activeCount += 1;\n\n\t\ttry {\n\t\t\tconst result = await task();\n\t\t\tresolve(result);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t} finally {\n\t\t\tthis.activeCount -= 1;\n\t\t\tthis.processQueue();\n\t\t}\n\t}",
    "start_line": 80,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "task",
      "resolve",
      "reject"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeTask",
    "component_id": "src.features.hooks.services.mcp-execution-pool.executeTask"
  },
  "src.features.hooks.services.mcp-execution-pool.processQueue": {
    "id": "src.features.hooks.services.mcp-execution-pool.processQueue",
    "name": "processQueue",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-execution-pool.ts",
    "relative_path": "src/features/hooks/services/mcp-execution-pool.ts",
    "depends_on": [],
    "source_code": "private processQueue(): void {\n\t\tif (this.queue.length > 0 && this.activeCount < this.capacity) {\n\t\t\tconst next = this.queue.shift();\n\t\t\tif (next) {\n\t\t\t\tthis.executeTask(next.task, next.resolve, next.reject);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 101,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method processQueue",
    "component_id": "src.features.hooks.services.mcp-execution-pool.processQueue"
  },
  "src.features.hooks.services.mcp-parameter-resolver.MCPParameterResolver": {
    "id": "src.features.hooks.services.mcp-parameter-resolver.MCPParameterResolver",
    "name": "MCPParameterResolver",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-parameter-resolver.ts",
    "relative_path": "src/features/hooks/services/mcp-parameter-resolver.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-parameter-resolver.resolveFromContext",
      "src.features.hooks.template-utils.expandTemplate",
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.types.ParameterMapping",
      "src.features.hooks.services.mcp-parameter-resolver.resolveSingle"
    ],
    "source_code": "class MCPParameterResolver implements IMCPParameterResolver {\n\t/**\n\t * Resolve parameter mappings using template context\n\t * @param mappings - Parameter mapping definitions\n\t * @param context - Template context (feature, branch, etc.)\n\t * @returns Resolved parameters as key-value pairs\n\t */\n\tresolve(\n\t\tmappings: ParameterMapping[],\n\t\tcontext: TemplateContext\n\t): Record<string, unknown> {\n\t\tconst resolved: Record<string, unknown> = {};\n\n\t\tfor (const mapping of mappings) {\n\t\t\tconst value = this.resolveSingle(mapping, context);\n\t\t\tresolved[mapping.toolParam] = value;\n\t\t}\n\n\t\treturn resolved;\n\t}\n\n\t/**\n\t * Resolve a single parameter mapping\n\t * @param mapping - Single parameter mapping\n\t * @param context - Template context\n\t * @returns Resolved value (string, number, boolean, etc.)\n\t */\n\tresolveSingle(mapping: ParameterMapping, context: TemplateContext): unknown {\n\t\tswitch (mapping.source) {\n\t\t\tcase \"context\":\n\t\t\t\t// Extract value directly from context by key\n\t\t\t\treturn this.resolveFromContext(mapping.value, context);\n\n\t\t\tcase \"literal\":\n\t\t\t\t// Use the value as-is (literal string)\n\t\t\t\treturn mapping.value;\n\n\t\t\tcase \"template\":\n\t\t\t\t// Expand template variables (e.g., \"{{feature}}\" -> \"mcp-hooks\")\n\t\t\t\treturn expandTemplate(mapping.value, context);\n\n\t\t\tdefault:\n\t\t\t\t// Unknown source type - return value as-is\n\t\t\t\treturn mapping.value;\n\t\t}\n\t}\n\n\t/**\n\t * Resolve a value from template context by key\n\t * @param key - Context key (e.g., \"feature\", \"branch\")\n\t * @param context - Template context\n\t * @returns Context value or undefined if not found\n\t */\n\tprivate resolveFromContext(key: string, context: TemplateContext): unknown {\n\t\t// Handle direct context keys\n\t\tif (key in context) {\n\t\t\treturn context[key as keyof TemplateContext];\n\t\t}\n\n\t\t// Key not found in context\n\t\treturn;\n\t}\n}",
    "start_line": 21,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class MCPParameterResolver",
    "component_id": "src.features.hooks.services.mcp-parameter-resolver.MCPParameterResolver"
  },
  "src.features.hooks.services.mcp-parameter-resolver.resolve": {
    "id": "src.features.hooks.services.mcp-parameter-resolver.resolve",
    "name": "resolve",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-parameter-resolver.ts",
    "relative_path": "src/features/hooks/services/mcp-parameter-resolver.ts",
    "depends_on": [],
    "source_code": "resolve(\n\t\tmappings: ParameterMapping[],\n\t\tcontext: TemplateContext\n\t): Record<string, unknown> {\n\t\tconst resolved: Record<string, unknown> = {};\n\n\t\tfor (const mapping of mappings) {\n\t\t\tconst value = this.resolveSingle(mapping, context);\n\t\t\tresolved[mapping.toolParam] = value;\n\t\t}\n\n\t\treturn resolved;\n\t}",
    "start_line": 28,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mappings",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolve",
    "component_id": "src.features.hooks.services.mcp-parameter-resolver.resolve"
  },
  "src.features.hooks.services.mcp-parameter-resolver.resolveSingle": {
    "id": "src.features.hooks.services.mcp-parameter-resolver.resolveSingle",
    "name": "resolveSingle",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-parameter-resolver.ts",
    "relative_path": "src/features/hooks/services/mcp-parameter-resolver.ts",
    "depends_on": [],
    "source_code": "resolveSingle(mapping: ParameterMapping, context: TemplateContext): unknown {\n\t\tswitch (mapping.source) {\n\t\t\tcase \"context\":\n\t\t\t\t// Extract value directly from context by key\n\t\t\t\treturn this.resolveFromContext(mapping.value, context);\n\n\t\t\tcase \"literal\":\n\t\t\t\t// Use the value as-is (literal string)\n\t\t\t\treturn mapping.value;\n\n\t\t\tcase \"template\":\n\t\t\t\t// Expand template variables (e.g., \"{{feature}}\" -> \"mcp-hooks\")\n\t\t\t\treturn expandTemplate(mapping.value, context);\n\n\t\t\tdefault:\n\t\t\t\t// Unknown source type - return value as-is\n\t\t\t\treturn mapping.value;\n\t\t}\n\t}",
    "start_line": 48,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mapping",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveSingle",
    "component_id": "src.features.hooks.services.mcp-parameter-resolver.resolveSingle"
  },
  "src.features.hooks.services.mcp-parameter-resolver.resolveFromContext": {
    "id": "src.features.hooks.services.mcp-parameter-resolver.resolveFromContext",
    "name": "resolveFromContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/services/mcp-parameter-resolver.ts",
    "relative_path": "src/features/hooks/services/mcp-parameter-resolver.ts",
    "depends_on": [],
    "source_code": "private resolveFromContext(key: string, context: TemplateContext): unknown {\n\t\t// Handle direct context keys\n\t\tif (key in context) {\n\t\t\treturn context[key as keyof TemplateContext];\n\t\t}\n\n\t\t// Key not found in context\n\t\treturn;\n\t}",
    "start_line": 74,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "key",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveFromContext",
    "component_id": "src.features.hooks.services.mcp-parameter-resolver.resolveFromContext"
  },
  "src.features.hooks.template-context-builder.ContextBuildOptions": {
    "id": "src.features.hooks.template-context-builder.ContextBuildOptions",
    "name": "ContextBuildOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-context-builder.ts",
    "relative_path": "src/features/hooks/template-context-builder.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType"
    ],
    "source_code": "interface ContextBuildOptions {\n\t// Required\n\ttriggerType: OperationType;\n\n\t// Standard optional variables\n\tuser?: string;\n\tbranch?: string;\n\tfeature?: string;\n\n\t// Spec-specific variables\n\tspecId?: string;\n\tspecPath?: string;\n\toldStatus?: string;\n\tnewStatus?: string;\n\tchangeAuthor?: string;\n\n\t// Custom dynamic variables (any key-value pairs)\n\t[key: string]: string | number | boolean | undefined;\n}",
    "start_line": 26,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ContextBuildOptions",
    "component_id": "src.features.hooks.template-context-builder.ContextBuildOptions"
  },
  "src.features.hooks.template-context-builder.TemplateContextBuilder": {
    "id": "src.features.hooks.template-context-builder.TemplateContextBuilder",
    "name": "TemplateContextBuilder",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-context-builder.ts",
    "relative_path": "src/features/hooks/template-context-builder.ts",
    "depends_on": [
      "src.features.hooks.types.TemplateContext",
      "src.features.hooks.template-context-builder.ContextBuildOptions"
    ],
    "source_code": "class TemplateContextBuilder {\n\t/**\n\t * Build template context from trigger event options\n\t *\n\t * @param options Context build options with trigger type and variables\n\t * @returns TemplateContext with populated variables\n\t */\n\tbuildContext(options: ContextBuildOptions): TemplateContext {\n\t\t// Build base context with required standard variables\n\t\tconst context: TemplateContext = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\ttriggerType: options.triggerType,\n\t\t};\n\n\t\t// Add optional standard variables if provided\n\t\tif (options.user !== undefined) {\n\t\t\tcontext.user = options.user;\n\t\t}\n\t\tif (options.branch !== undefined) {\n\t\t\tcontext.branch = options.branch;\n\t\t}\n\t\tif (options.feature !== undefined) {\n\t\t\tcontext.feature = options.feature;\n\t\t}\n\n\t\t// Add spec-specific variables if provided\n\t\tif (options.specId !== undefined) {\n\t\t\tcontext.specId = options.specId;\n\t\t}\n\t\tif (options.specPath !== undefined) {\n\t\t\tcontext.specPath = options.specPath;\n\t\t}\n\t\tif (options.oldStatus !== undefined) {\n\t\t\tcontext.oldStatus = options.oldStatus;\n\t\t}\n\t\tif (options.newStatus !== undefined) {\n\t\t\tcontext.newStatus = options.newStatus;\n\t\t}\n\t\tif (options.changeAuthor !== undefined) {\n\t\t\tcontext.changeAuthor = options.changeAuthor;\n\t\t}\n\n\t\t// Add any custom dynamic variables\n\t\t// Copy all properties from options except the standard ones we've already handled\n\t\tconst standardKeys = new Set([\n\t\t\t\"triggerType\",\n\t\t\t\"user\",\n\t\t\t\"branch\",\n\t\t\t\"feature\",\n\t\t\t\"specId\",\n\t\t\t\"specPath\",\n\t\t\t\"oldStatus\",\n\t\t\t\"newStatus\",\n\t\t\t\"changeAuthor\",\n\t\t]);\n\n\t\tfor (const [key, value] of Object.entries(options)) {\n\t\t\tif (!standardKeys.has(key) && value !== undefined) {\n\t\t\t\tcontext[key] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn context;\n\t}\n}",
    "start_line": 57,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class TemplateContextBuilder",
    "component_id": "src.features.hooks.template-context-builder.TemplateContextBuilder"
  },
  "src.features.hooks.template-context-builder.buildContext": {
    "id": "src.features.hooks.template-context-builder.buildContext",
    "name": "buildContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-context-builder.ts",
    "relative_path": "src/features/hooks/template-context-builder.ts",
    "depends_on": [],
    "source_code": "buildContext(options: ContextBuildOptions): TemplateContext {\n\t\t// Build base context with required standard variables\n\t\tconst context: TemplateContext = {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\ttriggerType: options.triggerType,\n\t\t};\n\n\t\t// Add optional standard variables if provided\n\t\tif (options.user !== undefined) {\n\t\t\tcontext.user = options.user;\n\t\t}\n\t\tif (options.branch !== undefined) {\n\t\t\tcontext.branch = options.branch;\n\t\t}\n\t\tif (options.feature !== undefined) {\n\t\t\tcontext.feature = options.feature;\n\t\t}\n\n\t\t// Add spec-specific variables if provided\n\t\tif (options.specId !== undefined) {\n\t\t\tcontext.specId = options.specId;\n\t\t}\n\t\tif (options.specPath !== undefined) {\n\t\t\tcontext.specPath = options.specPath;\n\t\t}\n\t\tif (options.oldStatus !== undefined) {\n\t\t\tcontext.oldStatus = options.oldStatus;\n\t\t}\n\t\tif (options.newStatus !== undefined) {\n\t\t\tcontext.newStatus = options.newStatus;\n\t\t}\n\t\tif (options.changeAuthor !== undefined) {\n\t\t\tcontext.changeAuthor = options.changeAuthor;\n\t\t}\n\n\t\t// Add any custom dynamic variables\n\t\t// Copy all properties from options except the standard ones we've already handled\n\t\tconst standardKeys = new Set([\n\t\t\t\"triggerType\",\n\t\t\t\"user\",\n\t\t\t\"branch\",\n\t\t\t\"feature\",\n\t\t\t\"specId\",\n\t\t\t\"specPath\",\n\t\t\t\"oldStatus\",\n\t\t\t\"newStatus\",\n\t\t\t\"changeAuthor\",\n\t\t]);\n\n\t\tfor (const [key, value] of Object.entries(options)) {\n\t\t\tif (!standardKeys.has(key) && value !== undefined) {\n\t\t\t\tcontext[key] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn context;\n\t}",
    "start_line": 64,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method buildContext",
    "component_id": "src.features.hooks.template-context-builder.buildContext"
  },
  "src.features.hooks.template-utils.expandTemplate": {
    "id": "src.features.hooks.template-utils.expandTemplate",
    "name": "expandTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-utils.ts",
    "relative_path": "src/features/hooks/template-utils.ts",
    "depends_on": [
      "src.features.hooks.types.TemplateContext"
    ],
    "source_code": "function expandTemplate(\n\ttemplate: string,\n\tcontext: TemplateContext\n): string {\n\tif (!template) {\n\t\treturn template;\n\t}\n\n\treturn template.replace(/\\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (_match, key) => {\n\t\tconst value = context[key as keyof TemplateContext];\n\t\treturn value === undefined || value === null ? \"\" : String(value);\n\t});\n}",
    "start_line": 6,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function expandTemplate",
    "component_id": "src.features.hooks.template-utils.expandTemplate"
  },
  "src.features.hooks.template-variable-constants.TemplateVariable": {
    "id": "src.features.hooks.template-variable-constants.TemplateVariable",
    "name": "TemplateVariable",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-constants.ts",
    "relative_path": "src/features/hooks/template-variable-constants.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType",
      "src.features.hooks.template-variable-constants.TemplateVariableCategory",
      "src.features.hooks.template-variable-constants.TemplateValueType"
    ],
    "source_code": "interface TemplateVariable {\n\t// Identity\n\tname: string; // Variable name (without braces)\n\n\t// Metadata\n\tdescription: string; // Human-readable description\n\tvalueType: TemplateValueType; // Expected value type\n\n\t// Availability\n\tavailableFor: OperationType[]; // Trigger types that provide this variable (empty = all)\n\trequired: boolean; // Always present for specified triggers?\n\n\t// Default behavior\n\tdefaultValue?: string; // Value if unavailable (default: empty string)\n\n\t// Display\n\texample?: string; // Example value for UI display\n\tcategory?: TemplateVariableCategory; // Grouping for UI organization\n}",
    "start_line": 23,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateVariable",
    "component_id": "src.features.hooks.template-variable-constants.TemplateVariable"
  },
  "src.features.hooks.template-variable-constants.TemplateValueType": {
    "id": "src.features.hooks.template-variable-constants.TemplateValueType",
    "name": "TemplateValueType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-constants.ts",
    "relative_path": "src/features/hooks/template-variable-constants.ts",
    "depends_on": [],
    "source_code": "type TemplateValueType =\n\t| \"string\" // Text value\n\t| \"number\" // Numeric value\n\t| \"boolean\" // True/false\n\t| \"timestamp\" // ISO 8601 timestamp\n\t| \"path\" // File system path\n\t| \"url\";",
    "start_line": 46,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateValueType",
    "component_id": "src.features.hooks.template-variable-constants.TemplateValueType"
  },
  "src.features.hooks.template-variable-constants.TemplateVariableCategory": {
    "id": "src.features.hooks.template-variable-constants.TemplateVariableCategory",
    "name": "TemplateVariableCategory",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-constants.ts",
    "relative_path": "src/features/hooks/template-variable-constants.ts",
    "depends_on": [],
    "source_code": "type TemplateVariableCategory =\n\t| \"standard\" // Available for all triggers\n\t| \"spec\" // Spec-related triggers\n\t| \"file\" // File operation triggers\n\t| \"git\" // Git operation triggers\n\t| \"user\" // User/author information\n\t| \"trigger\";",
    "start_line": 57,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateVariableCategory",
    "component_id": "src.features.hooks.template-variable-constants.TemplateVariableCategory"
  },
  "src.features.hooks.template-variable-constants.getVariablesForTrigger": {
    "id": "src.features.hooks.template-variable-constants.getVariablesForTrigger",
    "name": "getVariablesForTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-constants.ts",
    "relative_path": "src/features/hooks/template-variable-constants.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType",
      "src.features.hooks.template-variable-constants.TemplateVariable"
    ],
    "source_code": "function getVariablesForTrigger(\n\ttriggerType: OperationType\n): TemplateVariable[] {\n\treturn ALL_TEMPLATE_VARIABLES.filter(\n\t\t(variable) =>\n\t\t\tvariable.availableFor.length === 0 || // Available for all\n\t\t\tvariable.availableFor.includes(triggerType)\n\t);\n}",
    "start_line": 476,
    "end_line": 484,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "triggerType"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getVariablesForTrigger",
    "component_id": "src.features.hooks.template-variable-constants.getVariablesForTrigger"
  },
  "src.features.hooks.template-variable-constants.getVariableByName": {
    "id": "src.features.hooks.template-variable-constants.getVariableByName",
    "name": "getVariableByName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-constants.ts",
    "relative_path": "src/features/hooks/template-variable-constants.ts",
    "depends_on": [
      "src.features.hooks.template-variable-constants.TemplateVariable"
    ],
    "source_code": "function getVariableByName(name: string): TemplateVariable | undefined {\n\treturn ALL_TEMPLATE_VARIABLES.find((v) => v.name === name);\n}",
    "start_line": 491,
    "end_line": 493,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getVariableByName",
    "component_id": "src.features.hooks.template-variable-constants.getVariableByName"
  },
  "src.features.hooks.template-variable-constants.isValidVariableName": {
    "id": "src.features.hooks.template-variable-constants.isValidVariableName",
    "name": "isValidVariableName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-constants.ts",
    "relative_path": "src/features/hooks/template-variable-constants.ts",
    "depends_on": [],
    "source_code": "function isValidVariableName(name: string): boolean {\n\treturn VALID_VARIABLE_NAME_PATTERN.test(name);\n}",
    "start_line": 500,
    "end_line": 502,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidVariableName",
    "component_id": "src.features.hooks.template-variable-constants.isValidVariableName"
  },
  "src.features.hooks.template-variable-parser.TemplateContext": {
    "id": "src.features.hooks.template-variable-parser.TemplateContext",
    "name": "TemplateContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.OperationType"
    ],
    "source_code": "interface TemplateContext {\n\t// Standard variables (always present)\n\ttimestamp: string; // ISO 8601 format\n\ttriggerType: OperationType; // Type of trigger\n\n\t// Optional standard variables\n\tuser?: string; // Git user name\n\tbranch?: string; // Current git branch\n\tfeature?: string; // Current feature name\n\n\t// Dynamic variables (populated based on trigger type)\n\t[key: string]: string | number | boolean | undefined;\n}",
    "start_line": 34,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateContext",
    "component_id": "src.features.hooks.template-variable-parser.TemplateContext"
  },
  "src.features.hooks.template-variable-parser.TemplateValidationResult": {
    "id": "src.features.hooks.template-variable-parser.TemplateValidationResult",
    "name": "TemplateValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [
      "src.features.hooks.template-variable-parser.TemplateValidationWarning",
      "src.features.hooks.template-variable-parser.TemplateValidationError"
    ],
    "source_code": "interface TemplateValidationResult {\n\tvalid: boolean; // Syntax and variable availability OK?\n\terrors: TemplateValidationError[]; // Syntax errors\n\twarnings: TemplateValidationWarning[]; // Missing variables (non-blocking)\n}",
    "start_line": 51,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateValidationResult",
    "component_id": "src.features.hooks.template-variable-parser.TemplateValidationResult"
  },
  "src.features.hooks.template-variable-parser.TemplateValidationError": {
    "id": "src.features.hooks.template-variable-parser.TemplateValidationError",
    "name": "TemplateValidationError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [
      "src.features.hooks.template-variable-parser.TemplateErrorCode"
    ],
    "source_code": "interface TemplateValidationError {\n\tcode: TemplateErrorCode;\n\tmessage: string; // Human-readable error\n\tposition?: number; // Character position in template\n\tvariable?: string; // Variable name (if applicable)\n}",
    "start_line": 60,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateValidationError",
    "component_id": "src.features.hooks.template-variable-parser.TemplateValidationError"
  },
  "src.features.hooks.template-variable-parser.TemplateValidationWarning": {
    "id": "src.features.hooks.template-variable-parser.TemplateValidationWarning",
    "name": "TemplateValidationWarning",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [
      "src.features.hooks.template-variable-parser.TemplateWarningCode"
    ],
    "source_code": "interface TemplateValidationWarning {\n\tcode: TemplateWarningCode;\n\tmessage: string; // Human-readable warning\n\tvariable: string; // Variable name\n\tsuggestion?: string; // How to fix the issue\n}",
    "start_line": 70,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateValidationWarning",
    "component_id": "src.features.hooks.template-variable-parser.TemplateValidationWarning"
  },
  "src.features.hooks.template-variable-parser.TemplateErrorCode": {
    "id": "src.features.hooks.template-variable-parser.TemplateErrorCode",
    "name": "TemplateErrorCode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "type TemplateErrorCode =\n\t| \"INVALID_VARIABLE_NAME\" // $123abc or $var-name (invalid characters)\n\t| \"EMPTY_VARIABLE\" // $ with no name following\n\t| \"DEPRECATED_VARIABLE\";",
    "start_line": 80,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateErrorCode",
    "component_id": "src.features.hooks.template-variable-parser.TemplateErrorCode"
  },
  "src.features.hooks.template-variable-parser.TemplateWarningCode": {
    "id": "src.features.hooks.template-variable-parser.TemplateWarningCode",
    "name": "TemplateWarningCode",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "type TemplateWarningCode =\n\t| \"VARIABLE_NOT_AVAILABLE\" // Variable not provided by trigger type\n\t| \"VARIABLE_NOT_REQUIRED\" // Variable may be missing at runtime\n\t| \"DEPRECATED_VARIABLE\";",
    "start_line": 88,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TemplateWarningCode",
    "component_id": "src.features.hooks.template-variable-parser.TemplateWarningCode"
  },
  "src.features.hooks.template-variable-parser.ITemplateVariableParser": {
    "id": "src.features.hooks.template-variable-parser.ITemplateVariableParser",
    "name": "ITemplateVariableParser",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [
      "src.features.hooks.template-variable-parser.TemplateValidationResult",
      "ui.src.features.hooks-view.types.OperationType",
      "src.features.hooks.template-variable-constants.TemplateVariable",
      "src.features.hooks.template-variable-parser.TemplateContext"
    ],
    "source_code": "interface ITemplateVariableParser {\n\t/**\n\t * Parse template string to extract all variable references\n\t * @param template Template string with {variable} syntax\n\t * @returns Array of extracted variable names\n\t */\n\textractVariables(template: string): string[];\n\n\t/**\n\t * Substitute variables in template with values from context\n\t * @param template Template string with {variable} syntax\n\t * @param context Context object with variable values\n\t * @returns Resolved string with variables replaced\n\t */\n\tsubstitute(template: string, context: TemplateContext): string;\n\n\t/**\n\t * Validate template string for syntax errors\n\t * @param template Template string to validate\n\t * @returns Validation result with errors if any\n\t */\n\tvalidateSyntax(template: string): TemplateValidationResult;\n\n\t/**\n\t * Validate that all variables in template are available for trigger type\n\t * @param template Template string to validate\n\t * @param triggerType Type of trigger that will provide context\n\t * @returns Validation result with warnings for unavailable variables\n\t */\n\tvalidateVariables(\n\t\ttemplate: string,\n\t\ttriggerType: OperationType\n\t): TemplateValidationResult;\n\n\t/**\n\t * Get all available variables for a specific trigger type\n\t * @param triggerType Type of trigger\n\t * @returns Array of variable definitions available for this trigger\n\t */\n\tgetAvailableVariables(triggerType: OperationType): TemplateVariable[];\n}",
    "start_line": 100,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ITemplateVariableParser",
    "component_id": "src.features.hooks.template-variable-parser.ITemplateVariableParser"
  },
  "src.features.hooks.template-variable-parser.TemplateVariableParser": {
    "id": "src.features.hooks.template-variable-parser.TemplateVariableParser",
    "name": "TemplateVariableParser",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [
      "src.features.hooks.template-variable-parser.TemplateValidationResult",
      "ui.src.features.hooks-view.types.OperationType",
      "src.features.hooks.template-variable-constants.TemplateVariable",
      "src.features.hooks.template-variable-constants.getVariablesForTrigger",
      "src.features.hooks.template-variable-parser.TemplateContext",
      "src.features.hooks.template-variable-parser.ITemplateVariableParser",
      "src.features.hooks.template-variable-parser.TemplateValidationError"
    ],
    "source_code": "class TemplateVariableParser implements ITemplateVariableParser {\n\t// ============================================================================\n\t// Public API\n\t// ============================================================================\n\n\t/**\n\t * Parse template string to extract all variable references\n\t *\n\t * TODO: Phase 4 (T032) - Implement variable extraction\n\t * - Use TEMPLATE_VARIABLE_PATTERN regex to find all $variableName patterns\n\t * - Extract variable names from capture groups\n\t * - Remove duplicates and return unique variable names\n\t * - Handle edge cases: empty template, no variables, etc.\n\t *\n\t * @param template Template string with $variable syntax\n\t * @returns Array of extracted variable names\n\t */\n\textractVariables(template: string): string[] {\n\t\t// Handle empty template\n\t\tif (!template) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Use regex to find all $variableName patterns\n\t\t// TEMPLATE_VARIABLE_PATTERN = /\\$([a-zA-Z_][a-zA-Z0-9_]*)/g\n\t\tconst matches = template.matchAll(TEMPLATE_VARIABLE_PATTERN);\n\n\t\t// Extract variable names from capture groups\n\t\tconst variables = Array.from(matches).map((match) => match[1]);\n\n\t\t// Remove duplicates and return unique variable names\n\t\treturn [...new Set(variables)];\n\t}\n\n\t/**\n\t * Substitute variables in template with values from context\n\t *\n\t * TODO: Phase 4 (T034) - Implement variable substitution\n\t * - Use TEMPLATE_VARIABLE_PATTERN regex to find all $variableName patterns\n\t * - Replace each pattern with corresponding context value\n\t * - Use empty string for missing variables (graceful degradation)\n\t * - Handle type coercion (convert numbers/booleans to strings)\n\t * - Preserve original template if no variables found\n\t *\n\t * @param template Template string with $variable syntax\n\t * @param context Context object with variable values\n\t * @returns Resolved string with variables replaced\n\t */\n\tsubstitute(template: string, context: TemplateContext): string {\n\t\t// Handle empty template\n\t\tif (!template) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Replace each $variableName with corresponding context value\n\t\t// Use empty string for missing/undefined variables (graceful degradation)\n\t\treturn template.replace(\n\t\t\tTEMPLATE_VARIABLE_PATTERN,\n\t\t\t(_match, variableName) => {\n\t\t\t\tconst value = context[variableName];\n\n\t\t\t\t// Handle missing or undefined variables\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\n\t\t\t\t// Convert non-string values to strings\n\t\t\t\treturn String(value);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Validate template string for syntax errors\n\t *\n\t * @param template Template string to validate\n\t * @returns Validation result with errors if any\n\t */\n\tvalidateSyntax(template: string): TemplateValidationResult {\n\t\tconst errors: TemplateValidationError[] = [];\n\n\t\t// Handle empty template (valid)\n\t\tif (!template) {\n\t\t\treturn { valid: true, errors: [], warnings: [] };\n\t\t}\n\n\t\t// Check for invalid variable names\n\t\tconst matches = Array.from(template.matchAll(TEMPLATE_VARIABLE_PATTERN));\n\t\tfor (const match of matches) {\n\t\t\tconst varName = match[1];\n\t\t\tif (!VALID_VARIABLE_NAME_PATTERN.test(varName)) {\n\t\t\t\terrors.push({\n\t\t\t\t\tcode: \"INVALID_VARIABLE_NAME\",\n\t\t\t\t\tmessage: `Invalid variable name \"$${varName}\" - must start with letter or underscore, followed by letters, numbers, or underscores`,\n\t\t\t\t\tposition: match.index,\n\t\t\t\t\tvariable: varName,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Check for empty variables ($ followed by whitespace or end of string)\n\t\t// This explicitly allows $100, $$$, etc. as literal text\n\t\tconst emptyVarPattern = /\\$(?=\\s|$)/g;\n\t\tconst emptyMatches = Array.from(template.matchAll(emptyVarPattern));\n\t\tfor (const match of emptyMatches) {\n\t\t\terrors.push({\n\t\t\t\tcode: \"EMPTY_VARIABLE\",\n\t\t\t\tmessage:\n\t\t\t\t\t\"Empty variable name - $ must be followed by a valid identifier\",\n\t\t\t\tposition: match.index,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t\twarnings: [],\n\t\t};\n\t}\n\n\t/**\n\t * Validate that all variables in template are available for trigger type\n\t *\n\t * TODO: Phase 4 (T034) - Implement variable availability validation\n\t * - Extract variables from template using extractVariables()\n\t * - Check if each variable is available for the given trigger type\n\t * - Use getVariablesForTrigger() to get available variables\n\t * - Generate warnings for unavailable variables\n\t * - Generate warnings for optional variables (not required)\n\t * - Return validation result with warnings\n\t *\n\t * @param template Template string to validate\n\t * @param triggerType Type of trigger that will provide context\n\t * @returns Validation result with warnings for unavailable variables\n\t */\n\tvalidateVariables(\n\t\ttemplate: string,\n\t\ttriggerType: OperationType\n\t): TemplateValidationResult {\n\t\t// TODO: Phase 4 (T034) - Implement variable availability validation\n\t\t// Stub implementation: assume all variables available\n\t\treturn {\n\t\t\tvalid: true,\n\t\t\terrors: [],\n\t\t\twarnings: [],\n\t\t};\n\t}\n\n\t/**\n\t * Get all available variables for a specific trigger type\n\t *\n\t * Implementation: Delegates to template-variable-constants helper\n\t *\n\t * @param triggerType Type of trigger\n\t * @returns Array of variable definitions available for this trigger\n\t */\n\tgetAvailableVariables(triggerType: OperationType): TemplateVariable[] {\n\t\treturn getVariablesForTrigger(triggerType);\n\t}\n}",
    "start_line": 161,
    "end_line": 320,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class TemplateVariableParser",
    "component_id": "src.features.hooks.template-variable-parser.TemplateVariableParser"
  },
  "src.features.hooks.template-variable-parser.extractVariables": {
    "id": "src.features.hooks.template-variable-parser.extractVariables",
    "name": "extractVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "extractVariables(template: string): string[] {\n\t\t// Handle empty template\n\t\tif (!template) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Use regex to find all $variableName patterns\n\t\t// TEMPLATE_VARIABLE_PATTERN = /\\$([a-zA-Z_][a-zA-Z0-9_]*)/g\n\t\tconst matches = template.matchAll(TEMPLATE_VARIABLE_PATTERN);\n\n\t\t// Extract variable names from capture groups\n\t\tconst variables = Array.from(matches).map((match) => match[1]);\n\n\t\t// Remove duplicates and return unique variable names\n\t\treturn [...new Set(variables)];\n\t}",
    "start_line": 178,
    "end_line": 193,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractVariables",
    "component_id": "src.features.hooks.template-variable-parser.extractVariables"
  },
  "src.features.hooks.template-variable-parser.substitute": {
    "id": "src.features.hooks.template-variable-parser.substitute",
    "name": "substitute",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "substitute(template: string, context: TemplateContext): string {\n\t\t// Handle empty template\n\t\tif (!template) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Replace each $variableName with corresponding context value\n\t\t// Use empty string for missing/undefined variables (graceful degradation)\n\t\treturn template.replace(\n\t\t\tTEMPLATE_VARIABLE_PATTERN,\n\t\t\t(_match, variableName) => {\n\t\t\t\tconst value = context[variableName];\n\n\t\t\t\t// Handle missing or undefined variables\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\n\t\t\t\t// Convert non-string values to strings\n\t\t\t\treturn String(value);\n\t\t\t}\n\t\t);\n\t}",
    "start_line": 209,
    "end_line": 231,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method substitute",
    "component_id": "src.features.hooks.template-variable-parser.substitute"
  },
  "src.features.hooks.template-variable-parser.validateSyntax": {
    "id": "src.features.hooks.template-variable-parser.validateSyntax",
    "name": "validateSyntax",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "validateSyntax(template: string): TemplateValidationResult {\n\t\tconst errors: TemplateValidationError[] = [];\n\n\t\t// Handle empty template (valid)\n\t\tif (!template) {\n\t\t\treturn { valid: true, errors: [], warnings: [] };\n\t\t}\n\n\t\t// Check for invalid variable names\n\t\tconst matches = Array.from(template.matchAll(TEMPLATE_VARIABLE_PATTERN));\n\t\tfor (const match of matches) {\n\t\t\tconst varName = match[1];\n\t\t\tif (!VALID_VARIABLE_NAME_PATTERN.test(varName)) {\n\t\t\t\terrors.push({\n\t\t\t\t\tcode: \"INVALID_VARIABLE_NAME\",\n\t\t\t\t\tmessage: `Invalid variable name \"$${varName}\" - must start with letter or underscore, followed by letters, numbers, or underscores`,\n\t\t\t\t\tposition: match.index,\n\t\t\t\t\tvariable: varName,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Check for empty variables ($ followed by whitespace or end of string)\n\t\t// This explicitly allows $100, $$$, etc. as literal text\n\t\tconst emptyVarPattern = /\\$(?=\\s|$)/g;\n\t\tconst emptyMatches = Array.from(template.matchAll(emptyVarPattern));\n\t\tfor (const match of emptyMatches) {\n\t\t\terrors.push({\n\t\t\t\tcode: \"EMPTY_VARIABLE\",\n\t\t\t\tmessage:\n\t\t\t\t\t\"Empty variable name - $ must be followed by a valid identifier\",\n\t\t\t\tposition: match.index,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t\twarnings: [],\n\t\t};\n\t}",
    "start_line": 239,
    "end_line": 279,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateSyntax",
    "component_id": "src.features.hooks.template-variable-parser.validateSyntax"
  },
  "src.features.hooks.template-variable-parser.validateVariables": {
    "id": "src.features.hooks.template-variable-parser.validateVariables",
    "name": "validateVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "validateVariables(\n\t\ttemplate: string,\n\t\ttriggerType: OperationType\n\t): TemplateValidationResult {\n\t\t// TODO: Phase 4 (T034) - Implement variable availability validation\n\t\t// Stub implementation: assume all variables available\n\t\treturn {\n\t\t\tvalid: true,\n\t\t\terrors: [],\n\t\t\twarnings: [],\n\t\t};\n\t}",
    "start_line": 296,
    "end_line": 307,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template",
      "triggerType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateVariables",
    "component_id": "src.features.hooks.template-variable-parser.validateVariables"
  },
  "src.features.hooks.template-variable-parser.getAvailableVariables": {
    "id": "src.features.hooks.template-variable-parser.getAvailableVariables",
    "name": "getAvailableVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "getAvailableVariables(triggerType: OperationType): TemplateVariable[] {\n\t\treturn getVariablesForTrigger(triggerType);\n\t}",
    "start_line": 317,
    "end_line": 319,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "triggerType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAvailableVariables",
    "component_id": "src.features.hooks.template-variable-parser.getAvailableVariables"
  },
  "src.features.hooks.template-variable-parser.isTemplateContext": {
    "id": "src.features.hooks.template-variable-parser.isTemplateContext",
    "name": "isTemplateContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "function isTemplateContext(obj: unknown): obj is TemplateContext {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst context = obj as TemplateContext;\n\n\treturn (\n\t\ttypeof context.timestamp === \"string\" &&\n\t\ttypeof context.triggerType === \"string\"\n\t);\n}",
    "start_line": 329,
    "end_line": 340,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isTemplateContext",
    "component_id": "src.features.hooks.template-variable-parser.isTemplateContext"
  },
  "src.features.hooks.template-variable-parser.isTemplateValidationResult": {
    "id": "src.features.hooks.template-variable-parser.isTemplateValidationResult",
    "name": "isTemplateValidationResult",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/template-variable-parser.ts",
    "relative_path": "src/features/hooks/template-variable-parser.ts",
    "depends_on": [],
    "source_code": "function isTemplateValidationResult(\n\tobj: unknown\n): obj is TemplateValidationResult {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\n\tconst result = obj as TemplateValidationResult;\n\n\treturn (\n\t\ttypeof result.valid === \"boolean\" &&\n\t\tArray.isArray(result.errors) &&\n\t\tArray.isArray(result.warnings)\n\t);\n}",
    "start_line": 345,
    "end_line": 359,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isTemplateValidationResult",
    "component_id": "src.features.hooks.template-variable-parser.isTemplateValidationResult"
  },
  "src.features.hooks.trigger-registry.TriggerRegistry": {
    "id": "src.features.hooks.trigger-registry.TriggerRegistry",
    "name": "TriggerRegistry",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [
      "src.features.hooks.types.isValidTriggerEvent",
      "src.features.hooks.types.TriggerEvent",
      "src.services.agent-service.dispose",
      "src.features.hooks.trigger-registry.dispose",
      "src.features.hooks.trigger-registry.fireTriggerWithContext"
    ],
    "source_code": "class TriggerRegistry {\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly _onTrigger = new EventEmitter<TriggerEvent>();\n\tprivate triggerHistory: TriggerEvent[] = [];\n\tprivate disposed = false;\n\n\t/**\n\t * Event emitted when a trigger fires\n\t */\n\treadonly onTrigger: Event<TriggerEvent> = this._onTrigger.event;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Initialize the trigger registry\n\t */\n\tinitialize(): void {\n\t\tif (this.disposed) {\n\t\t\tthrow new Error(\"TriggerRegistry has been disposed\");\n\t\t}\n\t\tthis.outputChannel.appendLine(\"[TriggerRegistry] Initialized\");\n\t}\n\n\t/**\n\t * Dispose of resources\n\t */\n\tdispose(): void {\n\t\tthis._onTrigger.dispose();\n\t\tthis.triggerHistory = [];\n\t\tthis.disposed = true;\n\t\tthis.outputChannel.appendLine(\"[TriggerRegistry] Disposed\");\n\t}\n\n\t/**\n\t * Fire a trigger event (simple API)\n\t *\n\t * @param agent - Agent system ('speckit' | 'openspec')\n\t * @param operation - Operation name ('specify' | 'clarify' | 'plan' | 'analyze' | 'checklist')\n\t * @param timing - When the trigger fires ('before' | 'after')\n\t * @param outputData - Optional output capture data\n\t */\n\tfireTrigger(\n\t\tagent: string,\n\t\toperation: string,\n\t\ttiming: \"before\" | \"after\" = \"after\",\n\t\toutputData?: {\n\t\t\toutputPath?: string;\n\t\t\toutputContent?: string;\n\t\t}\n\t): void {\n\t\tconst event: TriggerEvent = {\n\t\t\tagent,\n\t\t\toperation,\n\t\t\ttimestamp: Date.now(),\n\t\t\ttiming,\n\t\t\toutputPath: outputData?.outputPath,\n\t\t\toutputContent: outputData?.outputContent,\n\t\t};\n\n\t\tthis.fireTriggerWithContext(event);\n\t}\n\n\t/**\n\t * Fire a trigger event with additional context (advanced API)\n\t *\n\t * @param event - Trigger event with optional metadata\n\t */\n\tfireTriggerWithContext(event: TriggerEvent): void {\n\t\tif (this.disposed) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[TriggerRegistry] Warning: Cannot fire trigger, registry disposed\"\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate event\n\t\tif (!isValidTriggerEvent(event)) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[TriggerRegistry] Invalid trigger event: ${JSON.stringify(event)}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Log trigger\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[TriggerRegistry] Trigger fired: ${event.agent}.${event.operation} (${event.timing || \"after\"}) at ${new Date(event.timestamp).toISOString()}`\n\t\t);\n\n\t\t// Store in history (FIFO)\n\t\tthis.triggerHistory.push(event);\n\t\tif (this.triggerHistory.length > MAX_TRIGGER_HISTORY) {\n\t\t\tthis.triggerHistory.shift();\n\t\t}\n\n\t\t// Emit event\n\t\ttry {\n\t\t\tthis._onTrigger.fire(event);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[TriggerRegistry] Error emitting trigger event: ${error}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get the last trigger event\n\t *\n\t * @returns Last trigger event or undefined if none\n\t */\n\tgetLastTrigger(): TriggerEvent | undefined {\n\t\treturn this.triggerHistory.at(-1);\n\t}\n\n\t/**\n\t * Get trigger history\n\t *\n\t * @param limit - Optional limit on number of events to return (defaults to all)\n\t * @returns Array of trigger events (newest last)\n\t */\n\tgetTriggerHistory(limit?: number): TriggerEvent[] {\n\t\tconst history = [...this.triggerHistory]; // Copy to prevent mutation\n\n\t\tif (limit !== undefined && limit > 0) {\n\t\t\treturn history.slice(-limit); // Last N events\n\t\t}\n\n\t\treturn history;\n\t}\n\n\t/**\n\t * Clear trigger history\n\t */\n\tclearTriggerHistory(): void {\n\t\tthis.triggerHistory = [];\n\t\tthis.outputChannel.appendLine(\"[TriggerRegistry] Trigger history cleared\");\n\t}\n}",
    "start_line": 14,
    "end_line": 152,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class TriggerRegistry",
    "component_id": "src.features.hooks.trigger-registry.TriggerRegistry"
  },
  "src.features.hooks.trigger-registry.initialize": {
    "id": "src.features.hooks.trigger-registry.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "initialize(): void {\n\t\tif (this.disposed) {\n\t\t\tthrow new Error(\"TriggerRegistry has been disposed\");\n\t\t}\n\t\tthis.outputChannel.appendLine(\"[TriggerRegistry] Initialized\");\n\t}",
    "start_line": 32,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initialize",
    "component_id": "src.features.hooks.trigger-registry.initialize"
  },
  "src.features.hooks.trigger-registry.dispose": {
    "id": "src.features.hooks.trigger-registry.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis._onTrigger.dispose();\n\t\tthis.triggerHistory = [];\n\t\tthis.disposed = true;\n\t\tthis.outputChannel.appendLine(\"[TriggerRegistry] Disposed\");\n\t}",
    "start_line": 42,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.features.hooks.trigger-registry.dispose"
  },
  "src.features.hooks.trigger-registry.fireTrigger": {
    "id": "src.features.hooks.trigger-registry.fireTrigger",
    "name": "fireTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "fireTrigger(\n\t\tagent: string,\n\t\toperation: string,\n\t\ttiming: \"before\" | \"after\" = \"after\",\n\t\toutputData?: {\n\t\t\toutputPath?: string;\n\t\t\toutputContent?: string;\n\t\t}\n\t): void {\n\t\tconst event: TriggerEvent = {\n\t\t\tagent,\n\t\t\toperation,\n\t\t\ttimestamp: Date.now(),\n\t\t\ttiming,\n\t\t\toutputPath: outputData?.outputPath,\n\t\t\toutputContent: outputData?.outputContent,\n\t\t};\n\n\t\tthis.fireTriggerWithContext(event);\n\t}",
    "start_line": 57,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agent",
      "operation",
      "timing",
      "outputData"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method fireTrigger",
    "component_id": "src.features.hooks.trigger-registry.fireTrigger"
  },
  "src.features.hooks.trigger-registry.fireTriggerWithContext": {
    "id": "src.features.hooks.trigger-registry.fireTriggerWithContext",
    "name": "fireTriggerWithContext",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "fireTriggerWithContext(event: TriggerEvent): void {\n\t\tif (this.disposed) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[TriggerRegistry] Warning: Cannot fire trigger, registry disposed\"\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate event\n\t\tif (!isValidTriggerEvent(event)) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[TriggerRegistry] Invalid trigger event: ${JSON.stringify(event)}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Log trigger\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[TriggerRegistry] Trigger fired: ${event.agent}.${event.operation} (${event.timing || \"after\"}) at ${new Date(event.timestamp).toISOString()}`\n\t\t);\n\n\t\t// Store in history (FIFO)\n\t\tthis.triggerHistory.push(event);\n\t\tif (this.triggerHistory.length > MAX_TRIGGER_HISTORY) {\n\t\t\tthis.triggerHistory.shift();\n\t\t}\n\n\t\t// Emit event\n\t\ttry {\n\t\t\tthis._onTrigger.fire(event);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[TriggerRegistry] Error emitting trigger event: ${error}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 83,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method fireTriggerWithContext",
    "component_id": "src.features.hooks.trigger-registry.fireTriggerWithContext"
  },
  "src.features.hooks.trigger-registry.getLastTrigger": {
    "id": "src.features.hooks.trigger-registry.getLastTrigger",
    "name": "getLastTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "getLastTrigger(): TriggerEvent | undefined {\n\t\treturn this.triggerHistory.at(-1);\n\t}",
    "start_line": 125,
    "end_line": 127,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getLastTrigger",
    "component_id": "src.features.hooks.trigger-registry.getLastTrigger"
  },
  "src.features.hooks.trigger-registry.getTriggerHistory": {
    "id": "src.features.hooks.trigger-registry.getTriggerHistory",
    "name": "getTriggerHistory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "getTriggerHistory(limit?: number): TriggerEvent[] {\n\t\tconst history = [...this.triggerHistory]; // Copy to prevent mutation\n\n\t\tif (limit !== undefined && limit > 0) {\n\t\t\treturn history.slice(-limit); // Last N events\n\t\t}\n\n\t\treturn history;\n\t}",
    "start_line": 135,
    "end_line": 143,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "limit"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTriggerHistory",
    "component_id": "src.features.hooks.trigger-registry.getTriggerHistory"
  },
  "src.features.hooks.trigger-registry.clearTriggerHistory": {
    "id": "src.features.hooks.trigger-registry.clearTriggerHistory",
    "name": "clearTriggerHistory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/trigger-registry.ts",
    "relative_path": "src/features/hooks/trigger-registry.ts",
    "depends_on": [],
    "source_code": "clearTriggerHistory(): void {\n\t\tthis.triggerHistory = [];\n\t\tthis.outputChannel.appendLine(\"[TriggerRegistry] Trigger history cleared\");\n\t}",
    "start_line": 148,
    "end_line": 151,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearTriggerHistory",
    "component_id": "src.features.hooks.trigger-registry.clearTriggerHistory"
  },
  "src.features.hooks.types.Hook": {
    "id": "src.features.hooks.types.Hook",
    "name": "Hook",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.ActionConfig",
      "src.features.hooks.types.TriggerCondition"
    ],
    "source_code": "interface Hook {\n\t// Identity\n\tid: string; // UUID v4 format\n\tname: string; // User-friendly name (max 100 chars)\n\n\t// Configuration\n\tenabled: boolean; // Active state (default: true)\n\ttrigger: TriggerCondition; // When to execute\n\taction: ActionConfig; // What to execute\n\n\t// Metadata\n\tcreatedAt: number; // Unix timestamp (milliseconds)\n\tmodifiedAt: number; // Unix timestamp (milliseconds)\n\tlastExecutedAt?: number; // Unix timestamp (milliseconds)\n\texecutionCount: number; // Total executions (default: 0)\n}",
    "start_line": 16,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Hook",
    "component_id": "src.features.hooks.types.Hook"
  },
  "src.features.hooks.types.TriggerCondition": {
    "id": "src.features.hooks.types.TriggerCondition",
    "name": "TriggerCondition",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.AgentType",
      "src.features.hooks.types.TriggerTiming",
      "src.features.hooks.types.OperationType"
    ],
    "source_code": "interface TriggerCondition {\n\tagent: AgentType; // Which agent system\n\toperation: OperationType; // Which operation\n\ttiming: TriggerTiming; // When to trigger\n\twaitForCompletion?: boolean; // Only for \"before\" timing: block operation until hook completes\n}",
    "start_line": 36,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TriggerCondition",
    "component_id": "src.features.hooks.types.TriggerCondition"
  },
  "src.features.hooks.types.AgentType": {
    "id": "src.features.hooks.types.AgentType",
    "name": "AgentType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type AgentType = \"speckit\" | \"openspec\";",
    "start_line": 46,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentType",
    "component_id": "src.features.hooks.types.AgentType"
  },
  "src.features.hooks.types.OperationType": {
    "id": "src.features.hooks.types.OperationType",
    "name": "OperationType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type OperationType =\n\t| \"research\" // Initial research completed\n\t| \"datamodel\" // Data model defined\n\t| \"design\" // Design plan completed\n\t| \"specify\" // Specification created\n\t| \"clarify\" // Clarification completed\n\t| \"plan\" // Plan generated\n\t| \"tasks\" // Tasks generated/updated\n\t| \"taskstoissues\" // Tasks converted to issues\n\t| \"analyze\" // Analysis completed\n\t| \"checklist\" // Checklist validated\n\t| \"constitution\" // Constitution updated\n\t| \"implementation\" // Implementation guidance completed\n\t| \"unit-test\" // Unit test generation completed\n\t| \"integration-test\";",
    "start_line": 51,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type OperationType",
    "component_id": "src.features.hooks.types.OperationType"
  },
  "src.features.hooks.types.TriggerTiming": {
    "id": "src.features.hooks.types.TriggerTiming",
    "name": "TriggerTiming",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type TriggerTiming = \"before\" | \"after\";",
    "start_line": 87,
    "end_line": 87,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TriggerTiming",
    "component_id": "src.features.hooks.types.TriggerTiming"
  },
  "src.features.hooks.types.ActionConfig": {
    "id": "src.features.hooks.types.ActionConfig",
    "name": "ActionConfig",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.ActionParameters",
      "src.features.hooks.types.ActionType"
    ],
    "source_code": "interface ActionConfig {\n\ttype: ActionType;\n\tparameters: ActionParameters;\n}",
    "start_line": 92,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ActionConfig",
    "component_id": "src.features.hooks.types.ActionConfig"
  },
  "src.features.hooks.types.ActionType": {
    "id": "src.features.hooks.types.ActionType",
    "name": "ActionType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type ActionType =\n\t| \"agent\" // Execute SpecKit/OpenSpec command\n\t| \"git\" // Git commit/push operation\n\t| \"github\" // GitHub via MCP Server\n\t| \"mcp\" // MCP server tool execution\n\t| \"custom\";",
    "start_line": 100,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ActionType",
    "component_id": "src.features.hooks.types.ActionType"
  },
  "src.features.hooks.types.ActionParameters": {
    "id": "src.features.hooks.types.ActionParameters",
    "name": "ActionParameters",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type ActionParameters =\n\t| AgentActionParams\n\t| GitActionParams\n\t| GitHubActionParams\n\t| MCPActionParams\n\t| CustomActionParams;",
    "start_line": 110,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ActionParameters",
    "component_id": "src.features.hooks.types.ActionParameters"
  },
  "src.features.hooks.types.AgentActionParams": {
    "id": "src.features.hooks.types.AgentActionParams",
    "name": "AgentActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface AgentActionParams {\n\tcommand: string; // Full agent command (e.g., '/speckit.clarify')\n}",
    "start_line": 124,
    "end_line": 126,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentActionParams",
    "component_id": "src.features.hooks.types.AgentActionParams"
  },
  "src.features.hooks.types.GitActionParams": {
    "id": "src.features.hooks.types.GitActionParams",
    "name": "GitActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.GitOperation"
    ],
    "source_code": "interface GitActionParams {\n\toperation: GitOperation;\n\tmessageTemplate: string; // Supports template variables\n\tpushToRemote?: boolean; // Auto-push after commit (default: false)\n}",
    "start_line": 131,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitActionParams",
    "component_id": "src.features.hooks.types.GitActionParams"
  },
  "src.features.hooks.types.GitOperation": {
    "id": "src.features.hooks.types.GitOperation",
    "name": "GitOperation",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type GitOperation = \"commit\" | \"push\";",
    "start_line": 140,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type GitOperation",
    "component_id": "src.features.hooks.types.GitOperation"
  },
  "src.features.hooks.types.GitHubActionParams": {
    "id": "src.features.hooks.types.GitHubActionParams",
    "name": "GitHubActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.GitHubOperation"
    ],
    "source_code": "interface GitHubActionParams {\n\toperation: GitHubOperation;\n\trepository?: string; // Format: 'owner/repo' (optional, defaults to current)\n\ttitleTemplate?: string; // For issue/PR creation\n\tbodyTemplate?: string; // For issue/PR creation\n\tissueNumber?: number; // For close/update operations\n}",
    "start_line": 145,
    "end_line": 151,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitHubActionParams",
    "component_id": "src.features.hooks.types.GitHubActionParams"
  },
  "src.features.hooks.types.GitHubOperation": {
    "id": "src.features.hooks.types.GitHubOperation",
    "name": "GitHubOperation",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type GitHubOperation =\n\t| \"open-issue\"\n\t| \"close-issue\"\n\t| \"create-pr\"\n\t| \"add-comment\";",
    "start_line": 156,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type GitHubOperation",
    "component_id": "src.features.hooks.types.GitHubOperation"
  },
  "src.features.hooks.types.CustomActionParams": {
    "id": "src.features.hooks.types.CustomActionParams",
    "name": "CustomActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.SelectedMCPTool",
      "src.features.hooks.types.CopilotCliOptions"
    ],
    "source_code": "interface CustomActionParams {\n\t// NEW: Agent Registry Integration (for custom-agent-hooks refactoring)\n\tagentId?: string; // Agent ID from agent registry (format: \"source:name\")\n\tagentType?: \"local\" | \"background\"; // Explicit type override\n\n\t// EXISTING: Legacy GitHub Copilot agent support\n\tagentName?: string; // Custom agent identifier (deprecated - use agentId instead)\n\tprompt?: string; // Instruction/action text for the agent\n\tselectedTools?: SelectedMCPTool[]; // Optional: MCP tools available to agent\n\targuments?: string; // Template string with {variable} syntax for passing trigger context\n\n\t// GitHub Copilot CLI Options\n\tcliOptions?: CopilotCliOptions; // All CLI parameters supported by GitHub Copilot\n}",
    "start_line": 165,
    "end_line": 178,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CustomActionParams",
    "component_id": "src.features.hooks.types.CustomActionParams"
  },
  "src.features.hooks.types.CopilotCliOptions": {
    "id": "src.features.hooks.types.CopilotCliOptions",
    "name": "CopilotCliOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.CopilotLogLevel",
      "src.features.hooks.types.CopilotModel"
    ],
    "source_code": "interface CopilotCliOptions {\n\t// Directory and Path Options\n\taddDir?: string[]; // --add-dir: Additional directories for file access\n\tallowAllPaths?: boolean; // --allow-all-paths: Disable file path verification\n\tdisallowTempDir?: boolean; // --disallow-temp-dir: Prevent temp directory access\n\n\t// Tool Permissions\n\tallowAllTools?: boolean; // --allow-all-tools: Allow all tools without confirmation\n\tallowTool?: string[]; // --allow-tool: Specific tools allowed\n\tavailableTools?: string[]; // --available-tools: Only these tools available\n\texcludedTools?: string[]; // --excluded-tools: These tools not available\n\tdenyTool?: string[]; // --deny-tool: Tools denied\n\n\t// URL Permissions\n\tallowAllUrls?: boolean; // --allow-all-urls: Allow all URLs\n\tallowUrl?: string[]; // --allow-url: Specific URLs allowed\n\tdenyUrl?: string[]; // --deny-url: Specific URLs denied\n\n\t// GitHub MCP Server Options\n\taddGithubMcpTool?: string[]; // --add-github-mcp-tool: Enable specific GitHub MCP tools\n\taddGithubMcpToolset?: string[]; // --add-github-mcp-toolset: Enable GitHub MCP toolsets\n\tenableAllGithubMcpTools?: boolean; // --enable-all-github-mcp-tools: Enable all GitHub MCP tools\n\n\t// MCP Server Configuration\n\tadditionalMcpConfig?: string[]; // --additional-mcp-config: Additional MCP config JSON\n\tdisableBuiltinMcps?: boolean; // --disable-builtin-mcps: Disable built-in MCP servers\n\tdisableMcpServer?: string[]; // --disable-mcp-server: Disable specific MCP servers\n\n\t// Execution Options\n\tagent?: string; // --agent: Custom agent to use\n\tmodel?: CopilotModel; // --model: AI model to use\n\tnoAskUser?: boolean; // --no-ask-user: Disable ask_user tool (autonomous mode)\n\tdisableParallelToolsExecution?: boolean; // --disable-parallel-tools-execution: Sequential tool execution\n\tnoCustomInstructions?: boolean; // --no-custom-instructions: Disable AGENTS.md loading\n\n\t// Output and Logging Options\n\tsilent?: boolean; // --silent / -s: Output only agent response\n\tlogLevel?: CopilotLogLevel; // --log-level: Set log level\n\tlogDir?: string; // --log-dir: Log file directory\n\tnoColor?: boolean; // --no-color: Disable color output\n\tplainDiff?: boolean; // --plain-diff: Disable rich diff rendering\n\tscreenReader?: boolean; // --screen-reader: Enable screen reader optimizations\n\tstream?: \"on\" | \"off\"; // --stream: Enable/disable streaming\n\n\t// Session Options\n\tresume?: boolean | string; // --resume: Resume previous session (true or session ID)\n\tcontinue?: boolean; // --continue: Resume most recent session\n\tshare?: boolean | string; // --share: Share to markdown (true or custom path)\n\tshareGist?: boolean; // --share-gist: Share to GitHub gist\n\n\t// Configuration\n\tconfigDir?: string; // --config-dir: Configuration directory\n\tbanner?: boolean; // --banner: Show startup banner\n\tnoAutoUpdate?: boolean; // --no-auto-update: Disable auto-update\n\n\t// Combined Flags\n\tallowAll?: boolean; // --allow-all or --yolo: Enable all permissions\n}",
    "start_line": 184,
    "end_line": 241,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CopilotCliOptions",
    "component_id": "src.features.hooks.types.CopilotCliOptions"
  },
  "src.features.hooks.types.CopilotModel": {
    "id": "src.features.hooks.types.CopilotModel",
    "name": "CopilotModel",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type CopilotModel =\n\t| \"claude-sonnet-4.5\"\n\t| \"claude-haiku-4.5\"\n\t| \"claude-opus-4.5\"\n\t| \"claude-sonnet-4\"\n\t| \"gpt-5.2-codex\"\n\t| \"gpt-5.1-codex-max\"\n\t| \"gpt-5.1-codex\"\n\t| \"gpt-5.2\"\n\t| \"gpt-5.1\"\n\t| \"gpt-5\"\n\t| \"gpt-5.1-codex-mini\"\n\t| \"gpt-5-mini\"\n\t| \"gpt-4.1\";",
    "start_line": 246,
    "end_line": 259,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CopilotModel",
    "component_id": "src.features.hooks.types.CopilotModel"
  },
  "src.features.hooks.types.CopilotLogLevel": {
    "id": "src.features.hooks.types.CopilotLogLevel",
    "name": "CopilotLogLevel",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type CopilotLogLevel =\n\t| \"none\"\n\t| \"error\"\n\t| \"warning\"\n\t| \"info\"\n\t| \"debug\"\n\t| \"all\"\n\t| \"default\";",
    "start_line": 264,
    "end_line": 271,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CopilotLogLevel",
    "component_id": "src.features.hooks.types.CopilotLogLevel"
  },
  "src.features.hooks.types.MCPActionParams": {
    "id": "src.features.hooks.types.MCPActionParams",
    "name": "MCPActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.ParameterMapping",
      "src.features.hooks.types.SelectedMCPTool"
    ],
    "source_code": "interface MCPActionParams {\n\t// Model and instruction\n\tmodelId?: string; // Optional: LLM model ID from GitHub subscription (e.g., 'gpt-4o', 'claude-3-5-sonnet')\n\tprompt: string; // Instruction/action text for the agent to execute\n\n\t// Selected tools (multiple selection supported)\n\tselectedTools: SelectedMCPTool[]; // Array of selected MCP tools\n\n\t// Legacy fields (kept for backward compatibility)\n\tserverId?: string; // MCP server identifier (deprecated, use selectedTools)\n\ttoolName?: string; // Tool to execute (deprecated, use selectedTools)\n\tparameterMappings?: ParameterMapping[]; // How to map parameters (optional)\n\ttimeout?: number; // Optional timeout override (1000-300000ms)\n}",
    "start_line": 276,
    "end_line": 289,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPActionParams",
    "component_id": "src.features.hooks.types.MCPActionParams"
  },
  "src.features.hooks.types.SelectedMCPTool": {
    "id": "src.features.hooks.types.SelectedMCPTool",
    "name": "SelectedMCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface SelectedMCPTool {\n\tserverId: string; // Server providing the tool\n\tserverName: string; // Display name of server\n\ttoolName: string; // Tool identifier\n\ttoolDisplayName: string; // Human-readable tool name\n}",
    "start_line": 294,
    "end_line": 299,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SelectedMCPTool",
    "component_id": "src.features.hooks.types.SelectedMCPTool"
  },
  "src.features.hooks.types.ParameterMapping": {
    "id": "src.features.hooks.types.ParameterMapping",
    "name": "ParameterMapping",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface ParameterMapping {\n\ttoolParam: string; // Parameter name in tool's input schema\n\tsource: \"context\" | \"literal\" | \"template\"; // Where to get the value\n\tvalue: string; // Template string or literal value\n}",
    "start_line": 304,
    "end_line": 308,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParameterMapping",
    "component_id": "src.features.hooks.types.ParameterMapping"
  },
  "src.features.hooks.types.ServerStatus": {
    "id": "src.features.hooks.types.ServerStatus",
    "name": "ServerStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type ServerStatus = \"available\" | \"unavailable\" | \"unknown\";",
    "start_line": 313,
    "end_line": 313,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ServerStatus",
    "component_id": "src.features.hooks.types.ServerStatus"
  },
  "src.features.hooks.types.MCPServer": {
    "id": "src.features.hooks.types.MCPServer",
    "name": "MCPServer",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.ServerStatus",
      "src.features.hooks.types.MCPTool"
    ],
    "source_code": "interface MCPServer {\n\tid: string; // Server identifier\n\tname: string; // Display name\n\tdescription?: string; // Optional description\n\tstatus: ServerStatus; // Current availability\n\ttools: MCPTool[]; // Available tools/actions\n\tlastDiscovered: number; // Unix timestamp (milliseconds)\n}",
    "start_line": 318,
    "end_line": 325,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServer",
    "component_id": "src.features.hooks.types.MCPServer"
  },
  "src.features.hooks.types.MCPTool": {
    "id": "src.features.hooks.types.MCPTool",
    "name": "MCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.JSONSchema"
    ],
    "source_code": "interface MCPTool {\n\tname: string; // Tool identifier\n\tdisplayName: string; // Human-readable name\n\tdescription: string; // What the tool does\n\tinputSchema: JSONSchema; // Parameter definition\n\tserverId: string; // Parent server reference\n}",
    "start_line": 330,
    "end_line": 336,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPTool",
    "component_id": "src.features.hooks.types.MCPTool"
  },
  "src.features.hooks.types.JSONSchema": {
    "id": "src.features.hooks.types.JSONSchema",
    "name": "JSONSchema",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.JSONSchemaProperty"
    ],
    "source_code": "interface JSONSchema {\n\ttype: string; // Schema type (e.g., 'object')\n\tproperties?: Record<string, JSONSchemaProperty>; // Parameter definitions\n\trequired?: string[]; // Required parameter names\n}",
    "start_line": 341,
    "end_line": 345,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchema",
    "component_id": "src.features.hooks.types.JSONSchema"
  },
  "src.features.hooks.types.JSONSchemaProperty": {
    "id": "src.features.hooks.types.JSONSchemaProperty",
    "name": "JSONSchemaProperty",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface JSONSchemaProperty {\n\ttype: string; // Parameter type (string, number, boolean, etc.)\n\tdescription?: string; // Parameter description\n\tenum?: unknown[]; // Allowed values (if applicable)\n\tdefault?: unknown; // Default value (if applicable)\n}",
    "start_line": 350,
    "end_line": 355,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchemaProperty",
    "component_id": "src.features.hooks.types.JSONSchemaProperty"
  },
  "src.features.hooks.types.HookExecutionLog": {
    "id": "src.features.hooks.types.HookExecutionLog",
    "name": "HookExecutionLog",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.ExecutionStatus",
      "src.features.hooks.types.ExecutionError",
      "src.features.hooks.types.TemplateContext"
    ],
    "source_code": "interface HookExecutionLog {\n\t// Identity\n\tid: string; // UUID for this log entry\n\thookId: string; // Reference to executed hook\n\n\t// Execution context\n\texecutionId: string; // UUID for this execution chain\n\tchainDepth: number; // Position in hook chain (0-based)\n\n\t// Timing\n\ttriggeredAt: number; // Unix timestamp (milliseconds)\n\tcompletedAt?: number; // Unix timestamp (milliseconds)\n\tduration?: number; // Milliseconds (completedAt - triggeredAt)\n\n\t// Result\n\tstatus: ExecutionStatus;\n\terror?: ExecutionError;\n\n\t// Context snapshot\n\tcontextSnapshot: TemplateContext;\n}",
    "start_line": 364,
    "end_line": 384,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookExecutionLog",
    "component_id": "src.features.hooks.types.HookExecutionLog"
  },
  "src.features.hooks.types.ExecutionStatus": {
    "id": "src.features.hooks.types.ExecutionStatus",
    "name": "ExecutionStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "type ExecutionStatus =\n\t| \"success\" // Action completed successfully\n\t| \"failure\" // Action failed with error\n\t| \"skipped\" // Hook was disabled or filtered\n\t| \"timeout\";",
    "start_line": 389,
    "end_line": 393,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExecutionStatus",
    "component_id": "src.features.hooks.types.ExecutionStatus"
  },
  "src.features.hooks.types.ExecutionError": {
    "id": "src.features.hooks.types.ExecutionError",
    "name": "ExecutionError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface ExecutionError {\n\tcode: string; // Error code (e.g., 'GIT_COMMIT_FAILED')\n\tmessage: string; // Human-readable error message\n\tstack?: string; // Stack trace (for debugging)\n}",
    "start_line": 398,
    "end_line": 402,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionError",
    "component_id": "src.features.hooks.types.ExecutionError"
  },
  "src.features.hooks.types.ExecutionContext": {
    "id": "src.features.hooks.types.ExecutionContext",
    "name": "ExecutionContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface ExecutionContext {\n\texecutionId: string; // UUID for entire execution chain\n\tchainDepth: number; // Current depth (0 = root trigger)\n\texecutedHooks: Set<string>; // Hook IDs already executed in this chain\n\tstartedAt: number; // Unix timestamp when chain started\n}",
    "start_line": 407,
    "end_line": 412,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionContext",
    "component_id": "src.features.hooks.types.ExecutionContext"
  },
  "src.features.hooks.types.TemplateContext": {
    "id": "src.features.hooks.types.TemplateContext",
    "name": "TemplateContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "interface TemplateContext {\n\tfeature?: string; // Current feature name (e.g., 'hooks-module')\n\tbranch?: string; // Current git branch (e.g., '001-hooks-module')\n\ttimestamp?: string; // ISO 8601 format\n\tuser?: string; // Git user name from config\n\t// Output capture variables\n\tagentOutput?: string; // Output content from triggering agent\n\tclipboardContent?: string; // Current clipboard content\n\toutputPath?: string; // Path to output file\n}",
    "start_line": 417,
    "end_line": 426,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TemplateContext",
    "component_id": "src.features.hooks.types.TemplateContext"
  },
  "src.features.hooks.types.TriggerEvent": {
    "id": "src.features.hooks.types.TriggerEvent",
    "name": "TriggerEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.TriggerTiming"
    ],
    "source_code": "interface TriggerEvent {\n\tagent: string; // 'speckit' | 'openspec'\n\toperation: string; // Operation name\n\ttimestamp: number; // Unix timestamp (milliseconds)\n\ttiming?: TriggerTiming; // When the trigger fired (before/after)\n\tmetadata?: Record<string, unknown>; // Optional context data\n\t// Output capture fields\n\toutputPath?: string; // Path to generated file (for file operations)\n\toutputContent?: string; // File content or captured output\n}",
    "start_line": 431,
    "end_line": 440,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TriggerEvent",
    "component_id": "src.features.hooks.types.TriggerEvent"
  },
  "src.features.hooks.types.isValidUUID": {
    "id": "src.features.hooks.types.isValidUUID",
    "name": "isValidUUID",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidUUID(id: string): boolean {\n\treturn UUID_V4_PATTERN.test(id);\n}",
    "start_line": 504,
    "end_line": 506,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidUUID",
    "component_id": "src.features.hooks.types.isValidUUID"
  },
  "src.features.hooks.types.isValidHook": {
    "id": "src.features.hooks.types.isValidHook",
    "name": "isValidHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.isValidAction",
      "src.features.hooks.types.isValidTrigger",
      "src.features.hooks.types.isValidUUID"
    ],
    "source_code": "function isValidHook(obj: unknown): obj is Hook {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst hook = obj as Hook;\n\n\treturn (\n\t\ttypeof hook.id === \"string\" &&\n\t\tisValidUUID(hook.id) &&\n\t\ttypeof hook.name === \"string\" &&\n\t\thook.name.length > 0 &&\n\t\thook.name.length <= MAX_HOOK_NAME_LENGTH &&\n\t\ttypeof hook.enabled === \"boolean\" &&\n\t\tisValidTrigger(hook.trigger) &&\n\t\tisValidAction(hook.action) &&\n\t\ttypeof hook.createdAt === \"number\" &&\n\t\ttypeof hook.modifiedAt === \"number\" &&\n\t\ttypeof hook.executionCount === \"number\"\n\t);\n}",
    "start_line": 511,
    "end_line": 530,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidHook",
    "component_id": "src.features.hooks.types.isValidHook"
  },
  "src.features.hooks.types.isValidTrigger": {
    "id": "src.features.hooks.types.isValidTrigger",
    "name": "isValidTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.AgentType",
      "src.features.hooks.types.TriggerTiming"
    ],
    "source_code": "function isValidTrigger(obj: unknown): obj is TriggerCondition {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst trigger = obj as TriggerCondition;\n\n\tconst validAgents: AgentType[] = [\"speckit\", \"openspec\"];\n\tconst validTimings: TriggerTiming[] = [\"before\", \"after\"];\n\n\treturn (\n\t\ttypeof trigger.agent === \"string\" &&\n\t\tvalidAgents.includes(trigger.agent) &&\n\t\ttypeof trigger.operation === \"string\" &&\n\t\tSUPPORTED_SPECKIT_OPERATIONS.includes(trigger.operation) &&\n\t\ttypeof trigger.timing === \"string\" &&\n\t\tvalidTimings.includes(trigger.timing) &&\n\t\t(trigger.waitForCompletion === undefined ||\n\t\t\ttypeof trigger.waitForCompletion === \"boolean\")\n\t);\n}",
    "start_line": 535,
    "end_line": 554,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidTrigger",
    "component_id": "src.features.hooks.types.isValidTrigger"
  },
  "src.features.hooks.types.isValidAction": {
    "id": "src.features.hooks.types.isValidAction",
    "name": "isValidAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.isValidGitHubParams",
      "src.features.hooks.types.isValidAgentParams",
      "src.features.hooks.types.isValidCustomParams",
      "src.features.hooks.types.isValidMCPParams",
      "src.features.hooks.types.isValidGitParams"
    ],
    "source_code": "function isValidAction(obj: unknown): obj is ActionConfig {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst action = obj as ActionConfig;\n\n\tif (typeof action.type !== \"string\") {\n\t\treturn false;\n\t}\n\n\tswitch (action.type) {\n\t\tcase \"agent\":\n\t\t\treturn isValidAgentParams(action.parameters);\n\t\tcase \"git\":\n\t\t\treturn isValidGitParams(action.parameters);\n\t\tcase \"github\":\n\t\t\treturn isValidGitHubParams(action.parameters);\n\t\tcase \"mcp\":\n\t\t\treturn isValidMCPParams(action.parameters);\n\t\tcase \"custom\":\n\t\t\treturn isValidCustomParams(action.parameters);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}",
    "start_line": 559,
    "end_line": 583,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidAction",
    "component_id": "src.features.hooks.types.isValidAction"
  },
  "src.features.hooks.types.isValidAgentParams": {
    "id": "src.features.hooks.types.isValidAgentParams",
    "name": "isValidAgentParams",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidAgentParams(obj: unknown): obj is AgentActionParams {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst params = obj as AgentActionParams;\n\n\treturn (\n\t\ttypeof params.command === \"string\" &&\n\t\tparams.command.length > 0 &&\n\t\tparams.command.length <= MAX_COMMAND_LENGTH &&\n\t\t(params.command.startsWith(\"/speckit.\") ||\n\t\t\tparams.command.startsWith(\"/openspec.\"))\n\t);\n}",
    "start_line": 588,
    "end_line": 601,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidAgentParams",
    "component_id": "src.features.hooks.types.isValidAgentParams"
  },
  "src.features.hooks.types.isValidGitParams": {
    "id": "src.features.hooks.types.isValidGitParams",
    "name": "isValidGitParams",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.GitOperation"
    ],
    "source_code": "function isValidGitParams(obj: unknown): obj is GitActionParams {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst params = obj as GitActionParams;\n\n\tconst validOperations: GitOperation[] = [\"commit\", \"push\"];\n\n\treturn (\n\t\ttypeof params.operation === \"string\" &&\n\t\tvalidOperations.includes(params.operation) &&\n\t\ttypeof params.messageTemplate === \"string\" &&\n\t\tparams.messageTemplate.length > 0 &&\n\t\tparams.messageTemplate.length <= MAX_MESSAGE_TEMPLATE_LENGTH &&\n\t\t(params.pushToRemote === undefined ||\n\t\t\ttypeof params.pushToRemote === \"boolean\")\n\t);\n}",
    "start_line": 606,
    "end_line": 623,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidGitParams",
    "component_id": "src.features.hooks.types.isValidGitParams"
  },
  "src.features.hooks.types.isValidGitHubOperation": {
    "id": "src.features.hooks.types.isValidGitHubOperation",
    "name": "isValidGitHubOperation",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.GitHubOperation"
    ],
    "source_code": "function isValidGitHubOperation(\n\toperation: unknown\n): operation is GitHubOperation {\n\tconst validOperations: GitHubOperation[] = [\n\t\t\"open-issue\",\n\t\t\"close-issue\",\n\t\t\"create-pr\",\n\t\t\"add-comment\",\n\t];\n\treturn (\n\t\ttypeof operation === \"string\" &&\n\t\tvalidOperations.includes(operation as GitHubOperation)\n\t);\n}",
    "start_line": 628,
    "end_line": 641,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operation"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidGitHubOperation",
    "component_id": "src.features.hooks.types.isValidGitHubOperation"
  },
  "src.features.hooks.types.isValidRepository": {
    "id": "src.features.hooks.types.isValidRepository",
    "name": "isValidRepository",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidRepository(repository: unknown): boolean {\n\tif (repository === undefined) {\n\t\treturn true;\n\t}\n\treturn typeof repository === \"string\" && REPOSITORY_PATTERN.test(repository);\n}",
    "start_line": 646,
    "end_line": 651,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repository"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidRepository",
    "component_id": "src.features.hooks.types.isValidRepository"
  },
  "src.features.hooks.types.isValidTitleTemplate": {
    "id": "src.features.hooks.types.isValidTitleTemplate",
    "name": "isValidTitleTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.GitHubOperation"
    ],
    "source_code": "function isValidTitleTemplate(\n\toperation: GitHubOperation,\n\ttitleTemplate: unknown\n): boolean {\n\tconst requiresTitle = operation === \"open-issue\" || operation === \"create-pr\";\n\tif (!requiresTitle) {\n\t\treturn true;\n\t}\n\treturn (\n\t\ttypeof titleTemplate === \"string\" &&\n\t\ttitleTemplate.length > 0 &&\n\t\ttitleTemplate.length <= MAX_TITLE_TEMPLATE_LENGTH\n\t);\n}",
    "start_line": 656,
    "end_line": 669,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operation",
      "titleTemplate"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidTitleTemplate",
    "component_id": "src.features.hooks.types.isValidTitleTemplate"
  },
  "src.features.hooks.types.isValidBodyTemplate": {
    "id": "src.features.hooks.types.isValidBodyTemplate",
    "name": "isValidBodyTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidBodyTemplate(bodyTemplate: unknown): boolean {\n\tif (bodyTemplate === undefined) {\n\t\treturn true;\n\t}\n\treturn (\n\t\ttypeof bodyTemplate === \"string\" &&\n\t\tbodyTemplate.length <= MAX_BODY_TEMPLATE_LENGTH\n\t);\n}",
    "start_line": 674,
    "end_line": 682,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "bodyTemplate"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidBodyTemplate",
    "component_id": "src.features.hooks.types.isValidBodyTemplate"
  },
  "src.features.hooks.types.isValidIssueNumber": {
    "id": "src.features.hooks.types.isValidIssueNumber",
    "name": "isValidIssueNumber",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.GitHubOperation"
    ],
    "source_code": "function isValidIssueNumber(\n\toperation: GitHubOperation,\n\tissueNumber: unknown\n): boolean {\n\tconst requiresIssueNumber =\n\t\toperation === \"close-issue\" || operation === \"add-comment\";\n\tif (!requiresIssueNumber) {\n\t\treturn true;\n\t}\n\treturn typeof issueNumber === \"number\" && issueNumber > 0;\n}",
    "start_line": 687,
    "end_line": 697,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operation",
      "issueNumber"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidIssueNumber",
    "component_id": "src.features.hooks.types.isValidIssueNumber"
  },
  "src.features.hooks.types.isValidGitHubParams": {
    "id": "src.features.hooks.types.isValidGitHubParams",
    "name": "isValidGitHubParams",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.isValidIssueNumber",
      "src.features.hooks.types.isValidBodyTemplate",
      "src.features.hooks.types.isValidGitHubOperation",
      "src.features.hooks.types.isValidRepository",
      "src.features.hooks.types.isValidTitleTemplate"
    ],
    "source_code": "function isValidGitHubParams(obj: unknown): obj is GitHubActionParams {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst params = obj as GitHubActionParams;\n\n\treturn (\n\t\tisValidGitHubOperation(params.operation) &&\n\t\tisValidRepository(params.repository) &&\n\t\tisValidTitleTemplate(params.operation, params.titleTemplate) &&\n\t\tisValidBodyTemplate(params.bodyTemplate) &&\n\t\tisValidIssueNumber(params.operation, params.issueNumber)\n\t);\n}",
    "start_line": 702,
    "end_line": 715,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidGitHubParams",
    "component_id": "src.features.hooks.types.isValidGitHubParams"
  },
  "src.features.hooks.types.isValidCustomParams": {
    "id": "src.features.hooks.types.isValidCustomParams",
    "name": "isValidCustomParams",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidCustomParams(obj: unknown): obj is CustomActionParams {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst params = obj as CustomActionParams;\n\n\t// Must have either agentId (preferred) or agentName (legacy)\n\tconst hasAgentId =\n\t\ttypeof params.agentId === \"string\" && params.agentId.length > 0;\n\tconst hasAgentName =\n\t\ttypeof params.agentName === \"string\" && params.agentName.length > 0;\n\n\tif (!(hasAgentId || hasAgentName)) {\n\t\treturn false;\n\t}\n\n\t// Validate agentName if present (legacy format without prefix)\n\tif (\n\t\thasAgentName &&\n\t\t(params.agentName!.length > MAX_AGENT_NAME_LENGTH ||\n\t\t\t!AGENT_NAME_PATTERN.test(params.agentName!))\n\t) {\n\t\treturn false;\n\t}\n\n\t// Validate arguments if present\n\tif (\n\t\tparams.arguments !== undefined &&\n\t\t(typeof params.arguments !== \"string\" ||\n\t\t\tparams.arguments.length > MAX_ARGUMENTS_LENGTH)\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "start_line": 720,
    "end_line": 755,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidCustomParams",
    "component_id": "src.features.hooks.types.isValidCustomParams"
  },
  "src.features.hooks.types.isValidTriggerEvent": {
    "id": "src.features.hooks.types.isValidTriggerEvent",
    "name": "isValidTriggerEvent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidTriggerEvent(obj: unknown): obj is TriggerEvent {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst event = obj as TriggerEvent;\n\n\tconst validAgents: string[] = [\"speckit\", \"openspec\"];\n\n\treturn (\n\t\ttypeof event.agent === \"string\" &&\n\t\tvalidAgents.includes(event.agent) &&\n\t\ttypeof event.operation === \"string\" &&\n\t\tSUPPORTED_SPECKIT_OPERATIONS.includes(event.operation as OperationType) &&\n\t\ttypeof event.timestamp === \"number\" &&\n\t\tevent.timestamp > 0\n\t);\n}",
    "start_line": 760,
    "end_line": 776,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidTriggerEvent",
    "component_id": "src.features.hooks.types.isValidTriggerEvent"
  },
  "src.features.hooks.types.isValidMCPParams": {
    "id": "src.features.hooks.types.isValidMCPParams",
    "name": "isValidMCPParams",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidMCPParams(obj: unknown): obj is MCPActionParams {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst params = obj as MCPActionParams;\n\n\t// New structure: requires prompt and selectedTools\n\tconst hasNewStructure =\n\t\ttypeof params.prompt === \"string\" &&\n\t\tparams.prompt.length > 0 &&\n\t\tArray.isArray(params.selectedTools) &&\n\t\tparams.selectedTools.length > 0 &&\n\t\tparams.selectedTools.every(isValidSelectedMCPTool);\n\n\t// Legacy structure: requires serverId and toolName\n\tconst hasLegacyStructure =\n\t\ttypeof params.serverId === \"string\" &&\n\t\tparams.serverId.length > 0 &&\n\t\ttypeof params.toolName === \"string\" &&\n\t\tparams.toolName.length > 0;\n\n\t// Accept either new or legacy structure\n\tconst hasValidStructure = hasNewStructure || hasLegacyStructure;\n\n\t// Validate optional fields\n\tconst hasValidOptionalFields =\n\t\t(params.modelId === undefined || typeof params.modelId === \"string\") &&\n\t\t(params.parameterMappings === undefined ||\n\t\t\t(Array.isArray(params.parameterMappings) &&\n\t\t\t\tparams.parameterMappings.every(isValidParameterMapping))) &&\n\t\t(params.timeout === undefined ||\n\t\t\t(typeof params.timeout === \"number\" &&\n\t\t\t\tparams.timeout >= MCP_MIN_TIMEOUT &&\n\t\t\t\tparams.timeout <= MCP_MAX_TIMEOUT));\n\n\treturn hasValidStructure && hasValidOptionalFields;\n}",
    "start_line": 781,
    "end_line": 817,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidMCPParams",
    "component_id": "src.features.hooks.types.isValidMCPParams"
  },
  "src.features.hooks.types.isValidSelectedMCPTool": {
    "id": "src.features.hooks.types.isValidSelectedMCPTool",
    "name": "isValidSelectedMCPTool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidSelectedMCPTool(obj: unknown): obj is SelectedMCPTool {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst tool = obj as SelectedMCPTool;\n\n\treturn (\n\t\ttypeof tool.serverId === \"string\" &&\n\t\ttool.serverId.length > 0 &&\n\t\ttypeof tool.serverName === \"string\" &&\n\t\ttool.serverName.length > 0 &&\n\t\ttypeof tool.toolName === \"string\" &&\n\t\ttool.toolName.length > 0 &&\n\t\ttypeof tool.toolDisplayName === \"string\" &&\n\t\ttool.toolDisplayName.length > 0\n\t);\n}",
    "start_line": 822,
    "end_line": 838,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidSelectedMCPTool",
    "component_id": "src.features.hooks.types.isValidSelectedMCPTool"
  },
  "src.features.hooks.types.isValidParameterMapping": {
    "id": "src.features.hooks.types.isValidParameterMapping",
    "name": "isValidParameterMapping",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidParameterMapping(obj: unknown): obj is ParameterMapping {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst mapping = obj as ParameterMapping;\n\n\tconst validSources = [\"context\", \"literal\", \"template\"];\n\n\treturn (\n\t\ttypeof mapping.toolParam === \"string\" &&\n\t\tmapping.toolParam.length > 0 &&\n\t\ttypeof mapping.source === \"string\" &&\n\t\tvalidSources.includes(mapping.source) &&\n\t\ttypeof mapping.value === \"string\"\n\t);\n}",
    "start_line": 843,
    "end_line": 858,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidParameterMapping",
    "component_id": "src.features.hooks.types.isValidParameterMapping"
  },
  "src.features.hooks.types.isValidMCPServer": {
    "id": "src.features.hooks.types.isValidMCPServer",
    "name": "isValidMCPServer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [
      "src.features.hooks.types.ServerStatus"
    ],
    "source_code": "function isValidMCPServer(obj: unknown): obj is MCPServer {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst server = obj as MCPServer;\n\n\tconst validStatuses: ServerStatus[] = [\"available\", \"unavailable\", \"unknown\"];\n\n\treturn (\n\t\ttypeof server.id === \"string\" &&\n\t\tserver.id.length > 0 &&\n\t\ttypeof server.name === \"string\" &&\n\t\tserver.name.length > 0 &&\n\t\tserver.name.length <= MAX_SERVER_NAME_LENGTH &&\n\t\ttypeof server.status === \"string\" &&\n\t\tvalidStatuses.includes(server.status) &&\n\t\tArray.isArray(server.tools) &&\n\t\ttypeof server.lastDiscovered === \"number\" &&\n\t\tserver.lastDiscovered > 0\n\t);\n}",
    "start_line": 863,
    "end_line": 883,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidMCPServer",
    "component_id": "src.features.hooks.types.isValidMCPServer"
  },
  "src.features.hooks.types.isValidMCPTool": {
    "id": "src.features.hooks.types.isValidMCPTool",
    "name": "isValidMCPTool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/hooks/types.ts",
    "relative_path": "src/features/hooks/types.ts",
    "depends_on": [],
    "source_code": "function isValidMCPTool(obj: unknown): obj is MCPTool {\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\treturn false;\n\t}\n\tconst tool = obj as MCPTool;\n\n\treturn (\n\t\ttypeof tool.name === \"string\" &&\n\t\ttool.name.length > 0 &&\n\t\tTOOL_NAME_PATTERN.test(tool.name) &&\n\t\ttypeof tool.displayName === \"string\" &&\n\t\ttool.displayName.length > 0 &&\n\t\ttool.displayName.length <= MAX_TOOL_NAME_LENGTH &&\n\t\ttypeof tool.description === \"string\" &&\n\t\ttypeof tool.inputSchema === \"object\" &&\n\t\ttool.inputSchema !== null &&\n\t\ttypeof tool.serverId === \"string\" &&\n\t\ttool.serverId.length > 0\n\t);\n}",
    "start_line": 888,
    "end_line": 907,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidMCPTool",
    "component_id": "src.features.hooks.types.isValidMCPTool"
  },
  "src.features.spec.create-spec-input-controller.CreateSpecInputControllerDependencies": {
    "id": "src.features.spec.create-spec-input-controller.CreateSpecInputControllerDependencies",
    "name": "CreateSpecInputControllerDependencies",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [
      "src.utils.config-manager.ConfigManager",
      "src.constants.SpecSystemMode",
      "src.services.prompt-loader.PromptLoader"
    ],
    "source_code": "interface CreateSpecInputControllerDependencies {\n\tcontext: ExtensionContext;\n\tconfigManager: ConfigManager;\n\tpromptLoader: PromptLoader;\n\toutputChannel: OutputChannel;\n\tactiveSystem: SpecSystemMode;\n}",
    "start_line": 23,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecInputControllerDependencies",
    "component_id": "src.features.spec.create-spec-input-controller.CreateSpecInputControllerDependencies"
  },
  "src.features.spec.create-spec-input-controller.isMessageItem": {
    "id": "src.features.spec.create-spec-input-controller.isMessageItem",
    "name": "isMessageItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "isMessageItem = (value: unknown): value is MessageItem => {\n\tif (typeof value !== \"object\" || value === null) {\n\t\treturn false;\n\t}\n\n\tconst candidate = value as { title?: unknown };\n\treturn typeof candidate.title === \"string\";\n}",
    "start_line": 33,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function isMessageItem",
    "component_id": "src.features.spec.create-spec-input-controller.isMessageItem"
  },
  "src.features.spec.create-spec-input-controller.normalizeFormData": {
    "id": "src.features.spec.create-spec-input-controller.normalizeFormData",
    "name": "normalizeFormData",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecFormData"
    ],
    "source_code": "normalizeFormData = (data: CreateSpecFormData): CreateSpecFormData => ({\n\tproductContext: data.productContext ?? \"\",\n\tkeyScenarios: data.keyScenarios ?? \"\",\n\ttechnicalConstraints: data.technicalConstraints ?? \"\",\n\trelatedFiles: data.relatedFiles ?? \"\",\n\topenQuestions: data.openQuestions ?? \"\",\n})",
    "start_line": 42,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function normalizeFormData",
    "component_id": "src.features.spec.create-spec-input-controller.normalizeFormData"
  },
  "src.features.spec.create-spec-input-controller.CreateSpecInputController": {
    "id": "src.features.spec.create-spec-input-controller.CreateSpecInputController",
    "name": "CreateSpecInputController",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecExtensionMessage",
      "src.utils.config-manager.ConfigManager",
      "src.providers.hook-view-provider.webview",
      "src.features.spec.create-spec-input-controller.CreateSpecInputControllerDependencies",
      "src.features.spec.create-spec-input-controller.postFocusMessage",
      "src.features.spec.create-spec-input-controller.postInitMessage",
      "src.features.spec.types.CreateSpecWebviewMessage",
      "src.features.spec.create-spec-input-controller.handleSubmit",
      "src.constants.SpecSystemMode",
      "src.features.spec.create-spec-input-controller.getDraftState",
      "src.features.spec.spec-submission-strategy.submit",
      "ui.src.features.create-spec-view.types.CreateSpecFormData",
      "src.features.spec.create-spec-input-controller.clearDraftState",
      "ui.src.features.create-spec-view.types.CreateSpecDraftState",
      "src.features.spec.create-spec-input-controller.createPanel",
      "src.features.spec.create-spec-input-controller.saveDraftState",
      "src.services.agent-service.dispose",
      "src.features.spec.create-spec-input-controller.registerPanelListeners",
      "src.features.agents.resource-cache.get",
      "src.utils.get-webview-content.getWebviewContent",
      "src.features.spec.create-spec-input-controller.handleAutosave",
      "src.features.spec.create-spec-input-controller.handleCloseAttempt",
      "src.panels.welcome-screen-panel.postMessage",
      "src.features.spec.create-spec-input-controller.isMessageItem",
      "src.services.prompt-loader.PromptLoader",
      "src.features.spec.spec-submission-strategy.create",
      "src.features.spec.create-spec-input-controller.normalizeFormData"
    ],
    "source_code": "class CreateSpecInputController {\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly configManager: ConfigManager;\n\tprivate readonly promptLoader: PromptLoader;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly activeSystem: SpecSystemMode;\n\tprivate draft: CreateSpecDraftState | undefined;\n\tprivate panel: WebviewPanel | undefined;\n\n\tconstructor({\n\t\tcontext,\n\t\tconfigManager,\n\t\tpromptLoader,\n\t\toutputChannel,\n\t\tactiveSystem,\n\t}: CreateSpecInputControllerDependencies) {\n\t\tthis.context = context;\n\t\tthis.configManager = configManager;\n\t\tthis.promptLoader = promptLoader;\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.activeSystem = activeSystem;\n\t}\n\n\tasync open(): Promise<void> {\n\t\tif (this.panel) {\n\t\t\tthis.panel.reveal(ViewColumn.Active, false);\n\t\t\tawait this.postFocusMessage();\n\t\t\treturn;\n\t\t}\n\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.draft = this.getDraftState();\n\n\t\tthis.panel = this.createPanel();\n\t\tif (!this.panel) {\n\t\t\twindow.showErrorMessage(\"Unable to open Create Spec dialog\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.registerPanelListeners(this.panel);\n\t\tthis.panel.webview.html = getWebviewContent(\n\t\t\tthis.panel.webview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"create-spec\"\n\t\t);\n\t\tawait this.postInitMessage();\n\t}\n\n\tprivate createPanel(): WebviewPanel | undefined {\n\t\tconst resourceRoots = [\n\t\t\tUri.joinPath(this.context.extensionUri, \"dist\", \"webview\"),\n\t\t\tUri.joinPath(this.context.extensionUri, \"dist\", \"webview\", \"app\"),\n\t\t];\n\n\t\ttry {\n\t\t\treturn window.createWebviewPanel(\n\t\t\t\t\"openspec.createSpecDialog\",\n\t\t\t\t\"Create New Spec\",\n\t\t\t\t{\n\t\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\t\tpreserveFocus: false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tenableScripts: true,\n\t\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\t\tlocalResourceRoots: resourceRoots,\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CreateSpecInputController] Failed to open modal panel: ${error}`\n\t\t\t);\n\t\t\ttry {\n\t\t\t\treturn window.createWebviewPanel(\n\t\t\t\t\t\"openspec.createSpecPanel\",\n\t\t\t\t\t\"Create New Spec\",\n\t\t\t\t\tViewColumn.Active,\n\t\t\t\t\t{\n\t\t\t\t\t\tenableScripts: true,\n\t\t\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\t\t\tlocalResourceRoots: resourceRoots,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} catch (fallbackError) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CreateSpecInputController] Fallback panel creation failed: ${fallbackError}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate registerPanelListeners(panel: WebviewPanel): void {\n\t\tpanel.onDidDispose(() => {\n\t\t\tthis.panel = undefined;\n\t\t});\n\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\tasync (message: CreateSpecWebviewMessage) => {\n\t\t\t\tif (message.type === \"create-spec/submit\") {\n\t\t\t\t\tawait this.handleSubmit(message.payload);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.type === \"create-spec/autosave\") {\n\t\t\t\t\tawait this.handleAutosave(message.payload);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.type === \"create-spec/close-attempt\") {\n\t\t\t\t\tawait this.handleCloseAttempt(message.payload.hasDirtyChanges);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.type === \"create-spec/cancel\") {\n\t\t\t\t\tpanel.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate async postInitMessage(): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst message: CreateSpecExtensionMessage = {\n\t\t\ttype: \"create-spec/init\",\n\t\t\tpayload: {\n\t\t\t\tdraft: this.draft,\n\t\t\t\tshouldFocusPrimaryField: true,\n\t\t\t},\n\t\t};\n\n\t\tawait this.panel.webview.postMessage(message);\n\t}\n\n\tprivate async postFocusMessage(): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst message: CreateSpecExtensionMessage = {\n\t\t\ttype: \"create-spec/focus\",\n\t\t};\n\n\t\tawait this.panel.webview.postMessage(message);\n\t}\n\n\tprivate async handleSubmit(data: CreateSpecFormData): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst sanitizedContext = data.productContext?.trim();\n\t\tif (!sanitizedContext) {\n\t\t\tawait this.panel.webview.postMessage({\n\t\t\t\ttype: \"create-spec/submit:error\",\n\t\t\t\tpayload: { message: \"Product Context is required.\" },\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst normalized = normalizeFormData({\n\t\t\t...data,\n\t\t\tproductContext: sanitizedContext,\n\t\t});\n\n\t\ttry {\n\t\t\tconst strategy = SpecSubmissionStrategyFactory.create(this.activeSystem);\n\t\t\tawait strategy.submit(normalized);\n\n\t\t\tawait this.clearDraftState();\n\n\t\t\tawait this.panel.webview.postMessage({\n\t\t\t\ttype: \"create-spec/submit:success\",\n\t\t\t});\n\t\t\tthis.panel.dispose();\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CreateSpecInputController] Failed to submit spec request: ${message}`\n\t\t\t);\n\n\t\t\tawait this.panel.webview.postMessage({\n\t\t\t\ttype: \"create-spec/submit:error\",\n\t\t\t\tpayload: { message },\n\t\t\t});\n\t\t\twindow.showErrorMessage(`Failed to create spec prompt: ${message}`);\n\t\t}\n\t}\n\n\tprivate async handleAutosave(data: CreateSpecFormData): Promise<void> {\n\t\tthis.draft = {\n\t\t\tformData: normalizeFormData(data),\n\t\t\tlastUpdated: Date.now(),\n\t\t};\n\t\tawait this.saveDraftState(this.draft);\n\t}\n\n\tprivate async handleCloseAttempt(hasDirtyChanges: boolean): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasDirtyChanges) {\n\t\t\tawait this.clearDraftState();\n\t\t\tthis.panel.dispose();\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = await window.showWarningMessage(\n\t\t\t\"You have unsaved spec input. Close the dialog and discard your changes?\",\n\t\t\t{\n\t\t\t\tmodal: true,\n\t\t\t\tdetail: \"Choose Cancel to resume editing and keep your current input.\",\n\t\t\t},\n\t\t\t\"Discard\"\n\t\t);\n\n\t\tconst selection = isMessageItem(result) ? result.title : result;\n\t\tconst shouldClose = selection === \"Discard\";\n\n\t\tif (shouldClose) {\n\t\t\tawait this.clearDraftState();\n\t\t\tthis.panel.dispose();\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.panel.webview.postMessage({\n\t\t\ttype: \"create-spec/confirm-close\",\n\t\t\tpayload: { shouldClose: false },\n\t\t});\n\t}\n\n\tprivate getDraftState(): CreateSpecDraftState | undefined {\n\t\treturn this.context.workspaceState.get<CreateSpecDraftState>(\n\t\t\tCREATE_SPEC_DRAFT_STATE_KEY\n\t\t);\n\t}\n\n\tprivate async saveDraftState(state: CreateSpecDraftState): Promise<void> {\n\t\tawait this.context.workspaceState.update(\n\t\t\tCREATE_SPEC_DRAFT_STATE_KEY,\n\t\t\tstate\n\t\t);\n\t}\n\n\tprivate async clearDraftState(): Promise<void> {\n\t\tthis.draft = undefined;\n\t\tawait this.context.workspaceState.update(\n\t\t\tCREATE_SPEC_DRAFT_STATE_KEY,\n\t\t\tundefined\n\t\t);\n\t}\n}",
    "start_line": 50,
    "end_line": 310,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CreateSpecInputController",
    "component_id": "src.features.spec.create-spec-input-controller.CreateSpecInputController"
  },
  "src.features.spec.create-spec-input-controller.open": {
    "id": "src.features.spec.create-spec-input-controller.open",
    "name": "open",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "async open(): Promise<void> {\n\t\tif (this.panel) {\n\t\t\tthis.panel.reveal(ViewColumn.Active, false);\n\t\t\tawait this.postFocusMessage();\n\t\t\treturn;\n\t\t}\n\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.draft = this.getDraftState();\n\n\t\tthis.panel = this.createPanel();\n\t\tif (!this.panel) {\n\t\t\twindow.showErrorMessage(\"Unable to open Create Spec dialog\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.registerPanelListeners(this.panel);\n\t\tthis.panel.webview.html = getWebviewContent(\n\t\t\tthis.panel.webview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"create-spec\"\n\t\t);\n\t\tawait this.postInitMessage();\n\t}",
    "start_line": 73,
    "end_line": 101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method open",
    "component_id": "src.features.spec.create-spec-input-controller.open"
  },
  "src.features.spec.create-spec-input-controller.createPanel": {
    "id": "src.features.spec.create-spec-input-controller.createPanel",
    "name": "createPanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private createPanel(): WebviewPanel | undefined {\n\t\tconst resourceRoots = [\n\t\t\tUri.joinPath(this.context.extensionUri, \"dist\", \"webview\"),\n\t\t\tUri.joinPath(this.context.extensionUri, \"dist\", \"webview\", \"app\"),\n\t\t];\n\n\t\ttry {\n\t\t\treturn window.createWebviewPanel(\n\t\t\t\t\"openspec.createSpecDialog\",\n\t\t\t\t\"Create New Spec\",\n\t\t\t\t{\n\t\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\t\tpreserveFocus: false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tenableScripts: true,\n\t\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\t\tlocalResourceRoots: resourceRoots,\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CreateSpecInputController] Failed to open modal panel: ${error}`\n\t\t\t);\n\t\t\ttry {\n\t\t\t\treturn window.createWebviewPanel(\n\t\t\t\t\t\"openspec.createSpecPanel\",\n\t\t\t\t\t\"Create New Spec\",\n\t\t\t\t\tViewColumn.Active,\n\t\t\t\t\t{\n\t\t\t\t\t\tenableScripts: true,\n\t\t\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\t\t\tlocalResourceRoots: resourceRoots,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} catch (fallbackError) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[CreateSpecInputController] Fallback panel creation failed: ${fallbackError}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 103,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createPanel",
    "component_id": "src.features.spec.create-spec-input-controller.createPanel"
  },
  "src.features.spec.create-spec-input-controller.registerPanelListeners": {
    "id": "src.features.spec.create-spec-input-controller.registerPanelListeners",
    "name": "registerPanelListeners",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private registerPanelListeners(panel: WebviewPanel): void {\n\t\tpanel.onDidDispose(() => {\n\t\t\tthis.panel = undefined;\n\t\t});\n\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\tasync (message: CreateSpecWebviewMessage) => {\n\t\t\t\tif (message.type === \"create-spec/submit\") {\n\t\t\t\t\tawait this.handleSubmit(message.payload);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.type === \"create-spec/autosave\") {\n\t\t\t\t\tawait this.handleAutosave(message.payload);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.type === \"create-spec/close-attempt\") {\n\t\t\t\t\tawait this.handleCloseAttempt(message.payload.hasDirtyChanges);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.type === \"create-spec/cancel\") {\n\t\t\t\t\tpanel.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}",
    "start_line": 147,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "panel"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method registerPanelListeners",
    "component_id": "src.features.spec.create-spec-input-controller.registerPanelListeners"
  },
  "src.features.spec.create-spec-input-controller.postInitMessage": {
    "id": "src.features.spec.create-spec-input-controller.postInitMessage",
    "name": "postInitMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async postInitMessage(): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst message: CreateSpecExtensionMessage = {\n\t\t\ttype: \"create-spec/init\",\n\t\t\tpayload: {\n\t\t\t\tdraft: this.draft,\n\t\t\t\tshouldFocusPrimaryField: true,\n\t\t\t},\n\t\t};\n\n\t\tawait this.panel.webview.postMessage(message);\n\t}",
    "start_line": 176,
    "end_line": 190,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method postInitMessage",
    "component_id": "src.features.spec.create-spec-input-controller.postInitMessage"
  },
  "src.features.spec.create-spec-input-controller.postFocusMessage": {
    "id": "src.features.spec.create-spec-input-controller.postFocusMessage",
    "name": "postFocusMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async postFocusMessage(): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst message: CreateSpecExtensionMessage = {\n\t\t\ttype: \"create-spec/focus\",\n\t\t};\n\n\t\tawait this.panel.webview.postMessage(message);\n\t}",
    "start_line": 192,
    "end_line": 202,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method postFocusMessage",
    "component_id": "src.features.spec.create-spec-input-controller.postFocusMessage"
  },
  "src.features.spec.create-spec-input-controller.handleSubmit": {
    "id": "src.features.spec.create-spec-input-controller.handleSubmit",
    "name": "handleSubmit",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async handleSubmit(data: CreateSpecFormData): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst sanitizedContext = data.productContext?.trim();\n\t\tif (!sanitizedContext) {\n\t\t\tawait this.panel.webview.postMessage({\n\t\t\t\ttype: \"create-spec/submit:error\",\n\t\t\t\tpayload: { message: \"Product Context is required.\" },\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst normalized = normalizeFormData({\n\t\t\t...data,\n\t\t\tproductContext: sanitizedContext,\n\t\t});\n\n\t\ttry {\n\t\t\tconst strategy = SpecSubmissionStrategyFactory.create(this.activeSystem);\n\t\t\tawait strategy.submit(normalized);\n\n\t\t\tawait this.clearDraftState();\n\n\t\t\tawait this.panel.webview.postMessage({\n\t\t\t\ttype: \"create-spec/submit:success\",\n\t\t\t});\n\t\t\tthis.panel.dispose();\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[CreateSpecInputController] Failed to submit spec request: ${message}`\n\t\t\t);\n\n\t\t\tawait this.panel.webview.postMessage({\n\t\t\t\ttype: \"create-spec/submit:error\",\n\t\t\t\tpayload: { message },\n\t\t\t});\n\t\t\twindow.showErrorMessage(`Failed to create spec prompt: ${message}`);\n\t\t}\n\t}",
    "start_line": 204,
    "end_line": 245,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleSubmit",
    "component_id": "src.features.spec.create-spec-input-controller.handleSubmit"
  },
  "src.features.spec.create-spec-input-controller.handleAutosave": {
    "id": "src.features.spec.create-spec-input-controller.handleAutosave",
    "name": "handleAutosave",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async handleAutosave(data: CreateSpecFormData): Promise<void> {\n\t\tthis.draft = {\n\t\t\tformData: normalizeFormData(data),\n\t\t\tlastUpdated: Date.now(),\n\t\t};\n\t\tawait this.saveDraftState(this.draft);\n\t}",
    "start_line": 247,
    "end_line": 253,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleAutosave",
    "component_id": "src.features.spec.create-spec-input-controller.handleAutosave"
  },
  "src.features.spec.create-spec-input-controller.handleCloseAttempt": {
    "id": "src.features.spec.create-spec-input-controller.handleCloseAttempt",
    "name": "handleCloseAttempt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async handleCloseAttempt(hasDirtyChanges: boolean): Promise<void> {\n\t\tif (!this.panel) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasDirtyChanges) {\n\t\t\tawait this.clearDraftState();\n\t\t\tthis.panel.dispose();\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = await window.showWarningMessage(\n\t\t\t\"You have unsaved spec input. Close the dialog and discard your changes?\",\n\t\t\t{\n\t\t\t\tmodal: true,\n\t\t\t\tdetail: \"Choose Cancel to resume editing and keep your current input.\",\n\t\t\t},\n\t\t\t\"Discard\"\n\t\t);\n\n\t\tconst selection = isMessageItem(result) ? result.title : result;\n\t\tconst shouldClose = selection === \"Discard\";\n\n\t\tif (shouldClose) {\n\t\t\tawait this.clearDraftState();\n\t\t\tthis.panel.dispose();\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.panel.webview.postMessage({\n\t\t\ttype: \"create-spec/confirm-close\",\n\t\t\tpayload: { shouldClose: false },\n\t\t});\n\t}",
    "start_line": 255,
    "end_line": 288,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hasDirtyChanges"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleCloseAttempt",
    "component_id": "src.features.spec.create-spec-input-controller.handleCloseAttempt"
  },
  "src.features.spec.create-spec-input-controller.getDraftState": {
    "id": "src.features.spec.create-spec-input-controller.getDraftState",
    "name": "getDraftState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private getDraftState(): CreateSpecDraftState | undefined {\n\t\treturn this.context.workspaceState.get<CreateSpecDraftState>(\n\t\t\tCREATE_SPEC_DRAFT_STATE_KEY\n\t\t);\n\t}",
    "start_line": 290,
    "end_line": 294,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getDraftState",
    "component_id": "src.features.spec.create-spec-input-controller.getDraftState"
  },
  "src.features.spec.create-spec-input-controller.saveDraftState": {
    "id": "src.features.spec.create-spec-input-controller.saveDraftState",
    "name": "saveDraftState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async saveDraftState(state: CreateSpecDraftState): Promise<void> {\n\t\tawait this.context.workspaceState.update(\n\t\t\tCREATE_SPEC_DRAFT_STATE_KEY,\n\t\t\tstate\n\t\t);\n\t}",
    "start_line": 296,
    "end_line": 301,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method saveDraftState",
    "component_id": "src.features.spec.create-spec-input-controller.saveDraftState"
  },
  "src.features.spec.create-spec-input-controller.clearDraftState": {
    "id": "src.features.spec.create-spec-input-controller.clearDraftState",
    "name": "clearDraftState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/create-spec-input-controller.ts",
    "relative_path": "src/features/spec/create-spec-input-controller.ts",
    "depends_on": [],
    "source_code": "private async clearDraftState(): Promise<void> {\n\t\tthis.draft = undefined;\n\t\tawait this.context.workspaceState.update(\n\t\t\tCREATE_SPEC_DRAFT_STATE_KEY,\n\t\t\tundefined\n\t\t);\n\t}",
    "start_line": 303,
    "end_line": 309,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method clearDraftState",
    "component_id": "src.features.spec.create-spec-input-controller.clearDraftState"
  },
  "src.features.spec.review-flow.change-requests-service.DuplicateChangeRequestError": {
    "id": "src.features.spec.review-flow.change-requests-service.DuplicateChangeRequestError",
    "name": "DuplicateChangeRequestError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/change-requests-service.ts",
    "relative_path": "src/features/spec/review-flow/change-requests-service.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest"
    ],
    "source_code": "class DuplicateChangeRequestError extends Error {\n\tduplicate?: ChangeRequest;\n\n\tconstructor(message: string, duplicate?: ChangeRequest) {\n\t\tsuper(message);\n\t\tthis.name = \"DuplicateChangeRequestError\";\n\t\tthis.duplicate = duplicate;\n\t}\n}",
    "start_line": 16,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DuplicateChangeRequestError",
    "component_id": "src.features.spec.review-flow.change-requests-service.DuplicateChangeRequestError"
  },
  "src.features.spec.review-flow.change-requests-service.ChangeRequestInput": {
    "id": "src.features.spec.review-flow.change-requests-service.ChangeRequestInput",
    "name": "ChangeRequestInput",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/change-requests-service.ts",
    "relative_path": "src/features/spec/review-flow/change-requests-service.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest"
    ],
    "source_code": "interface ChangeRequestInput {\n\ttitle: string;\n\tdescription: string;\n\tseverity: ChangeRequest[\"severity\"];\n\tsubmitter: string;\n\tnotes?: string;\n}",
    "start_line": 26,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChangeRequestInput",
    "component_id": "src.features.spec.review-flow.change-requests-service.ChangeRequestInput"
  },
  "src.features.spec.review-flow.change-requests-service.createChangeRequest": {
    "id": "src.features.spec.review-flow.change-requests-service.createChangeRequest",
    "name": "createChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/change-requests-service.ts",
    "relative_path": "src/features/spec/review-flow/change-requests-service.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.addChangeRequest",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.change-requests-service.ChangeRequestInput",
      "src.features.spec.review-flow.change-requests-service.DuplicateChangeRequestError",
      "src.features.spec.review-flow.telemetry.logChangeRequestCreated",
      "src.features.spec.review-flow.duplicate-guard.validateUniqueChangeRequest"
    ],
    "source_code": "function createChangeRequest(\n\tspecId: string,\n\tinput: ChangeRequestInput\n): { spec: Specification; changeRequest: ChangeRequest } {\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\tthrow new Error(`Spec not found: ${specId}`);\n\t}\n\n\tconst existingChangeRequests = spec.changeRequests ?? [];\n\tconst { isValid, duplicate } = validateUniqueChangeRequest(\n\t\tspecId,\n\t\tinput.title,\n\t\texistingChangeRequests\n\t);\n\n\tif (!isValid) {\n\t\tthrow new DuplicateChangeRequestError(\n\t\t\t\"Duplicate change request title\",\n\t\t\tduplicate\n\t\t);\n\t}\n\n\tconst now = new Date();\n\tconst changeRequest: ChangeRequest = {\n\t\tid: randomUUID(),\n\t\tspecId,\n\t\ttitle: input.title.trim(),\n\t\tdescription: input.description.trim(),\n\t\tseverity: input.severity,\n\t\tstatus: \"open\",\n\t\ttasks: [],\n\t\tsubmitter: input.submitter,\n\t\tcreatedAt: now,\n\t\tupdatedAt: now,\n\t\tsentToTasksAt: null,\n\t\tarchivalBlocker: true,\n\t\tnotes: input.notes?.trim() || undefined,\n\t};\n\n\tconst updatedSpec = addChangeRequest(specId, changeRequest);\n\tif (!updatedSpec) {\n\t\tthrow new Error(`Failed to add change request to spec: ${specId}`);\n\t}\n\n\tlogChangeRequestCreated({\n\t\tspecId,\n\t\tchangeRequestId: changeRequest.id,\n\t\tseverity: changeRequest.severity,\n\t\ttitle: changeRequest.title,\n\t\tsubmitter: changeRequest.submitter,\n\t});\n\n\treturn { spec: updatedSpec, changeRequest };\n}",
    "start_line": 34,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "input"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createChangeRequest",
    "component_id": "src.features.spec.review-flow.change-requests-service.createChangeRequest"
  },
  "src.features.spec.review-flow.change-requests-service.hasDuplicateChangeRequest": {
    "id": "src.features.spec.review-flow.change-requests-service.hasDuplicateChangeRequest",
    "name": "hasDuplicateChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/change-requests-service.ts",
    "relative_path": "src/features/spec/review-flow/change-requests-service.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.duplicate-guard.validateUniqueChangeRequest"
    ],
    "source_code": "function hasDuplicateChangeRequest(\n\tspecId: string,\n\ttitle: string\n): boolean {\n\tconst spec = getSpecState(specId);\n\tif (!spec?.changeRequests) {\n\t\treturn false;\n\t}\n\n\tconst { isValid } = validateUniqueChangeRequest(\n\t\tspecId,\n\t\ttitle,\n\t\tspec.changeRequests\n\t);\n\treturn !isValid;\n}",
    "start_line": 96,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "title"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function hasDuplicateChangeRequest",
    "component_id": "src.features.spec.review-flow.change-requests-service.hasDuplicateChangeRequest"
  },
  "src.features.spec.review-flow.change-requests-service.getChangeRequestsForSpec": {
    "id": "src.features.spec.review-flow.change-requests-service.getChangeRequestsForSpec",
    "name": "getChangeRequestsForSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/change-requests-service.ts",
    "relative_path": "src/features/spec/review-flow/change-requests-service.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.state.getSpecState"
    ],
    "source_code": "function getChangeRequestsForSpec(specId: string): ChangeRequest[] {\n\tconst spec = getSpecState(specId);\n\treturn spec?.changeRequests ?? [];\n}",
    "start_line": 118,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getChangeRequestsForSpec",
    "component_id": "src.features.spec.review-flow.change-requests-service.getChangeRequestsForSpec"
  },
  "src.features.spec.review-flow.change-requests-service.__testInitSpec": {
    "id": "src.features.spec.review-flow.change-requests-service.__testInitSpec",
    "name": "__testInitSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/change-requests-service.ts",
    "relative_path": "src/features/spec/review-flow/change-requests-service.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function __testInitSpec(spec: Specification): void {\n\tinitSpec(spec);\n}",
    "start_line": 126,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function __testInitSpec",
    "component_id": "src.features.spec.review-flow.change-requests-service.__testInitSpec"
  },
  "src.features.spec.review-flow.commands.dispatch-to-tasks-command.registerDispatchToTasksCommand": {
    "id": "src.features.spec.review-flow.commands.dispatch-to-tasks-command.registerDispatchToTasksCommand",
    "name": "registerDispatchToTasksCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/dispatch-to-tasks-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/dispatch-to-tasks-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.commands.dispatch-to-tasks-command.dispatchToTasksHandler"
    ],
    "source_code": "function registerDispatchToTasksCommand(\n\tcontext: ExtensionContext\n): void {\n\tconst command = commands.registerCommand(\n\t\tDISPATCH_TO_TASKS_COMMAND_ID,\n\t\tasync (specId: string, changeRequestId: string) => {\n\t\t\ttry {\n\t\t\t\tawait dispatchToTasksHandler(specId, changeRequestId);\n\t\t\t\twindow.showInformationMessage(\n\t\t\t\t\t\"Successfully dispatched change request to tasks\"\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tconst message =\n\t\t\t\t\terror instanceof Error ? error.message : \"Unknown error occurred\";\n\t\t\t\twindow.showErrorMessage(`Failed to dispatch to tasks: ${message}`);\n\t\t\t}\n\t\t}\n\t);\n\n\tcontext.subscriptions.push(command);\n}",
    "start_line": 28,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function registerDispatchToTasksCommand",
    "component_id": "src.features.spec.review-flow.commands.dispatch-to-tasks-command.registerDispatchToTasksCommand"
  },
  "src.features.spec.review-flow.commands.dispatch-to-tasks-command.dispatchToTasksHandler": {
    "id": "src.features.spec.review-flow.commands.dispatch-to-tasks-command.dispatchToTasksHandler",
    "name": "dispatchToTasksHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/dispatch-to-tasks-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/dispatch-to-tasks-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.tasks-dispatch.dispatchToTasksPrompt",
      "src.features.spec.review-flow.tasks-dispatch.buildTasksPromptPayload",
      "src.features.spec.review-flow.tasks-dispatch.convertResponseToTaskLinks",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.updateChangeRequestStatus",
      "src.features.spec.review-flow.state.attachTasksToChangeRequest"
    ],
    "source_code": "async function dispatchToTasksHandler(\n\tspecId: string,\n\tchangeRequestId: string\n): Promise<void> {\n\t// Get spec and change request\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\tthrow new Error(`Spec not found: ${specId}`);\n\t}\n\n\tconst changeRequest = spec.changeRequests?.find(\n\t\t(cr) => cr.id === changeRequestId\n\t);\n\tif (!changeRequest) {\n\t\tthrow new Error(`Change request not found: ${changeRequestId}`);\n\t}\n\n\t// Verify change request can be dispatched\n\tif (changeRequest.status !== \"open\" && changeRequest.status !== \"blocked\") {\n\t\tthrow new Error(\n\t\t\t`Change request cannot be dispatched from status: ${changeRequest.status}`\n\t\t);\n\t}\n\n\t// Show progress\n\tawait window.withProgress(\n\t\t{\n\t\t\tlocation: ProgressLocation.Notification,\n\t\t\ttitle: \"Dispatching to tasks prompt...\",\n\t\t\tcancellable: false,\n\t\t},\n\t\tasync (progress) => {\n\t\t\tprogress.report({ increment: 0 });\n\n\t\t\t// Call tasks prompt API\n\t\t\tconst payload = buildTasksPromptPayload(spec, changeRequest);\n\t\t\tconst response = await dispatchToTasksPrompt(payload);\n\n\t\t\tprogress.report({ increment: 50 });\n\n\t\t\tif (!response.success) {\n\t\t\t\t// Mark as blocked if dispatch failed\n\t\t\t\tupdateChangeRequestStatus(specId, changeRequestId, \"blocked\");\n\t\t\t\tthrow new Error(response.message || \"Tasks prompt service unavailable\");\n\t\t\t}\n\n\t\t\t// Convert response to task links\n\t\t\tconst taskLinks = convertResponseToTaskLinks(response);\n\n\t\t\tprogress.report({ increment: 75 });\n\n\t\t\t// Attach tasks to change request\n\t\t\tconst updatedCR = attachTasksToChangeRequest(\n\t\t\t\tspecId,\n\t\t\t\tchangeRequestId,\n\t\t\t\ttaskLinks\n\t\t\t);\n\n\t\t\tif (!updatedCR) {\n\t\t\t\tthrow new Error(\"Failed to attach tasks to change request\");\n\t\t\t}\n\n\t\t\tprogress.report({ increment: 100 });\n\t\t}\n\t);\n}",
    "start_line": 53,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function dispatchToTasksHandler",
    "component_id": "src.features.spec.review-flow.commands.dispatch-to-tasks-command.dispatchToTasksHandler"
  },
  "src.features.spec.review-flow.commands.dispatch-to-tasks-command.retryDispatchHandler": {
    "id": "src.features.spec.review-flow.commands.dispatch-to-tasks-command.retryDispatchHandler",
    "name": "retryDispatchHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/dispatch-to-tasks-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/dispatch-to-tasks-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.commands.dispatch-to-tasks-command.dispatchToTasksHandler"
    ],
    "source_code": "function retryDispatchHandler(\n\tspecId: string,\n\tchangeRequestId: string\n): Promise<void> {\n\t// Retry uses the same logic as initial dispatch\n\treturn dispatchToTasksHandler(specId, changeRequestId);\n}",
    "start_line": 123,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function retryDispatchHandler",
    "component_id": "src.features.spec.review-flow.commands.dispatch-to-tasks-command.retryDispatchHandler"
  },
  "src.features.spec.review-flow.commands.reopen-spec-command.handleReopenSpec": {
    "id": "src.features.spec.review-flow.commands.reopen-spec-command.handleReopenSpec",
    "name": "handleReopenSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/reopen-spec-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/reopen-spec-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.updateSpecStatus",
      "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg",
      "src.features.spec.review-flow.state.getSpecState"
    ],
    "source_code": "async function handleReopenSpec(\n\tspecArg: unknown,\n\trefreshCallback?: () => void\n): Promise<void> {\n\tconst specId = resolveSpecIdFromCommandArg(specArg);\n\tif (!specId) {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Spec not found. Please refresh and try again.\"\n\t\t);\n\t\treturn;\n\t}\n\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Spec not found. Please refresh and try again.\"\n\t\t);\n\t\treturn;\n\t}\n\n\tif (spec.status !== \"review\") {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Cannot reopen: spec is not in review status.\"\n\t\t);\n\t\treturn;\n\t}\n\n\tconst result = updateSpecStatus(specId, \"reopened\");\n\tif (!result) {\n\t\tawait window.showErrorMessage(\"Failed to reopen spec. Please try again.\");\n\t\treturn;\n\t}\n\n\tawait window.showInformationMessage(\n\t\t`Spec \"${result.title}\" reopened and moved to Current Specs.`\n\t);\n\n\trefreshCallback?.();\n}",
    "start_line": 12,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specArg",
      "refreshCallback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handleReopenSpec",
    "component_id": "src.features.spec.review-flow.commands.reopen-spec-command.handleReopenSpec"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.isInReviewStatus": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.isInReviewStatus",
    "name": "isInReviewStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function isInReviewStatus(spec: Specification): boolean {\n\treturn spec.status === \"review\" || spec.status === \"readyToReview\";\n}",
    "start_line": 17,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isInReviewStatus",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.isInReviewStatus"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.addStatusBlocker": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.addStatusBlocker",
    "name": "addStatusBlocker",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.commands.send-to-archived-command.isInReviewStatus",
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function addStatusBlocker(blockers: string[], spec: Specification): void {\n\tif (isInReviewStatus(spec)) {\n\t\treturn;\n\t}\n\tblockers.push(`spec status is \"${spec.status}\" (must be in review)`);\n}",
    "start_line": 21,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "blockers",
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addStatusBlocker",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.addStatusBlocker"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.addPendingTasksBlocker": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.addPendingTasksBlocker",
    "name": "addPendingTasksBlocker",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [],
    "source_code": "function addPendingTasksBlocker(\n\tblockers: string[],\n\tpendingTasks: number\n): void {\n\tif (pendingTasks <= 0) {\n\t\treturn;\n\t}\n\tblockers.push(`${pendingTasks} pending task${pendingTasks === 1 ? \"\" : \"s\"}`);\n}",
    "start_line": 28,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "blockers",
      "pendingTasks"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addPendingTasksBlocker",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.addPendingTasksBlocker"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.addPendingChecklistItemsBlocker": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.addPendingChecklistItemsBlocker",
    "name": "addPendingChecklistItemsBlocker",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [],
    "source_code": "function addPendingChecklistItemsBlocker(\n\tblockers: string[],\n\tpendingChecklistItems: number\n): void {\n\tif (pendingChecklistItems <= 0) {\n\t\treturn;\n\t}\n\tblockers.push(\n\t\t`${pendingChecklistItems} pending checklist item${pendingChecklistItems === 1 ? \"\" : \"s\"}`\n\t);\n}",
    "start_line": 38,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "blockers",
      "pendingChecklistItems"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addPendingChecklistItemsBlocker",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.addPendingChecklistItemsBlocker"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.addOpenChangeRequestsBlocker": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.addOpenChangeRequestsBlocker",
    "name": "addOpenChangeRequestsBlocker",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [],
    "source_code": "function addOpenChangeRequestsBlocker(\n\tblockers: string[],\n\topenChangeRequests: number\n): void {\n\tif (openChangeRequests <= 0) {\n\t\treturn;\n\t}\n\tblockers.push(\n\t\t`${openChangeRequests} open change request${openChangeRequests === 1 ? \"\" : \"s\"}`\n\t);\n}",
    "start_line": 50,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "blockers",
      "openChangeRequests"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addOpenChangeRequestsBlocker",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.addOpenChangeRequestsBlocker"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.addIncompleteTasksInChangeRequestsBlocker": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.addIncompleteTasksInChangeRequestsBlocker",
    "name": "addIncompleteTasksInChangeRequestsBlocker",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [],
    "source_code": "function addIncompleteTasksInChangeRequestsBlocker(\n\tblockers: string[],\n\tincompleteTasksInChangeRequests: boolean\n): void {\n\tif (!incompleteTasksInChangeRequests) {\n\t\treturn;\n\t}\n\tblockers.push(\"incomplete tasks in change requests\");\n}",
    "start_line": 62,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "blockers",
      "incompleteTasksInChangeRequests"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addIncompleteTasksInChangeRequestsBlocker",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.addIncompleteTasksInChangeRequestsBlocker"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.getBlockerMessages": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.getBlockerMessages",
    "name": "getBlockerMessages",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.commands.send-to-archived-command.addPendingTasksBlocker",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.commands.send-to-archived-command.addStatusBlocker",
      "src.features.spec.review-flow.commands.send-to-archived-command.addIncompleteTasksInChangeRequestsBlocker",
      "src.features.spec.review-flow.commands.send-to-archived-command.addPendingChecklistItemsBlocker",
      "src.features.spec.review-flow.commands.send-to-archived-command.addOpenChangeRequestsBlocker"
    ],
    "source_code": "function getBlockerMessages(spec: Specification): string[] {\n\tconst blockers: string[] = [];\n\taddStatusBlocker(blockers, spec);\n\n\tconst pendingTasks = spec.pendingTasks ?? 0;\n\taddPendingTasksBlocker(blockers, pendingTasks);\n\n\tconst pendingChecklistItems = spec.pendingChecklistItems ?? 0;\n\taddPendingChecklistItemsBlocker(blockers, pendingChecklistItems);\n\n\tconst openChangeRequests =\n\t\tspec.changeRequests?.filter((cr) => cr.status !== \"addressed\").length ?? 0;\n\taddOpenChangeRequestsBlocker(blockers, openChangeRequests);\n\n\tconst incompleteTasksInChangeRequests =\n\t\tspec.changeRequests?.some(\n\t\t\t(cr) => cr.tasks?.some((t) => t.status !== \"done\") ?? false\n\t\t) ?? false;\n\taddIncompleteTasksInChangeRequestsBlocker(\n\t\tblockers,\n\t\tincompleteTasksInChangeRequests\n\t);\n\n\treturn blockers;\n}",
    "start_line": 72,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getBlockerMessages",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.getBlockerMessages"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.handleSendToArchived": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.handleSendToArchived",
    "name": "handleSendToArchived",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.commands.send-to-archived-command.getBlockerMessages",
      "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.archiveSpec",
      "src.features.spec.review-flow.state.canArchive"
    ],
    "source_code": "async function handleSendToArchived(\n\tspecArg: unknown,\n\trefreshCallback?: () => void\n): Promise<void> {\n\tconst specId = resolveSpecIdFromCommandArg(specArg);\n\tif (!specId) {\n\t\tawait window.showErrorMessage(\"Cannot archive spec: Spec not found\");\n\t\treturn;\n\t}\n\n\tconst existingSpec = getSpecState(specId);\n\tif (!existingSpec) {\n\t\tawait window.showErrorMessage(\"Cannot archive spec: Spec not found\");\n\t\treturn;\n\t}\n\n\t// Check gating conditions\n\tif (!canArchive(specId)) {\n\t\t// Get spec to build detailed error message\n\t\tconst spec = existingSpec;\n\t\tlet blockers: string[] = [];\n\n\t\tif (spec) {\n\t\t\tblockers = getBlockerMessages(spec);\n\t\t}\n\n\t\tconst blockerMessage =\n\t\t\tblockers.length > 0\n\t\t\t\t? blockers.join(\", \")\n\t\t\t\t: \"blocked (please refresh and try again)\";\n\t\tawait window.showErrorMessage(`Cannot archive spec: ${blockerMessage}`);\n\t\treturn;\n\t}\n\n\t// Attempt to archive\n\tconst result = archiveSpec(specId);\n\n\tif (!result) {\n\t\tawait window.showErrorMessage(\"Failed to archive spec. Please try again.\");\n\t\treturn;\n\t}\n\n\t// Show success message\n\tawait window.showInformationMessage(\n\t\t`Spec \"${result.title}\" archived successfully.`\n\t);\n\n\t// Refresh the Spec Explorer view to show updated status\n\tif (refreshCallback) {\n\t\trefreshCallback();\n\t}\n}",
    "start_line": 103,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specArg",
      "refreshCallback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handleSendToArchived",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.handleSendToArchived"
  },
  "src.features.spec.review-flow.commands.send-to-archived-command.handleUnarchive": {
    "id": "src.features.spec.review-flow.commands.send-to-archived-command.handleUnarchive",
    "name": "handleUnarchive",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-archived-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg",
      "src.features.spec.review-flow.state.unarchiveSpec"
    ],
    "source_code": "async function handleUnarchive(\n\tspecArg: unknown,\n\trefreshCallback?: () => void,\n\toptions?: { initiatedBy?: string; reason?: string }\n): Promise<void> {\n\tconst specId = resolveSpecIdFromCommandArg(specArg);\n\tif (!specId) {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Spec not found. Please refresh and try again.\"\n\t\t);\n\t\treturn;\n\t}\n\n\t// Get spec to show title in messages\n\tconst spec = getSpecState(specId);\n\n\tif (!spec) {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Spec not found. Please refresh and try again.\"\n\t\t);\n\t\treturn;\n\t}\n\n\tif (spec.status !== \"archived\") {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Cannot unarchive: spec is not in archived status.\"\n\t\t);\n\t\treturn;\n\t}\n\n\t// Attempt to unarchive\n\tconst result = unarchiveSpec(specId, options);\n\n\tif (!result) {\n\t\tawait window.showErrorMessage(\n\t\t\t\"Failed to unarchive spec. Please try again.\"\n\t\t);\n\t\treturn;\n\t}\n\n\t// Show success message\n\tawait window.showInformationMessage(\n\t\t`Spec \"${result.title}\" unarchived successfully. Status: ${result.status}`\n\t);\n\n\t// Refresh the Spec Explorer view to show updated status\n\tif (refreshCallback) {\n\t\trefreshCallback();\n\t}\n}",
    "start_line": 162,
    "end_line": 211,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specArg",
      "refreshCallback",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handleUnarchive",
    "component_id": "src.features.spec.review-flow.commands.send-to-archived-command.handleUnarchive"
  },
  "src.features.spec.review-flow.commands.send-to-review-command.handleSendToReview": {
    "id": "src.features.spec.review-flow.commands.send-to-review-command.handleSendToReview",
    "name": "handleSendToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/send-to-review-command.ts",
    "relative_path": "src/features/spec/review-flow/commands/send-to-review-command.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.sendToReviewWithTrigger",
      "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg"
    ],
    "source_code": "async function handleSendToReview(\n\tspecArg: unknown,\n\trefreshCallback?: () => void\n): Promise<void> {\n\tconst specId = resolveSpecIdFromCommandArg(specArg);\n\tif (!specId) {\n\t\tawait window.showErrorMessage(\"Cannot send spec to review: Spec not found\");\n\t\treturn;\n\t}\n\n\tconst { result, blockers } = sendToReviewWithTrigger({\n\t\tspecId,\n\t\ttriggerType: \"manual\",\n\t\tinitiatedBy: \"manual-command\",\n\t});\n\n\tif (!result) {\n\t\tif (blockers.length > 0) {\n\t\t\tconst blockerMessage = blockers.join(\", \");\n\t\t\tawait window.showErrorMessage(\n\t\t\t\t`Cannot send spec to review: ${blockerMessage}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.showErrorMessage(\n\t\t\t\"Failed to send spec to review. Please try again.\"\n\t\t);\n\t\treturn;\n\t}\n\n\t// Show success message\n\tawait window.showInformationMessage(\n\t\t`Spec \"${result.title}\" sent to review successfully.`\n\t);\n\n\t// Refresh the Spec Explorer view to show updated status\n\tif (refreshCallback) {\n\t\trefreshCallback();\n\t}\n}",
    "start_line": 17,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specArg",
      "refreshCallback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handleSendToReview",
    "component_id": "src.features.spec.review-flow.commands.send-to-review-command.handleSendToReview"
  },
  "src.features.spec.review-flow.commands.spec-command-args.SpecCommandArg": {
    "id": "src.features.spec.review-flow.commands.spec-command-args.SpecCommandArg",
    "name": "SpecCommandArg",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/spec-command-args.ts",
    "relative_path": "src/features/spec/review-flow/commands/spec-command-args.ts",
    "depends_on": [],
    "source_code": "interface SpecCommandArg {\n\tspecName?: unknown;\n\tid?: unknown;\n}",
    "start_line": 1,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecCommandArg",
    "component_id": "src.features.spec.review-flow.commands.spec-command-args.SpecCommandArg"
  },
  "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg": {
    "id": "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg",
    "name": "resolveSpecIdFromCommandArg",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/commands/spec-command-args.ts",
    "relative_path": "src/features/spec/review-flow/commands/spec-command-args.ts",
    "depends_on": [],
    "source_code": "function resolveSpecIdFromCommandArg(arg: unknown): string | null {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t}\n\n\tif (!arg || typeof arg !== \"object\") {\n\t\treturn null;\n\t}\n\n\tconst record = arg as SpecCommandArg;\n\n\tconst specName = record.specName;\n\tif (typeof specName === \"string\" && specName.length > 0) {\n\t\treturn specName;\n\t}\n\n\tconst id = record.id;\n\tif (typeof id === \"string\" && id.length > 0) {\n\t\treturn id;\n\t}\n\n\treturn null;\n}",
    "start_line": 6,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "arg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function resolveSpecIdFromCommandArg",
    "component_id": "src.features.spec.review-flow.commands.spec-command-args.resolveSpecIdFromCommandArg"
  },
  "src.features.spec.review-flow.duplicate-guard.normalizeTitle": {
    "id": "src.features.spec.review-flow.duplicate-guard.normalizeTitle",
    "name": "normalizeTitle",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/duplicate-guard.ts",
    "relative_path": "src/features/spec/review-flow/duplicate-guard.ts",
    "depends_on": [],
    "source_code": "function normalizeTitle(title: string): string {\n\treturn title.toLowerCase().trim().replace(/\\s+/g, \" \");\n}",
    "start_line": 13,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "title"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalizeTitle",
    "component_id": "src.features.spec.review-flow.duplicate-guard.normalizeTitle"
  },
  "src.features.spec.review-flow.duplicate-guard.findDuplicateChangeRequest": {
    "id": "src.features.spec.review-flow.duplicate-guard.findDuplicateChangeRequest",
    "name": "findDuplicateChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/duplicate-guard.ts",
    "relative_path": "src/features/spec/review-flow/duplicate-guard.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.duplicate-guard.normalizeTitle"
    ],
    "source_code": "function findDuplicateChangeRequest(\n\tspecId: string,\n\tnewTitle: string,\n\texistingChangeRequests: ChangeRequest[]\n): ChangeRequest | null {\n\tconst normalizedNewTitle = normalizeTitle(newTitle);\n\n\t// Find open/blocked/inProgress change requests with matching normalized title\n\tconst duplicate = existingChangeRequests.find((cr) => {\n\t\t// Only consider open/addressed change requests for duplicate check\n\t\t// (addressed are past, so new request is allowed)\n\t\tif (cr.status === \"addressed\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst normalizedExistingTitle = normalizeTitle(cr.title);\n\t\treturn normalizedExistingTitle === normalizedNewTitle;\n\t});\n\n\treturn duplicate || null;\n}",
    "start_line": 24,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "newTitle",
      "existingChangeRequests"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findDuplicateChangeRequest",
    "component_id": "src.features.spec.review-flow.duplicate-guard.findDuplicateChangeRequest"
  },
  "src.features.spec.review-flow.duplicate-guard.validateUniqueChangeRequest": {
    "id": "src.features.spec.review-flow.duplicate-guard.validateUniqueChangeRequest",
    "name": "validateUniqueChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/duplicate-guard.ts",
    "relative_path": "src/features/spec/review-flow/duplicate-guard.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.duplicate-guard.findDuplicateChangeRequest"
    ],
    "source_code": "function validateUniqueChangeRequest(\n\tspecId: string,\n\ttitle: string,\n\texistingChangeRequests: ChangeRequest[]\n): { isValid: boolean; duplicate?: ChangeRequest } {\n\tconst duplicate = findDuplicateChangeRequest(\n\t\tspecId,\n\t\ttitle,\n\t\texistingChangeRequests\n\t);\n\n\tif (duplicate) {\n\t\treturn { isValid: false, duplicate };\n\t}\n\n\treturn { isValid: true };\n}",
    "start_line": 53,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "title",
      "existingChangeRequests"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateUniqueChangeRequest",
    "component_id": "src.features.spec.review-flow.duplicate-guard.validateUniqueChangeRequest"
  },
  "src.features.spec.review-flow.state.getStateFilePath": {
    "id": "src.features.spec.review-flow.state.getStateFilePath",
    "name": "getStateFilePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [],
    "source_code": "function getStateFilePath(): string | null {\n\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\tif (!workspaceRoot) {\n\t\treturn null;\n\t}\n\treturn join(workspaceRoot, \".vscode\", \"gatomia\", \"spec-review-state.json\");\n}",
    "start_line": 56,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getStateFilePath",
    "component_id": "src.features.spec.review-flow.state.getStateFilePath"
  },
  "src.features.spec.review-flow.state.loadStateCache": {
    "id": "src.features.spec.review-flow.state.loadStateCache",
    "name": "loadStateCache",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "src.features.spec.review-flow.state.getStateFilePath",
      "src.features.spec.review-flow.storage.PersistedSpecification",
      "src.features.spec.review-flow.storage.deserializeSpecification"
    ],
    "source_code": "function loadStateCache(): void {\n\tif (cacheInitialized) {\n\t\treturn;\n\t}\n\n\tconst filePath = getStateFilePath();\n\tif (!filePath) {\n\t\tcacheInitialized = true;\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst raw = readFileSync(filePath, \"utf8\");\n\t\tconst parsed = JSON.parse(raw) as {\n\t\t\tspecStates?: Record<string, PersistedSpecification>;\n\t\t};\n\t\tspecStateCache.clear();\n\t\tif (parsed.specStates) {\n\t\t\tfor (const [specId, persisted] of Object.entries(parsed.specStates)) {\n\t\t\t\tspecStateCache.set(specId, deserializeSpecification(persisted));\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconst nodeError = error as NodeJS.ErrnoException;\n\t\tif (nodeError.code !== \"ENOENT\") {\n\t\t\tconsole.error(\"[ReviewFlow State] Failed to load state cache:\", error);\n\t\t}\n\t}\n\n\tcacheInitialized = true;\n}",
    "start_line": 67,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function loadStateCache",
    "component_id": "src.features.spec.review-flow.state.loadStateCache"
  },
  "src.features.spec.review-flow.state.persistStateCache": {
    "id": "src.features.spec.review-flow.state.persistStateCache",
    "name": "persistStateCache",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.storage.serializeSpecification",
      "src.features.spec.review-flow.state.getStateFilePath",
      "src.features.spec.review-flow.storage.PersistedSpecification"
    ],
    "source_code": "function persistStateCache(): void {\n\tconst filePath = getStateFilePath();\n\tif (!filePath) {\n\t\treturn;\n\t}\n\n\tconst payload: Record<string, PersistedSpecification> = {};\n\tfor (const [specId, spec] of specStateCache.entries()) {\n\t\tpayload[specId] = serializeSpecification(spec);\n\t}\n\n\ttry {\n\t\tmkdirSync(dirname(filePath), { recursive: true });\n\t\twriteFileSync(\n\t\t\tfilePath,\n\t\t\tJSON.stringify({ specStates: payload }, null, 2),\n\t\t\t\"utf8\"\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(\"[ReviewFlow State] Failed to persist state cache:\", error);\n\t}\n}",
    "start_line": 102,
    "end_line": 123,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function persistStateCache",
    "component_id": "src.features.spec.review-flow.state.persistStateCache"
  },
  "src.features.spec.review-flow.state.validateStatusTransition": {
    "id": "src.features.spec.review-flow.state.validateStatusTransition",
    "name": "validateStatusTransition",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.SpecStatus",
      "src.features.spec.review-flow.state.normalizeStatus"
    ],
    "source_code": "function validateStatusTransition(\n\tcurrentStatus: SpecStatus,\n\tnewStatus: SpecStatus\n): boolean {\n\tconst normalizedCurrent = normalizeStatus(currentStatus);\n\tconst normalizedNext = normalizeStatus(newStatus);\n\n\tconst validTransitions: Record<SpecStatus, SpecStatus[]> = {\n\t\tcurrent: [\"review\"],\n\t\treadyToReview: [\"reopened\", \"review\"],\n\t\treview: [\"reopened\", \"archived\", \"current\"],\n\t\treopened: [\"review\"],\n\t\tarchived: [\"reopened\"],\n\t};\n\n\treturn validTransitions[normalizedCurrent]?.includes(normalizedNext) ?? false;\n}",
    "start_line": 128,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "currentStatus",
      "newStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateStatusTransition",
    "component_id": "src.features.spec.review-flow.state.validateStatusTransition"
  },
  "src.features.spec.review-flow.state.normalizeStatus": {
    "id": "src.features.spec.review-flow.state.normalizeStatus",
    "name": "normalizeStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.SpecStatus"
    ],
    "source_code": "function normalizeStatus(status: SpecStatus): SpecStatus {\n\tif (status === \"readyToReview\") {\n\t\treturn \"review\";\n\t}\n\treturn status;\n}",
    "start_line": 146,
    "end_line": 151,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalizeStatus",
    "component_id": "src.features.spec.review-flow.state.normalizeStatus"
  },
  "src.features.spec.review-flow.state.isReviewStatus": {
    "id": "src.features.spec.review-flow.state.isReviewStatus",
    "name": "isReviewStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.SpecStatus",
      "src.features.spec.review-flow.state.normalizeStatus"
    ],
    "source_code": "function isReviewStatus(status: SpecStatus): boolean {\n\tconst normalized = normalizeStatus(status);\n\treturn normalized === \"review\";\n}",
    "start_line": 153,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isReviewStatus",
    "component_id": "src.features.spec.review-flow.state.isReviewStatus"
  },
  "src.features.spec.review-flow.state.buildReviewAlertMessage": {
    "id": "src.features.spec.review-flow.state.buildReviewAlertMessage",
    "name": "buildReviewAlertMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.types.ReviewTransitionTrigger"
    ],
    "source_code": "function buildReviewAlertMessage(\n\tspec: Specification,\n\ttriggerType: ReviewTransitionTrigger\n): string {\n\tconst base = `Spec \"${spec.title}\" is ready for review`;\n\tconst suffix = triggerType === \"auto\" ? \" (auto).\" : \".\";\n\treturn `${base}${suffix}`;\n}",
    "start_line": 158,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec",
      "triggerType"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildReviewAlertMessage",
    "component_id": "src.features.spec.review-flow.state.buildReviewAlertMessage"
  },
  "src.features.spec.review-flow.state.notifyReviewAlert": {
    "id": "src.features.spec.review-flow.state.notifyReviewAlert",
    "name": "notifyReviewAlert",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.utils.notification-utils.showReviewAlert",
      "src.features.spec.review-flow.types.ReviewTransitionTrigger",
      "src.features.spec.review-flow.state.buildReviewAlertMessage"
    ],
    "source_code": "function notifyReviewAlert(\n\tspec: Specification,\n\ttriggerType: ReviewTransitionTrigger\n): void {\n\tNotificationUtils.showReviewAlert(buildReviewAlertMessage(spec, triggerType));\n}",
    "start_line": 167,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec",
      "triggerType"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function notifyReviewAlert",
    "component_id": "src.features.spec.review-flow.state.notifyReviewAlert"
  },
  "src.features.spec.review-flow.state.getReviewNotificationRecipients": {
    "id": "src.features.spec.review-flow.state.getReviewNotificationRecipients",
    "name": "getReviewNotificationRecipients",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function getReviewNotificationRecipients(spec: Specification): string[] {\n\tif (spec.watchers && spec.watchers.length > 0) {\n\t\treturn Array.from(new Set(spec.watchers));\n\t}\n\treturn spec.owner ? [spec.owner] : [];\n}",
    "start_line": 174,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getReviewNotificationRecipients",
    "component_id": "src.features.spec.review-flow.state.getReviewNotificationRecipients"
  },
  "src.features.spec.review-flow.state.getSpecState": {
    "id": "src.features.spec.review-flow.state.getSpecState",
    "name": "getSpecState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.loadStateCache",
      "ui.src.services.spec-explorer.Specification",
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "function getSpecState(specId: string): Specification | null {\n\tloadStateCache();\n\n\tif (specStateCache.has(specId)) {\n\t\treturn specStateCache.get(specId) ?? null;\n\t}\n\n\t// If spec not in cache, attempt to create default spec for testing/initialization\n\t// In production, specs should be initialized from SpecExplorer metadata via upsertSpecState.\n\t// We return null here to keep the state layer decoupled from the explorer layer.\n\treturn null;\n}",
    "start_line": 186,
    "end_line": 197,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getSpecState",
    "component_id": "src.features.spec.review-flow.state.getSpecState"
  },
  "src.features.spec.review-flow.state.upsertSpecState": {
    "id": "src.features.spec.review-flow.state.upsertSpecState",
    "name": "upsertSpecState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.loadStateCache",
      "ui.src.services.spec-explorer.Specification",
      "src.features.agents.resource-cache.get",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function upsertSpecState(options: {\n\tspecId: string;\n\ttitle: string;\n\towner: string;\n\tlinks: Specification[\"links\"];\n\twatchers?: string[];\n}): Specification {\n\tloadStateCache();\n\n\tconst existing = specStateCache.get(options.specId);\n\tif (existing) {\n\t\tlet changed = false;\n\t\tif (existing.title !== options.title) {\n\t\t\texisting.title = options.title;\n\t\t\tchanged = true;\n\t\t}\n\t\tif (existing.owner !== options.owner) {\n\t\t\texisting.owner = options.owner;\n\t\t\tchanged = true;\n\t\t}\n\t\tif (\n\t\t\texisting.links.specPath !== options.links.specPath ||\n\t\t\texisting.links.docUrl !== options.links.docUrl\n\t\t) {\n\t\t\texisting.links = options.links;\n\t\t\tchanged = true;\n\t\t}\n\t\tif (\n\t\t\toptions.watchers &&\n\t\t\toptions.watchers.join(\"|\") !== existing.watchers?.join(\"|\")\n\t\t) {\n\t\t\texisting.watchers = options.watchers;\n\t\t\tchanged = true;\n\t\t}\n\n\t\tif (changed) {\n\t\t\texisting.updatedAt = new Date();\n\t\t\tspecStateCache.set(options.specId, existing);\n\t\t\tpersistStateCache();\n\t\t\t_onReviewFlowStateChange.fire();\n\t\t}\n\t\treturn existing;\n\t}\n\n\tconst created: Specification = {\n\t\tid: options.specId,\n\t\ttitle: options.title,\n\t\towner: options.owner,\n\t\tstatus: \"current\",\n\t\tcompletedAt: null,\n\t\treviewEnteredAt: null,\n\t\tarchivedAt: null,\n\t\tupdatedAt: new Date(),\n\t\tlinks: options.links,\n\t\tpendingTasks: 0,\n\t\tpendingChecklistItems: 0,\n\t\tchangeRequests: [],\n\t\twatchers: options.watchers,\n\t};\n\n\tspecStateCache.set(options.specId, created);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\treturn created;\n}",
    "start_line": 199,
    "end_line": 263,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function upsertSpecState",
    "component_id": "src.features.spec.review-flow.state.upsertSpecState"
  },
  "src.features.spec.review-flow.state.updateSpecStatus": {
    "id": "src.features.spec.review-flow.state.updateSpecStatus",
    "name": "updateSpecStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.normalizeStatus",
      "src.features.spec.review-flow.state.loadStateCache",
      "src.features.spec.review-flow.telemetry.logOutstandingBlockerCount",
      "src.features.spec.review-flow.state.getSpecState",
      "ui.src.services.spec-explorer.SpecStatus",
      "src.features.spec.review-flow.state.persistStateCache",
      "src.features.spec.review-flow.state.validateStatusTransition",
      "src.features.spec.review-flow.telemetry.logSpecStatusChange",
      "src.features.spec.review-flow.telemetry.logSendToReviewAction"
    ],
    "source_code": "function updateSpecStatus(\n\tspecId: string,\n\tnewStatus: SpecStatus\n): Specification | null {\n\tloadStateCache();\n\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\tconsole.warn(\"[ReviewFlow State] Spec not found:\", specId);\n\t\treturn null;\n\t}\n\n\tconst normalizedCurrent = normalizeStatus(spec.status);\n\tconst normalizedTarget = normalizeStatus(newStatus);\n\n\t// Validate FSM transition\n\tif (!validateStatusTransition(normalizedCurrent, normalizedTarget)) {\n\t\tconsole.error(\n\t\t\t`[ReviewFlow State] Invalid transition: ${spec.status}  ${newStatus}`\n\t\t);\n\t\treturn null;\n\t}\n\n\tconst oldStatus = normalizedCurrent;\n\tspec.status = normalizedTarget;\n\tspec.updatedAt = new Date();\n\n\t// Set completedAt and reviewEnteredAt when first transitioning to review\n\tif (normalizedTarget === \"review\") {\n\t\tspec.completedAt = new Date();\n\t\tspec.reviewEnteredAt = spec.reviewEnteredAt ?? spec.completedAt;\n\t}\n\n\tif (normalizedTarget === \"archived\") {\n\t\tspec.archivedAt = new Date();\n\t}\n\n\t// Persist and update cache\n\tspecStateCache.set(specId, spec);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\n\t// Telemetry\n\tlogSpecStatusChange(specId, oldStatus, normalizedTarget);\n\tif (normalizedTarget === \"review\" && oldStatus === \"current\") {\n\t\tlogSendToReviewAction({\n\t\t\tspecId,\n\t\t\tpendingTasks: spec.pendingTasks ?? 0,\n\t\t\tpendingChecklistItems: spec.pendingChecklistItems ?? 0,\n\t\t});\n\t}\n\n\t// Log blocker count for all status transitions\n\tconst totalChangeRequests = spec.changeRequests?.length ?? 0;\n\tconst openChangeRequests =\n\t\tspec.changeRequests?.filter((cr) => cr.status !== \"addressed\").length ?? 0;\n\tconst blockingChangeRequests =\n\t\tspec.changeRequests?.filter(\n\t\t\t(cr) => cr.archivalBlocker && cr.status !== \"addressed\"\n\t\t).length ?? 0;\n\n\tif (totalChangeRequests > 0) {\n\t\tlogOutstandingBlockerCount({\n\t\t\tspecId,\n\t\t\tstatus: normalizedTarget,\n\t\t\ttotalChangeRequests,\n\t\t\topenChangeRequests,\n\t\t\tblockingChangeRequests,\n\t\t});\n\t}\n\n\treturn spec;\n}",
    "start_line": 271,
    "end_line": 343,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "newStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateSpecStatus",
    "component_id": "src.features.spec.review-flow.state.updateSpecStatus"
  },
  "src.features.spec.review-flow.state.addChangeRequest": {
    "id": "src.features.spec.review-flow.state.addChangeRequest",
    "name": "addChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.telemetry.logSpecReopenedFromChangeRequest",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.loadStateCache",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.isReviewStatus",
      "src.features.spec.review-flow.telemetry.logSpecStatusChange",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function addChangeRequest(\n\tspecId: string,\n\tchangeRequest: ChangeRequest\n): Specification | null {\n\tloadStateCache();\n\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\tconsole.warn(\"[ReviewFlow State] Spec not found:\", specId);\n\t\treturn null;\n\t}\n\n\t// Append change request\n\tif (!spec.changeRequests) {\n\t\tspec.changeRequests = [];\n\t}\n\tspec.changeRequests.push(changeRequest);\n\tspec.updatedAt = new Date();\n\n\t// Transition to reopened if in review\n\tif (isReviewStatus(spec.status)) {\n\t\tspec.status = \"reopened\";\n\t\tlogSpecStatusChange(specId, \"review\", \"reopened\");\n\t\tlogSpecReopenedFromChangeRequest({\n\t\t\tspecId,\n\t\t\tchangeRequestId: changeRequest.id,\n\t\t});\n\t}\n\n\t// Persist\n\tspecStateCache.set(specId, spec);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\n\treturn spec;\n}",
    "start_line": 351,
    "end_line": 386,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequest"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addChangeRequest",
    "component_id": "src.features.spec.review-flow.state.addChangeRequest"
  },
  "src.features.spec.review-flow.state.updateChangeRequestStatus": {
    "id": "src.features.spec.review-flow.state.updateChangeRequestStatus",
    "name": "updateChangeRequestStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.state.loadStateCache",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.returnSpecToReview",
      "src.features.spec.review-flow.telemetry.logChangeRequestStatusChange",
      "ui.src.services.spec-explorer.ChangeRequestStatus",
      "src.features.spec.review-flow.state.shouldReturnToReview",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function updateChangeRequestStatus(\n\tspecId: string,\n\tchangeRequestId: string,\n\tnewStatus: ChangeRequestStatus\n): ChangeRequest | null {\n\tloadStateCache();\n\n\tconst spec = getSpecState(specId);\n\tif (!spec?.changeRequests) {\n\t\tconsole.warn(\n\t\t\t\"[ReviewFlow State] Spec or change requests not found:\",\n\t\t\tspecId\n\t\t);\n\t\treturn null;\n\t}\n\n\tconst changeRequest = spec.changeRequests.find(\n\t\t(cr) => cr.id === changeRequestId\n\t);\n\tif (!changeRequest) {\n\t\tconsole.warn(\n\t\t\t\"[ReviewFlow State] Change request not found:\",\n\t\t\tchangeRequestId\n\t\t);\n\t\treturn null;\n\t}\n\n\tconst oldStatus = changeRequest.status;\n\tchangeRequest.status = newStatus;\n\tchangeRequest.updatedAt = new Date();\n\n\t// Persist\n\tspecStateCache.set(specId, spec);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\n\t// Telemetry\n\tlogChangeRequestStatusChange(changeRequestId, oldStatus, newStatus);\n\n\t// Check if spec should return to review\n\tif (newStatus === \"addressed\" && shouldReturnToReview(specId)) {\n\t\treturnSpecToReview(specId);\n\t}\n\n\treturn changeRequest;\n}",
    "start_line": 395,
    "end_line": 440,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId",
      "newStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateChangeRequestStatus",
    "component_id": "src.features.spec.review-flow.state.updateChangeRequestStatus"
  },
  "src.features.spec.review-flow.state.shouldReturnToReview": {
    "id": "src.features.spec.review-flow.state.shouldReturnToReview",
    "name": "shouldReturnToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.getSpecState"
    ],
    "source_code": "function shouldReturnToReview(specId: string): boolean {\n\tconst spec = getSpecState(specId);\n\tif (!spec?.changeRequests || spec.changeRequests.length === 0) {\n\t\treturn false;\n\t}\n\n\t// All change requests must be addressed\n\tconst allAddressed = spec.changeRequests.every(\n\t\t(cr) => cr.status === \"addressed\"\n\t);\n\tif (!allAddressed) {\n\t\treturn false;\n\t}\n\n\t// All tasks in all change requests must be done\n\tconst allTasksDone = spec.changeRequests.every((cr) =>\n\t\tcr.tasks.every((task) => task.status === \"done\")\n\t);\n\n\tconst pendingTasks = spec.pendingTasks ?? 0;\n\tconst pendingChecklistItems = spec.pendingChecklistItems ?? 0;\n\n\treturn allTasksDone && pendingTasks === 0 && pendingChecklistItems === 0;\n}",
    "start_line": 447,
    "end_line": 470,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function shouldReturnToReview",
    "component_id": "src.features.spec.review-flow.state.shouldReturnToReview"
  },
  "src.features.spec.review-flow.state.returnSpecToReview": {
    "id": "src.features.spec.review-flow.state.returnSpecToReview",
    "name": "returnSpecToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.updateSpecStatus",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.normalizeStatus",
      "src.features.spec.review-flow.state.getSpecState"
    ],
    "source_code": "function returnSpecToReview(specId: string): Specification | null {\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\tconsole.warn(\"[ReviewFlow State] Spec not found:\", specId);\n\t\treturn null;\n\t}\n\n\tif (normalizeStatus(spec.status) !== \"reopened\") {\n\t\tconsole.warn(\n\t\t\t\"[ReviewFlow State] Spec not in reopened status:\",\n\t\t\tspecId,\n\t\t\tspec.status\n\t\t);\n\t\treturn null;\n\t}\n\n\treturn updateSpecStatus(specId, \"review\");\n}",
    "start_line": 477,
    "end_line": 494,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function returnSpecToReview",
    "component_id": "src.features.spec.review-flow.state.returnSpecToReview"
  },
  "src.features.spec.review-flow.state.__testInitSpec": {
    "id": "src.features.spec.review-flow.state.__testInitSpec",
    "name": "__testInitSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function __testInitSpec(spec: Specification): void {\n\tspecStateCache.set(spec.id, spec);\n}",
    "start_line": 500,
    "end_line": 502,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function __testInitSpec",
    "component_id": "src.features.spec.review-flow.state.__testInitSpec"
  },
  "src.features.spec.review-flow.state.updatePendingSummary": {
    "id": "src.features.spec.review-flow.state.updatePendingSummary",
    "name": "updatePendingSummary",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.updateSpecStatus",
      "src.features.spec.review-flow.state.evaluateAutoReviewTransitions",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.telemetry.logReviewExitEvent",
      "src.features.spec.review-flow.state.getSpecState",
      "src.utils.notification-utils.showWarning",
      "src.features.spec.review-flow.state.isReviewStatus",
      "src.features.spec.review-flow.state.hasBlockingChangeRequests",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function updatePendingSummary(\n\tspecId: string,\n\tpendingTasks: number,\n\tpendingChecklistItems: number\n): Specification | null {\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\treturn null;\n\t}\n\n\tspec.pendingTasks = Math.max(0, pendingTasks);\n\tspec.pendingChecklistItems = Math.max(0, pendingChecklistItems);\n\tspec.updatedAt = new Date();\n\tspecStateCache.set(specId, spec);\n\n\tif (\n\t\tisReviewStatus(spec.status) &&\n\t\t(spec.pendingTasks > 0 || spec.pendingChecklistItems > 0)\n\t) {\n\t\tconst nextStatus = hasBlockingChangeRequests(spec) ? \"reopened\" : \"current\";\n\t\tconst updated = updateSpecStatus(specId, nextStatus);\n\t\tif (updated) {\n\t\t\tconst reason =\n\t\t\t\tspec.pendingTasks > 0 ? \"pending-tasks\" : \"pending-checklist-items\";\n\t\t\tlogReviewExitEvent({\n\t\t\t\tspecId,\n\t\t\t\tfromStatus: \"review\",\n\t\t\t\ttoStatus: nextStatus,\n\t\t\t\treason,\n\t\t\t\tpendingTasks: spec.pendingTasks,\n\t\t\t\tpendingChecklistItems: spec.pendingChecklistItems,\n\t\t\t});\n\t\t\tNotificationUtils.showWarning(\n\t\t\t\t`Spec \"${spec.title}\" returned to execution due to new blockers.`\n\t\t\t);\n\t\t}\n\t\treturn updated;\n\t}\n\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\tevaluateAutoReviewTransitions();\n\treturn spec;\n}",
    "start_line": 507,
    "end_line": 550,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "pendingTasks",
      "pendingChecklistItems"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updatePendingSummary",
    "component_id": "src.features.spec.review-flow.state.updatePendingSummary"
  },
  "src.features.spec.review-flow.state.evaluateAutoReviewTransitions": {
    "id": "src.features.spec.review-flow.state.evaluateAutoReviewTransitions",
    "name": "evaluateAutoReviewTransitions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state._autoSendToReview",
      "src.features.spec.spec-manager.delete"
    ],
    "source_code": "function evaluateAutoReviewTransitions(): void {\n\tif (!autoReviewInitialized || specStateCache.size === 0) {\n\t\treturn;\n\t}\n\n\tconst candidates = new Set<string>([\n\t\t...specStateCache.keys(),\n\t\t...autoReviewRetryQueue,\n\t]);\n\n\tfor (const specId of candidates) {\n\t\tconst result = _autoSendToReview(specId);\n\t\tif (result) {\n\t\t\tautoReviewRetryQueue.delete(specId);\n\t\t}\n\t}\n}",
    "start_line": 552,
    "end_line": 568,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function evaluateAutoReviewTransitions",
    "component_id": "src.features.spec.review-flow.state.evaluateAutoReviewTransitions"
  },
  "src.features.spec.review-flow.state._autoSendToReview": {
    "id": "src.features.spec.review-flow.state._autoSendToReview",
    "name": "_autoSendToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.utils.notification-utils.showError",
      "src.features.spec.review-flow.state.performReviewTransition",
      "src.features.spec.review-flow.state.canSendToReview",
      "src.features.spec.spec-manager.delete"
    ],
    "source_code": "function _autoSendToReview(specId: string): Specification | null {\n\tconst gatingResult = canSendToReview(specId);\n\tif (!gatingResult.canSend) {\n\t\tautoReviewRetryQueue.delete(specId);\n\t\treturn null;\n\t}\n\n\tconst result = performReviewTransition(specId, \"auto\");\n\tif (!result) {\n\t\tautoReviewRetryQueue.add(specId);\n\t\tNotificationUtils.showError(\n\t\t\t\"Failed to send spec to review automatically. Will retry.\"\n\t\t);\n\t\treturn null;\n\t}\n\n\treturn result;\n}",
    "start_line": 570,
    "end_line": 587,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _autoSendToReview",
    "component_id": "src.features.spec.review-flow.state._autoSendToReview"
  },
  "src.features.spec.review-flow.state.performReviewTransition": {
    "id": "src.features.spec.review-flow.state.performReviewTransition",
    "name": "performReviewTransition",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.sendToReview",
      "src.features.spec.review-flow.state.getReviewNotificationRecipients",
      "src.features.spec.review-flow.types.ReviewTransitionTrigger",
      "src.features.spec.review-flow.telemetry.logReviewTransitionEvent",
      "src.features.spec.review-flow.state.notifyReviewAlert"
    ],
    "source_code": "function performReviewTransition(\n\tspecId: string,\n\ttriggerType: ReviewTransitionTrigger,\n\tinitiatedBy?: string\n): Specification | null {\n\tconst result = sendToReview(specId);\n\tif (!result) {\n\t\tlogReviewTransitionEvent({\n\t\t\teventId: `${triggerType}-${specId}-${Date.now()}`,\n\t\t\tspecId,\n\t\t\ttriggerType,\n\t\t\tinitiatedBy,\n\t\t\toccurredAt: new Date(),\n\t\t\tnotificationRecipients: [],\n\t\t\tstatus: \"failed\",\n\t\t\tfailureReason: \"send-to-review-failed\",\n\t\t});\n\t\treturn null;\n\t}\n\n\tconst recipients = getReviewNotificationRecipients(result);\n\tlogReviewTransitionEvent({\n\t\teventId: `${triggerType}-${specId}-${Date.now()}`,\n\t\tspecId,\n\t\ttriggerType,\n\t\tinitiatedBy,\n\t\toccurredAt: new Date(),\n\t\tnotificationRecipients: recipients,\n\t\tstatus: \"succeeded\",\n\t\tfailureReason: null,\n\t});\n\tnotifyReviewAlert(result, triggerType);\n\treturn result;\n}",
    "start_line": 589,
    "end_line": 622,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "triggerType",
      "initiatedBy"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function performReviewTransition",
    "component_id": "src.features.spec.review-flow.state.performReviewTransition"
  },
  "src.features.spec.review-flow.state.initializeAutoReviewTransitions": {
    "id": "src.features.spec.review-flow.state.initializeAutoReviewTransitions",
    "name": "initializeAutoReviewTransitions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.evaluateAutoReviewTransitions"
    ],
    "source_code": "function initializeAutoReviewTransitions(): void {\n\tif (autoReviewInitialized) {\n\t\treturn;\n\t}\n\n\tautoReviewInitialized = true;\n\tonReviewFlowStateChange(() => {\n\t\tevaluateAutoReviewTransitions();\n\t});\n}",
    "start_line": 624,
    "end_line": 633,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initializeAutoReviewTransitions",
    "component_id": "src.features.spec.review-flow.state.initializeAutoReviewTransitions"
  },
  "src.features.spec.review-flow.state.__testAutoSendToReview": {
    "id": "src.features.spec.review-flow.state.__testAutoSendToReview",
    "name": "__testAutoSendToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state._autoSendToReview",
      "src.utils.notification-utils.showError",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.telemetry.logReviewTransitionEvent"
    ],
    "source_code": "function __testAutoSendToReview(\n\tspecId: string,\n\toptions?: { forceFailure?: boolean }\n): Specification | null {\n\tif (options?.forceFailure) {\n\t\tlogReviewTransitionEvent({\n\t\t\teventId: `auto-${specId}-${Date.now()}`,\n\t\t\tspecId,\n\t\t\ttriggerType: \"auto\",\n\t\t\toccurredAt: new Date(),\n\t\t\tnotificationRecipients: [],\n\t\t\tstatus: \"failed\",\n\t\t\tfailureReason: \"test-forced-failure\",\n\t\t});\n\t\tNotificationUtils.showError(\n\t\t\t\"Failed to send spec to review automatically. Will retry.\"\n\t\t);\n\t\treturn null;\n\t}\n\treturn _autoSendToReview(specId);\n}",
    "start_line": 635,
    "end_line": 655,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function __testAutoSendToReview",
    "component_id": "src.features.spec.review-flow.state.__testAutoSendToReview"
  },
  "src.features.spec.review-flow.state.sendToReviewWithTrigger": {
    "id": "src.features.spec.review-flow.state.sendToReviewWithTrigger",
    "name": "sendToReviewWithTrigger",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.performReviewTransition",
      "src.features.spec.review-flow.types.ReviewTransitionTrigger",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.canSendToReview"
    ],
    "source_code": "function sendToReviewWithTrigger(options: {\n\tspecId: string;\n\ttriggerType: ReviewTransitionTrigger;\n\tinitiatedBy?: string;\n}): { result: Specification | null; blockers: string[] } {\n\tconst gatingResult = canSendToReview(options.specId);\n\tif (!gatingResult.canSend) {\n\t\treturn { result: null, blockers: gatingResult.blockers };\n\t}\n\n\tconst result = performReviewTransition(\n\t\toptions.specId,\n\t\toptions.triggerType,\n\t\toptions.initiatedBy\n\t);\n\tif (!result) {\n\t\treturn {\n\t\t\tresult: null,\n\t\t\tblockers: [\"Send to review failed\"],\n\t\t};\n\t}\n\n\treturn { result, blockers: [] };\n}",
    "start_line": 657,
    "end_line": 680,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sendToReviewWithTrigger",
    "component_id": "src.features.spec.review-flow.state.sendToReviewWithTrigger"
  },
  "src.features.spec.review-flow.state.hasBlockingChangeRequests": {
    "id": "src.features.spec.review-flow.state.hasBlockingChangeRequests",
    "name": "hasBlockingChangeRequests",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function hasBlockingChangeRequests(spec: Specification): boolean {\n\treturn (\n\t\tspec.changeRequests?.some(\n\t\t\t(cr) =>\n\t\t\t\tcr.status !== \"addressed\" || cr.tasks.some((t) => t.status !== \"done\")\n\t\t) ?? false\n\t);\n}",
    "start_line": 682,
    "end_line": 689,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function hasBlockingChangeRequests",
    "component_id": "src.features.spec.review-flow.state.hasBlockingChangeRequests"
  },
  "src.features.spec.review-flow.state.canArchive": {
    "id": "src.features.spec.review-flow.state.canArchive",
    "name": "canArchive",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.isReviewStatus",
      "src.features.spec.review-flow.state.hasBlockingChangeRequests"
    ],
    "source_code": "function canArchive(specId: string): boolean {\n\tconst spec = getSpecState(specId);\n\tif (!(spec && isReviewStatus(spec.status))) {\n\t\treturn false;\n\t}\n\n\tconst pendingTasks = spec.pendingTasks ?? 0;\n\tconst pendingChecklistItems = spec.pendingChecklistItems ?? 0;\n\n\treturn (\n\t\tpendingTasks === 0 &&\n\t\tpendingChecklistItems === 0 &&\n\t\t!hasBlockingChangeRequests(spec)\n\t);\n}",
    "start_line": 694,
    "end_line": 708,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function canArchive",
    "component_id": "src.features.spec.review-flow.state.canArchive"
  },
  "src.features.spec.review-flow.state.archiveSpec": {
    "id": "src.features.spec.review-flow.state.archiveSpec",
    "name": "archiveSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.updateSpecStatus",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.canArchive",
      "src.features.spec.review-flow.state.isReviewStatus",
      "src.features.spec.review-flow.telemetry.logSendToArchivedAction"
    ],
    "source_code": "function archiveSpec(specId: string): Specification | null {\n\tconst spec = getSpecState(specId);\n\tif (!(spec && isReviewStatus(spec.status))) {\n\t\treturn null;\n\t}\n\n\tif (!canArchive(specId)) {\n\t\treturn null;\n\t}\n\n\tconst updated = updateSpecStatus(specId, \"archived\");\n\tif (updated) {\n\t\tlogSendToArchivedAction({\n\t\t\tspecId,\n\t\t\tblockerChangeRequestIds: [],\n\t\t});\n\t}\n\treturn updated;\n}",
    "start_line": 713,
    "end_line": 731,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function archiveSpec",
    "component_id": "src.features.spec.review-flow.state.archiveSpec"
  },
  "src.features.spec.review-flow.state.unarchiveSpec": {
    "id": "src.features.spec.review-flow.state.unarchiveSpec",
    "name": "unarchiveSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.state.normalizeStatus",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.telemetry.logSpecUnarchived",
      "src.features.spec.review-flow.telemetry.logSpecStatusChange",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function unarchiveSpec(\n\tspecId: string,\n\toptions?: { initiatedBy?: string; reason?: string }\n): Specification | null {\n\tconst spec = getSpecState(specId);\n\tif (!spec || normalizeStatus(spec.status) !== \"archived\") {\n\t\treturn null;\n\t}\n\n\tspec.status = \"reopened\";\n\tspec.archivedAt = null;\n\tspec.updatedAt = new Date();\n\tspecStateCache.set(specId, spec);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\n\tlogSpecUnarchived({\n\t\tspecId,\n\t\tinitiatedBy: options?.initiatedBy ?? \"unknown\",\n\t\treason: options?.reason ?? \"manual-unarchive\",\n\t});\n\tlogSpecStatusChange(specId, \"archived\", \"reopened\");\n\treturn spec;\n}",
    "start_line": 736,
    "end_line": 759,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function unarchiveSpec",
    "component_id": "src.features.spec.review-flow.state.unarchiveSpec"
  },
  "src.features.spec.review-flow.state.attachTasksToChangeRequest": {
    "id": "src.features.spec.review-flow.state.attachTasksToChangeRequest",
    "name": "attachTasksToChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.types.TaskLink",
      "src.features.spec.review-flow.state.loadStateCache",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.telemetry.logChangeRequestStatusChange",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function attachTasksToChangeRequest(\n\tspecId: string,\n\tchangeRequestId: string,\n\ttasks: TaskLink[]\n): ChangeRequest | null {\n\tloadStateCache();\n\n\tconst spec = getSpecState(specId);\n\tif (!spec?.changeRequests) {\n\t\tconsole.warn(\n\t\t\t\"[ReviewFlow State] Spec or change requests not found:\",\n\t\t\tspecId\n\t\t);\n\t\treturn null;\n\t}\n\n\tconst changeRequest = spec.changeRequests.find(\n\t\t(cr) => cr.id === changeRequestId\n\t);\n\tif (!changeRequest) {\n\t\tconsole.warn(\n\t\t\t\"[ReviewFlow State] Change request not found:\",\n\t\t\tchangeRequestId\n\t\t);\n\t\treturn null;\n\t}\n\n\t// Attach tasks\n\tchangeRequest.tasks = tasks;\n\tchangeRequest.sentToTasksAt = new Date();\n\tchangeRequest.updatedAt = new Date();\n\tchangeRequest.archivalBlocker = true;\n\n\t// Transition to inProgress\n\tconst oldStatus = changeRequest.status;\n\tchangeRequest.status = \"inProgress\";\n\n\t// Persist\n\tspecStateCache.set(specId, spec);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\n\t// Telemetry\n\tlogChangeRequestStatusChange(changeRequestId, oldStatus, \"inProgress\");\n\n\treturn changeRequest;\n}",
    "start_line": 768,
    "end_line": 814,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId",
      "tasks"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function attachTasksToChangeRequest",
    "component_id": "src.features.spec.review-flow.state.attachTasksToChangeRequest"
  },
  "src.features.spec.review-flow.state.updateTaskStatus": {
    "id": "src.features.spec.review-flow.state.updateTaskStatus",
    "name": "updateTaskStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.TaskLink",
      "src.features.spec.review-flow.state.loadStateCache",
      "src.features.spec.review-flow.state.getSpecState",
      "src.features.spec.review-flow.state.returnSpecToReview",
      "src.features.spec.review-flow.telemetry.logChangeRequestStatusChange",
      "src.features.spec.review-flow.state.shouldReturnToReview",
      "src.features.spec.review-flow.types.TaskLinkStatus",
      "src.features.spec.review-flow.state.persistStateCache"
    ],
    "source_code": "function updateTaskStatus(\n\tspecId: string,\n\tchangeRequestId: string,\n\ttaskId: string,\n\tnewStatus: TaskLinkStatus\n): TaskLink | null {\n\tloadStateCache();\n\n\tconst spec = getSpecState(specId);\n\tif (!spec?.changeRequests) {\n\t\treturn null;\n\t}\n\n\tconst changeRequest = spec.changeRequests.find(\n\t\t(cr) => cr.id === changeRequestId\n\t);\n\tif (!changeRequest) {\n\t\treturn null;\n\t}\n\n\tconst task = changeRequest.tasks?.find((t) => t.taskId === taskId);\n\tif (!task) {\n\t\treturn null;\n\t}\n\n\ttask.status = newStatus;\n\tchangeRequest.updatedAt = new Date();\n\n\t// Check if all tasks are done -> mark CR as addressed\n\tif (\n\t\tnewStatus === \"done\" &&\n\t\tchangeRequest.tasks.every((t) => t.status === \"done\")\n\t) {\n\t\tconst oldCrStatus = changeRequest.status;\n\t\tchangeRequest.status = \"addressed\";\n\t\tchangeRequest.archivalBlocker = false;\n\t\tlogChangeRequestStatusChange(changeRequestId, oldCrStatus, \"addressed\");\n\t} else if (newStatus !== \"done\" && changeRequest.status === \"addressed\") {\n\t\t// Re-open CR if a task is moved back from done\n\t\tconst oldCrStatus = changeRequest.status;\n\t\tchangeRequest.status = \"inProgress\";\n\t\tchangeRequest.archivalBlocker = true;\n\t\tlogChangeRequestStatusChange(changeRequestId, oldCrStatus, \"inProgress\");\n\t}\n\n\t// Persist changes\n\tspecStateCache.set(specId, spec);\n\tpersistStateCache();\n\t_onReviewFlowStateChange.fire();\n\n\t// Check if spec should return to review\n\tif (shouldReturnToReview(specId)) {\n\t\treturnSpecToReview(specId);\n\t}\n\n\treturn task;\n}",
    "start_line": 824,
    "end_line": 880,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId",
      "taskId",
      "newStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateTaskStatus",
    "component_id": "src.features.spec.review-flow.state.updateTaskStatus"
  },
  "src.features.spec.review-flow.state.canSendToReview": {
    "id": "src.features.spec.review-flow.state.canSendToReview",
    "name": "canSendToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.normalizeStatus",
      "src.features.spec.review-flow.state.getSpecState"
    ],
    "source_code": "function canSendToReview(specId: string): {\n\tcanSend: boolean;\n\tblockers: string[];\n} {\n\tconst spec = getSpecState(specId);\n\tif (!spec) {\n\t\treturn { canSend: false, blockers: [\"Spec not found\"] };\n\t}\n\n\tconst blockers: string[] = [];\n\n\t// Check if spec is in current or reopened status\n\tconst normalizedStatus = normalizeStatus(spec.status);\n\tif (normalizedStatus === \"review\") {\n\t\tblockers.push(\"Spec already in review\");\n\t} else if (\n\t\tnormalizedStatus !== \"current\" &&\n\t\tnormalizedStatus !== \"reopened\"\n\t) {\n\t\tblockers.push(\"Spec not in current status\");\n\t}\n\n\t// Check for pending tasks\n\tconst pendingTasks = spec.pendingTasks ?? 0;\n\tif (pendingTasks > 0) {\n\t\tblockers.push(\n\t\t\t`${pendingTasks} pending task${pendingTasks === 1 ? \"\" : \"s\"}`\n\t\t);\n\t}\n\n\t// Check for pending checklist items\n\tconst pendingChecklistItems = spec.pendingChecklistItems ?? 0;\n\tif (pendingChecklistItems > 0) {\n\t\tblockers.push(\n\t\t\t`${pendingChecklistItems} pending checklist item${pendingChecklistItems === 1 ? \"\" : \"s\"}`\n\t\t);\n\t}\n\n\treturn {\n\t\tcanSend: blockers.length === 0,\n\t\tblockers,\n\t};\n}",
    "start_line": 887,
    "end_line": 929,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function canSendToReview",
    "component_id": "src.features.spec.review-flow.state.canSendToReview"
  },
  "src.features.spec.review-flow.state.sendToReview": {
    "id": "src.features.spec.review-flow.state.sendToReview",
    "name": "sendToReview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/state.ts",
    "relative_path": "src/features/spec/review-flow/state.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.updateSpecStatus",
      "src.features.spec.review-flow.state.canSendToReview",
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "function sendToReview(specId: string): Specification | null {\n\tconst gatingResult = canSendToReview(specId);\n\tif (!gatingResult.canSend) {\n\t\tconsole.warn(\n\t\t\t`[ReviewFlow State] Cannot send spec to review: ${gatingResult.blockers.join(\", \")}`\n\t\t);\n\t\treturn null;\n\t}\n\n\t// Transition to review status\n\treturn updateSpecStatus(specId, \"review\");\n}",
    "start_line": 937,
    "end_line": 948,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sendToReview",
    "component_id": "src.features.spec.review-flow.state.sendToReview"
  },
  "src.features.spec.review-flow.storage.PersistedTaskLink": {
    "id": "src.features.spec.review-flow.storage.PersistedTaskLink",
    "name": "PersistedTaskLink",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.TaskLink"
    ],
    "source_code": "interface PersistedTaskLink {\n\ttaskId: string;\n\tsource: TaskLink[\"source\"];\n\tstatus: TaskLink[\"status\"];\n\tcreatedAt: string;\n}",
    "start_line": 8,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PersistedTaskLink",
    "component_id": "src.features.spec.review-flow.storage.PersistedTaskLink"
  },
  "src.features.spec.review-flow.storage.PersistedChangeRequest": {
    "id": "src.features.spec.review-flow.storage.PersistedChangeRequest",
    "name": "PersistedChangeRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.storage.PersistedTaskLink"
    ],
    "source_code": "interface PersistedChangeRequest {\n\tid: string;\n\tspecId: string;\n\ttitle: string;\n\tdescription: string;\n\tseverity: ChangeRequest[\"severity\"];\n\tstatus: ChangeRequest[\"status\"];\n\ttasks: PersistedTaskLink[];\n\tsubmitter: string;\n\tcreatedAt: string;\n\tupdatedAt: string;\n\tsentToTasksAt: string | null;\n\tnotes?: string;\n\tarchivalBlocker?: boolean;\n}",
    "start_line": 15,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PersistedChangeRequest",
    "component_id": "src.features.spec.review-flow.storage.PersistedChangeRequest"
  },
  "src.features.spec.review-flow.storage.PersistedSpecification": {
    "id": "src.features.spec.review-flow.storage.PersistedSpecification",
    "name": "PersistedSpecification",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "src.features.spec.review-flow.storage.PersistedChangeRequest",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.types.SpecLinks"
    ],
    "source_code": "interface PersistedSpecification {\n\tid: string;\n\ttitle: string;\n\towner: string;\n\tstatus: Specification[\"status\"];\n\tcompletedAt: string | null;\n\treviewEnteredAt?: string | null;\n\tarchivedAt?: string | null;\n\tupdatedAt: string;\n\tlinks: SpecLinks;\n\tpendingTasks?: number;\n\tpendingChecklistItems?: number;\n\tchangeRequests?: PersistedChangeRequest[];\n\twatchers?: string[];\n}",
    "start_line": 31,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PersistedSpecification",
    "component_id": "src.features.spec.review-flow.storage.PersistedSpecification"
  },
  "src.features.spec.review-flow.storage.coerceOptionalCount": {
    "id": "src.features.spec.review-flow.storage.coerceOptionalCount",
    "name": "coerceOptionalCount",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [],
    "source_code": "function coerceOptionalCount(value: unknown): number | undefined {\n\tif (value === undefined) {\n\t\treturn;\n\t}\n\n\tlet numeric: number;\n\tif (typeof value === \"number\") {\n\t\tnumeric = value;\n\t} else if (typeof value === \"string\") {\n\t\tnumeric = Number(value);\n\t} else {\n\t\tnumeric = Number.NaN;\n\t}\n\n\tif (!Number.isFinite(numeric)) {\n\t\treturn;\n\t}\n\n\treturn Math.max(0, Math.trunc(numeric));\n}",
    "start_line": 47,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function coerceOptionalCount",
    "component_id": "src.features.spec.review-flow.storage.coerceOptionalCount"
  },
  "src.features.spec.review-flow.storage.serializeSpecification": {
    "id": "src.features.spec.review-flow.storage.serializeSpecification",
    "name": "serializeSpecification",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.storage.PersistedSpecification"
    ],
    "source_code": "function serializeSpecification(\n\tspec: Specification\n): PersistedSpecification {\n\treturn {\n\t\tid: spec.id,\n\t\ttitle: spec.title,\n\t\towner: spec.owner,\n\t\tstatus: spec.status,\n\t\tcompletedAt: spec.completedAt ? spec.completedAt.toISOString() : null,\n\t\treviewEnteredAt: spec.reviewEnteredAt\n\t\t\t? spec.reviewEnteredAt.toISOString()\n\t\t\t: null,\n\t\tarchivedAt: spec.archivedAt ? spec.archivedAt.toISOString() : null,\n\t\tupdatedAt: spec.updatedAt.toISOString(),\n\t\tlinks: spec.links,\n\t\tpendingTasks: spec.pendingTasks,\n\t\tpendingChecklistItems: spec.pendingChecklistItems,\n\t\tchangeRequests: spec.changeRequests?.map(serializeChangeRequest),\n\t\twatchers: spec.watchers,\n\t};\n}",
    "start_line": 71,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function serializeSpecification",
    "component_id": "src.features.spec.review-flow.storage.serializeSpecification"
  },
  "src.features.spec.review-flow.storage.deserializeSpecification": {
    "id": "src.features.spec.review-flow.storage.deserializeSpecification",
    "name": "deserializeSpecification",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.storage.coerceOptionalCount",
      "src.features.spec.review-flow.storage.PersistedSpecification"
    ],
    "source_code": "function deserializeSpecification(\n\tdata: PersistedSpecification\n): Specification {\n\treturn {\n\t\tid: data.id,\n\t\ttitle: data.title,\n\t\towner: data.owner,\n\t\tstatus: data.status,\n\t\tcompletedAt: data.completedAt ? new Date(data.completedAt) : null,\n\t\treviewEnteredAt: data.reviewEnteredAt\n\t\t\t? new Date(data.reviewEnteredAt)\n\t\t\t: null,\n\t\tarchivedAt: data.archivedAt ? new Date(data.archivedAt) : null,\n\t\tupdatedAt: new Date(data.updatedAt),\n\t\tlinks: data.links,\n\t\tpendingTasks: coerceOptionalCount(data.pendingTasks),\n\t\tpendingChecklistItems: coerceOptionalCount(data.pendingChecklistItems),\n\t\tchangeRequests: data.changeRequests?.map(deserializeChangeRequest),\n\t\twatchers: data.watchers,\n\t};\n}",
    "start_line": 96,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deserializeSpecification",
    "component_id": "src.features.spec.review-flow.storage.deserializeSpecification"
  },
  "src.features.spec.review-flow.storage.serializeChangeRequest": {
    "id": "src.features.spec.review-flow.storage.serializeChangeRequest",
    "name": "serializeChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.storage.PersistedChangeRequest"
    ],
    "source_code": "function serializeChangeRequest(\n\tchangeRequest: ChangeRequest\n): PersistedChangeRequest {\n\treturn {\n\t\tid: changeRequest.id,\n\t\tspecId: changeRequest.specId,\n\t\ttitle: changeRequest.title,\n\t\tdescription: changeRequest.description,\n\t\tseverity: changeRequest.severity,\n\t\tstatus: changeRequest.status,\n\t\ttasks: changeRequest.tasks.map(serializeTaskLink),\n\t\tsubmitter: changeRequest.submitter,\n\t\tcreatedAt: changeRequest.createdAt.toISOString(),\n\t\tupdatedAt: changeRequest.updatedAt.toISOString(),\n\t\tsentToTasksAt: changeRequest.sentToTasksAt\n\t\t\t? changeRequest.sentToTasksAt.toISOString()\n\t\t\t: null,\n\t\tnotes: changeRequest.notes,\n\t\tarchivalBlocker: changeRequest.archivalBlocker,\n\t};\n}",
    "start_line": 118,
    "end_line": 138,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changeRequest"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function serializeChangeRequest",
    "component_id": "src.features.spec.review-flow.storage.serializeChangeRequest"
  },
  "src.features.spec.review-flow.storage.deserializeChangeRequest": {
    "id": "src.features.spec.review-flow.storage.deserializeChangeRequest",
    "name": "deserializeChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.features.spec.review-flow.storage.PersistedChangeRequest"
    ],
    "source_code": "function deserializeChangeRequest(data: PersistedChangeRequest): ChangeRequest {\n\treturn {\n\t\tid: data.id,\n\t\tspecId: data.specId,\n\t\ttitle: data.title,\n\t\tdescription: data.description,\n\t\tseverity: data.severity,\n\t\tstatus: data.status,\n\t\ttasks: data.tasks.map(deserializeTaskLink),\n\t\tsubmitter: data.submitter,\n\t\tcreatedAt: new Date(data.createdAt),\n\t\tupdatedAt: new Date(data.updatedAt),\n\t\tsentToTasksAt: data.sentToTasksAt ? new Date(data.sentToTasksAt) : null,\n\t\tnotes: data.notes,\n\t\tarchivalBlocker: data.archivalBlocker,\n\t};\n}",
    "start_line": 140,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deserializeChangeRequest",
    "component_id": "src.features.spec.review-flow.storage.deserializeChangeRequest"
  },
  "src.features.spec.review-flow.storage.serializeTaskLink": {
    "id": "src.features.spec.review-flow.storage.serializeTaskLink",
    "name": "serializeTaskLink",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.TaskLink",
      "src.features.spec.review-flow.storage.PersistedTaskLink"
    ],
    "source_code": "function serializeTaskLink(task: TaskLink): PersistedTaskLink {\n\treturn {\n\t\ttaskId: task.taskId,\n\t\tsource: task.source,\n\t\tstatus: task.status,\n\t\tcreatedAt: task.createdAt.toISOString(),\n\t};\n}",
    "start_line": 158,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "task"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function serializeTaskLink",
    "component_id": "src.features.spec.review-flow.storage.serializeTaskLink"
  },
  "src.features.spec.review-flow.storage.deserializeTaskLink": {
    "id": "src.features.spec.review-flow.storage.deserializeTaskLink",
    "name": "deserializeTaskLink",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/storage.ts",
    "relative_path": "src/features/spec/review-flow/storage.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.TaskLink",
      "src.features.spec.review-flow.storage.PersistedTaskLink"
    ],
    "source_code": "function deserializeTaskLink(data: PersistedTaskLink): TaskLink {\n\treturn {\n\t\ttaskId: data.taskId,\n\t\tsource: data.source,\n\t\tstatus: data.status,\n\t\tcreatedAt: new Date(data.createdAt),\n\t};\n}",
    "start_line": 167,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deserializeTaskLink",
    "component_id": "src.features.spec.review-flow.storage.deserializeTaskLink"
  },
  "src.features.spec.review-flow.tasks-dispatch.TasksPromptPayload": {
    "id": "src.features.spec.review-flow.tasks-dispatch.TasksPromptPayload",
    "name": "TasksPromptPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/tasks-dispatch.ts",
    "relative_path": "src/features/spec/review-flow/tasks-dispatch.ts",
    "depends_on": [],
    "source_code": "interface TasksPromptPayload {\n\tspecId: string;\n\tspecTitle: string;\n\tspecPath: string;\n\tchangeRequestId: string;\n\tchangeRequestTitle: string;\n\tchangeRequestDescription: string;\n\tseverity: string;\n\tsubmitter: string;\n\tcontext: {\n\t\tspecLink: string;\n\t\tchangeRequestLink?: string;\n\t};\n\tnotes?: string;\n}",
    "start_line": 9,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TasksPromptPayload",
    "component_id": "src.features.spec.review-flow.tasks-dispatch.TasksPromptPayload"
  },
  "src.features.spec.review-flow.tasks-dispatch.TasksPromptResponse": {
    "id": "src.features.spec.review-flow.tasks-dispatch.TasksPromptResponse",
    "name": "TasksPromptResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/tasks-dispatch.ts",
    "relative_path": "src/features/spec/review-flow/tasks-dispatch.ts",
    "depends_on": [],
    "source_code": "interface TasksPromptResponse {\n\ttasks: Array<{\n\t\ttaskId: string;\n\t\ttitle: string;\n\t\tdescription: string;\n\t}>;\n\tsuccess: boolean;\n\tmessage?: string;\n}",
    "start_line": 25,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TasksPromptResponse",
    "component_id": "src.features.spec.review-flow.tasks-dispatch.TasksPromptResponse"
  },
  "src.features.spec.review-flow.tasks-dispatch.convertResponseToTaskLinks": {
    "id": "src.features.spec.review-flow.tasks-dispatch.convertResponseToTaskLinks",
    "name": "convertResponseToTaskLinks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/tasks-dispatch.ts",
    "relative_path": "src/features/spec/review-flow/tasks-dispatch.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.TaskLink",
      "src.features.spec.review-flow.tasks-dispatch.TasksPromptResponse"
    ],
    "source_code": "function convertResponseToTaskLinks(\n\tresponse: TasksPromptResponse\n): TaskLink[] {\n\treturn response.tasks.map((t) => ({\n\t\ttaskId: t.taskId,\n\t\tsource: \"tasksPrompt\",\n\t\tstatus: \"open\",\n\t\tcreatedAt: new Date(),\n\t}));\n}",
    "start_line": 38,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convertResponseToTaskLinks",
    "component_id": "src.features.spec.review-flow.tasks-dispatch.convertResponseToTaskLinks"
  },
  "src.features.spec.review-flow.tasks-dispatch.buildTasksPromptPayload": {
    "id": "src.features.spec.review-flow.tasks-dispatch.buildTasksPromptPayload",
    "name": "buildTasksPromptPayload",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/tasks-dispatch.ts",
    "relative_path": "src/features/spec/review-flow/tasks-dispatch.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "ui.src.services.spec-explorer.Specification",
      "src.features.spec.review-flow.tasks-dispatch.TasksPromptPayload"
    ],
    "source_code": "function buildTasksPromptPayload(\n\tspec: Specification,\n\tchangeRequest: ChangeRequest\n): TasksPromptPayload {\n\treturn {\n\t\tspecId: spec.id,\n\t\tspecTitle: spec.title,\n\t\tspecPath: spec.links.specPath,\n\t\tchangeRequestId: changeRequest.id,\n\t\tchangeRequestTitle: changeRequest.title,\n\t\tchangeRequestDescription: changeRequest.description,\n\t\tseverity: changeRequest.severity,\n\t\tsubmitter: changeRequest.submitter,\n\t\tcontext: {\n\t\t\tspecLink: spec.links.docUrl || spec.links.specPath,\n\t\t},\n\t\tnotes: changeRequest.notes,\n\t};\n}",
    "start_line": 52,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec",
      "changeRequest"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildTasksPromptPayload",
    "component_id": "src.features.spec.review-flow.tasks-dispatch.buildTasksPromptPayload"
  },
  "src.features.spec.review-flow.tasks-dispatch.dispatchToTasksPrompt": {
    "id": "src.features.spec.review-flow.tasks-dispatch.dispatchToTasksPrompt",
    "name": "dispatchToTasksPrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/tasks-dispatch.ts",
    "relative_path": "src/features/spec/review-flow/tasks-dispatch.ts",
    "depends_on": [
      "src.features.spec.review-flow.telemetry.logTasksDispatchSuccess",
      "src.features.spec.review-flow.tasks-dispatch.TasksPromptPayload",
      "src.features.spec.review-flow.tasks-dispatch.TasksPromptResponse",
      "src.features.spec.review-flow.telemetry.logTasksDispatchFailed"
    ],
    "source_code": "async function dispatchToTasksPrompt(\n\tpayload: TasksPromptPayload\n): Promise<TasksPromptResponse> {\n\tconst startTime = Date.now();\n\n\t// Simulate network latency (500-1500ms)\n\tconst latency = 500 + Math.random() * 1000;\n\tawait new Promise((resolve) => setTimeout(resolve, latency));\n\n\ttry {\n\t\t// Mock logic: 10% chance of failure to test error handling\n\t\t// In production, this would be a real API call\n\t\t// For demo/dev purposes, we might want to control this via config or environment\n\t\tconst shouldFail = Math.random() < 0.1;\n\n\t\tif (shouldFail) {\n\t\t\tthrow new Error(\"Tasks prompt service unavailable (simulated)\");\n\t\t}\n\n\t\t// Mock successful response\n\t\tconst response: TasksPromptResponse = {\n\t\t\tsuccess: true,\n\t\t\ttasks: [\n\t\t\t\t{\n\t\t\t\t\ttaskId: `task-${Date.now()}-1`,\n\t\t\t\t\ttitle: `Fix: ${payload.changeRequestTitle}`,\n\t\t\t\t\tdescription: `Address the feedback: ${payload.changeRequestDescription}`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttaskId: `task-${Date.now()}-2`,\n\t\t\t\t\ttitle: \"Verify changes\",\n\t\t\t\t\tdescription: \"Verify that the changes meet the requirements\",\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tlogTasksDispatchSuccess(\n\t\t\tpayload.specId,\n\t\t\tpayload.changeRequestId,\n\t\t\tresponse.tasks.length,\n\t\t\tDate.now() - startTime\n\t\t);\n\n\t\treturn response;\n\t} catch (error: any) {\n\t\tconst errorMessage = error.message || \"Unknown error\";\n\t\tlogTasksDispatchFailed(\n\t\t\tpayload.specId,\n\t\t\tpayload.changeRequestId,\n\t\t\terrorMessage,\n\t\t\ttrue // retryable\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\ttasks: [],\n\t\t\tmessage: errorMessage,\n\t\t};\n\t}\n}",
    "start_line": 76,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function dispatchToTasksPrompt",
    "component_id": "src.features.spec.review-flow.tasks-dispatch.dispatchToTasksPrompt"
  },
  "src.features.spec.review-flow.telemetry.ReviewFlowEventType": {
    "id": "src.features.spec.review-flow.telemetry.ReviewFlowEventType",
    "name": "ReviewFlowEventType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "type ReviewFlowEventType =\n\t(typeof REVIEW_FLOW_EVENTS)[keyof typeof REVIEW_FLOW_EVENTS];",
    "start_line": 42,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ReviewFlowEventType",
    "component_id": "src.features.spec.review-flow.telemetry.ReviewFlowEventType"
  },
  "src.features.spec.review-flow.telemetry.logReviewTransitionEvent": {
    "id": "src.features.spec.review-flow.telemetry.logReviewTransitionEvent",
    "name": "logReviewTransitionEvent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.ReviewTransitionEvent"
    ],
    "source_code": "function logReviewTransitionEvent(event: ReviewTransitionEvent): void {\n\tconst payload = {\n\t\ttype: REVIEW_FLOW_EVENTS.REVIEW_TRANSITION,\n\t\ttimestamp: event.occurredAt.toISOString(),\n\t\t...event,\n\t};\n\n\tconsole.log(\"[ReviewFlow Telemetry] Review transition:\", payload);\n}",
    "start_line": 48,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logReviewTransitionEvent",
    "component_id": "src.features.spec.review-flow.telemetry.logReviewTransitionEvent"
  },
  "src.features.spec.review-flow.telemetry.logReviewExitEvent": {
    "id": "src.features.spec.review-flow.telemetry.logReviewExitEvent",
    "name": "logReviewExitEvent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.SpecStatus"
    ],
    "source_code": "function logReviewExitEvent(options: {\n\tspecId: string;\n\tfromStatus: SpecStatus;\n\ttoStatus: SpecStatus;\n\treason: string;\n\tpendingTasks: number;\n\tpendingChecklistItems: number;\n}): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.REVIEW_EXITED,\n\t\ttimestamp: new Date().toISOString(),\n\t\t...options,\n\t};\n\n\tconsole.log(\"[ReviewFlow Telemetry] Review exit:\", event);\n}",
    "start_line": 58,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logReviewExitEvent",
    "component_id": "src.features.spec.review-flow.telemetry.logReviewExitEvent"
  },
  "src.features.spec.review-flow.telemetry.logSpecStatusChange": {
    "id": "src.features.spec.review-flow.telemetry.logSpecStatusChange",
    "name": "logSpecStatusChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.SpecStatus"
    ],
    "source_code": "function logSpecStatusChange(\n\tspecId: string,\n\tfromStatus: SpecStatus,\n\ttoStatus: SpecStatus\n): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.SPEC_STATUS_CHANGED,\n\t\ttimestamp: new Date().toISOString(),\n\t\tspecId,\n\t\tfromStatus,\n\t\ttoStatus,\n\t};\n\n\tconsole.log(\"[ReviewFlow Telemetry] Spec status change:\", event);\n\n\t// TODO: Send to telemetry backend (e.g., Application Insights, custom analytics)\n\t// telemetryClient.trackEvent('review-flow:spec-status-change', {\n\t//   specId,\n\t//   fromStatus,\n\t//   toStatus,\n\t// });\n}",
    "start_line": 81,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "fromStatus",
      "toStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logSpecStatusChange",
    "component_id": "src.features.spec.review-flow.telemetry.logSpecStatusChange"
  },
  "src.features.spec.review-flow.telemetry.logChangeRequestCreated": {
    "id": "src.features.spec.review-flow.telemetry.logChangeRequestCreated",
    "name": "logChangeRequestCreated",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequestSeverity"
    ],
    "source_code": "function logChangeRequestCreated(options: {\n\tspecId: string;\n\tchangeRequestId: string;\n\tseverity: ChangeRequestSeverity;\n\ttitle: string;\n\tsubmitter: string;\n}): void {\n\tconst { specId, changeRequestId, severity, title, submitter } = options;\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.CHANGE_REQUEST_CREATED,\n\t\ttimestamp: new Date().toISOString(),\n\t\tspecId,\n\t\tchangeRequestId,\n\t\tseverity,\n\t\ttitleLength: title.length,\n\t\tsubmitter,\n\t};\n\n\tconsole.log(\"[ReviewFlow Telemetry] Change request created:\", event);\n\n\t// TODO: Send to telemetry backend\n\t// telemetryClient.trackEvent('review-flow:change-request-created', {\n\t//   specId,\n\t//   changeRequestId,\n\t//   severity,\n\t// });\n}",
    "start_line": 108,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logChangeRequestCreated",
    "component_id": "src.features.spec.review-flow.telemetry.logChangeRequestCreated"
  },
  "src.features.spec.review-flow.telemetry.logChangeRequestStatusChange": {
    "id": "src.features.spec.review-flow.telemetry.logChangeRequestStatusChange",
    "name": "logChangeRequestStatusChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequestStatus"
    ],
    "source_code": "function logChangeRequestStatusChange(\n\tchangeRequestId: string,\n\tfromStatus: ChangeRequestStatus,\n\ttoStatus: ChangeRequestStatus\n): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.CHANGE_REQUEST_STATUS_CHANGED,\n\t\ttimestamp: new Date().toISOString(),\n\t\tchangeRequestId,\n\t\tfromStatus,\n\t\ttoStatus,\n\t};\n\n\tconsole.log(\"[ReviewFlow Telemetry] Change request status change:\", event);\n\n\t// TODO: Send to telemetry backend\n\t// telemetryClient.trackEvent('review-flow:change-request-status-change', {\n\t//   changeRequestId,\n\t//   fromStatus,\n\t//   toStatus,\n\t// });\n}",
    "start_line": 142,
    "end_line": 163,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changeRequestId",
      "fromStatus",
      "toStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logChangeRequestStatusChange",
    "component_id": "src.features.spec.review-flow.telemetry.logChangeRequestStatusChange"
  },
  "src.features.spec.review-flow.telemetry.logTasksDispatchSuccess": {
    "id": "src.features.spec.review-flow.telemetry.logTasksDispatchSuccess",
    "name": "logTasksDispatchSuccess",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "function logTasksDispatchSuccess(\n\tspecId: string,\n\tchangeRequestId: string,\n\ttaskCount: number,\n\troundtripMs: number\n): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.TASKS_DISPATCHED,\n\t\ttimestamp: new Date().toISOString(),\n\t\tspecId,\n\t\tchangeRequestId,\n\t\ttaskCount,\n\t\troundtripMs,\n\t};\n\n\tconsole.log(\"[ReviewFlow Telemetry] Tasks dispatch success:\", event);\n\n\t// TODO: Send to telemetry backend with metrics\n\t// telemetryClient.trackEvent('review-flow:tasks-dispatch-success', {\n\t//   specId,\n\t//   changeRequestId,\n\t// }, {\n\t//   taskCount,\n\t//   roundtripMs,\n\t// });\n}",
    "start_line": 172,
    "end_line": 197,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId",
      "taskCount",
      "roundtripMs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logTasksDispatchSuccess",
    "component_id": "src.features.spec.review-flow.telemetry.logTasksDispatchSuccess"
  },
  "src.features.spec.review-flow.telemetry.logTasksDispatchFailed": {
    "id": "src.features.spec.review-flow.telemetry.logTasksDispatchFailed",
    "name": "logTasksDispatchFailed",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "function logTasksDispatchFailed(\n\tspecId: string,\n\tchangeRequestId: string,\n\terror: string,\n\tretryable: boolean\n): void {\n\tconst event = {\n\t\ttype: retryable\n\t\t\t? REVIEW_FLOW_EVENTS.TASKS_DISPATCH_FAILED\n\t\t\t: REVIEW_FLOW_EVENTS.TASKS_DISPATCH_BLOCKED,\n\t\ttimestamp: new Date().toISOString(),\n\t\tspecId,\n\t\tchangeRequestId,\n\t\terror,\n\t\tretryable,\n\t};\n\n\tconsole.warn(\"[ReviewFlow Telemetry] Tasks dispatch failed:\", event);\n\n\t// TODO: Send to telemetry backend with error tracking\n\t// telemetryClient.trackException(new Error(error), {\n\t//   specId,\n\t//   changeRequestId,\n\t//   retryable: retryable.toString(),\n\t// });\n}",
    "start_line": 206,
    "end_line": 231,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "changeRequestId",
      "error",
      "retryable"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logTasksDispatchFailed",
    "component_id": "src.features.spec.review-flow.telemetry.logTasksDispatchFailed"
  },
  "src.features.spec.review-flow.telemetry.logSendToReviewAction": {
    "id": "src.features.spec.review-flow.telemetry.logSendToReviewAction",
    "name": "logSendToReviewAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "function logSendToReviewAction(options: {\n\tspecId: string;\n\tpendingTasks: number;\n\tpendingChecklistItems: number;\n\tlatencyMs?: number;\n}): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.SEND_TO_REVIEW,\n\t\ttimestamp: new Date().toISOString(),\n\t\t...options,\n\t};\n\tconsole.log(\"[ReviewFlow Telemetry] Send to Review:\", event);\n}",
    "start_line": 236,
    "end_line": 248,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logSendToReviewAction",
    "component_id": "src.features.spec.review-flow.telemetry.logSendToReviewAction"
  },
  "src.features.spec.review-flow.telemetry.logSendToArchivedAction": {
    "id": "src.features.spec.review-flow.telemetry.logSendToArchivedAction",
    "name": "logSendToArchivedAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "function logSendToArchivedAction(options: {\n\tspecId: string;\n\tblockerChangeRequestIds: string[];\n\tlatencyMs?: number;\n}): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.SEND_TO_ARCHIVED,\n\t\ttimestamp: new Date().toISOString(),\n\t\t...options,\n\t};\n\tconsole.log(\"[ReviewFlow Telemetry] Send to Archived:\", event);\n}",
    "start_line": 253,
    "end_line": 264,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logSendToArchivedAction",
    "component_id": "src.features.spec.review-flow.telemetry.logSendToArchivedAction"
  },
  "src.features.spec.review-flow.telemetry.logSpecUnarchived": {
    "id": "src.features.spec.review-flow.telemetry.logSpecUnarchived",
    "name": "logSpecUnarchived",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "function logSpecUnarchived(options: {\n\tspecId: string;\n\tinitiatedBy: string;\n\treason: string;\n}): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.SPEC_UNARCHIVED,\n\t\ttimestamp: new Date().toISOString(),\n\t\t...options,\n\t};\n\tconsole.log(\"[ReviewFlow Telemetry] Spec unarchived:\", event);\n}",
    "start_line": 269,
    "end_line": 280,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logSpecUnarchived",
    "component_id": "src.features.spec.review-flow.telemetry.logSpecUnarchived"
  },
  "src.features.spec.review-flow.telemetry.logSpecReopenedFromChangeRequest": {
    "id": "src.features.spec.review-flow.telemetry.logSpecReopenedFromChangeRequest",
    "name": "logSpecReopenedFromChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [],
    "source_code": "function logSpecReopenedFromChangeRequest(options: {\n\tspecId: string;\n\tchangeRequestId: string;\n\treason?: string;\n}): void {\n\tconst event = {\n\t\ttype: REVIEW_FLOW_EVENTS.SPEC_REOPENED,\n\t\ttimestamp: new Date().toISOString(),\n\t\t...options,\n\t};\n\tconsole.log(\"[ReviewFlow Telemetry] Spec reopened:\", event);\n}",
    "start_line": 285,
    "end_line": 296,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logSpecReopenedFromChangeRequest",
    "component_id": "src.features.spec.review-flow.telemetry.logSpecReopenedFromChangeRequest"
  },
  "src.features.spec.review-flow.telemetry.logOutstandingBlockerCount": {
    "id": "src.features.spec.review-flow.telemetry.logOutstandingBlockerCount",
    "name": "logOutstandingBlockerCount",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/telemetry.ts",
    "relative_path": "src/features/spec/review-flow/telemetry.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.SpecStatus"
    ],
    "source_code": "function logOutstandingBlockerCount(options: {\n\tspecId: string;\n\tstatus: SpecStatus;\n\ttotalChangeRequests: number;\n\topenChangeRequests: number;\n\tblockingChangeRequests: number;\n}): void {\n\tconst event = {\n\t\ttype: \"review.blocker_count\",\n\t\ttimestamp: new Date().toISOString(),\n\t\t...options,\n\t};\n\tconsole.log(\"[ReviewFlow Telemetry] Outstanding blocker count:\", event);\n}",
    "start_line": 302,
    "end_line": 315,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logOutstandingBlockerCount",
    "component_id": "src.features.spec.review-flow.telemetry.logOutstandingBlockerCount"
  },
  "src.features.spec.review-flow.types.SpecStatus": {
    "id": "src.features.spec.review-flow.types.SpecStatus",
    "name": "SpecStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "type SpecStatus =\n\t| \"current\"\n\t| \"readyToReview\"\n\t| \"review\"\n\t| \"reopened\"\n\t| \"archived\";",
    "start_line": 10,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SpecStatus",
    "component_id": "src.features.spec.review-flow.types.SpecStatus"
  },
  "src.features.spec.review-flow.types.ChangeRequestStatus": {
    "id": "src.features.spec.review-flow.types.ChangeRequestStatus",
    "name": "ChangeRequestStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "type ChangeRequestStatus =\n\t| \"open\"\n\t| \"blocked\"\n\t| \"inProgress\"\n\t| \"addressed\";",
    "start_line": 20,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeRequestStatus",
    "component_id": "src.features.spec.review-flow.types.ChangeRequestStatus"
  },
  "src.features.spec.review-flow.types.TaskLinkStatus": {
    "id": "src.features.spec.review-flow.types.TaskLinkStatus",
    "name": "TaskLinkStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "type TaskLinkStatus = \"open\" | \"inProgress\" | \"done\";",
    "start_line": 29,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TaskLinkStatus",
    "component_id": "src.features.spec.review-flow.types.TaskLinkStatus"
  },
  "src.features.spec.review-flow.types.ChangeRequestSeverity": {
    "id": "src.features.spec.review-flow.types.ChangeRequestSeverity",
    "name": "ChangeRequestSeverity",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "type ChangeRequestSeverity = \"low\" | \"medium\" | \"high\" | \"critical\";",
    "start_line": 34,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeRequestSeverity",
    "component_id": "src.features.spec.review-flow.types.ChangeRequestSeverity"
  },
  "src.features.spec.review-flow.types.SpecLinks": {
    "id": "src.features.spec.review-flow.types.SpecLinks",
    "name": "SpecLinks",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "interface SpecLinks {\n\tspecPath: string;\n\tdocUrl?: string;\n}",
    "start_line": 39,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecLinks",
    "component_id": "src.features.spec.review-flow.types.SpecLinks"
  },
  "src.features.spec.review-flow.types.Specification": {
    "id": "src.features.spec.review-flow.types.Specification",
    "name": "Specification",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.ChangeRequest",
      "src.features.spec.review-flow.types.SpecStatus",
      "src.features.spec.review-flow.types.SpecLinks"
    ],
    "source_code": "interface Specification {\n\tid: string;\n\ttitle: string;\n\towner: string;\n\tstatus: SpecStatus;\n\tcompletedAt: Date | null;\n\treviewEnteredAt?: Date | null;\n\tarchivedAt?: Date | null;\n\tupdatedAt: Date;\n\tlinks: SpecLinks;\n\tpendingTasks?: number;\n\tpendingChecklistItems?: number;\n\tchangeRequests?: ChangeRequest[];\n\twatchers?: string[];\n}",
    "start_line": 47,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Specification",
    "component_id": "src.features.spec.review-flow.types.Specification"
  },
  "src.features.spec.review-flow.types.TaskLink": {
    "id": "src.features.spec.review-flow.types.TaskLink",
    "name": "TaskLink",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.TaskLinkStatus"
    ],
    "source_code": "interface TaskLink {\n\ttaskId: string;\n\tsource: \"tasksPrompt\";\n\tstatus: TaskLinkStatus;\n\tcreatedAt: Date;\n}",
    "start_line": 66,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TaskLink",
    "component_id": "src.features.spec.review-flow.types.TaskLink"
  },
  "src.features.spec.review-flow.types.ChangeRequest": {
    "id": "src.features.spec.review-flow.types.ChangeRequest",
    "name": "ChangeRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.ChangeRequestSeverity",
      "src.features.spec.review-flow.types.TaskLink",
      "src.features.spec.review-flow.types.ChangeRequestStatus"
    ],
    "source_code": "interface ChangeRequest {\n\tid: string;\n\tspecId: string;\n\ttitle: string;\n\tdescription: string;\n\tseverity: ChangeRequestSeverity;\n\tstatus: ChangeRequestStatus;\n\ttasks: TaskLink[];\n\tsubmitter: string;\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n\tsentToTasksAt: Date | null;\n\tnotes?: string;\n\t/**\n\t * Flag indicating this change request currently blocks archiving/unarchiving actions.\n\t */\n\tarchivalBlocker?: boolean;\n}",
    "start_line": 76,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChangeRequest",
    "component_id": "src.features.spec.review-flow.types.ChangeRequest"
  },
  "src.features.spec.review-flow.types.ReviewTransitionTrigger": {
    "id": "src.features.spec.review-flow.types.ReviewTransitionTrigger",
    "name": "ReviewTransitionTrigger",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "type ReviewTransitionTrigger = \"auto\" | \"manual\";",
    "start_line": 95,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ReviewTransitionTrigger",
    "component_id": "src.features.spec.review-flow.types.ReviewTransitionTrigger"
  },
  "src.features.spec.review-flow.types.ReviewTransitionStatus": {
    "id": "src.features.spec.review-flow.types.ReviewTransitionStatus",
    "name": "ReviewTransitionStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [],
    "source_code": "type ReviewTransitionStatus = \"succeeded\" | \"failed\";",
    "start_line": 96,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ReviewTransitionStatus",
    "component_id": "src.features.spec.review-flow.types.ReviewTransitionStatus"
  },
  "src.features.spec.review-flow.types.ReviewTransitionEvent": {
    "id": "src.features.spec.review-flow.types.ReviewTransitionEvent",
    "name": "ReviewTransitionEvent",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/review-flow/types.ts",
    "relative_path": "src/features/spec/review-flow/types.ts",
    "depends_on": [
      "src.features.spec.review-flow.types.ReviewTransitionStatus",
      "src.features.spec.review-flow.types.ReviewTransitionTrigger"
    ],
    "source_code": "interface ReviewTransitionEvent {\n\teventId: string;\n\tspecId: string;\n\ttriggerType: ReviewTransitionTrigger;\n\tinitiatedBy?: string;\n\toccurredAt: Date;\n\tnotificationRecipients: string[];\n\tstatus: ReviewTransitionStatus;\n\tfailureReason?: string | null;\n}",
    "start_line": 98,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ReviewTransitionEvent",
    "component_id": "src.features.spec.review-flow.types.ReviewTransitionEvent"
  },
  "src.features.spec.spec-kit-manager.SpecKitManager": {
    "id": "src.features.spec.spec-kit-manager.SpecKitManager",
    "name": "SpecKitManager",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-kit-manager.ts",
    "relative_path": "src/features/spec/spec-kit-manager.ts",
    "depends_on": [
      "src.features.spec.spec-kit-manager.SpecKitManager",
      "src.features.spec.spec-kit-manager.getFileTemplate",
      "src.utils.spec-kit-utilities.createFeatureDirectoryName",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter",
      "src.utils.spec-kit-utilities.generateNextFeatureNumber",
      "src.features.spec.spec-kit-manager.createFeatureFiles",
      "src.utils.spec-kit-adapter.getSpecsBasePath"
    ],
    "source_code": "class SpecKitManager {\n\tprivate static instance: SpecKitManager;\n\n\tprivate constructor() {}\n\n\tstatic getInstance(): SpecKitManager {\n\t\tif (!SpecKitManager.instance) {\n\t\t\tSpecKitManager.instance = new SpecKitManager();\n\t\t}\n\t\treturn SpecKitManager.instance;\n\t}\n\n\t/**\n\t * Creates a new SpecKit feature with the necessary files\n\t */\n\tasync createFeature(\n\t\tname: string,\n\t\tcontext?: {\n\t\t\tproductContext?: string;\n\t\t\tkeyScenarios?: string;\n\t\t\ttechnicalConstraints?: string;\n\t\t}\n\t): Promise<string> {\n\t\tconst adapter = getSpecSystemAdapter();\n\t\tconst specsPath = adapter.getSpecsBasePath();\n\n\t\t// 1. Create directory\n\t\tconst nextNumber = generateNextFeatureNumber(specsPath);\n\t\tconst dirName = createFeatureDirectoryName(nextNumber, name);\n\t\tconst featurePath = join(specsPath, dirName);\n\n\t\tawait workspace.fs.createDirectory(Uri.file(featurePath));\n\n\t\t// 2. Create files\n\t\tawait this.createFeatureFiles(featurePath, name, context);\n\n\t\treturn featurePath;\n\t}\n\n\tprivate async createFeatureFiles(\n\t\tfeaturePath: string,\n\t\tname: string,\n\t\tcontext?: {\n\t\t\tproductContext?: string;\n\t\t\tkeyScenarios?: string;\n\t\t\ttechnicalConstraints?: string;\n\t\t}\n\t): Promise<void> {\n\t\tconst files = [\"spec.md\", \"plan.md\", \"tasks.md\"];\n\n\t\tfor (const file of files) {\n\t\t\tconst filePath = Uri.file(join(featurePath, file));\n\t\t\tconst content = this.getFileTemplate(file, name, context);\n\t\t\tawait workspace.fs.writeFile(filePath, Buffer.from(content));\n\t\t}\n\t}\n\n\tprivate getFileTemplate(\n\t\tfileName: string,\n\t\tfeatureName: string,\n\t\tcontext?: {\n\t\t\tproductContext?: string;\n\t\t\tkeyScenarios?: string;\n\t\t\ttechnicalConstraints?: string;\n\t\t}\n\t): string {\n\t\tconst baseContext = context?.productContext\n\t\t\t? `\\n\\n## Context\\n${context.productContext}`\n\t\t\t: \"\";\n\n\t\tswitch (fileName) {\n\t\t\tcase \"spec.md\":\n\t\t\t\treturn `# Specification: ${featureName}\n\n## Status\n- [ ] Draft\n- [ ] Approved\n\n## Overview\n${baseContext}\n\n## Scenarios\n${context?.keyScenarios || \"- Add scenarios here\"}\n\n## Constraints\n${context?.technicalConstraints || \"- Add constraints here\"}\n`;\n\t\t\tcase \"plan.md\":\n\t\t\t\treturn `# Implementation Plan: ${featureName}\n\n## Status\n- [ ] Draft\n- [ ] Approved\n\n## Proposed Changes\n- [ ] ...\n\n## Verification Plan\n- [ ] ...\n`;\n\t\t\tcase \"tasks.md\":\n\t\t\t\treturn `# Tasks: ${featureName}\n\n## Status\n- [ ] Todo\n- [ ] In Progress\n- [ ] Done\n\n## Task List\n- [ ] Initial setup\n`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t}\n}",
    "start_line": 9,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecKitManager",
    "component_id": "src.features.spec.spec-kit-manager.SpecKitManager"
  },
  "src.features.spec.spec-kit-manager.getInstance": {
    "id": "src.features.spec.spec-kit-manager.getInstance",
    "name": "getInstance",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-kit-manager.ts",
    "relative_path": "src/features/spec/spec-kit-manager.ts",
    "depends_on": [],
    "source_code": "static getInstance(): SpecKitManager {\n\t\tif (!SpecKitManager.instance) {\n\t\t\tSpecKitManager.instance = new SpecKitManager();\n\t\t}\n\t\treturn SpecKitManager.instance;\n\t}",
    "start_line": 14,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method getInstance",
    "component_id": "src.features.spec.spec-kit-manager.getInstance"
  },
  "src.features.spec.spec-kit-manager.createFeature": {
    "id": "src.features.spec.spec-kit-manager.createFeature",
    "name": "createFeature",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-kit-manager.ts",
    "relative_path": "src/features/spec/spec-kit-manager.ts",
    "depends_on": [],
    "source_code": "async createFeature(\n\t\tname: string,\n\t\tcontext?: {\n\t\t\tproductContext?: string;\n\t\t\tkeyScenarios?: string;\n\t\t\ttechnicalConstraints?: string;\n\t\t}\n\t): Promise<string> {\n\t\tconst adapter = getSpecSystemAdapter();\n\t\tconst specsPath = adapter.getSpecsBasePath();\n\n\t\t// 1. Create directory\n\t\tconst nextNumber = generateNextFeatureNumber(specsPath);\n\t\tconst dirName = createFeatureDirectoryName(nextNumber, name);\n\t\tconst featurePath = join(specsPath, dirName);\n\n\t\tawait workspace.fs.createDirectory(Uri.file(featurePath));\n\n\t\t// 2. Create files\n\t\tawait this.createFeatureFiles(featurePath, name, context);\n\n\t\treturn featurePath;\n\t}",
    "start_line": 24,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createFeature",
    "component_id": "src.features.spec.spec-kit-manager.createFeature"
  },
  "src.features.spec.spec-kit-manager.createFeatureFiles": {
    "id": "src.features.spec.spec-kit-manager.createFeatureFiles",
    "name": "createFeatureFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-kit-manager.ts",
    "relative_path": "src/features/spec/spec-kit-manager.ts",
    "depends_on": [],
    "source_code": "private async createFeatureFiles(\n\t\tfeaturePath: string,\n\t\tname: string,\n\t\tcontext?: {\n\t\t\tproductContext?: string;\n\t\t\tkeyScenarios?: string;\n\t\t\ttechnicalConstraints?: string;\n\t\t}\n\t): Promise<void> {\n\t\tconst files = [\"spec.md\", \"plan.md\", \"tasks.md\"];\n\n\t\tfor (const file of files) {\n\t\t\tconst filePath = Uri.file(join(featurePath, file));\n\t\t\tconst content = this.getFileTemplate(file, name, context);\n\t\t\tawait workspace.fs.writeFile(filePath, Buffer.from(content));\n\t\t}\n\t}",
    "start_line": 48,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "featurePath",
      "name",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createFeatureFiles",
    "component_id": "src.features.spec.spec-kit-manager.createFeatureFiles"
  },
  "src.features.spec.spec-kit-manager.getFileTemplate": {
    "id": "src.features.spec.spec-kit-manager.getFileTemplate",
    "name": "getFileTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-kit-manager.ts",
    "relative_path": "src/features/spec/spec-kit-manager.ts",
    "depends_on": [],
    "source_code": "private getFileTemplate(\n\t\tfileName: string,\n\t\tfeatureName: string,\n\t\tcontext?: {\n\t\t\tproductContext?: string;\n\t\t\tkeyScenarios?: string;\n\t\t\ttechnicalConstraints?: string;\n\t\t}\n\t): string {\n\t\tconst baseContext = context?.productContext\n\t\t\t? `\\n\\n## Context\\n${context.productContext}`\n\t\t\t: \"\";\n\n\t\tswitch (fileName) {\n\t\t\tcase \"spec.md\":\n\t\t\t\treturn `# Specification: ${featureName}\n\n## Status\n- [ ] Draft\n- [ ] Approved\n\n## Overview\n${baseContext}\n\n## Scenarios\n${context?.keyScenarios || \"- Add scenarios here\"}\n\n## Constraints\n${context?.technicalConstraints || \"- Add constraints here\"}\n`;\n\t\t\tcase \"plan.md\":\n\t\t\t\treturn `# Implementation Plan: ${featureName}\n\n## Status\n- [ ] Draft\n- [ ] Approved\n\n## Proposed Changes\n- [ ] ...\n\n## Verification Plan\n- [ ] ...\n`;\n\t\t\tcase \"tasks.md\":\n\t\t\t\treturn `# Tasks: ${featureName}\n\n## Status\n- [ ] Todo\n- [ ] In Progress\n- [ ] Done\n\n## Task List\n- [ ] Initial setup\n`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t}",
    "start_line": 66,
    "end_line": 123,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fileName",
      "featureName",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getFileTemplate",
    "component_id": "src.features.spec.spec-kit-manager.getFileTemplate"
  },
  "src.features.spec.spec-manager.SpecDocumentType": {
    "id": "src.features.spec.spec-manager.SpecDocumentType",
    "name": "SpecDocumentType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "type SpecDocumentType = \"requirements\" | \"design\" | \"tasks\";",
    "start_line": 29,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SpecDocumentType",
    "component_id": "src.features.spec.spec-manager.SpecDocumentType"
  },
  "src.features.spec.spec-manager.SpecManager": {
    "id": "src.features.spec.spec-manager.SpecManager",
    "name": "SpecManager",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [
      "src.features.hooks.trigger-registry.TriggerRegistry",
      "src.features.spec.spec-kit-manager.createFeature",
      "src.utils.config-manager.getPath",
      "src.features.spec.review-flow.state.getSpecState",
      "src.utils.config-manager.ConfigManager",
      "src.utils.spec-kit-adapter.listSpecs",
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.utils.config-manager.loadSettings",
      "src.constants.SpecSystemMode",
      "src.features.spec.spec-manager.openDocument",
      "src.features.spec.spec-manager.getActiveSystem",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter",
      "src.features.spec.spec-manager.getSpecBasePath",
      "src.features.spec.create-spec-input-controller.open",
      "src.utils.notification-utils.showAutoDismissNotification",
      "src.features.spec.spec-manager.initializeAdapter",
      "src.features.spec.spec-manager.getDirectories",
      "src.features.spec.create-spec-input-controller.CreateSpecInputController",
      "src.features.spec.spec-manager.SpecDocumentType",
      "src.features.spec.spec-manager.create",
      "src.features.spec.spec-manager.getAllSpecsUnified",
      "src.utils.spec-kit-adapter.getActiveSystem",
      "src.services.prompt-loader.PromptLoader",
      "src.utils.spec-kit-adapter.SpecSystemAdapter",
      "src.utils.spec-kit-adapter.getInstance",
      "src.features.spec.spec-submission-strategy.create",
      "src.features.spec.spec-manager.getSpecs",
      "src.utils.chat-prompt-runner.sendPromptToChat",
      "src.features.spec.spec-manager.delete"
    ],
    "source_code": "class SpecManager {\n\tprivate readonly configManager: ConfigManager;\n\tprivate readonly promptLoader: PromptLoader;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate createSpecInputController: CreateSpecInputController;\n\tprivate specAdapter: SpecSystemAdapter | null = null;\n\tprivate activeSystem: SpecSystemMode = SPEC_SYSTEM_MODE.AUTO;\n\tprivate triggerRegistry: TriggerRegistry | null = null;\n\n\tconstructor(context: ExtensionContext, outputChannel: OutputChannel) {\n\t\tthis.configManager = ConfigManager.getInstance();\n\t\tthis.configManager.loadSettings();\n\t\tthis.promptLoader = PromptLoader.getInstance();\n\t\tthis.outputChannel = outputChannel;\n\t\t// Initialize with default, will be updated after adapter init\n\t\tthis.createSpecInputController = new CreateSpecInputController({\n\t\t\tcontext,\n\t\t\tconfigManager: this.configManager,\n\t\t\tpromptLoader: this.promptLoader,\n\t\t\toutputChannel: this.outputChannel,\n\t\t\tactiveSystem: this.activeSystem,\n\t\t});\n\t\tthis.initializeAdapter(context);\n\t}\n\n\tprivate initializeAdapter(context: ExtensionContext): void {\n\t\ttry {\n\t\t\t// Adapter is already initialized in extension.ts\n\t\t\tthis.specAdapter = getSpecSystemAdapter();\n\t\t\tthis.activeSystem = this.specAdapter.getActiveSystem();\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Initialized with active spec system: ${this.activeSystem}`\n\t\t\t);\n\n\t\t\t// Re-initialize controller with correct system\n\t\t\tthis.createSpecInputController = new CreateSpecInputController({\n\t\t\t\tcontext,\n\t\t\t\tconfigManager: this.configManager,\n\t\t\t\tpromptLoader: this.promptLoader,\n\t\t\t\toutputChannel: this.outputChannel,\n\t\t\t\tactiveSystem: this.activeSystem,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Warning: Failed to get spec-kit adapter: ${error}`\n\t\t\t);\n\t\t\t// Fall back to OpenSpec mode\n\t\t\tthis.activeSystem = SPEC_SYSTEM_MODE.OPENSPEC;\n\n\t\t\t// Re-initialize controller with fallback system\n\t\t\tthis.createSpecInputController = new CreateSpecInputController({\n\t\t\t\tcontext,\n\t\t\t\tconfigManager: this.configManager,\n\t\t\t\tpromptLoader: this.promptLoader,\n\t\t\t\toutputChannel: this.outputChannel,\n\t\t\t\tactiveSystem: this.activeSystem,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Sets the TriggerRegistry for hook integration\n\t */\n\tsetTriggerRegistry(registry: TriggerRegistry): void {\n\t\tthis.triggerRegistry = registry;\n\t\tthis.outputChannel.appendLine(\"[SpecManager] TriggerRegistry connected\");\n\t}\n\n\t/**\n\t * Executes a SpecKit command\n\t *\n\t * NOTE: Triggers are now fired automatically by CommandCompletionDetector\n\t * when it detects file changes that indicate command completion.\n\t * This ensures triggers fire AFTER the command completes, not before.\n\t */\n\tasync executeSpecKitCommand(operation: string): Promise<void> {\n\t\ttry {\n\t\t\t// Send command to Copilot Chat\n\t\t\tawait sendPromptToChat(`/speckit.${operation}`);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Executed command: /speckit.${operation}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to execute speckit.${operation}`;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Error executing ${operation}: ${message}`\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the active spec system (OpenSpec, SpecKit, or Auto)\n\t */\n\tgetActiveSystem(): SpecSystemMode {\n\t\treturn this.activeSystem;\n\t}\n\n\tgetSpecBasePath(): string {\n\t\treturn this.configManager.getPath(\"specs\");\n\t}\n\n\tasync create() {\n\t\ttry {\n\t\t\tawait this.createSpecInputController.open();\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error ? error.message : \"Unable to open spec dialog\";\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to open Create Spec dialog: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to open Create Spec dialog: ${message}`);\n\t\t}\n\t}\n\n\tasync openDocument(relativePath: string, type: string) {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst docPath = join(workspaceFolder.uri.fsPath, relativePath);\n\n\t\ttry {\n\t\t\tconst doc = await workspace.openTextDocument(docPath);\n\t\t\tawait window.showTextDocument(doc);\n\t\t} catch (error) {\n\t\t\t// File doesn't exist, look for already open virtual documents\n\t\t\t// Create unique identifier for this spec document\n\t\t\tconst uniqueMarker = `<!-- openspec-spec: ${relativePath} -->`;\n\n\t\t\tfor (const doc of workspace.textDocuments) {\n\t\t\t\t// Check if this is an untitled document with our unique marker\n\t\t\t\tif (doc.isUntitled && doc.getText().includes(uniqueMarker)) {\n\t\t\t\t\t// Found our specific virtual document, show it\n\t\t\t\t\tawait window.showTextDocument(doc, {\n\t\t\t\t\t\tpreview: false,\n\t\t\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No existing virtual document found, create a new one\n\t\t\tlet placeholderContent = `${uniqueMarker}\n# ${type.charAt(0).toUpperCase() + type.slice(1)} Document\n\nThis document has not been created yet.`;\n\n\t\t\tif (type === \"design\") {\n\t\t\t\tplaceholderContent +=\n\t\t\t\t\t\"\\n\\nPlease approve the requirements document first.\";\n\t\t\t} else if (type === \"tasks\") {\n\t\t\t\tplaceholderContent += \"\\n\\nPlease approve the design document first.\";\n\t\t\t} else if (type === \"requirements\") {\n\t\t\t\tplaceholderContent +=\n\t\t\t\t\t'\\n\\nRun \"Create New Spec\" to generate this document.';\n\t\t\t}\n\n\t\t\t// Create a new untitled document\n\t\t\tconst doc = await workspace.openTextDocument({\n\t\t\t\tcontent: placeholderContent,\n\t\t\t\tlanguage: \"markdown\",\n\t\t\t});\n\n\t\t\t// Show it\n\t\t\tawait window.showTextDocument(doc, {\n\t\t\t\tpreview: false,\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync navigateToDocument(specName: string, type: SpecDocumentType) {\n\t\t// Legacy support or redirect to openDocument\n\t\t// Assuming specName is a current spec in openspec/specs\n\t\tconst path = join(this.getSpecBasePath(), \"specs\", specName, `${type}.md`);\n\t\tawait this.openDocument(path, type);\n\t}\n\n\tasync delete(specName: string, system?: SpecSystemMode): Promise<void> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Show confirmation dialog\n\t\tconst confirm = await window.showWarningMessage(\n\t\t\t`Are you sure you want to delete \"${specName}\"? This action cannot be undone.`,\n\t\t\t{ modal: true },\n\t\t\t\"Delete\"\n\t\t);\n\n\t\tif (confirm !== \"Delete\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use provided system or fall back to active system\n\t\tconst targetSystem = system || this.activeSystem;\n\n\t\t// Construct path based on system type\n\t\tlet specPath: string;\n\t\tif (targetSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t// SpecKit path: specs/<specName>\n\t\t\tspecPath = join(\n\t\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\t\tSPECKIT_CONFIG.paths.specs,\n\t\t\t\tspecName\n\t\t\t);\n\t\t} else {\n\t\t\t// OpenSpec path: openspec/specs/<specName>\n\t\t\tspecPath = join(\n\t\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\t\tDEFAULT_CONFIG.paths.specs,\n\t\t\t\t\"specs\",\n\t\t\t\tspecName\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\tawait workspace.fs.delete(Uri.file(specPath), {\n\t\t\t\trecursive: true,\n\t\t\t});\n\t\t\tawait NotificationUtils.showAutoDismissNotification(\n\t\t\t\t`Spec \"${specName}\" deleted successfully`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to delete spec: ${error}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to delete spec: ${error}`);\n\t\t}\n\t}\n\n\tprivate async getDirectories(subPath: string): Promise<string[]> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst fullPath = join(\n\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\tthis.getSpecBasePath(),\n\t\t\tsubPath\n\t\t);\n\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(Uri.file(fullPath));\n\t\t\treturn entries\n\t\t\t\t.filter(([, type]) => type === FileType.Directory)\n\t\t\t\t.map(([name]) => name);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to read directory ${fullPath}: ${error}`\n\t\t\t);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tasync getSpecs(): Promise<string[]> {\n\t\treturn await this.getDirectories(\"specs\");\n\t}\n\n\tasync getChanges(): Promise<string[]> {\n\t\tconst changes = await this.getDirectories(\"changes\");\n\t\treturn changes.filter((name) => name !== \"archive\");\n\t}\n\n\t/**\n\t * Get active change requests from review flow state (non-addressed)\n\t */\n\tasync getActiveChangeRequests(): Promise<\n\t\tArray<{\n\t\t\tspecId: string;\n\t\t\tspecTitle: string;\n\t\t\tchangeRequest: import(\"./review-flow/types\").ChangeRequest;\n\t\t}>\n\t> {\n\t\tconst { getSpecState } = await import(\"./review-flow/state\");\n\t\tconst unifiedSpecs = await this.getAllSpecsUnified();\n\n\t\tconst activeRequests: Array<{\n\t\t\tspecId: string;\n\t\t\tspecTitle: string;\n\t\t\tchangeRequest: import(\"./review-flow/types\").ChangeRequest;\n\t\t}> = [];\n\n\t\tfor (const spec of unifiedSpecs) {\n\t\t\tconst state = getSpecState(spec.id);\n\t\t\tif (state?.changeRequests) {\n\t\t\t\tfor (const cr of state.changeRequests) {\n\t\t\t\t\tif (cr.status !== \"addressed\") {\n\t\t\t\t\t\tactiveRequests.push({\n\t\t\t\t\t\t\tspecId: spec.id,\n\t\t\t\t\t\t\tspecTitle: spec.name,\n\t\t\t\t\t\t\tchangeRequest: cr,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn activeRequests;\n\t}\n\n\tasync getSpecList(): Promise<string[]> {\n\t\t// For backward compatibility, return specs\n\t\treturn await this.getSpecs();\n\t}\n\n\tasync runOpenSpecApply(documentUri: Uri) {\n\t\tif (this.activeSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\tawait sendPromptToChat(\"/speckit.implementation\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract change ID from path: .../openspec/changes/<change-id>/tasks.md\n\t\tconst changeId = basename(dirname(documentUri.fsPath));\n\n\t\t// Read prompt template from .github/prompts/openspec-apply.prompt.md\n\t\tconst promptPath = join(\n\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\t\".github\",\n\t\t\t\"prompts\",\n\t\t\t\"openspec-apply.prompt.md\"\n\t\t);\n\n\t\tlet promptContent = \"\";\n\t\ttry {\n\t\t\tconst promptUri = Uri.file(promptPath);\n\t\t\tconst promptData = await workspace.fs.readFile(promptUri);\n\t\t\tpromptContent = Buffer.from(promptData).toString(\"utf-8\");\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to read prompt file at ${promptPath}`;\n\t\t\tthis.outputChannel.appendLine(`[SpecManager] ${message}: ${error}`);\n\t\t\twindow.showErrorMessage(message);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append change ID\n\t\tconst finalPrompt = `${promptContent}\\n\\nid: ${changeId}`;\n\n\t\tawait sendPromptToChat(finalPrompt, { instructionType: \"startAllTask\" });\n\t}\n\n\tasync getChangeSpecs(changeName: string): Promise<string[]> {\n\t\treturn await this.getDirectories(`changes/${changeName}/specs`);\n\t}\n\n\t/**\n\t * Gets all available specs from both OpenSpec and SpecKit systems\n\t * This method unifies spec discovery across both systems\n\t */\n\tasync getAllSpecsUnified(): Promise<\n\t\tArray<{ id: string; name: string; system: SpecSystemMode }>\n\t> {\n\t\tif (!this.specAdapter) {\n\t\t\t// Fallback to OpenSpec-only if adapter failed\n\t\t\tconst specs = await this.getSpecs();\n\t\t\treturn specs.map((spec) => ({\n\t\t\t\tid: spec,\n\t\t\t\tname: spec,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t}));\n\t\t}\n\n\t\ttry {\n\t\t\tconst unifiedSpecs = await this.specAdapter.listSpecs();\n\t\t\treturn unifiedSpecs.map((spec) => ({\n\t\t\t\tid: spec.id,\n\t\t\t\tname: spec.name,\n\t\t\t\tsystem: spec.system,\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Warning: Failed to list unified specs: ${error}`\n\t\t\t);\n\t\t\t// Fallback to OpenSpec\n\t\t\tconst specs = await this.getSpecs();\n\t\t\treturn specs.map((spec) => ({\n\t\t\t\tid: spec,\n\t\t\t\tname: spec,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t}));\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new spec using the appropriate system (OpenSpec or SpecKit)\n\t */\n\tasync createUnified(specName: string): Promise<boolean> {\n\t\ttry {\n\t\t\tif (this.specAdapter && this.activeSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t\t// Use SpecKitManager to create feature with files\n\t\t\t\tconst manager = SpecKitManager.getInstance();\n\t\t\t\tawait manager.createFeature(specName);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[SpecManager] Created SpecKit feature: ${specName}`\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Use existing OpenSpec creation (via dialog)\n\t\t\tawait this.create();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to create spec: ${error}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to create spec: ${error}`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the adapter instance (for testing/debugging purposes)\n\t */\n\tgetAdapter(): SpecSystemAdapter | null {\n\t\treturn this.specAdapter;\n\t}\n}",
    "start_line": 31,
    "end_line": 463,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecManager",
    "component_id": "src.features.spec.spec-manager.SpecManager"
  },
  "src.features.spec.spec-manager.initializeAdapter": {
    "id": "src.features.spec.spec-manager.initializeAdapter",
    "name": "initializeAdapter",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "private initializeAdapter(context: ExtensionContext): void {\n\t\ttry {\n\t\t\t// Adapter is already initialized in extension.ts\n\t\t\tthis.specAdapter = getSpecSystemAdapter();\n\t\t\tthis.activeSystem = this.specAdapter.getActiveSystem();\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Initialized with active spec system: ${this.activeSystem}`\n\t\t\t);\n\n\t\t\t// Re-initialize controller with correct system\n\t\t\tthis.createSpecInputController = new CreateSpecInputController({\n\t\t\t\tcontext,\n\t\t\t\tconfigManager: this.configManager,\n\t\t\t\tpromptLoader: this.promptLoader,\n\t\t\t\toutputChannel: this.outputChannel,\n\t\t\t\tactiveSystem: this.activeSystem,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Warning: Failed to get spec-kit adapter: ${error}`\n\t\t\t);\n\t\t\t// Fall back to OpenSpec mode\n\t\t\tthis.activeSystem = SPEC_SYSTEM_MODE.OPENSPEC;\n\n\t\t\t// Re-initialize controller with fallback system\n\t\t\tthis.createSpecInputController = new CreateSpecInputController({\n\t\t\t\tcontext,\n\t\t\t\tconfigManager: this.configManager,\n\t\t\t\tpromptLoader: this.promptLoader,\n\t\t\t\toutputChannel: this.outputChannel,\n\t\t\t\tactiveSystem: this.activeSystem,\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 56,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initializeAdapter",
    "component_id": "src.features.spec.spec-manager.initializeAdapter"
  },
  "src.features.spec.spec-manager.setTriggerRegistry": {
    "id": "src.features.spec.spec-manager.setTriggerRegistry",
    "name": "setTriggerRegistry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "setTriggerRegistry(registry: TriggerRegistry): void {\n\t\tthis.triggerRegistry = registry;\n\t\tthis.outputChannel.appendLine(\"[SpecManager] TriggerRegistry connected\");\n\t}",
    "start_line": 95,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "registry"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setTriggerRegistry",
    "component_id": "src.features.spec.spec-manager.setTriggerRegistry"
  },
  "src.features.spec.spec-manager.executeSpecKitCommand": {
    "id": "src.features.spec.spec-manager.executeSpecKitCommand",
    "name": "executeSpecKitCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async executeSpecKitCommand(operation: string): Promise<void> {\n\t\ttry {\n\t\t\t// Send command to Copilot Chat\n\t\t\tawait sendPromptToChat(`/speckit.${operation}`);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Executed command: /speckit.${operation}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error\n\t\t\t\t\t? error.message\n\t\t\t\t\t: `Failed to execute speckit.${operation}`;\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Error executing ${operation}: ${message}`\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t}",
    "start_line": 107,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operation"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeSpecKitCommand",
    "component_id": "src.features.spec.spec-manager.executeSpecKitCommand"
  },
  "src.features.spec.spec-manager.getActiveSystem": {
    "id": "src.features.spec.spec-manager.getActiveSystem",
    "name": "getActiveSystem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "getActiveSystem(): SpecSystemMode {\n\t\treturn this.activeSystem;\n\t}",
    "start_line": 130,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getActiveSystem",
    "component_id": "src.features.spec.spec-manager.getActiveSystem"
  },
  "src.features.spec.spec-manager.getSpecBasePath": {
    "id": "src.features.spec.spec-manager.getSpecBasePath",
    "name": "getSpecBasePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "getSpecBasePath(): string {\n\t\treturn this.configManager.getPath(\"specs\");\n\t}",
    "start_line": 134,
    "end_line": 136,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecBasePath",
    "component_id": "src.features.spec.spec-manager.getSpecBasePath"
  },
  "src.features.spec.spec-manager.create": {
    "id": "src.features.spec.spec-manager.create",
    "name": "create",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async create() {\n\t\ttry {\n\t\t\tawait this.createSpecInputController.open();\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error ? error.message : \"Unable to open spec dialog\";\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to open Create Spec dialog: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to open Create Spec dialog: ${message}`);\n\t\t}\n\t}",
    "start_line": 138,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method create",
    "component_id": "src.features.spec.spec-manager.create"
  },
  "src.features.spec.spec-manager.openDocument": {
    "id": "src.features.spec.spec-manager.openDocument",
    "name": "openDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async openDocument(relativePath: string, type: string) {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst docPath = join(workspaceFolder.uri.fsPath, relativePath);\n\n\t\ttry {\n\t\t\tconst doc = await workspace.openTextDocument(docPath);\n\t\t\tawait window.showTextDocument(doc);\n\t\t} catch (error) {\n\t\t\t// File doesn't exist, look for already open virtual documents\n\t\t\t// Create unique identifier for this spec document\n\t\t\tconst uniqueMarker = `<!-- openspec-spec: ${relativePath} -->`;\n\n\t\t\tfor (const doc of workspace.textDocuments) {\n\t\t\t\t// Check if this is an untitled document with our unique marker\n\t\t\t\tif (doc.isUntitled && doc.getText().includes(uniqueMarker)) {\n\t\t\t\t\t// Found our specific virtual document, show it\n\t\t\t\t\tawait window.showTextDocument(doc, {\n\t\t\t\t\t\tpreview: false,\n\t\t\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No existing virtual document found, create a new one\n\t\t\tlet placeholderContent = `${uniqueMarker}\n# ${type.charAt(0).toUpperCase() + type.slice(1)} Document\n\nThis document has not been created yet.`;\n\n\t\t\tif (type === \"design\") {\n\t\t\t\tplaceholderContent +=\n\t\t\t\t\t\"\\n\\nPlease approve the requirements document first.\";\n\t\t\t} else if (type === \"tasks\") {\n\t\t\t\tplaceholderContent += \"\\n\\nPlease approve the design document first.\";\n\t\t\t} else if (type === \"requirements\") {\n\t\t\t\tplaceholderContent +=\n\t\t\t\t\t'\\n\\nRun \"Create New Spec\" to generate this document.';\n\t\t\t}\n\n\t\t\t// Create a new untitled document\n\t\t\tconst doc = await workspace.openTextDocument({\n\t\t\t\tcontent: placeholderContent,\n\t\t\t\tlanguage: \"markdown\",\n\t\t\t});\n\n\t\t\t// Show it\n\t\t\tawait window.showTextDocument(doc, {\n\t\t\t\tpreview: false,\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 151,
    "end_line": 207,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "relativePath",
      "type"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method openDocument",
    "component_id": "src.features.spec.spec-manager.openDocument"
  },
  "src.features.spec.spec-manager.navigateToDocument": {
    "id": "src.features.spec.spec-manager.navigateToDocument",
    "name": "navigateToDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async navigateToDocument(specName: string, type: SpecDocumentType) {\n\t\t// Legacy support or redirect to openDocument\n\t\t// Assuming specName is a current spec in openspec/specs\n\t\tconst path = join(this.getSpecBasePath(), \"specs\", specName, `${type}.md`);\n\t\tawait this.openDocument(path, type);\n\t}",
    "start_line": 209,
    "end_line": 214,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specName",
      "type"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method navigateToDocument",
    "component_id": "src.features.spec.spec-manager.navigateToDocument"
  },
  "src.features.spec.spec-manager.delete": {
    "id": "src.features.spec.spec-manager.delete",
    "name": "delete",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async delete(specName: string, system?: SpecSystemMode): Promise<void> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Show confirmation dialog\n\t\tconst confirm = await window.showWarningMessage(\n\t\t\t`Are you sure you want to delete \"${specName}\"? This action cannot be undone.`,\n\t\t\t{ modal: true },\n\t\t\t\"Delete\"\n\t\t);\n\n\t\tif (confirm !== \"Delete\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use provided system or fall back to active system\n\t\tconst targetSystem = system || this.activeSystem;\n\n\t\t// Construct path based on system type\n\t\tlet specPath: string;\n\t\tif (targetSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t// SpecKit path: specs/<specName>\n\t\t\tspecPath = join(\n\t\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\t\tSPECKIT_CONFIG.paths.specs,\n\t\t\t\tspecName\n\t\t\t);\n\t\t} else {\n\t\t\t// OpenSpec path: openspec/specs/<specName>\n\t\t\tspecPath = join(\n\t\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\t\tDEFAULT_CONFIG.paths.specs,\n\t\t\t\t\"specs\",\n\t\t\t\tspecName\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\tawait workspace.fs.delete(Uri.file(specPath), {\n\t\t\t\trecursive: true,\n\t\t\t});\n\t\t\tawait NotificationUtils.showAutoDismissNotification(\n\t\t\t\t`Spec \"${specName}\" deleted successfully`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to delete spec: ${error}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to delete spec: ${error}`);\n\t\t}\n\t}",
    "start_line": 216,
    "end_line": 269,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specName",
      "system"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method delete",
    "component_id": "src.features.spec.spec-manager.delete"
  },
  "src.features.spec.spec-manager.getDirectories": {
    "id": "src.features.spec.spec-manager.getDirectories",
    "name": "getDirectories",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "private async getDirectories(subPath: string): Promise<string[]> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst fullPath = join(\n\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\tthis.getSpecBasePath(),\n\t\t\tsubPath\n\t\t);\n\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(Uri.file(fullPath));\n\t\t\treturn entries\n\t\t\t\t.filter(([, type]) => type === FileType.Directory)\n\t\t\t\t.map(([name]) => name);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to read directory ${fullPath}: ${error}`\n\t\t\t);\n\t\t\treturn [];\n\t\t}\n\t}",
    "start_line": 271,
    "end_line": 294,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "subPath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getDirectories",
    "component_id": "src.features.spec.spec-manager.getDirectories"
  },
  "src.features.spec.spec-manager.getSpecs": {
    "id": "src.features.spec.spec-manager.getSpecs",
    "name": "getSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async getSpecs(): Promise<string[]> {\n\t\treturn await this.getDirectories(\"specs\");\n\t}",
    "start_line": 296,
    "end_line": 298,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getSpecs",
    "component_id": "src.features.spec.spec-manager.getSpecs"
  },
  "src.features.spec.spec-manager.getChanges": {
    "id": "src.features.spec.spec-manager.getChanges",
    "name": "getChanges",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async getChanges(): Promise<string[]> {\n\t\tconst changes = await this.getDirectories(\"changes\");\n\t\treturn changes.filter((name) => name !== \"archive\");\n\t}",
    "start_line": 300,
    "end_line": 303,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getChanges",
    "component_id": "src.features.spec.spec-manager.getChanges"
  },
  "src.features.spec.spec-manager.getActiveChangeRequests": {
    "id": "src.features.spec.spec-manager.getActiveChangeRequests",
    "name": "getActiveChangeRequests",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async getActiveChangeRequests(): Promise<\n\t\tArray<{\n\t\t\tspecId: string;\n\t\t\tspecTitle: string;\n\t\t\tchangeRequest: import(\"./review-flow/types\").ChangeRequest;\n\t\t}>\n\t> {\n\t\tconst { getSpecState } = await import(\"./review-flow/state\");\n\t\tconst unifiedSpecs = await this.getAllSpecsUnified();\n\n\t\tconst activeRequests: Array<{\n\t\t\tspecId: string;\n\t\t\tspecTitle: string;\n\t\t\tchangeRequest: import(\"./review-flow/types\").ChangeRequest;\n\t\t}> = [];\n\n\t\tfor (const spec of unifiedSpecs) {\n\t\t\tconst state = getSpecState(spec.id);\n\t\t\tif (state?.changeRequests) {\n\t\t\t\tfor (const cr of state.changeRequests) {\n\t\t\t\t\tif (cr.status !== \"addressed\") {\n\t\t\t\t\t\tactiveRequests.push({\n\t\t\t\t\t\t\tspecId: spec.id,\n\t\t\t\t\t\t\tspecTitle: spec.name,\n\t\t\t\t\t\t\tchangeRequest: cr,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn activeRequests;\n\t}",
    "start_line": 308,
    "end_line": 340,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getActiveChangeRequests",
    "component_id": "src.features.spec.spec-manager.getActiveChangeRequests"
  },
  "src.features.spec.spec-manager.getSpecList": {
    "id": "src.features.spec.spec-manager.getSpecList",
    "name": "getSpecList",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async getSpecList(): Promise<string[]> {\n\t\t// For backward compatibility, return specs\n\t\treturn await this.getSpecs();\n\t}",
    "start_line": 342,
    "end_line": 345,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getSpecList",
    "component_id": "src.features.spec.spec-manager.getSpecList"
  },
  "src.features.spec.spec-manager.runOpenSpecApply": {
    "id": "src.features.spec.spec-manager.runOpenSpecApply",
    "name": "runOpenSpecApply",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async runOpenSpecApply(documentUri: Uri) {\n\t\tif (this.activeSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\tawait sendPromptToChat(\"/speckit.implementation\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract change ID from path: .../openspec/changes/<change-id>/tasks.md\n\t\tconst changeId = basename(dirname(documentUri.fsPath));\n\n\t\t// Read prompt template from .github/prompts/openspec-apply.prompt.md\n\t\tconst promptPath = join(\n\t\t\tworkspaceFolder.uri.fsPath,\n\t\t\t\".github\",\n\t\t\t\"prompts\",\n\t\t\t\"openspec-apply.prompt.md\"\n\t\t);\n\n\t\tlet promptContent = \"\";\n\t\ttry {\n\t\t\tconst promptUri = Uri.file(promptPath);\n\t\t\tconst promptData = await workspace.fs.readFile(promptUri);\n\t\t\tpromptContent = Buffer.from(promptData).toString(\"utf-8\");\n\t\t} catch (error) {\n\t\t\tconst message = `Failed to read prompt file at ${promptPath}`;\n\t\t\tthis.outputChannel.appendLine(`[SpecManager] ${message}: ${error}`);\n\t\t\twindow.showErrorMessage(message);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append change ID\n\t\tconst finalPrompt = `${promptContent}\\n\\nid: ${changeId}`;\n\n\t\tawait sendPromptToChat(finalPrompt, { instructionType: \"startAllTask\" });\n\t}",
    "start_line": 347,
    "end_line": 386,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentUri"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method runOpenSpecApply",
    "component_id": "src.features.spec.spec-manager.runOpenSpecApply"
  },
  "src.features.spec.spec-manager.getChangeSpecs": {
    "id": "src.features.spec.spec-manager.getChangeSpecs",
    "name": "getChangeSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async getChangeSpecs(changeName: string): Promise<string[]> {\n\t\treturn await this.getDirectories(`changes/${changeName}/specs`);\n\t}",
    "start_line": 388,
    "end_line": 390,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changeName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getChangeSpecs",
    "component_id": "src.features.spec.spec-manager.getChangeSpecs"
  },
  "src.features.spec.spec-manager.getAllSpecsUnified": {
    "id": "src.features.spec.spec-manager.getAllSpecsUnified",
    "name": "getAllSpecsUnified",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async getAllSpecsUnified(): Promise<\n\t\tArray<{ id: string; name: string; system: SpecSystemMode }>\n\t> {\n\t\tif (!this.specAdapter) {\n\t\t\t// Fallback to OpenSpec-only if adapter failed\n\t\t\tconst specs = await this.getSpecs();\n\t\t\treturn specs.map((spec) => ({\n\t\t\t\tid: spec,\n\t\t\t\tname: spec,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t}));\n\t\t}\n\n\t\ttry {\n\t\t\tconst unifiedSpecs = await this.specAdapter.listSpecs();\n\t\t\treturn unifiedSpecs.map((spec) => ({\n\t\t\t\tid: spec.id,\n\t\t\t\tname: spec.name,\n\t\t\t\tsystem: spec.system,\n\t\t\t}));\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Warning: Failed to list unified specs: ${error}`\n\t\t\t);\n\t\t\t// Fallback to OpenSpec\n\t\t\tconst specs = await this.getSpecs();\n\t\t\treturn specs.map((spec) => ({\n\t\t\t\tid: spec,\n\t\t\t\tname: spec,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t}));\n\t\t}\n\t}",
    "start_line": 396,
    "end_line": 428,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getAllSpecsUnified",
    "component_id": "src.features.spec.spec-manager.getAllSpecsUnified"
  },
  "src.features.spec.spec-manager.createUnified": {
    "id": "src.features.spec.spec-manager.createUnified",
    "name": "createUnified",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "async createUnified(specName: string): Promise<boolean> {\n\t\ttry {\n\t\t\tif (this.specAdapter && this.activeSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t\t// Use SpecKitManager to create feature with files\n\t\t\t\tconst manager = SpecKitManager.getInstance();\n\t\t\t\tawait manager.createFeature(specName);\n\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[SpecManager] Created SpecKit feature: ${specName}`\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Use existing OpenSpec creation (via dialog)\n\t\t\tawait this.create();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[SpecManager] Failed to create spec: ${error}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to create spec: ${error}`);\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 433,
    "end_line": 455,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createUnified",
    "component_id": "src.features.spec.spec-manager.createUnified"
  },
  "src.features.spec.spec-manager.getAdapter": {
    "id": "src.features.spec.spec-manager.getAdapter",
    "name": "getAdapter",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-manager.ts",
    "relative_path": "src/features/spec/spec-manager.ts",
    "depends_on": [],
    "source_code": "getAdapter(): SpecSystemAdapter | null {\n\t\treturn this.specAdapter;\n\t}",
    "start_line": 460,
    "end_line": 462,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAdapter",
    "component_id": "src.features.spec.spec-manager.getAdapter"
  },
  "src.features.spec.spec-submission-strategy.SpecSubmissionContext": {
    "id": "src.features.spec.spec-submission-strategy.SpecSubmissionContext",
    "name": "SpecSubmissionContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [],
    "source_code": "interface SpecSubmissionContext {\n\tproductContext: string;\n\tkeyScenarios: string;\n\ttechnicalConstraints: string;\n\trelatedFiles: string;\n\topenQuestions: string;\n}",
    "start_line": 5,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecSubmissionContext",
    "component_id": "src.features.spec.spec-submission-strategy.SpecSubmissionContext"
  },
  "src.features.spec.spec-submission-strategy.SpecSubmissionStrategy": {
    "id": "src.features.spec.spec-submission-strategy.SpecSubmissionStrategy",
    "name": "SpecSubmissionStrategy",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [
      "src.features.spec.spec-submission-strategy.SpecSubmissionContext"
    ],
    "source_code": "interface SpecSubmissionStrategy {\n\tsubmit(context: SpecSubmissionContext): Promise<void>;\n}",
    "start_line": 13,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecSubmissionStrategy",
    "component_id": "src.features.spec.spec-submission-strategy.SpecSubmissionStrategy"
  },
  "src.features.spec.spec-submission-strategy.OpenSpecSubmissionStrategy": {
    "id": "src.features.spec.spec-submission-strategy.OpenSpecSubmissionStrategy",
    "name": "OpenSpecSubmissionStrategy",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [
      "src.features.spec.spec-submission-strategy.SpecSubmissionContext",
      "src.features.spec.spec-submission-strategy.SpecSubmissionStrategy",
      "src.providers.hooks-explorer-provider.formatDescription",
      "src.features.spec.spec-submission-strategy.formatDescription",
      "src.utils.chat-prompt-runner.sendPromptToChat"
    ],
    "source_code": "class OpenSpecSubmissionStrategy implements SpecSubmissionStrategy {\n\tasync submit(context: SpecSubmissionContext): Promise<void> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\tthrow new Error(\"No workspace folder open\");\n\t\t}\n\n\t\tconst payload = this.formatDescription(context);\n\n\t\tconst promptUri = Uri.joinPath(\n\t\t\tworkspaceFolder.uri,\n\t\t\t\".github\",\n\t\t\t\"prompts\",\n\t\t\t\"openspec-proposal.prompt.md\"\n\t\t);\n\t\tlet promptTemplate = \"\";\n\t\ttry {\n\t\t\tconst fileData = await workspace.fs.readFile(promptUri);\n\t\t\tpromptTemplate = new TextDecoder().decode(fileData);\n\t\t} catch (error) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Required prompt file not found: .github/prompts/openspec-proposal.prompt.md\"\n\t\t\t);\n\t\t}\n\n\t\tconst prompt = `${promptTemplate}\\n\\nThe following sections describe the specification and context for this change request.\\n\\n${payload}\\n\\nIMPORTANT:\\nAfter generating the proposal documents, you MUST STOP and ask the user for confirmation.\\nDo NOT proceed with any implementation steps until the user has explicitly approved the proposal.`;\n\n\t\tawait sendPromptToChat(prompt, { instructionType: \"createSpec\" });\n\t}\n\n\tprivate formatDescription(data: SpecSubmissionContext): string {\n\t\tconst sections = [\n\t\t\tdata.productContext.trim()\n\t\t\t\t? `Product Context / Goal:\\n${data.productContext.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.keyScenarios.trim()\n\t\t\t\t? `Key Scenarios / Acceptance Criteria:\\n${data.keyScenarios.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.technicalConstraints.trim()\n\t\t\t\t? `Technical Constraints:\\n${data.technicalConstraints.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.relatedFiles.trim()\n\t\t\t\t? `Related Files / Impact:\\n${data.relatedFiles.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.openQuestions.trim()\n\t\t\t\t? `Open Questions:\\n${data.openQuestions.trim()}`\n\t\t\t\t: undefined,\n\t\t].filter(Boolean);\n\n\t\treturn sections.join(\"\\n\\n\");\n\t}\n}",
    "start_line": 17,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class OpenSpecSubmissionStrategy",
    "component_id": "src.features.spec.spec-submission-strategy.OpenSpecSubmissionStrategy"
  },
  "src.features.spec.spec-submission-strategy.submit": {
    "id": "src.features.spec.spec-submission-strategy.submit",
    "name": "submit",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [],
    "source_code": "async submit(context: SpecSubmissionContext): Promise<void> {\n\t\t// Format the description and send to Speckit agent\n\t\tconst payload = this.formatDescription(context);\n\t\tconst prompt = `/speckit.specify ${payload}`;\n\n\t\tawait sendPromptToChat(prompt, { instructionType: \"createSpec\" });\n\t}",
    "start_line": 71,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method submit",
    "component_id": "src.features.spec.spec-submission-strategy.submit"
  },
  "src.features.spec.spec-submission-strategy.formatDescription": {
    "id": "src.features.spec.spec-submission-strategy.formatDescription",
    "name": "formatDescription",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [],
    "source_code": "private formatDescription(data: SpecSubmissionContext): string {\n\t\tconst sections = [\n\t\t\tdata.productContext.trim()\n\t\t\t\t? `Product Context / Goal:\\n${data.productContext.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.keyScenarios.trim()\n\t\t\t\t? `Key Scenarios / Acceptance Criteria:\\n${data.keyScenarios.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.technicalConstraints.trim()\n\t\t\t\t? `Technical Constraints:\\n${data.technicalConstraints.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.relatedFiles.trim()\n\t\t\t\t? `Related Files / Impact:\\n${data.relatedFiles.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.openQuestions.trim()\n\t\t\t\t? `Open Questions:\\n${data.openQuestions.trim()}`\n\t\t\t\t: undefined,\n\t\t].filter(Boolean);\n\n\t\treturn sections.join(\"\\n\\n\");\n\t}",
    "start_line": 79,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method formatDescription",
    "component_id": "src.features.spec.spec-submission-strategy.formatDescription"
  },
  "src.features.spec.spec-submission-strategy.SpecKitSubmissionStrategy": {
    "id": "src.features.spec.spec-submission-strategy.SpecKitSubmissionStrategy",
    "name": "SpecKitSubmissionStrategy",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [
      "src.features.spec.spec-submission-strategy.SpecSubmissionContext",
      "src.features.spec.spec-submission-strategy.SpecSubmissionStrategy",
      "src.providers.hooks-explorer-provider.formatDescription",
      "src.features.spec.spec-submission-strategy.formatDescription",
      "src.utils.chat-prompt-runner.sendPromptToChat"
    ],
    "source_code": "class SpecKitSubmissionStrategy implements SpecSubmissionStrategy {\n\tasync submit(context: SpecSubmissionContext): Promise<void> {\n\t\t// Format the description and send to Speckit agent\n\t\tconst payload = this.formatDescription(context);\n\t\tconst prompt = `/speckit.specify ${payload}`;\n\n\t\tawait sendPromptToChat(prompt, { instructionType: \"createSpec\" });\n\t}\n\n\tprivate formatDescription(data: SpecSubmissionContext): string {\n\t\tconst sections = [\n\t\t\tdata.productContext.trim()\n\t\t\t\t? `Product Context / Goal:\\n${data.productContext.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.keyScenarios.trim()\n\t\t\t\t? `Key Scenarios / Acceptance Criteria:\\n${data.keyScenarios.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.technicalConstraints.trim()\n\t\t\t\t? `Technical Constraints:\\n${data.technicalConstraints.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.relatedFiles.trim()\n\t\t\t\t? `Related Files / Impact:\\n${data.relatedFiles.trim()}`\n\t\t\t\t: undefined,\n\t\t\tdata.openQuestions.trim()\n\t\t\t\t? `Open Questions:\\n${data.openQuestions.trim()}`\n\t\t\t\t: undefined,\n\t\t].filter(Boolean);\n\n\t\treturn sections.join(\"\\n\\n\");\n\t}\n}",
    "start_line": 70,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecKitSubmissionStrategy",
    "component_id": "src.features.spec.spec-submission-strategy.SpecKitSubmissionStrategy"
  },
  "src.features.spec.spec-submission-strategy.SpecSubmissionStrategyFactory": {
    "id": "src.features.spec.spec-submission-strategy.SpecSubmissionStrategyFactory",
    "name": "SpecSubmissionStrategyFactory",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [
      "src.constants.SpecSystemMode",
      "src.features.spec.spec-submission-strategy.SpecKitSubmissionStrategy",
      "src.features.spec.spec-submission-strategy.SpecSubmissionStrategy",
      "src.features.spec.spec-submission-strategy.OpenSpecSubmissionStrategy"
    ],
    "source_code": "class SpecSubmissionStrategyFactory {\n\tstatic create(mode: SpecSystemMode): SpecSubmissionStrategy {\n\t\tswitch (mode) {\n\t\t\tcase SPEC_SYSTEM_MODE.SPECKIT:\n\t\t\t\treturn new SpecKitSubmissionStrategy();\n\t\t\tdefault:\n\t\t\t\treturn new OpenSpecSubmissionStrategy();\n\t\t}\n\t}\n}",
    "start_line": 102,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecSubmissionStrategyFactory",
    "component_id": "src.features.spec.spec-submission-strategy.SpecSubmissionStrategyFactory"
  },
  "src.features.spec.spec-submission-strategy.create": {
    "id": "src.features.spec.spec-submission-strategy.create",
    "name": "create",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/spec-submission-strategy.ts",
    "relative_path": "src/features/spec/spec-submission-strategy.ts",
    "depends_on": [],
    "source_code": "static create(mode: SpecSystemMode): SpecSubmissionStrategy {\n\t\tswitch (mode) {\n\t\t\tcase SPEC_SYSTEM_MODE.SPECKIT:\n\t\t\t\treturn new SpecKitSubmissionStrategy();\n\t\t\tdefault:\n\t\t\t\treturn new OpenSpecSubmissionStrategy();\n\t\t}\n\t}",
    "start_line": 103,
    "end_line": 110,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mode"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method create",
    "component_id": "src.features.spec.spec-submission-strategy.create"
  },
  "src.features.spec.types.CreateSpecFormData": {
    "id": "src.features.spec.types.CreateSpecFormData",
    "name": "CreateSpecFormData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecFormData {\n\tproductContext: string;\n\tkeyScenarios: string;\n\ttechnicalConstraints: string;\n\trelatedFiles: string;\n\topenQuestions: string;\n}",
    "start_line": 1,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecFormData",
    "component_id": "src.features.spec.types.CreateSpecFormData"
  },
  "src.features.spec.types.CreateSpecDraftState": {
    "id": "src.features.spec.types.CreateSpecDraftState",
    "name": "CreateSpecDraftState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [
      "src.features.spec.types.CreateSpecFormData"
    ],
    "source_code": "interface CreateSpecDraftState {\n\tformData: CreateSpecFormData;\n\tlastUpdated: number;\n}",
    "start_line": 9,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecDraftState",
    "component_id": "src.features.spec.types.CreateSpecDraftState"
  },
  "src.features.spec.types.CreateSpecInitPayload": {
    "id": "src.features.spec.types.CreateSpecInitPayload",
    "name": "CreateSpecInitPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [
      "src.features.spec.types.CreateSpecDraftState"
    ],
    "source_code": "interface CreateSpecInitPayload {\n\tshouldFocusPrimaryField: boolean;\n\tdraft?: CreateSpecDraftState;\n}",
    "start_line": 14,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecInitPayload",
    "component_id": "src.features.spec.types.CreateSpecInitPayload"
  },
  "src.features.spec.types.CreateSpecSubmitSuccessMessage": {
    "id": "src.features.spec.types.CreateSpecSubmitSuccessMessage",
    "name": "CreateSpecSubmitSuccessMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecSubmitSuccessMessage {\n\ttype: \"create-spec/submit:success\";\n}",
    "start_line": 19,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecSubmitSuccessMessage",
    "component_id": "src.features.spec.types.CreateSpecSubmitSuccessMessage"
  },
  "src.features.spec.types.CreateSpecSubmitErrorMessage": {
    "id": "src.features.spec.types.CreateSpecSubmitErrorMessage",
    "name": "CreateSpecSubmitErrorMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecSubmitErrorMessage {\n\ttype: \"create-spec/submit:error\";\n\tpayload: { message: string };\n}",
    "start_line": 23,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecSubmitErrorMessage",
    "component_id": "src.features.spec.types.CreateSpecSubmitErrorMessage"
  },
  "src.features.spec.types.CreateSpecConfirmCloseMessage": {
    "id": "src.features.spec.types.CreateSpecConfirmCloseMessage",
    "name": "CreateSpecConfirmCloseMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecConfirmCloseMessage {\n\ttype: \"create-spec/confirm-close\";\n\tpayload: { shouldClose: boolean };\n}",
    "start_line": 28,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecConfirmCloseMessage",
    "component_id": "src.features.spec.types.CreateSpecConfirmCloseMessage"
  },
  "src.features.spec.types.CreateSpecFocusMessage": {
    "id": "src.features.spec.types.CreateSpecFocusMessage",
    "name": "CreateSpecFocusMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecFocusMessage {\n\ttype: \"create-spec/focus\";\n}",
    "start_line": 33,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecFocusMessage",
    "component_id": "src.features.spec.types.CreateSpecFocusMessage"
  },
  "src.features.spec.types.CreateSpecInitMessage": {
    "id": "src.features.spec.types.CreateSpecInitMessage",
    "name": "CreateSpecInitMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [
      "src.features.spec.types.CreateSpecInitPayload"
    ],
    "source_code": "interface CreateSpecInitMessage {\n\ttype: \"create-spec/init\";\n\tpayload: CreateSpecInitPayload;\n}",
    "start_line": 37,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecInitMessage",
    "component_id": "src.features.spec.types.CreateSpecInitMessage"
  },
  "src.features.spec.types.CreateSpecExtensionMessage": {
    "id": "src.features.spec.types.CreateSpecExtensionMessage",
    "name": "CreateSpecExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "type CreateSpecExtensionMessage =\n\t| CreateSpecInitMessage\n\t| CreateSpecSubmitSuccessMessage\n\t| CreateSpecSubmitErrorMessage\n\t| CreateSpecConfirmCloseMessage\n\t| CreateSpecFocusMessage;",
    "start_line": 42,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSpecExtensionMessage",
    "component_id": "src.features.spec.types.CreateSpecExtensionMessage"
  },
  "src.features.spec.types.CreateSpecSubmitMessage": {
    "id": "src.features.spec.types.CreateSpecSubmitMessage",
    "name": "CreateSpecSubmitMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [
      "src.features.spec.types.CreateSpecFormData"
    ],
    "source_code": "interface CreateSpecSubmitMessage {\n\ttype: \"create-spec/submit\";\n\tpayload: CreateSpecFormData;\n}",
    "start_line": 49,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecSubmitMessage",
    "component_id": "src.features.spec.types.CreateSpecSubmitMessage"
  },
  "src.features.spec.types.CreateSpecAutosaveMessage": {
    "id": "src.features.spec.types.CreateSpecAutosaveMessage",
    "name": "CreateSpecAutosaveMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [
      "src.features.spec.types.CreateSpecFormData"
    ],
    "source_code": "interface CreateSpecAutosaveMessage {\n\ttype: \"create-spec/autosave\";\n\tpayload: CreateSpecFormData;\n}",
    "start_line": 54,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecAutosaveMessage",
    "component_id": "src.features.spec.types.CreateSpecAutosaveMessage"
  },
  "src.features.spec.types.CreateSpecCloseAttemptMessage": {
    "id": "src.features.spec.types.CreateSpecCloseAttemptMessage",
    "name": "CreateSpecCloseAttemptMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecCloseAttemptMessage {\n\ttype: \"create-spec/close-attempt\";\n\tpayload: { hasDirtyChanges: boolean };\n}",
    "start_line": 59,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecCloseAttemptMessage",
    "component_id": "src.features.spec.types.CreateSpecCloseAttemptMessage"
  },
  "src.features.spec.types.CreateSpecCancelMessage": {
    "id": "src.features.spec.types.CreateSpecCancelMessage",
    "name": "CreateSpecCancelMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecCancelMessage {\n\ttype: \"create-spec/cancel\";\n}",
    "start_line": 64,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecCancelMessage",
    "component_id": "src.features.spec.types.CreateSpecCancelMessage"
  },
  "src.features.spec.types.CreateSpecReadyMessage": {
    "id": "src.features.spec.types.CreateSpecReadyMessage",
    "name": "CreateSpecReadyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecReadyMessage {\n\ttype: \"create-spec/ready\";\n}",
    "start_line": 68,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecReadyMessage",
    "component_id": "src.features.spec.types.CreateSpecReadyMessage"
  },
  "src.features.spec.types.CreateSpecWebviewMessage": {
    "id": "src.features.spec.types.CreateSpecWebviewMessage",
    "name": "CreateSpecWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/spec/types.ts",
    "relative_path": "src/features/spec/types.ts",
    "depends_on": [],
    "source_code": "type CreateSpecWebviewMessage =\n\t| CreateSpecSubmitMessage\n\t| CreateSpecAutosaveMessage\n\t| CreateSpecCloseAttemptMessage\n\t| CreateSpecCancelMessage\n\t| CreateSpecReadyMessage;",
    "start_line": 72,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSpecWebviewMessage",
    "component_id": "src.features.spec.types.CreateSpecWebviewMessage"
  },
  "src.features.steering.constitution-manager.ConstitutionManager": {
    "id": "src.features.steering.constitution-manager.ConstitutionManager",
    "name": "ConstitutionManager",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/constitution-manager.ts",
    "relative_path": "src/features/steering/constitution-manager.ts",
    "depends_on": [
      "src.features.steering.constitution-manager.createDefaultConstitution",
      "src.features.steering.constitution-manager.getConstitutionPath",
      "src.utils.spec-kit-utilities.getConstitutionPath"
    ],
    "source_code": "class ConstitutionManager {\n\tprivate readonly workspaceRoot: string;\n\n\tconstructor(workspaceRoot: string) {\n\t\tthis.workspaceRoot = workspaceRoot;\n\t}\n\n\tgetConstitutionPath(): string {\n\t\treturn getConstitutionPath(this.workspaceRoot);\n\t}\n\n\tensureConstitutionExists(): boolean {\n\t\tconst filePath = this.getConstitutionPath();\n\t\treturn existsSync(filePath);\n\t}\n\n\tasync openConstitution(): Promise<void> {\n\t\tconst filePath = this.getConstitutionPath();\n\t\tif (!existsSync(filePath)) {\n\t\t\tconst create = await window.showInformationMessage(\n\t\t\t\t\"Constitution file not found. Create one?\",\n\t\t\t\t\"Yes\",\n\t\t\t\t\"No\"\n\t\t\t);\n\t\t\tif (create === \"Yes\") {\n\t\t\t\tawait this.createDefaultConstitution();\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst document = await workspace.openTextDocument(filePath);\n\t\tawait window.showTextDocument(document, {\n\t\t\tpreview: false,\n\t\t\tviewColumn: ViewColumn.Active,\n\t\t});\n\t}\n\n\tasync createDefaultConstitution(): Promise<void> {\n\t\tconst filePath = this.getConstitutionPath();\n\t\tconst defaultContent = `# Project Constitution\n\n## 1. Core Principles\n- **Quality First**: Code must be clean, tested, and maintainable.\n- **User Centric**: Features must provide value to the user.\n\n## 2. Technical Standards\n- Use TypeScript for all new code.\n- Follow the project's linting rules.\n\n## 3. Workflow\n- All changes must be specified before implementation.\n- Use the SpecKit workflow: Specify -> Plan -> Implement.\n`;\n\n\t\tconst uri = Uri.file(filePath);\n\t\t// Ensure directory exists\n\t\tconst dirPath = Uri.file(join(filePath, \"..\"));\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(dirPath);\n\t\t} catch (e) {\n\t\t\t// Ignore if exists\n\t\t}\n\n\t\tawait workspace.fs.writeFile(uri, Buffer.from(defaultContent));\n\t}\n\n\t// Future: Add validation logic here\n\tvalidateConstitution(): boolean {\n\t\t// Placeholder for validation logic\n\t\treturn true;\n\t}\n}",
    "start_line": 6,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ConstitutionManager",
    "component_id": "src.features.steering.constitution-manager.ConstitutionManager"
  },
  "src.features.steering.constitution-manager.getConstitutionPath": {
    "id": "src.features.steering.constitution-manager.getConstitutionPath",
    "name": "getConstitutionPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/constitution-manager.ts",
    "relative_path": "src/features/steering/constitution-manager.ts",
    "depends_on": [],
    "source_code": "getConstitutionPath(): string {\n\t\treturn getConstitutionPath(this.workspaceRoot);\n\t}",
    "start_line": 13,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getConstitutionPath",
    "component_id": "src.features.steering.constitution-manager.getConstitutionPath"
  },
  "src.features.steering.constitution-manager.ensureConstitutionExists": {
    "id": "src.features.steering.constitution-manager.ensureConstitutionExists",
    "name": "ensureConstitutionExists",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/constitution-manager.ts",
    "relative_path": "src/features/steering/constitution-manager.ts",
    "depends_on": [],
    "source_code": "ensureConstitutionExists(): boolean {\n\t\tconst filePath = this.getConstitutionPath();\n\t\treturn existsSync(filePath);\n\t}",
    "start_line": 17,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ensureConstitutionExists",
    "component_id": "src.features.steering.constitution-manager.ensureConstitutionExists"
  },
  "src.features.steering.constitution-manager.openConstitution": {
    "id": "src.features.steering.constitution-manager.openConstitution",
    "name": "openConstitution",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/constitution-manager.ts",
    "relative_path": "src/features/steering/constitution-manager.ts",
    "depends_on": [],
    "source_code": "async openConstitution(): Promise<void> {\n\t\tconst filePath = this.getConstitutionPath();\n\t\tif (!existsSync(filePath)) {\n\t\t\tconst create = await window.showInformationMessage(\n\t\t\t\t\"Constitution file not found. Create one?\",\n\t\t\t\t\"Yes\",\n\t\t\t\t\"No\"\n\t\t\t);\n\t\t\tif (create === \"Yes\") {\n\t\t\t\tawait this.createDefaultConstitution();\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst document = await workspace.openTextDocument(filePath);\n\t\tawait window.showTextDocument(document, {\n\t\t\tpreview: false,\n\t\t\tviewColumn: ViewColumn.Active,\n\t\t});\n\t}",
    "start_line": 22,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method openConstitution",
    "component_id": "src.features.steering.constitution-manager.openConstitution"
  },
  "src.features.steering.constitution-manager.createDefaultConstitution": {
    "id": "src.features.steering.constitution-manager.createDefaultConstitution",
    "name": "createDefaultConstitution",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/constitution-manager.ts",
    "relative_path": "src/features/steering/constitution-manager.ts",
    "depends_on": [],
    "source_code": "async createDefaultConstitution(): Promise<void> {\n\t\tconst filePath = this.getConstitutionPath();\n\t\tconst defaultContent = `# Project Constitution\n\n## 1. Core Principles\n- **Quality First**: Code must be clean, tested, and maintainable.\n- **User Centric**: Features must provide value to the user.\n\n## 2. Technical Standards\n- Use TypeScript for all new code.\n- Follow the project's linting rules.\n\n## 3. Workflow\n- All changes must be specified before implementation.\n- Use the SpecKit workflow: Specify -> Plan -> Implement.\n`;\n\n\t\tconst uri = Uri.file(filePath);\n\t\t// Ensure directory exists\n\t\tconst dirPath = Uri.file(join(filePath, \"..\"));\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(dirPath);\n\t\t} catch (e) {\n\t\t\t// Ignore if exists\n\t\t}\n\n\t\tawait workspace.fs.writeFile(uri, Buffer.from(defaultContent));\n\t}",
    "start_line": 44,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createDefaultConstitution",
    "component_id": "src.features.steering.constitution-manager.createDefaultConstitution"
  },
  "src.features.steering.constitution-manager.validateConstitution": {
    "id": "src.features.steering.constitution-manager.validateConstitution",
    "name": "validateConstitution",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/constitution-manager.ts",
    "relative_path": "src/features/steering/constitution-manager.ts",
    "depends_on": [],
    "source_code": "validateConstitution(): boolean {\n\t\t// Placeholder for validation logic\n\t\treturn true;\n\t}",
    "start_line": 74,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateConstitution",
    "component_id": "src.features.steering.constitution-manager.validateConstitution"
  },
  "src.features.steering.instruction-rules.InstructionRuleError": {
    "id": "src.features.steering.instruction-rules.InstructionRuleError",
    "name": "InstructionRuleError",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [],
    "source_code": "class InstructionRuleError extends Error {\n\treadonly userMessage: string;\n\n\tconstructor(userMessage: string) {\n\t\tsuper(userMessage);\n\t\tthis.userMessage = userMessage;\n\t}\n}",
    "start_line": 10,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class InstructionRuleError",
    "component_id": "src.features.steering.instruction-rules.InstructionRuleError"
  },
  "src.features.steering.instruction-rules.NormalizeInstructionRuleNameResult": {
    "id": "src.features.steering.instruction-rules.NormalizeInstructionRuleNameResult",
    "name": "NormalizeInstructionRuleNameResult",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [
      "src.features.steering.instruction-rules.InstructionRuleError"
    ],
    "source_code": "type NormalizeInstructionRuleNameResult =\n\t| {\n\t\t\tok: true;\n\t\t\tnormalizedName: string;\n\t  }\n\t| {\n\t\t\tok: false;\n\t\t\terror: InstructionRuleError;\n\t  };",
    "start_line": 19,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type NormalizeInstructionRuleNameResult",
    "component_id": "src.features.steering.instruction-rules.NormalizeInstructionRuleNameResult"
  },
  "src.features.steering.instruction-rules.normalizeToKebabCase": {
    "id": "src.features.steering.instruction-rules.normalizeToKebabCase",
    "name": "normalizeToKebabCase",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [],
    "source_code": "function normalizeToKebabCase(raw: string): string {\n\treturn raw\n\t\t.trim()\n\t\t.toLowerCase()\n\t\t.replace(NON_ALPHANUMERIC_RUN, \"-\")\n\t\t.replace(DASH_RUN, \"-\")\n\t\t.replace(TRIM_DASHES, \"\");\n}",
    "start_line": 29,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "raw"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalizeToKebabCase",
    "component_id": "src.features.steering.instruction-rules.normalizeToKebabCase"
  },
  "src.features.steering.instruction-rules.normalizeInstructionRuleName": {
    "id": "src.features.steering.instruction-rules.normalizeInstructionRuleName",
    "name": "normalizeInstructionRuleName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [
      "src.features.steering.instruction-rules.normalizeToKebabCase",
      "src.features.steering.instruction-rules.InstructionRuleError",
      "src.features.steering.instruction-rules.NormalizeInstructionRuleNameResult"
    ],
    "source_code": "function normalizeInstructionRuleName(\n\traw: string\n): NormalizeInstructionRuleNameResult {\n\tif (raw.trim().length === 0) {\n\t\treturn {\n\t\t\tok: false,\n\t\t\terror: new InstructionRuleError(\"Instruction name is required.\"),\n\t\t};\n\t}\n\n\tconst normalizedName = normalizeToKebabCase(raw);\n\tif (normalizedName.length === 0) {\n\t\treturn {\n\t\t\tok: false,\n\t\t\terror: new InstructionRuleError(\n\t\t\t\t\"Instruction name must include at least one letter or number.\"\n\t\t\t),\n\t\t};\n\t}\n\n\tif (!KEBAB_CASE_PATTERN.test(normalizedName)) {\n\t\treturn {\n\t\t\tok: false,\n\t\t\terror: new InstructionRuleError(\n\t\t\t\t\"Instruction name must normalize to lowercase kebab-case.\"\n\t\t\t),\n\t\t};\n\t}\n\n\treturn { ok: true, normalizedName };\n}",
    "start_line": 38,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "raw"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalizeInstructionRuleName",
    "component_id": "src.features.steering.instruction-rules.normalizeInstructionRuleName"
  },
  "src.features.steering.instruction-rules.instructionRuleFileName": {
    "id": "src.features.steering.instruction-rules.instructionRuleFileName",
    "name": "instructionRuleFileName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [],
    "source_code": "function instructionRuleFileName(normalizedName: string): string {\n\treturn `${normalizedName}.instructions.md`;\n}",
    "start_line": 70,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "normalizedName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function instructionRuleFileName",
    "component_id": "src.features.steering.instruction-rules.instructionRuleFileName"
  },
  "src.features.steering.instruction-rules.buildInstructionRuleTemplate": {
    "id": "src.features.steering.instruction-rules.buildInstructionRuleTemplate",
    "name": "buildInstructionRuleTemplate",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [],
    "source_code": "function buildInstructionRuleTemplate(normalizedName: string): string {\n\treturn `---\\ndescription: 'TODO: Describe this instruction'\\napplyTo: '**'\\n---\\n\\n# ${normalizedName}\\n`;\n}",
    "start_line": 74,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "normalizedName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildInstructionRuleTemplate",
    "component_id": "src.features.steering.instruction-rules.buildInstructionRuleTemplate"
  },
  "src.features.steering.instruction-rules.projectInstructionsDirUri": {
    "id": "src.features.steering.instruction-rules.projectInstructionsDirUri",
    "name": "projectInstructionsDirUri",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [],
    "source_code": "function projectInstructionsDirUri(workspaceFolder: Uri): Uri {\n\treturn Uri.joinPath(workspaceFolder, \".github\", \"instructions\");\n}",
    "start_line": 78,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspaceFolder"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function projectInstructionsDirUri",
    "component_id": "src.features.steering.instruction-rules.projectInstructionsDirUri"
  },
  "src.features.steering.instruction-rules.userInstructionsDirUri": {
    "id": "src.features.steering.instruction-rules.userInstructionsDirUri",
    "name": "userInstructionsDirUri",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [
      "src.features.steering.instruction-rules.userInstructionsDirUriFromHomeDir"
    ],
    "source_code": "function userInstructionsDirUri(): Uri {\n\treturn userInstructionsDirUriFromHomeDir(\n\t\thomedir() || process.env.USERPROFILE || \"\"\n\t);\n}",
    "start_line": 82,
    "end_line": 86,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function userInstructionsDirUri",
    "component_id": "src.features.steering.instruction-rules.userInstructionsDirUri"
  },
  "src.features.steering.instruction-rules.userInstructionsDirUriFromHomeDir": {
    "id": "src.features.steering.instruction-rules.userInstructionsDirUriFromHomeDir",
    "name": "userInstructionsDirUriFromHomeDir",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [
      "src.features.steering.instruction-rules.InstructionRuleError"
    ],
    "source_code": "function userInstructionsDirUriFromHomeDir(homeDir: string): Uri {\n\tif (!homeDir) {\n\t\tthrow new InstructionRuleError(\n\t\t\t\"Unable to resolve home directory for user instruction rules.\"\n\t\t);\n\t}\n\n\treturn Uri.file(join(homeDir, \".github\", \"instructions\"));\n}",
    "start_line": 88,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "homeDir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function userInstructionsDirUriFromHomeDir",
    "component_id": "src.features.steering.instruction-rules.userInstructionsDirUriFromHomeDir"
  },
  "src.features.steering.instruction-rules.assertFileDoesNotExist": {
    "id": "src.features.steering.instruction-rules.assertFileDoesNotExist",
    "name": "assertFileDoesNotExist",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/instruction-rules.ts",
    "relative_path": "src/features/steering/instruction-rules.ts",
    "depends_on": [
      "src.features.steering.instruction-rules.InstructionRuleError"
    ],
    "source_code": "async function assertFileDoesNotExist(uri: Uri): Promise<void> {\n\ttry {\n\t\tawait workspace.fs.stat(uri);\n\t\tthrow new InstructionRuleError(\n\t\t\t\"File already exists. Choose a different instruction name.\"\n\t\t);\n\t} catch (error) {\n\t\tif (error instanceof InstructionRuleError) {\n\t\t\tthrow error;\n\t\t}\n\t\t// stat failed => file does not exist\n\t}\n}",
    "start_line": 98,
    "end_line": 110,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function assertFileDoesNotExist",
    "component_id": "src.features.steering.instruction-rules.assertFileDoesNotExist"
  },
  "src.features.steering.steering-manager.SteeringManager": {
    "id": "src.features.steering.steering-manager.SteeringManager",
    "name": "SteeringManager",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [
      "src.features.steering.steering-manager.createSpecKitConstitution",
      "src.features.steering.constitution-manager.ensureConstitutionExists",
      "src.features.steering.steering-manager.createOpenSpecAgents",
      "src.features.steering.instruction-rules.userInstructionsDirUri",
      "src.utils.config-manager.getSettings",
      "src.utils.spec-kit-adapter.initialize",
      "src.utils.config-manager.ConfigManager",
      "src.features.steering.instruction-rules.projectInstructionsDirUri",
      "src.features.steering.instruction-rules.assertFileDoesNotExist",
      "src.features.steering.instruction-rules.instructionRuleFileName",
      "src.features.steering.instruction-rules.buildInstructionRuleTemplate",
      "src.utils.config-manager.saveSettings",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter",
      "src.features.steering.instruction-rules.normalizeInstructionRuleName",
      "src.features.steering.constitution-manager.ConstitutionManager",
      "src.utils.spec-kit-adapter.getActiveSystem",
      "src.services.prompt-loader.PromptLoader",
      "src.utils.spec-kit-adapter.getInstance",
      "src.utils.config-manager.loadSettings",
      "src.providers.copilot-provider.CopilotProvider",
      "src.utils.chat-prompt-runner.sendPromptToChat"
    ],
    "source_code": "class SteeringManager {\n\tprivate readonly configManager: ConfigManager;\n\tprivate readonly promptLoader: PromptLoader;\n\tprivate readonly copilotProvider: CopilotProvider;\n\tprivate readonly outputChannel: OutputChannel;\n\n\tconstructor(\n\t\tcontext: ExtensionContext,\n\t\tcopilotProvider: CopilotProvider,\n\t\toutputChannel: OutputChannel\n\t) {\n\t\tthis.configManager = ConfigManager.getInstance();\n\t\tthis.configManager.loadSettings();\n\t\tthis.promptLoader = PromptLoader.getInstance();\n\t\tthis.copilotProvider = copilotProvider;\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Create global Copilot configuration file (~/.github/copilot-instructions.md)\n\t */\n\tasync createUserConfiguration() {\n\t\tconst homeDir = homedir() || process.env.USERPROFILE || \"\";\n\t\tconst githubDir = join(homeDir, \".github\");\n\t\tconst filePath = join(githubDir, \"copilot-instructions.md\");\n\n\t\t// Ensure directory exists\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(Uri.file(githubDir));\n\t\t} catch (error) {\n\t\t\t// Directory might already exist\n\t\t}\n\n\t\t// Check if file already exists\n\t\ttry {\n\t\t\tawait workspace.fs.stat(Uri.file(filePath));\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Global configuration file (~/.github/copilot-instructions.md) already exists. Overwrite?\",\n\t\t\t\t\"Overwrite\",\n\t\t\t\t\"Cancel\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Overwrite\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// File doesn't exist, continue\n\t\t}\n\n\t\t// Create initial MD content\n\t\tconst initialContent = `# Global Copilot Instructions\n\nThis file controls default behavior for GitHub Copilot across all projects.\n`;\n\n\t\tawait workspace.fs.writeFile(\n\t\t\tUri.file(filePath),\n\t\t\tBuffer.from(initialContent)\n\t\t);\n\n\t\tconst document = await workspace.openTextDocument(filePath);\n\t\tawait window.showTextDocument(document, {\n\t\t\tpreview: false,\n\t\t\tviewColumn: ViewColumn.Active,\n\t\t});\n\t}\n\n\t/**\n\t * Create project-level documentation (AGENTS.md or constitution.md)\n\t */\n\tasync createProjectDocumentation() {\n\t\tif (!workspace.workspaceFolders) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open.\");\n\t\t\treturn;\n\t\t}\n\t\tconst workspaceRoot = workspace.workspaceFolders[0].uri.fsPath;\n\t\tconst adapter = getSpecSystemAdapter();\n\t\tlet activeSystem = adapter.getActiveSystem();\n\n\t\t// Check if project is initialized with any system\n\t\tconst hasOpenSpec = existsSync(join(workspaceRoot, \"openspec\"));\n\t\tconst hasSpecKit =\n\t\t\texistsSync(join(workspaceRoot, \".specify\")) ||\n\t\t\texistsSync(join(workspaceRoot, \"specs\"));\n\n\t\t// If no system is detected and we are about to create project rules,\n\t\t// we must ask the user which system they intend to use.\n\t\tif (!(hasOpenSpec || hasSpecKit)) {\n\t\t\tconst choice = await window.showQuickPick(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"SpecKit\",\n\t\t\t\t\t\tdescription: \"Use SpecKit system\",\n\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"OpenSpec\",\n\t\t\t\t\t\tdescription: \"Use OpenSpec system\",\n\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t{\n\t\t\t\t\tplaceHolder:\n\t\t\t\t\t\t\"No SDD system detected. Which agent do you want to initialize?\",\n\t\t\t\t\tignoreFocusOut: true,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (!choice) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tactiveSystem = choice.value;\n\n\t\t\t// Save preference\n\t\t\tconst settings = this.configManager.getSettings();\n\t\t\tawait this.configManager.saveSettings({\n\t\t\t\t...settings,\n\t\t\t\tspecSystem: activeSystem,\n\t\t\t});\n\n\t\t\t// Re-initialize adapter\n\t\t\tawait adapter.initialize();\n\t\t}\n\n\t\tif (activeSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\tawait this.createSpecKitConstitution(workspaceRoot);\n\t\t} else {\n\t\t\tawait this.createOpenSpecAgents(workspaceRoot);\n\t\t}\n\t}\n\n\tprivate async createSpecKitConstitution(workspaceRoot: string) {\n\t\tconst constitutionManager = new ConstitutionManager(workspaceRoot);\n\t\tconst exists = await constitutionManager.ensureConstitutionExists();\n\n\t\tif (exists) {\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Project constitution (constitution.md) already exists. Running the agent might overwrite it. Continue?\",\n\t\t\t\t\"Continue\",\n\t\t\t\t\"Cancel\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Continue\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Prompt for directives\n\t\tconst directives = await window.showInputBox({\n\t\t\ttitle: \"Create Constitution\",\n\t\t\tprompt:\n\t\t\t\t\"Enter the constitution directives (e.g. 'Create principles focused on code quality...')\",\n\t\t\tplaceHolder: \"Directives...\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!directives) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Send to chat\n\t\tawait sendPromptToChat(`/speckit.constitution ${directives}`);\n\t}\n\n\tprivate async createOpenSpecAgents(workspaceRoot: string) {\n\t\tconst openspecDir = join(workspaceRoot, \"openspec\");\n\t\tconst filePath = join(openspecDir, \"AGENTS.md\");\n\n\t\t// Ensure directory exists\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(Uri.file(openspecDir));\n\t\t} catch (error) {\n\t\t\t// Directory might already exist\n\t\t}\n\n\t\t// Check if file already exists\n\t\ttry {\n\t\t\tawait workspace.fs.stat(Uri.file(filePath));\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Project AGENTS.md (openspec/AGENTS.md) already exists. Overwrite?\",\n\t\t\t\t\"Overwrite\",\n\t\t\t\t\"Cancel\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Overwrite\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// File doesn't exist\n\t\t}\n\n\t\t// Create initial content\n\t\tconst initialContent = `# Project Instructions\n\nThis file contains instructions for AI agents working on this project.\n`;\n\t\tawait workspace.fs.writeFile(\n\t\t\tUri.file(filePath),\n\t\t\tBuffer.from(initialContent)\n\t\t);\n\n\t\tconst document = await workspace.openTextDocument(filePath);\n\t\tawait window.showTextDocument(document, {\n\t\t\tpreview: false,\n\t\t\tviewColumn: ViewColumn.Active,\n\t\t});\n\t}\n\n\tasync createProjectInstructionRule(): Promise<boolean> {\n\t\tif (!workspace.workspaceFolders) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open.\");\n\t\t\treturn false;\n\t\t}\n\n\t\tconst name = await window.showInputBox({\n\t\t\ttitle: \"Create Project Rule\",\n\t\t\tprompt: \"Enter a name for the project instruction rule.\",\n\t\t\tplaceHolder: \"TypeScript Rules\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!name) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst normalized = normalizeInstructionRuleName(name);\n\t\tif (!normalized.ok) {\n\t\t\twindow.showErrorMessage(normalized.error.userMessage);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst workspaceFolderUri = workspace.workspaceFolders[0].uri;\n\t\tconst instructionsDir = projectInstructionsDirUri(workspaceFolderUri);\n\t\tconst fileUri = Uri.joinPath(\n\t\t\tinstructionsDir,\n\t\t\tinstructionRuleFileName(normalized.normalizedName)\n\t\t);\n\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(instructionsDir);\n\t\t\tawait assertFileDoesNotExist(fileUri);\n\n\t\t\tconst templateBytes = new TextEncoder().encode(\n\t\t\t\tbuildInstructionRuleTemplate(normalized.normalizedName)\n\t\t\t);\n\n\t\t\tawait workspace.fs.writeFile(fileUri, templateBytes);\n\n\t\t\tconst document = await workspace.openTextDocument(fileUri);\n\t\t\tawait window.showTextDocument(document, {\n\t\t\t\tpreview: false,\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tif (error instanceof InstructionRuleError) {\n\t\t\t\twindow.showErrorMessage(error.userMessage);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[Create Project Rule] Failed to create instruction rule: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to create project rule: ${message}`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync createUserInstructionRule(): Promise<boolean> {\n\t\tconst name = await window.showInputBox({\n\t\t\ttitle: \"Create User Rule\",\n\t\t\tprompt: \"Enter a name for the user instruction rule.\",\n\t\t\tplaceHolder: \"TypeScript Rules\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!name) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst normalized = normalizeInstructionRuleName(name);\n\t\tif (!normalized.ok) {\n\t\t\twindow.showErrorMessage(normalized.error.userMessage);\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tconst instructionsDir = userInstructionsDirUri();\n\t\t\tconst fileUri = Uri.joinPath(\n\t\t\t\tinstructionsDir,\n\t\t\t\tinstructionRuleFileName(normalized.normalizedName)\n\t\t\t);\n\n\t\t\tawait workspace.fs.createDirectory(instructionsDir);\n\t\t\tawait assertFileDoesNotExist(fileUri);\n\n\t\t\tconst templateBytes = new TextEncoder().encode(\n\t\t\t\tbuildInstructionRuleTemplate(normalized.normalizedName)\n\t\t\t);\n\n\t\t\tawait workspace.fs.writeFile(fileUri, templateBytes);\n\n\t\t\tconst document = await workspace.openTextDocument(fileUri);\n\t\t\tawait window.showTextDocument(document, {\n\t\t\t\tpreview: false,\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tif (error instanceof InstructionRuleError) {\n\t\t\t\twindow.showErrorMessage(error.userMessage);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[Create User Rule] Failed to create instruction rule: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to create user rule: ${message}`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync createConstitutionRequest(): Promise<void> {\n\t\tconst description = await window.showInputBox({\n\t\t\ttitle: \"Create Constitution\",\n\t\t\tprompt: \"Enter a brief description for the constitution.\",\n\t\t\tplaceHolder: \"Python project with FastAPI\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!description || description.trim().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait sendPromptToChat(`/speckit.constitution ${description}`);\n\t}\n}",
    "start_line": 29,
    "end_line": 367,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SteeringManager",
    "component_id": "src.features.steering.steering-manager.SteeringManager"
  },
  "src.features.steering.steering-manager.createUserConfiguration": {
    "id": "src.features.steering.steering-manager.createUserConfiguration",
    "name": "createUserConfiguration",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "async createUserConfiguration() {\n\t\tconst homeDir = homedir() || process.env.USERPROFILE || \"\";\n\t\tconst githubDir = join(homeDir, \".github\");\n\t\tconst filePath = join(githubDir, \"copilot-instructions.md\");\n\n\t\t// Ensure directory exists\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(Uri.file(githubDir));\n\t\t} catch (error) {\n\t\t\t// Directory might already exist\n\t\t}\n\n\t\t// Check if file already exists\n\t\ttry {\n\t\t\tawait workspace.fs.stat(Uri.file(filePath));\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Global configuration file (~/.github/copilot-instructions.md) already exists. Overwrite?\",\n\t\t\t\t\"Overwrite\",\n\t\t\t\t\"Cancel\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Overwrite\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// File doesn't exist, continue\n\t\t}\n\n\t\t// Create initial MD content\n\t\tconst initialContent = `# Global Copilot Instructions\n\nThis file controls default behavior for GitHub Copilot across all projects.\n`;\n\n\t\tawait workspace.fs.writeFile(\n\t\t\tUri.file(filePath),\n\t\t\tBuffer.from(initialContent)\n\t\t);\n\n\t\tconst document = await workspace.openTextDocument(filePath);\n\t\tawait window.showTextDocument(document, {\n\t\t\tpreview: false,\n\t\t\tviewColumn: ViewColumn.Active,\n\t\t});\n\t}",
    "start_line": 50,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createUserConfiguration",
    "component_id": "src.features.steering.steering-manager.createUserConfiguration"
  },
  "src.features.steering.steering-manager.createProjectDocumentation": {
    "id": "src.features.steering.steering-manager.createProjectDocumentation",
    "name": "createProjectDocumentation",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "async createProjectDocumentation() {\n\t\tif (!workspace.workspaceFolders) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open.\");\n\t\t\treturn;\n\t\t}\n\t\tconst workspaceRoot = workspace.workspaceFolders[0].uri.fsPath;\n\t\tconst adapter = getSpecSystemAdapter();\n\t\tlet activeSystem = adapter.getActiveSystem();\n\n\t\t// Check if project is initialized with any system\n\t\tconst hasOpenSpec = existsSync(join(workspaceRoot, \"openspec\"));\n\t\tconst hasSpecKit =\n\t\t\texistsSync(join(workspaceRoot, \".specify\")) ||\n\t\t\texistsSync(join(workspaceRoot, \"specs\"));\n\n\t\t// If no system is detected and we are about to create project rules,\n\t\t// we must ask the user which system they intend to use.\n\t\tif (!(hasOpenSpec || hasSpecKit)) {\n\t\t\tconst choice = await window.showQuickPick(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"SpecKit\",\n\t\t\t\t\t\tdescription: \"Use SpecKit system\",\n\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"OpenSpec\",\n\t\t\t\t\t\tdescription: \"Use OpenSpec system\",\n\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t{\n\t\t\t\t\tplaceHolder:\n\t\t\t\t\t\t\"No SDD system detected. Which agent do you want to initialize?\",\n\t\t\t\t\tignoreFocusOut: true,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (!choice) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tactiveSystem = choice.value;\n\n\t\t\t// Save preference\n\t\t\tconst settings = this.configManager.getSettings();\n\t\t\tawait this.configManager.saveSettings({\n\t\t\t\t...settings,\n\t\t\t\tspecSystem: activeSystem,\n\t\t\t});\n\n\t\t\t// Re-initialize adapter\n\t\t\tawait adapter.initialize();\n\t\t}\n\n\t\tif (activeSystem === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\tawait this.createSpecKitConstitution(workspaceRoot);\n\t\t} else {\n\t\t\tawait this.createOpenSpecAgents(workspaceRoot);\n\t\t}\n\t}",
    "start_line": 98,
    "end_line": 158,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createProjectDocumentation",
    "component_id": "src.features.steering.steering-manager.createProjectDocumentation"
  },
  "src.features.steering.steering-manager.createSpecKitConstitution": {
    "id": "src.features.steering.steering-manager.createSpecKitConstitution",
    "name": "createSpecKitConstitution",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "private async createSpecKitConstitution(workspaceRoot: string) {\n\t\tconst constitutionManager = new ConstitutionManager(workspaceRoot);\n\t\tconst exists = await constitutionManager.ensureConstitutionExists();\n\n\t\tif (exists) {\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Project constitution (constitution.md) already exists. Running the agent might overwrite it. Continue?\",\n\t\t\t\t\"Continue\",\n\t\t\t\t\"Cancel\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Continue\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Prompt for directives\n\t\tconst directives = await window.showInputBox({\n\t\t\ttitle: \"Create Constitution\",\n\t\t\tprompt:\n\t\t\t\t\"Enter the constitution directives (e.g. 'Create principles focused on code quality...')\",\n\t\t\tplaceHolder: \"Directives...\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!directives) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Send to chat\n\t\tawait sendPromptToChat(`/speckit.constitution ${directives}`);\n\t}",
    "start_line": 160,
    "end_line": 190,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspaceRoot"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createSpecKitConstitution",
    "component_id": "src.features.steering.steering-manager.createSpecKitConstitution"
  },
  "src.features.steering.steering-manager.createOpenSpecAgents": {
    "id": "src.features.steering.steering-manager.createOpenSpecAgents",
    "name": "createOpenSpecAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "private async createOpenSpecAgents(workspaceRoot: string) {\n\t\tconst openspecDir = join(workspaceRoot, \"openspec\");\n\t\tconst filePath = join(openspecDir, \"AGENTS.md\");\n\n\t\t// Ensure directory exists\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(Uri.file(openspecDir));\n\t\t} catch (error) {\n\t\t\t// Directory might already exist\n\t\t}\n\n\t\t// Check if file already exists\n\t\ttry {\n\t\t\tawait workspace.fs.stat(Uri.file(filePath));\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Project AGENTS.md (openspec/AGENTS.md) already exists. Overwrite?\",\n\t\t\t\t\"Overwrite\",\n\t\t\t\t\"Cancel\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Overwrite\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// File doesn't exist\n\t\t}\n\n\t\t// Create initial content\n\t\tconst initialContent = `# Project Instructions\n\nThis file contains instructions for AI agents working on this project.\n`;\n\t\tawait workspace.fs.writeFile(\n\t\t\tUri.file(filePath),\n\t\t\tBuffer.from(initialContent)\n\t\t);\n\n\t\tconst document = await workspace.openTextDocument(filePath);\n\t\tawait window.showTextDocument(document, {\n\t\t\tpreview: false,\n\t\t\tviewColumn: ViewColumn.Active,\n\t\t});\n\t}",
    "start_line": 192,
    "end_line": 233,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspaceRoot"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createOpenSpecAgents",
    "component_id": "src.features.steering.steering-manager.createOpenSpecAgents"
  },
  "src.features.steering.steering-manager.createProjectInstructionRule": {
    "id": "src.features.steering.steering-manager.createProjectInstructionRule",
    "name": "createProjectInstructionRule",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "async createProjectInstructionRule(): Promise<boolean> {\n\t\tif (!workspace.workspaceFolders) {\n\t\t\twindow.showErrorMessage(\"No workspace folder open.\");\n\t\t\treturn false;\n\t\t}\n\n\t\tconst name = await window.showInputBox({\n\t\t\ttitle: \"Create Project Rule\",\n\t\t\tprompt: \"Enter a name for the project instruction rule.\",\n\t\t\tplaceHolder: \"TypeScript Rules\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!name) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst normalized = normalizeInstructionRuleName(name);\n\t\tif (!normalized.ok) {\n\t\t\twindow.showErrorMessage(normalized.error.userMessage);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst workspaceFolderUri = workspace.workspaceFolders[0].uri;\n\t\tconst instructionsDir = projectInstructionsDirUri(workspaceFolderUri);\n\t\tconst fileUri = Uri.joinPath(\n\t\t\tinstructionsDir,\n\t\t\tinstructionRuleFileName(normalized.normalizedName)\n\t\t);\n\n\t\ttry {\n\t\t\tawait workspace.fs.createDirectory(instructionsDir);\n\t\t\tawait assertFileDoesNotExist(fileUri);\n\n\t\t\tconst templateBytes = new TextEncoder().encode(\n\t\t\t\tbuildInstructionRuleTemplate(normalized.normalizedName)\n\t\t\t);\n\n\t\t\tawait workspace.fs.writeFile(fileUri, templateBytes);\n\n\t\t\tconst document = await workspace.openTextDocument(fileUri);\n\t\t\tawait window.showTextDocument(document, {\n\t\t\t\tpreview: false,\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tif (error instanceof InstructionRuleError) {\n\t\t\t\twindow.showErrorMessage(error.userMessage);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[Create Project Rule] Failed to create instruction rule: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to create project rule: ${message}`);\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 235,
    "end_line": 295,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createProjectInstructionRule",
    "component_id": "src.features.steering.steering-manager.createProjectInstructionRule"
  },
  "src.features.steering.steering-manager.createUserInstructionRule": {
    "id": "src.features.steering.steering-manager.createUserInstructionRule",
    "name": "createUserInstructionRule",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "async createUserInstructionRule(): Promise<boolean> {\n\t\tconst name = await window.showInputBox({\n\t\t\ttitle: \"Create User Rule\",\n\t\t\tprompt: \"Enter a name for the user instruction rule.\",\n\t\t\tplaceHolder: \"TypeScript Rules\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!name) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst normalized = normalizeInstructionRuleName(name);\n\t\tif (!normalized.ok) {\n\t\t\twindow.showErrorMessage(normalized.error.userMessage);\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tconst instructionsDir = userInstructionsDirUri();\n\t\t\tconst fileUri = Uri.joinPath(\n\t\t\t\tinstructionsDir,\n\t\t\t\tinstructionRuleFileName(normalized.normalizedName)\n\t\t\t);\n\n\t\t\tawait workspace.fs.createDirectory(instructionsDir);\n\t\t\tawait assertFileDoesNotExist(fileUri);\n\n\t\t\tconst templateBytes = new TextEncoder().encode(\n\t\t\t\tbuildInstructionRuleTemplate(normalized.normalizedName)\n\t\t\t);\n\n\t\t\tawait workspace.fs.writeFile(fileUri, templateBytes);\n\n\t\t\tconst document = await workspace.openTextDocument(fileUri);\n\t\t\tawait window.showTextDocument(document, {\n\t\t\t\tpreview: false,\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tif (error instanceof InstructionRuleError) {\n\t\t\t\twindow.showErrorMessage(error.userMessage);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[Create User Rule] Failed to create instruction rule: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to create user rule: ${message}`);\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 297,
    "end_line": 351,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createUserInstructionRule",
    "component_id": "src.features.steering.steering-manager.createUserInstructionRule"
  },
  "src.features.steering.steering-manager.createConstitutionRequest": {
    "id": "src.features.steering.steering-manager.createConstitutionRequest",
    "name": "createConstitutionRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/steering-manager.ts",
    "relative_path": "src/features/steering/steering-manager.ts",
    "depends_on": [],
    "source_code": "async createConstitutionRequest(): Promise<void> {\n\t\tconst description = await window.showInputBox({\n\t\t\ttitle: \"Create Constitution\",\n\t\t\tprompt: \"Enter a brief description for the constitution.\",\n\t\t\tplaceHolder: \"Python project with FastAPI\",\n\t\t\tignoreFocusOut: true,\n\t\t});\n\n\t\tif (!description || description.trim().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait sendPromptToChat(`/speckit.constitution ${description}`);\n\t}",
    "start_line": 353,
    "end_line": 366,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createConstitutionRequest",
    "component_id": "src.features.steering.steering-manager.createConstitutionRequest"
  },
  "src.features.steering.types.CreateSteeringFormData": {
    "id": "src.features.steering.types.CreateSteeringFormData",
    "name": "CreateSteeringFormData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringFormData {\n\tsummary: string;\n\taudience: string;\n\tkeyPractices: string;\n\tantiPatterns: string;\n}",
    "start_line": 1,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringFormData",
    "component_id": "src.features.steering.types.CreateSteeringFormData"
  },
  "src.features.steering.types.CreateSteeringDraftState": {
    "id": "src.features.steering.types.CreateSteeringDraftState",
    "name": "CreateSteeringDraftState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [
      "src.features.steering.types.CreateSteeringFormData"
    ],
    "source_code": "interface CreateSteeringDraftState {\n\tformData: CreateSteeringFormData;\n\tlastUpdated: number;\n}",
    "start_line": 8,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringDraftState",
    "component_id": "src.features.steering.types.CreateSteeringDraftState"
  },
  "src.features.steering.types.CreateSteeringInitPayload": {
    "id": "src.features.steering.types.CreateSteeringInitPayload",
    "name": "CreateSteeringInitPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [
      "src.features.steering.types.CreateSteeringDraftState"
    ],
    "source_code": "interface CreateSteeringInitPayload {\n\tshouldFocusPrimaryField: boolean;\n\tdraft?: CreateSteeringDraftState;\n}",
    "start_line": 13,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringInitPayload",
    "component_id": "src.features.steering.types.CreateSteeringInitPayload"
  },
  "src.features.steering.types.CreateSteeringExtensionMessage": {
    "id": "src.features.steering.types.CreateSteeringExtensionMessage",
    "name": "CreateSteeringExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [
      "src.features.steering.types.CreateSteeringInitPayload"
    ],
    "source_code": "type CreateSteeringExtensionMessage =\n\t| { type: \"create-steering/init\"; payload: CreateSteeringInitPayload }\n\t| { type: \"create-steering/submit:success\" }\n\t| { type: \"create-steering/submit:error\"; payload: { message: string } }\n\t| { type: \"create-steering/confirm-close\"; payload: { shouldClose: boolean } }\n\t| { type: \"create-steering/focus\" };",
    "start_line": 18,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSteeringExtensionMessage",
    "component_id": "src.features.steering.types.CreateSteeringExtensionMessage"
  },
  "src.features.steering.types.CreateSteeringFieldErrors": {
    "id": "src.features.steering.types.CreateSteeringFieldErrors",
    "name": "CreateSteeringFieldErrors",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringFieldErrors {\n\tsummary?: string;\n}",
    "start_line": 25,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringFieldErrors",
    "component_id": "src.features.steering.types.CreateSteeringFieldErrors"
  },
  "src.features.steering.types.CreateSteeringSubmitMessage": {
    "id": "src.features.steering.types.CreateSteeringSubmitMessage",
    "name": "CreateSteeringSubmitMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [
      "src.features.steering.types.CreateSteeringFormData"
    ],
    "source_code": "interface CreateSteeringSubmitMessage {\n\ttype: \"create-steering/submit\";\n\tpayload: CreateSteeringFormData;\n}",
    "start_line": 29,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringSubmitMessage",
    "component_id": "src.features.steering.types.CreateSteeringSubmitMessage"
  },
  "src.features.steering.types.CreateSteeringAutosaveMessage": {
    "id": "src.features.steering.types.CreateSteeringAutosaveMessage",
    "name": "CreateSteeringAutosaveMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [
      "src.features.steering.types.CreateSteeringFormData"
    ],
    "source_code": "interface CreateSteeringAutosaveMessage {\n\ttype: \"create-steering/autosave\";\n\tpayload: CreateSteeringFormData;\n}",
    "start_line": 34,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringAutosaveMessage",
    "component_id": "src.features.steering.types.CreateSteeringAutosaveMessage"
  },
  "src.features.steering.types.CreateSteeringCloseAttemptMessage": {
    "id": "src.features.steering.types.CreateSteeringCloseAttemptMessage",
    "name": "CreateSteeringCloseAttemptMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringCloseAttemptMessage {\n\ttype: \"create-steering/close-attempt\";\n\tpayload: { hasDirtyChanges: boolean };\n}",
    "start_line": 39,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringCloseAttemptMessage",
    "component_id": "src.features.steering.types.CreateSteeringCloseAttemptMessage"
  },
  "src.features.steering.types.CreateSteeringCancelMessage": {
    "id": "src.features.steering.types.CreateSteeringCancelMessage",
    "name": "CreateSteeringCancelMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringCancelMessage {\n\ttype: \"create-steering/cancel\";\n}",
    "start_line": 44,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringCancelMessage",
    "component_id": "src.features.steering.types.CreateSteeringCancelMessage"
  },
  "src.features.steering.types.CreateSteeringReadyMessage": {
    "id": "src.features.steering.types.CreateSteeringReadyMessage",
    "name": "CreateSteeringReadyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringReadyMessage {\n\ttype: \"create-steering/ready\";\n}",
    "start_line": 48,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringReadyMessage",
    "component_id": "src.features.steering.types.CreateSteeringReadyMessage"
  },
  "src.features.steering.types.CreateSteeringWebviewMessage": {
    "id": "src.features.steering.types.CreateSteeringWebviewMessage",
    "name": "CreateSteeringWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/features/steering/types.ts",
    "relative_path": "src/features/steering/types.ts",
    "depends_on": [],
    "source_code": "type CreateSteeringWebviewMessage =\n\t| CreateSteeringSubmitMessage\n\t| CreateSteeringAutosaveMessage\n\t| CreateSteeringCloseAttemptMessage\n\t| CreateSteeringCancelMessage\n\t| CreateSteeringReadyMessage;",
    "start_line": 52,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSteeringWebviewMessage",
    "component_id": "src.features.steering.types.CreateSteeringWebviewMessage"
  },
  "src.panels.document-preview-panel.DocumentPreviewPanelOptions": {
    "id": "src.panels.document-preview-panel.DocumentPreviewPanelOptions",
    "name": "DocumentPreviewPanelOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [
      "ui.src.features.preview.api.form-bridge.FormSubmissionPayload",
      "src.types.preview.RefinementRequestPayload"
    ],
    "source_code": "interface DocumentPreviewPanelOptions {\n\tonReloadRequested?: () => Promise<void> | void;\n\tonEditAttempt?: (reason?: string) => void;\n\tonOpenInEditor?: () => Promise<void> | void;\n\tonFormSubmit?: (payload: FormSubmissionPayload) => Promise<{\n\t\tstatus?: \"success\" | \"error\";\n\t\tmessage?: string;\n\t} | void> | void;\n\tonRefineSubmit?: (payload: RefinementRequestPayload) => Promise<{\n\t\tstatus?: \"success\" | \"error\";\n\t\tmessage?: string;\n\t} | void> | void;\n\tonExecuteTaskGroup?: (groupName: string) => Promise<void> | void;\n\tonOpenFile?: (filePath: string) => Promise<void> | void;\n}",
    "start_line": 17,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentPreviewPanelOptions",
    "component_id": "src.panels.document-preview-panel.DocumentPreviewPanelOptions"
  },
  "src.panels.document-preview-panel.DocumentPreviewPanel": {
    "id": "src.panels.document-preview-panel.DocumentPreviewPanel",
    "name": "DocumentPreviewPanel",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [
      "src.panels.document-preview-panel.getHtml",
      "src.providers.hook-view-provider.ensurePanel",
      "src.panels.document-preview-panel.dispose",
      "src.providers.hook-view-provider.webview",
      "src.panels.document-preview-panel.handleRefineSubmission",
      "src.panels.document-preview-panel.postMessage",
      "ui.src.features.preview.types.PreviewWebviewMessage",
      "src.panels.document-preview-panel.handleWebviewMessage",
      "ui.src.features.preview.api.form-bridge.FormSubmissionPayload",
      "ui.src.features.preview.types.DocumentArtifact",
      "src.panels.welcome-screen-panel.disposePanel",
      "src.panels.document-preview-panel.DocumentPreviewPanelOptions",
      "src.providers.hook-view-provider.flushPendingMessages",
      "src.panels.document-preview-panel.ensurePanel",
      "src.services.agent-service.dispose",
      "src.utils.get-webview-content.getWebviewContent",
      "src.panels.document-preview-panel.disposePanel",
      "src.panels.welcome-screen-panel.postMessage",
      "src.types.preview.PreviewPanelMessage",
      "src.panels.document-preview-panel.flushPendingMessages",
      "src.panels.document-preview-panel.handleFormSubmission",
      "src.panels.document-preview-panel.handleExecuteTaskGroup",
      "src.types.preview.RefinementRequestPayload",
      "src.panels.welcome-screen-panel.getHtml",
      "src.providers.hook-view-provider.handleWebviewMessage"
    ],
    "source_code": "class DocumentPreviewPanel {\n\tstatic readonly panelType = \"gatomia.documentPreview\";\n\n\tprivate panel: WebviewPanel | undefined;\n\tprivate isWebviewReady = false;\n\tprivate pendingMessages: PreviewPanelMessage[] = [];\n\tprivate disposables: Disposable[] = [];\n\tprivate lastArtifact?: DocumentArtifact;\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly options: DocumentPreviewPanelOptions;\n\n\tconstructor(\n\t\tcontext: ExtensionContext,\n\t\toutputChannel: OutputChannel,\n\t\toptions: DocumentPreviewPanelOptions = {}\n\t) {\n\t\tthis.context = context;\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.options = options;\n\t}\n\n\tasync renderDocument(artifact: DocumentArtifact): Promise<void> {\n\t\tthis.lastArtifact = artifact;\n\t\tconst panel = this.ensurePanel();\n\t\tpanel.reveal(ViewColumn.Active, true);\n\t\tawait this.postMessage({\n\t\t\ttype: \"preview/load-document\",\n\t\t\tpayload: artifact,\n\t\t});\n\t}\n\n\tasync markDocumentStale(reason?: string): Promise<void> {\n\t\tawait this.postMessage({\n\t\t\ttype: \"preview/show-placeholder\",\n\t\t\tpayload: { reason },\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.disposePanel();\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.disposables = [];\n\t}\n\n\tprivate ensurePanel(): WebviewPanel {\n\t\tif (this.panel) {\n\t\t\treturn this.panel;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tDocumentPreviewPanel.panelType,\n\t\t\t\"Document Preview\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\tpreserveFocus: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tpanel.webview.html = this.getHtml(panel.webview);\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\tasync (message: PreviewWebviewMessage) => {\n\t\t\t\tawait this.handleWebviewMessage(message);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\t\tpanel.onDidDispose(() => this.disposePanel(), undefined, this.disposables);\n\n\t\tthis.panel = panel;\n\t\tthis.isWebviewReady = false;\n\t\treturn panel;\n\t}\n\n\tprivate disposePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.dispose();\n\t\t\tthis.panel = undefined;\n\t\t}\n\t\tthis.isWebviewReady = false;\n\t\tthis.pendingMessages = [];\n\t}\n\n\tprivate getHtml(webview: Webview): string {\n\t\treturn getWebviewContent(\n\t\t\twebview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"document-preview\"\n\t\t);\n\t}\n\n\tprivate async handleWebviewMessage(\n\t\tmessage: PreviewWebviewMessage\n\t): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewPanel] Received message: ${message?.type ?? \"undefined\"}`\n\t\t);\n\t\tswitch (message?.type) {\n\t\t\tcase \"preview/ready\":\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[DocumentPreviewPanel] Webview ready, lastArtifact: ${this.lastArtifact ? \"present\" : \"null\"}`\n\t\t\t\t);\n\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\tawait this.flushPendingMessages();\n\t\t\t\tif (this.lastArtifact) {\n\t\t\t\t\tawait this.postMessage({\n\t\t\t\t\t\ttype: \"preview/load-document\",\n\t\t\t\t\t\tpayload: this.lastArtifact,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tcase \"preview/request-reload\":\n\t\t\t\tawait this.options.onReloadRequested?.();\n\t\t\t\treturn;\n\t\t\tcase \"preview/edit-attempt\":\n\t\t\t\tthis.options.onEditAttempt?.(message.payload?.reason);\n\t\t\t\twindow.showWarningMessage(\n\t\t\t\t\t\"Document preview is read-only. Use the editor to modify the source.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\tcase \"preview/open-in-editor\":\n\t\t\t\tawait this.options.onOpenInEditor?.();\n\t\t\t\treturn;\n\t\t\tcase \"preview/forms/submit\":\n\t\t\t\tawait this.handleFormSubmission(message.payload);\n\t\t\t\treturn;\n\t\t\tcase \"preview/refine/submit\":\n\t\t\t\tawait this.handleRefineSubmission(message.payload);\n\t\t\t\treturn;\n\t\t\tcase \"preview/execute-task-group\":\n\t\t\t\tawait this.handleExecuteTaskGroup(message.payload);\n\t\t\t\treturn;\n\t\t\tcase \"preview/open-file\":\n\t\t\t\tawait this.options.onOpenFile?.(message.payload?.filePath);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[DocumentPreviewPanel] Unknown message received: ${message?.type ?? \"undefined\"}`\n\t\t\t\t);\n\t\t}\n\t}\n\n\tprivate async postMessage(message: PreviewPanelMessage): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewPanel] Posting message: ${message.type}, ready: ${this.isWebviewReady}, hasPanel: ${!!this.panel?.webview}`\n\t\t);\n\t\tif (!this.panel?.webview) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[DocumentPreviewPanel] No panel webview, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isWebviewReady) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[DocumentPreviewPanel] Webview not ready, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.panel.webview.postMessage(message);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DocumentPreviewPanel] Message sent successfully: ${message.type}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DocumentPreviewPanel] Failed to post message ${message.type}: ${\n\t\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async flushPendingMessages(): Promise<void> {\n\t\tif (!(this.panel && this.isWebviewReady)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst queue = [...this.pendingMessages];\n\t\tthis.pendingMessages = [];\n\n\t\tfor (const message of queue) {\n\t\t\tawait this.postMessage(message);\n\t\t}\n\t}\n\n\tprivate async handleFormSubmission(\n\t\tpayload: FormSubmissionPayload | undefined\n\t): Promise<void> {\n\t\tif (!payload?.requestId) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = await this.options.onFormSubmit?.(payload);\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/forms/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: result?.status ?? \"success\",\n\t\t\t\t\tmessage: result?.message,\n\t\t\t\t},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/forms/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage:\n\t\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t\t: \"Failed to save form changes\",\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate async handleRefineSubmission(\n\t\tpayload: RefinementRequestPayload | undefined\n\t): Promise<void> {\n\t\tif (!payload?.requestId) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = await this.options.onRefineSubmit?.(payload);\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/refine/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: result?.status ?? \"success\",\n\t\t\t\t\tmessage: result?.message,\n\t\t\t\t},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/refine/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage:\n\t\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t\t: \"Failed to submit refinement request\",\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate async handleExecuteTaskGroup(\n\t\tpayload: { groupName: string } | undefined\n\t): Promise<void> {\n\t\tif (!payload?.groupName) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.options.onExecuteTaskGroup?.(payload.groupName);\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error ? error.message : \"Failed to execute task group\";\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DocumentPreviewPanel] Error executing task group: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to execute task group: ${message}`);\n\t\t}\n\t}\n}",
    "start_line": 37,
    "end_line": 315,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DocumentPreviewPanel",
    "component_id": "src.panels.document-preview-panel.DocumentPreviewPanel"
  },
  "src.panels.document-preview-panel.renderDocument": {
    "id": "src.panels.document-preview-panel.renderDocument",
    "name": "renderDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "async renderDocument(artifact: DocumentArtifact): Promise<void> {\n\t\tthis.lastArtifact = artifact;\n\t\tconst panel = this.ensurePanel();\n\t\tpanel.reveal(ViewColumn.Active, true);\n\t\tawait this.postMessage({\n\t\t\ttype: \"preview/load-document\",\n\t\t\tpayload: artifact,\n\t\t});\n\t}",
    "start_line": 59,
    "end_line": 67,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "artifact"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method renderDocument",
    "component_id": "src.panels.document-preview-panel.renderDocument"
  },
  "src.panels.document-preview-panel.markDocumentStale": {
    "id": "src.panels.document-preview-panel.markDocumentStale",
    "name": "markDocumentStale",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "async markDocumentStale(reason?: string): Promise<void> {\n\t\tawait this.postMessage({\n\t\t\ttype: \"preview/show-placeholder\",\n\t\t\tpayload: { reason },\n\t\t});\n\t}",
    "start_line": 69,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "reason"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method markDocumentStale",
    "component_id": "src.panels.document-preview-panel.markDocumentStale"
  },
  "src.panels.document-preview-panel.dispose": {
    "id": "src.panels.document-preview-panel.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.disposePanel();\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.disposables = [];\n\t}",
    "start_line": 76,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.panels.document-preview-panel.dispose"
  },
  "src.panels.document-preview-panel.ensurePanel": {
    "id": "src.panels.document-preview-panel.ensurePanel",
    "name": "ensurePanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private ensurePanel(): WebviewPanel {\n\t\tif (this.panel) {\n\t\t\treturn this.panel;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tDocumentPreviewPanel.panelType,\n\t\t\t\"Document Preview\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\tpreserveFocus: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tpanel.webview.html = this.getHtml(panel.webview);\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\tasync (message: PreviewWebviewMessage) => {\n\t\t\t\tawait this.handleWebviewMessage(message);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\t\tpanel.onDidDispose(() => this.disposePanel(), undefined, this.disposables);\n\n\t\tthis.panel = panel;\n\t\tthis.isWebviewReady = false;\n\t\treturn panel;\n\t}",
    "start_line": 84,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method ensurePanel",
    "component_id": "src.panels.document-preview-panel.ensurePanel"
  },
  "src.panels.document-preview-panel.disposePanel": {
    "id": "src.panels.document-preview-panel.disposePanel",
    "name": "disposePanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private disposePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.dispose();\n\t\t\tthis.panel = undefined;\n\t\t}\n\t\tthis.isWebviewReady = false;\n\t\tthis.pendingMessages = [];\n\t}",
    "start_line": 118,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method disposePanel",
    "component_id": "src.panels.document-preview-panel.disposePanel"
  },
  "src.panels.document-preview-panel.getHtml": {
    "id": "src.panels.document-preview-panel.getHtml",
    "name": "getHtml",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private getHtml(webview: Webview): string {\n\t\treturn getWebviewContent(\n\t\t\twebview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"document-preview\"\n\t\t);\n\t}",
    "start_line": 127,
    "end_line": 133,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webview"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getHtml",
    "component_id": "src.panels.document-preview-panel.getHtml"
  },
  "src.panels.document-preview-panel.handleWebviewMessage": {
    "id": "src.panels.document-preview-panel.handleWebviewMessage",
    "name": "handleWebviewMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private async handleWebviewMessage(\n\t\tmessage: PreviewWebviewMessage\n\t): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewPanel] Received message: ${message?.type ?? \"undefined\"}`\n\t\t);\n\t\tswitch (message?.type) {\n\t\t\tcase \"preview/ready\":\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[DocumentPreviewPanel] Webview ready, lastArtifact: ${this.lastArtifact ? \"present\" : \"null\"}`\n\t\t\t\t);\n\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\tawait this.flushPendingMessages();\n\t\t\t\tif (this.lastArtifact) {\n\t\t\t\t\tawait this.postMessage({\n\t\t\t\t\t\ttype: \"preview/load-document\",\n\t\t\t\t\t\tpayload: this.lastArtifact,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tcase \"preview/request-reload\":\n\t\t\t\tawait this.options.onReloadRequested?.();\n\t\t\t\treturn;\n\t\t\tcase \"preview/edit-attempt\":\n\t\t\t\tthis.options.onEditAttempt?.(message.payload?.reason);\n\t\t\t\twindow.showWarningMessage(\n\t\t\t\t\t\"Document preview is read-only. Use the editor to modify the source.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\tcase \"preview/open-in-editor\":\n\t\t\t\tawait this.options.onOpenInEditor?.();\n\t\t\t\treturn;\n\t\t\tcase \"preview/forms/submit\":\n\t\t\t\tawait this.handleFormSubmission(message.payload);\n\t\t\t\treturn;\n\t\t\tcase \"preview/refine/submit\":\n\t\t\t\tawait this.handleRefineSubmission(message.payload);\n\t\t\t\treturn;\n\t\t\tcase \"preview/execute-task-group\":\n\t\t\t\tawait this.handleExecuteTaskGroup(message.payload);\n\t\t\t\treturn;\n\t\t\tcase \"preview/open-file\":\n\t\t\t\tawait this.options.onOpenFile?.(message.payload?.filePath);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[DocumentPreviewPanel] Unknown message received: ${message?.type ?? \"undefined\"}`\n\t\t\t\t);\n\t\t}\n\t}",
    "start_line": 135,
    "end_line": 184,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleWebviewMessage",
    "component_id": "src.panels.document-preview-panel.handleWebviewMessage"
  },
  "src.panels.document-preview-panel.postMessage": {
    "id": "src.panels.document-preview-panel.postMessage",
    "name": "postMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private async postMessage(message: PreviewPanelMessage): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewPanel] Posting message: ${message.type}, ready: ${this.isWebviewReady}, hasPanel: ${!!this.panel?.webview}`\n\t\t);\n\t\tif (!this.panel?.webview) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[DocumentPreviewPanel] No panel webview, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isWebviewReady) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[DocumentPreviewPanel] Webview not ready, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.panel.webview.postMessage(message);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DocumentPreviewPanel] Message sent successfully: ${message.type}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DocumentPreviewPanel] Failed to post message ${message.type}: ${\n\t\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 186,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method postMessage",
    "component_id": "src.panels.document-preview-panel.postMessage"
  },
  "src.panels.document-preview-panel.flushPendingMessages": {
    "id": "src.panels.document-preview-panel.flushPendingMessages",
    "name": "flushPendingMessages",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private async flushPendingMessages(): Promise<void> {\n\t\tif (!(this.panel && this.isWebviewReady)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst queue = [...this.pendingMessages];\n\t\tthis.pendingMessages = [];\n\n\t\tfor (const message of queue) {\n\t\t\tawait this.postMessage(message);\n\t\t}\n\t}",
    "start_line": 220,
    "end_line": 231,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method flushPendingMessages",
    "component_id": "src.panels.document-preview-panel.flushPendingMessages"
  },
  "src.panels.document-preview-panel.handleFormSubmission": {
    "id": "src.panels.document-preview-panel.handleFormSubmission",
    "name": "handleFormSubmission",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private async handleFormSubmission(\n\t\tpayload: FormSubmissionPayload | undefined\n\t): Promise<void> {\n\t\tif (!payload?.requestId) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = await this.options.onFormSubmit?.(payload);\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/forms/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: result?.status ?? \"success\",\n\t\t\t\t\tmessage: result?.message,\n\t\t\t\t},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/forms/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage:\n\t\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t\t: \"Failed to save form changes\",\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 233,
    "end_line": 263,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleFormSubmission",
    "component_id": "src.panels.document-preview-panel.handleFormSubmission"
  },
  "src.panels.document-preview-panel.handleRefineSubmission": {
    "id": "src.panels.document-preview-panel.handleRefineSubmission",
    "name": "handleRefineSubmission",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private async handleRefineSubmission(\n\t\tpayload: RefinementRequestPayload | undefined\n\t): Promise<void> {\n\t\tif (!payload?.requestId) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = await this.options.onRefineSubmit?.(payload);\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/refine/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: result?.status ?? \"success\",\n\t\t\t\t\tmessage: result?.message,\n\t\t\t\t},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tawait this.postMessage({\n\t\t\t\ttype: \"preview/refine/result\",\n\t\t\t\tpayload: {\n\t\t\t\t\trequestId: payload.requestId,\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage:\n\t\t\t\t\t\terror instanceof Error\n\t\t\t\t\t\t\t? error.message\n\t\t\t\t\t\t\t: \"Failed to submit refinement request\",\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 265,
    "end_line": 295,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleRefineSubmission",
    "component_id": "src.panels.document-preview-panel.handleRefineSubmission"
  },
  "src.panels.document-preview-panel.handleExecuteTaskGroup": {
    "id": "src.panels.document-preview-panel.handleExecuteTaskGroup",
    "name": "handleExecuteTaskGroup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/document-preview-panel.ts",
    "relative_path": "src/panels/document-preview-panel.ts",
    "depends_on": [],
    "source_code": "private async handleExecuteTaskGroup(\n\t\tpayload: { groupName: string } | undefined\n\t): Promise<void> {\n\t\tif (!payload?.groupName) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.options.onExecuteTaskGroup?.(payload.groupName);\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error ? error.message : \"Failed to execute task group\";\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DocumentPreviewPanel] Error executing task group: ${message}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to execute task group: ${message}`);\n\t\t}\n\t}",
    "start_line": 297,
    "end_line": 314,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleExecuteTaskGroup",
    "component_id": "src.panels.document-preview-panel.handleExecuteTaskGroup"
  },
  "src.panels.welcome-screen-panel.WelcomeScreenPanelCallbacks": {
    "id": "src.panels.welcome-screen-panel.WelcomeScreenPanelCallbacks",
    "name": "WelcomeScreenPanelCallbacks",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [
      "src.panels.welcome-screen-panel.WelcomeScreenPanel"
    ],
    "source_code": "interface WelcomeScreenPanelCallbacks {\n\tonReady?: () => Promise<void> | void;\n\tonExecuteCommand?: (\n\t\tcommandId: string,\n\t\targs?: unknown[]\n\t) => Promise<void> | void;\n\tonUpdateConfig?: (\n\t\tkey: string,\n\t\tvalue: string | boolean\n\t) => Promise<void> | void;\n\tonInstallDependency?: (\n\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\"\n\t) => Promise<void> | void;\n\tonRefreshDependencies?: () => Promise<void> | void;\n\tonUpdatePreference?: (\n\t\tpreference: \"dontShowOnStartup\",\n\t\tvalue: boolean\n\t) => Promise<void> | void;\n\tonOpenExternal?: (url: string) => Promise<void> | void;\n\tonNavigateSection?: (section: string) => Promise<void> | void;\n\tonSearchResources?: (query: string) => Promise<void> | void;\n\tsetPanel?: (panel: WelcomeScreenPanel) => void;\n}",
    "start_line": 21,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeScreenPanelCallbacks",
    "component_id": "src.panels.welcome-screen-panel.WelcomeScreenPanelCallbacks"
  },
  "src.panels.welcome-screen-panel.WelcomeScreenPanel": {
    "id": "src.panels.welcome-screen-panel.WelcomeScreenPanel",
    "name": "WelcomeScreenPanel",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [
      "src.panels.welcome-screen-panel.handleWebviewMessage",
      "src.types.welcome.WebviewToExtensionMessage",
      "src.providers.hook-view-provider.flushPendingMessages",
      "src.providers.hook-view-provider.webview",
      "src.panels.welcome-screen-panel.WelcomeScreenPanel",
      "src.providers.hook-view-provider.ensurePanel",
      "src.panels.welcome-screen-panel.WelcomeScreenPanelCallbacks",
      "src.services.agent-service.dispose",
      "src.panels.welcome-screen-panel.ensurePanel",
      "src.utils.get-webview-content.getWebviewContent",
      "src.types.welcome.ExtensionToWebviewMessage",
      "src.panels.welcome-screen-panel.dispose",
      "src.panels.welcome-screen-panel.getHtml",
      "src.providers.hook-view-provider.handleWebviewMessage",
      "src.panels.welcome-screen-panel.flushPendingMessages",
      "src.panels.welcome-screen-panel.postMessage",
      "src.panels.welcome-screen-panel.disposePanel"
    ],
    "source_code": "class WelcomeScreenPanel {\n\tstatic readonly panelType = \"gatomia.welcomeScreen\";\n\tprivate static currentPanel: WelcomeScreenPanel | undefined;\n\n\tprivate panel: WebviewPanel | undefined;\n\tprivate isWebviewReady = false;\n\tprivate pendingMessages: ExtensionToWebviewMessage[] = [];\n\tprivate disposables: Disposable[] = [];\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly callbacks: WelcomeScreenPanelCallbacks;\n\n\tprivate constructor(\n\t\tcontext: ExtensionContext,\n\t\toutputChannel: OutputChannel,\n\t\tcallbacks: WelcomeScreenPanelCallbacks = {}\n\t) {\n\t\tthis.context = context;\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.callbacks = callbacks;\n\t}\n\n\t/**\n\t * Show or focus the welcome screen panel (singleton pattern)\n\t * Implements FR-017: Prevent opening multiple instances\n\t */\n\tstatic show(\n\t\tcontext: ExtensionContext,\n\t\toutputChannel: OutputChannel,\n\t\tcallbacks: WelcomeScreenPanelCallbacks = {}\n\t): WelcomeScreenPanel {\n\t\t// If panel already exists, reveal it\n\t\tif (WelcomeScreenPanel.currentPanel) {\n\t\t\tWelcomeScreenPanel.currentPanel.panel?.reveal(ViewColumn.One);\n\t\t\treturn WelcomeScreenPanel.currentPanel;\n\t\t}\n\n\t\t// Create new panel\n\t\tconst panel = new WelcomeScreenPanel(context, outputChannel, callbacks);\n\t\tWelcomeScreenPanel.currentPanel = panel;\n\t\tpanel.ensurePanel();\n\t\treturn panel;\n\t}\n\n\t/**\n\t * Post message to webview\n\t */\n\tasync postMessage(message: ExtensionToWebviewMessage): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[WelcomeScreenPanel] Posting message: ${message.type}, ready: ${this.isWebviewReady}, hasPanel: ${!!this.panel?.webview}`\n\t\t);\n\n\t\tif (!this.panel?.webview) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[WelcomeScreenPanel] No panel webview, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isWebviewReady) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[WelcomeScreenPanel] Webview not ready, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tconst success = await this.panel.webview.postMessage(message);\n\t\tif (!success) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[WelcomeScreenPanel] Failed to post message\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Dispose panel and cleanup resources\n\t */\n\tdispose(): void {\n\t\tthis.disposePanel();\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.disposables = [];\n\t\tWelcomeScreenPanel.currentPanel = undefined;\n\t}\n\n\t/**\n\t * Check if panel is currently visible\n\t */\n\tisVisible(): boolean {\n\t\treturn this.panel?.visible ?? false;\n\t}\n\n\t/**\n\t * Ensure panel exists and return it (singleton within instance)\n\t */\n\tprivate ensurePanel(): WebviewPanel {\n\t\tif (this.panel) {\n\t\t\treturn this.panel;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tWelcomeScreenPanel.panelType,\n\t\t\t\"GatomIA Welcome\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.One,\n\t\t\t\tpreserveFocus: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tpanel.iconPath = {\n\t\t\tlight: Uri.joinPath(\n\t\t\t\tthis.context.extensionUri,\n\t\t\t\t\"assets\",\n\t\t\t\t\"icons\",\n\t\t\t\t\"logo-light.svg\"\n\t\t\t),\n\t\t\tdark: Uri.joinPath(\n\t\t\t\tthis.context.extensionUri,\n\t\t\t\t\"assets\",\n\t\t\t\t\"icons\",\n\t\t\t\t\"logo-dark.svg\"\n\t\t\t),\n\t\t};\n\n\t\tpanel.webview.html = this.getHtml(panel.webview);\n\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\tasync (message: WebviewToExtensionMessage) => {\n\t\t\t\tawait this.handleWebviewMessage(message);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\n\t\tpanel.onDidDispose(() => this.disposePanel(), undefined, this.disposables);\n\n\t\tthis.panel = panel;\n\t\tthis.isWebviewReady = false;\n\n\t\treturn panel;\n\t}\n\n\t/**\n\t * Dispose panel and reset state\n\t */\n\tprivate disposePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.dispose();\n\t\t\tthis.panel = undefined;\n\t\t}\n\t\tthis.isWebviewReady = false;\n\t\tthis.pendingMessages = [];\n\t\tWelcomeScreenPanel.currentPanel = undefined;\n\t}\n\n\t/**\n\t * Get HTML content for webview\n\t * Uses getWebviewContent utility for consistent webview setup\n\t */\n\tprivate getHtml(webview: Webview): string {\n\t\treturn getWebviewContent(\n\t\t\twebview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"welcome-screen\"\n\t\t);\n\t}\n\n\t/**\n\t * Handle messages received from webview\n\t */\n\tprivate async handleWebviewMessage(\n\t\tmessage: WebviewToExtensionMessage\n\t): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[WelcomeScreenPanel] Received message: ${message?.type ?? \"undefined\"}`\n\t\t);\n\n\t\tswitch (message?.type) {\n\t\t\tcase \"welcome/ready\":\n\t\t\t\tthis.outputChannel.appendLine(\"[WelcomeScreenPanel] Webview ready\");\n\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\tawait this.flushPendingMessages();\n\t\t\t\tawait this.callbacks.onReady?.();\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/execute-command\":\n\t\t\t\tawait this.callbacks.onExecuteCommand?.(\n\t\t\t\t\tmessage.commandId,\n\t\t\t\t\tmessage.args\n\t\t\t\t);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/update-config\":\n\t\t\t\tawait this.callbacks.onUpdateConfig?.(message.key, message.value);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/install-dependency\":\n\t\t\t\tawait this.callbacks.onInstallDependency?.(message.dependency);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/refresh-dependencies\":\n\t\t\t\tawait this.callbacks.onRefreshDependencies?.();\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/update-preference\":\n\t\t\t\tawait this.callbacks.onUpdatePreference?.(\n\t\t\t\t\tmessage.preference,\n\t\t\t\t\tmessage.value\n\t\t\t\t);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/open-external\":\n\t\t\t\tawait this.callbacks.onOpenExternal?.(message.url);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/navigate-section\":\n\t\t\t\tawait this.callbacks.onNavigateSection?.(message.section);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/search-resources\":\n\t\t\t\tawait this.callbacks.onSearchResources?.(message.query);\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenPanel] Unknown message type: ${(message as any)?.type ?? \"undefined\"}`\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Flush pending messages after webview becomes ready\n\t */\n\tprivate async flushPendingMessages(): Promise<void> {\n\t\tif (this.pendingMessages.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[WelcomeScreenPanel] Flushing ${this.pendingMessages.length} pending messages`\n\t\t);\n\n\t\tconst messages = [...this.pendingMessages];\n\t\tthis.pendingMessages = [];\n\n\t\tfor (const message of messages) {\n\t\t\tif (this.panel?.webview) {\n\t\t\t\tawait this.panel.webview.postMessage(message);\n\t\t\t}\n\t\t}\n\t}\n}",
    "start_line": 48,
    "end_line": 307,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class WelcomeScreenPanel",
    "component_id": "src.panels.welcome-screen-panel.WelcomeScreenPanel"
  },
  "src.panels.welcome-screen-panel.show": {
    "id": "src.panels.welcome-screen-panel.show",
    "name": "show",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "static show(\n\t\tcontext: ExtensionContext,\n\t\toutputChannel: OutputChannel,\n\t\tcallbacks: WelcomeScreenPanelCallbacks = {}\n\t): WelcomeScreenPanel {\n\t\t// If panel already exists, reveal it\n\t\tif (WelcomeScreenPanel.currentPanel) {\n\t\t\tWelcomeScreenPanel.currentPanel.panel?.reveal(ViewColumn.One);\n\t\t\treturn WelcomeScreenPanel.currentPanel;\n\t\t}\n\n\t\t// Create new panel\n\t\tconst panel = new WelcomeScreenPanel(context, outputChannel, callbacks);\n\t\tWelcomeScreenPanel.currentPanel = panel;\n\t\tpanel.ensurePanel();\n\t\treturn panel;\n\t}",
    "start_line": 74,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "outputChannel",
      "callbacks"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method show",
    "component_id": "src.panels.welcome-screen-panel.show"
  },
  "src.panels.welcome-screen-panel.postMessage": {
    "id": "src.panels.welcome-screen-panel.postMessage",
    "name": "postMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "async postMessage(message: ExtensionToWebviewMessage): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[WelcomeScreenPanel] Posting message: ${message.type}, ready: ${this.isWebviewReady}, hasPanel: ${!!this.panel?.webview}`\n\t\t);\n\n\t\tif (!this.panel?.webview) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[WelcomeScreenPanel] No panel webview, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isWebviewReady) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[WelcomeScreenPanel] Webview not ready, queueing message\"\n\t\t\t);\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tconst success = await this.panel.webview.postMessage(message);\n\t\tif (!success) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[WelcomeScreenPanel] Failed to post message\"\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 95,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method postMessage",
    "component_id": "src.panels.welcome-screen-panel.postMessage"
  },
  "src.panels.welcome-screen-panel.dispose": {
    "id": "src.panels.welcome-screen-panel.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.disposePanel();\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.disposables = [];\n\t\tWelcomeScreenPanel.currentPanel = undefined;\n\t}",
    "start_line": 127,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.panels.welcome-screen-panel.dispose"
  },
  "src.panels.welcome-screen-panel.isVisible": {
    "id": "src.panels.welcome-screen-panel.isVisible",
    "name": "isVisible",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "isVisible(): boolean {\n\t\treturn this.panel?.visible ?? false;\n\t}",
    "start_line": 139,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isVisible",
    "component_id": "src.panels.welcome-screen-panel.isVisible"
  },
  "src.panels.welcome-screen-panel.ensurePanel": {
    "id": "src.panels.welcome-screen-panel.ensurePanel",
    "name": "ensurePanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "private ensurePanel(): WebviewPanel {\n\t\tif (this.panel) {\n\t\t\treturn this.panel;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tWelcomeScreenPanel.panelType,\n\t\t\t\"GatomIA Welcome\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.One,\n\t\t\t\tpreserveFocus: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tpanel.iconPath = {\n\t\t\tlight: Uri.joinPath(\n\t\t\t\tthis.context.extensionUri,\n\t\t\t\t\"assets\",\n\t\t\t\t\"icons\",\n\t\t\t\t\"logo-light.svg\"\n\t\t\t),\n\t\t\tdark: Uri.joinPath(\n\t\t\t\tthis.context.extensionUri,\n\t\t\t\t\"assets\",\n\t\t\t\t\"icons\",\n\t\t\t\t\"logo-dark.svg\"\n\t\t\t),\n\t\t};\n\n\t\tpanel.webview.html = this.getHtml(panel.webview);\n\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\tasync (message: WebviewToExtensionMessage) => {\n\t\t\t\tawait this.handleWebviewMessage(message);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\n\t\tpanel.onDidDispose(() => this.disposePanel(), undefined, this.disposables);\n\n\t\tthis.panel = panel;\n\t\tthis.isWebviewReady = false;\n\n\t\treturn panel;\n\t}",
    "start_line": 146,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method ensurePanel",
    "component_id": "src.panels.welcome-screen-panel.ensurePanel"
  },
  "src.panels.welcome-screen-panel.disposePanel": {
    "id": "src.panels.welcome-screen-panel.disposePanel",
    "name": "disposePanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "private disposePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.dispose();\n\t\t\tthis.panel = undefined;\n\t\t}\n\t\tthis.isWebviewReady = false;\n\t\tthis.pendingMessages = [];\n\t\tWelcomeScreenPanel.currentPanel = undefined;\n\t}",
    "start_line": 201,
    "end_line": 209,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method disposePanel",
    "component_id": "src.panels.welcome-screen-panel.disposePanel"
  },
  "src.panels.welcome-screen-panel.getHtml": {
    "id": "src.panels.welcome-screen-panel.getHtml",
    "name": "getHtml",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "private getHtml(webview: Webview): string {\n\t\treturn getWebviewContent(\n\t\t\twebview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"welcome-screen\"\n\t\t);\n\t}",
    "start_line": 215,
    "end_line": 221,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webview"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getHtml",
    "component_id": "src.panels.welcome-screen-panel.getHtml"
  },
  "src.panels.welcome-screen-panel.handleWebviewMessage": {
    "id": "src.panels.welcome-screen-panel.handleWebviewMessage",
    "name": "handleWebviewMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "private async handleWebviewMessage(\n\t\tmessage: WebviewToExtensionMessage\n\t): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[WelcomeScreenPanel] Received message: ${message?.type ?? \"undefined\"}`\n\t\t);\n\n\t\tswitch (message?.type) {\n\t\t\tcase \"welcome/ready\":\n\t\t\t\tthis.outputChannel.appendLine(\"[WelcomeScreenPanel] Webview ready\");\n\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\tawait this.flushPendingMessages();\n\t\t\t\tawait this.callbacks.onReady?.();\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/execute-command\":\n\t\t\t\tawait this.callbacks.onExecuteCommand?.(\n\t\t\t\t\tmessage.commandId,\n\t\t\t\t\tmessage.args\n\t\t\t\t);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/update-config\":\n\t\t\t\tawait this.callbacks.onUpdateConfig?.(message.key, message.value);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/install-dependency\":\n\t\t\t\tawait this.callbacks.onInstallDependency?.(message.dependency);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/refresh-dependencies\":\n\t\t\t\tawait this.callbacks.onRefreshDependencies?.();\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/update-preference\":\n\t\t\t\tawait this.callbacks.onUpdatePreference?.(\n\t\t\t\t\tmessage.preference,\n\t\t\t\t\tmessage.value\n\t\t\t\t);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/open-external\":\n\t\t\t\tawait this.callbacks.onOpenExternal?.(message.url);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/navigate-section\":\n\t\t\t\tawait this.callbacks.onNavigateSection?.(message.section);\n\t\t\t\treturn;\n\n\t\t\tcase \"welcome/search-resources\":\n\t\t\t\tawait this.callbacks.onSearchResources?.(message.query);\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenPanel] Unknown message type: ${(message as any)?.type ?? \"undefined\"}`\n\t\t\t\t);\n\t\t}\n\t}",
    "start_line": 226,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleWebviewMessage",
    "component_id": "src.panels.welcome-screen-panel.handleWebviewMessage"
  },
  "src.panels.welcome-screen-panel.flushPendingMessages": {
    "id": "src.panels.welcome-screen-panel.flushPendingMessages",
    "name": "flushPendingMessages",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/panels/welcome-screen-panel.ts",
    "relative_path": "src/panels/welcome-screen-panel.ts",
    "depends_on": [],
    "source_code": "private async flushPendingMessages(): Promise<void> {\n\t\tif (this.pendingMessages.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[WelcomeScreenPanel] Flushing ${this.pendingMessages.length} pending messages`\n\t\t);\n\n\t\tconst messages = [...this.pendingMessages];\n\t\tthis.pendingMessages = [];\n\n\t\tfor (const message of messages) {\n\t\t\tif (this.panel?.webview) {\n\t\t\t\tawait this.panel.webview.postMessage(message);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 289,
    "end_line": 306,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method flushPendingMessages",
    "component_id": "src.panels.welcome-screen-panel.flushPendingMessages"
  },
  "src.providers.actions-explorer-provider.ActionCategory": {
    "id": "src.providers.actions-explorer-provider.ActionCategory",
    "name": "ActionCategory",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "type ActionCategory =\n\t| \"prompts\"\n\t| \"agents\"\n\t| \"skills\"\n\t| \"scripts\"\n\t| \"templates\"\n\t| \"instructions\"\n\t| \"speckit\"\n\t| \"speckit-prompts\"\n\t| \"speckit-agents\"\n\t| \"speckit-skills\"\n\t| \"speckit-scripts\"\n\t| \"speckit-templates\"\n\t| \"speckit-instructions\";",
    "start_line": 29,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ActionCategory",
    "component_id": "src.providers.actions-explorer-provider.ActionCategory"
  },
  "src.providers.actions-explorer-provider.ActionItemOptions": {
    "id": "src.providers.actions-explorer-provider.ActionItemOptions",
    "name": "ActionItemOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [
      "src.providers.actions-explorer-provider.ActionCategory"
    ],
    "source_code": "interface ActionItemOptions {\n\tresourceUri?: Uri;\n\tcommand?: Command;\n\ttooltip?: string;\n\tdescription?: string;\n\tcategory?: ActionCategory;\n\tisAgent?: boolean;\n\tisSkill?: boolean;\n}",
    "start_line": 44,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ActionItemOptions",
    "component_id": "src.providers.actions-explorer-provider.ActionItemOptions"
  },
  "src.providers.actions-explorer-provider.ActionItem": {
    "id": "src.providers.actions-explorer-provider.ActionItem",
    "name": "ActionItem",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [
      "src.providers.actions-explorer-provider.getIconPath",
      "src.providers.actions-explorer-provider.ActionCategory",
      "src.providers.actions-explorer-provider.ActionItemOptions",
      "src.providers.actions-explorer-provider.getGroupIcon",
      "src.providers.actions-explorer-provider.getSpeckitGroupIcon"
    ],
    "source_code": "class ActionItem extends TreeItem {\n\treadonly category: ActionCategory | undefined;\n\treadonly contextValue: string;\n\n\tconstructor(\n\t\tlabel: string,\n\t\tcollapsibleState: TreeItemCollapsibleState,\n\t\tcontextValue: string,\n\t\toptions?: ActionItemOptions\n\t) {\n\t\tsuper(label, collapsibleState);\n\t\tthis.contextValue = contextValue;\n\t\tthis.category = options?.category;\n\t\tthis.resourceUri = options?.resourceUri;\n\t\tthis.command = options?.command;\n\t\tthis.tooltip = options?.tooltip;\n\t\tthis.description = options?.description;\n\t\tthis.iconPath = this.getIconPath(contextValue, options);\n\t}\n\n\tprivate getIconPath(\n\t\tcontextValue: string,\n\t\toptions?: ActionItemOptions\n\t): ThemeIcon {\n\t\tif (contextValue.startsWith(\"group-speckit\")) {\n\t\t\treturn this.getSpeckitGroupIcon(contextValue);\n\t\t}\n\t\tif (contextValue.startsWith(\"group-\")) {\n\t\t\treturn this.getGroupIcon(contextValue);\n\t\t}\n\t\tif (contextValue === \"action-runnable\") {\n\t\t\treturn new ThemeIcon(options?.isAgent ? \"robot\" : \"zap\");\n\t\t}\n\t\tif (contextValue === \"action-skill\") {\n\t\t\treturn new ThemeIcon(\"tools\");\n\t\t}\n\t\tif (contextValue === \"action-script\") {\n\t\t\treturn new ThemeIcon(\"terminal\");\n\t\t}\n\t\tif (contextValue === \"action-template\") {\n\t\t\treturn new ThemeIcon(\"file-code\");\n\t\t}\n\t\tif (contextValue === \"action-file\") {\n\t\t\treturn new ThemeIcon(\"file\");\n\t\t}\n\t\treturn new ThemeIcon(\"folder\");\n\t}\n\n\tprivate getSpeckitGroupIcon(contextValue: string): ThemeIcon {\n\t\tswitch (contextValue) {\n\t\t\tcase \"group-speckit-prompts\":\n\t\t\t\treturn new ThemeIcon(\"comment-discussion\");\n\t\t\tcase \"group-speckit-agents\":\n\t\t\t\treturn new ThemeIcon(\"robot\");\n\t\t\tcase \"group-speckit-instructions\":\n\t\t\t\treturn new ThemeIcon(\"book\");\n\t\t\tcase \"group-speckit-scripts\":\n\t\t\t\treturn new ThemeIcon(\"terminal\");\n\t\t\tcase \"group-speckit-templates\":\n\t\t\t\treturn new ThemeIcon(\"file-code\");\n\t\t\tdefault:\n\t\t\t\treturn new ThemeIcon(\"package\");\n\t\t}\n\t}\n\n\tprivate getGroupIcon(contextValue: string): ThemeIcon {\n\t\tswitch (contextValue) {\n\t\t\tcase \"group-prompts\":\n\t\t\t\treturn new ThemeIcon(\"comment-discussion\");\n\t\t\tcase \"group-agents\":\n\t\t\t\treturn new ThemeIcon(\"robot\");\n\t\t\tcase \"group-skills\":\n\t\t\t\treturn new ThemeIcon(\"tools\");\n\t\t\tcase \"group-scripts\":\n\t\t\t\treturn new ThemeIcon(\"terminal\");\n\t\t\tcase \"group-templates\":\n\t\t\t\treturn new ThemeIcon(\"file-code\");\n\t\t\tdefault:\n\t\t\t\treturn new ThemeIcon(\"folder\");\n\t\t}\n\t}\n}",
    "start_line": 54,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ActionItem",
    "component_id": "src.providers.actions-explorer-provider.ActionItem"
  },
  "src.providers.actions-explorer-provider.getIconPath": {
    "id": "src.providers.actions-explorer-provider.getIconPath",
    "name": "getIconPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getIconPath(\n\t\tcontextValue: string,\n\t\toptions?: ActionItemOptions\n\t): ThemeIcon {\n\t\tif (contextValue.startsWith(\"group-speckit\")) {\n\t\t\treturn this.getSpeckitGroupIcon(contextValue);\n\t\t}\n\t\tif (contextValue.startsWith(\"group-\")) {\n\t\t\treturn this.getGroupIcon(contextValue);\n\t\t}\n\t\tif (contextValue === \"action-runnable\") {\n\t\t\treturn new ThemeIcon(options?.isAgent ? \"robot\" : \"zap\");\n\t\t}\n\t\tif (contextValue === \"action-skill\") {\n\t\t\treturn new ThemeIcon(\"tools\");\n\t\t}\n\t\tif (contextValue === \"action-script\") {\n\t\t\treturn new ThemeIcon(\"terminal\");\n\t\t}\n\t\tif (contextValue === \"action-template\") {\n\t\t\treturn new ThemeIcon(\"file-code\");\n\t\t}\n\t\tif (contextValue === \"action-file\") {\n\t\t\treturn new ThemeIcon(\"file\");\n\t\t}\n\t\treturn new ThemeIcon(\"folder\");\n\t}",
    "start_line": 74,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "contextValue",
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getIconPath",
    "component_id": "src.providers.actions-explorer-provider.getIconPath"
  },
  "src.providers.actions-explorer-provider.getSpeckitGroupIcon": {
    "id": "src.providers.actions-explorer-provider.getSpeckitGroupIcon",
    "name": "getSpeckitGroupIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getSpeckitGroupIcon(contextValue: string): ThemeIcon {\n\t\tswitch (contextValue) {\n\t\t\tcase \"group-speckit-prompts\":\n\t\t\t\treturn new ThemeIcon(\"comment-discussion\");\n\t\t\tcase \"group-speckit-agents\":\n\t\t\t\treturn new ThemeIcon(\"robot\");\n\t\t\tcase \"group-speckit-instructions\":\n\t\t\t\treturn new ThemeIcon(\"book\");\n\t\t\tcase \"group-speckit-scripts\":\n\t\t\t\treturn new ThemeIcon(\"terminal\");\n\t\t\tcase \"group-speckit-templates\":\n\t\t\t\treturn new ThemeIcon(\"file-code\");\n\t\t\tdefault:\n\t\t\t\treturn new ThemeIcon(\"package\");\n\t\t}\n\t}",
    "start_line": 102,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "contextValue"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpeckitGroupIcon",
    "component_id": "src.providers.actions-explorer-provider.getSpeckitGroupIcon"
  },
  "src.providers.actions-explorer-provider.getGroupIcon": {
    "id": "src.providers.actions-explorer-provider.getGroupIcon",
    "name": "getGroupIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getGroupIcon(contextValue: string): ThemeIcon {\n\t\tswitch (contextValue) {\n\t\t\tcase \"group-prompts\":\n\t\t\t\treturn new ThemeIcon(\"comment-discussion\");\n\t\t\tcase \"group-agents\":\n\t\t\t\treturn new ThemeIcon(\"robot\");\n\t\t\tcase \"group-skills\":\n\t\t\t\treturn new ThemeIcon(\"tools\");\n\t\t\tcase \"group-scripts\":\n\t\t\t\treturn new ThemeIcon(\"terminal\");\n\t\t\tcase \"group-templates\":\n\t\t\t\treturn new ThemeIcon(\"file-code\");\n\t\t\tdefault:\n\t\t\t\treturn new ThemeIcon(\"folder\");\n\t\t}\n\t}",
    "start_line": 119,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "contextValue"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getGroupIcon",
    "component_id": "src.providers.actions-explorer-provider.getGroupIcon"
  },
  "src.providers.actions-explorer-provider.ActionsExplorerProvider": {
    "id": "src.providers.actions-explorer-provider.ActionsExplorerProvider",
    "name": "ActionsExplorerProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [
      "src.providers.actions-explorer-provider.normalizeName",
      "src.providers.actions-explorer-provider.getRootItems",
      "src.providers.actions-explorer-provider.getTemplates",
      "src.providers.steering-explorer-provider.readDisplayName",
      "src.utils.config-manager.ConfigManager",
      "src.providers.actions-explorer-provider.getSkills",
      "src.providers.actions-explorer-provider.getScripts",
      "src.providers.actions-explorer-provider.getFiles",
      "src.providers.actions-explorer-provider.readDisplayName",
      "src.providers.steering-explorer-provider.normalizeName",
      "src.providers.actions-explorer-provider.getRegularChildren",
      "src.providers.actions-explorer-provider.getSpeckitRootItems",
      "src.providers.steering-explorer-provider.refresh",
      "src.providers.actions-explorer-provider.ActionItem",
      "src.providers.steering-explorer-provider.getRootItems",
      "src.providers.actions-explorer-provider.ActionCategory",
      "src.providers.actions-explorer-provider.refresh",
      "src.providers.actions-explorer-provider.getSpeckitChildren",
      "src.providers.actions-explorer-provider.collectFilesRecursive",
      "src.utils.spec-kit-adapter.getInstance"
    ],
    "source_code": "class ActionsExplorerProvider implements TreeDataProvider<ActionItem> {\n\tstatic readonly viewId = \"gatomia.views.actionsExplorer\";\n\n\tprivate readonly changeEmitter = new EventEmitter<\n\t\tActionItem | undefined | null | void\n\t>();\n\treadonly onDidChangeTreeData: Event<ActionItem | undefined | null | void> =\n\t\tthis.changeEmitter.event;\n\n\tprivate readonly configManager: ConfigManager;\n\tprivate readonly context: ExtensionContext;\n\n\tconstructor(context: ExtensionContext) {\n\t\tthis.context = context;\n\t\tthis.configManager = ConfigManager.getInstance();\n\t}\n\n\trefresh(): void {\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tgetTreeItem(element: ActionItem): TreeItem {\n\t\treturn element;\n\t}\n\n\tasync getChildren(element?: ActionItem): Promise<ActionItem[]> {\n\t\tif (!element) {\n\t\t\treturn this.getRootItems();\n\t\t}\n\n\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\tif (!ws) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (element.category === \"speckit\") {\n\t\t\treturn this.getSpeckitRootItems();\n\t\t}\n\n\t\t// SpecKit Children\n\t\tif (element.category?.startsWith(\"speckit-\")) {\n\t\t\treturn await this.getSpeckitChildren(element, ws.uri);\n\t\t}\n\n\t\t// Regular Children\n\t\tif (element.category) {\n\t\t\treturn await this.getRegularChildren(element, ws.uri);\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate getRootItems(): ActionItem[] {\n\t\treturn [\n\t\t\tnew ActionItem(\n\t\t\t\t\"SpecKit\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit\",\n\t\t\t\t{ category: \"speckit\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Prompts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-prompts\",\n\t\t\t\t{ category: \"prompts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Agents\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-agents\",\n\t\t\t\t{ category: \"agents\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Skills\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-skills\",\n\t\t\t\t{ category: \"skills\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Scripts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-scripts\",\n\t\t\t\t{ category: \"scripts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Templates\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-templates\",\n\t\t\t\t{ category: \"templates\" }\n\t\t\t),\n\t\t];\n\t}\n\n\tprivate getSpeckitRootItems(): ActionItem[] {\n\t\treturn [\n\t\t\tnew ActionItem(\n\t\t\t\t\"Prompts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-prompts\",\n\t\t\t\t{ category: \"speckit-prompts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Agents\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-agents\",\n\t\t\t\t{ category: \"speckit-agents\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Instructions\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-instructions\",\n\t\t\t\t{ category: \"speckit-instructions\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Scripts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-scripts\",\n\t\t\t\t{ category: \"speckit-scripts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Templates\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-templates\",\n\t\t\t\t{ category: \"speckit-templates\" }\n\t\t\t),\n\t\t];\n\t}\n\n\tprivate async getSpeckitChildren(\n\t\telement: ActionItem,\n\t\twsUri: Uri\n\t): Promise<ActionItem[]> {\n\t\tswitch (element.category) {\n\t\t\tcase \"speckit-prompts\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"prompts\"),\n\t\t\t\t\tpatterns: [\"*.prompt.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"prompts\",\n\t\t\t\t\tisAgent: false,\n\t\t\t\t\tisSpecKit: true,\n\t\t\t\t});\n\t\t\tcase \"speckit-agents\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"agents\"),\n\t\t\t\t\tpatterns: [\"*.agent.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"agents\",\n\t\t\t\t\tisAgent: true,\n\t\t\t\t\tisSpecKit: true,\n\t\t\t\t});\n\t\t\tcase \"speckit-instructions\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"instructions\"),\n\t\t\t\t\tpatterns: [\"*.instructions.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"instructions\",\n\t\t\t\t\tisAgent: false,\n\t\t\t\t\tisSpecKit: true,\n\t\t\t\t});\n\t\t\tcase \"speckit-scripts\":\n\t\t\t\treturn await this.getScripts(wsUri, true);\n\t\t\tcase \"speckit-templates\":\n\t\t\t\treturn await this.getTemplates(wsUri, true);\n\t\t\tdefault:\n\t\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate async getRegularChildren(\n\t\telement: ActionItem,\n\t\twsUri: Uri\n\t): Promise<ActionItem[]> {\n\t\tswitch (element.category) {\n\t\t\tcase \"prompts\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"prompts\"),\n\t\t\t\t\tpatterns: [\"*.prompt.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"prompts\",\n\t\t\t\t\tisAgent: false,\n\t\t\t\t\tisSpecKit: false,\n\t\t\t\t});\n\t\t\tcase \"agents\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"agents\"),\n\t\t\t\t\tpatterns: [\"*.agent.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"agents\",\n\t\t\t\t\tisAgent: true,\n\t\t\t\t\tisSpecKit: false,\n\t\t\t\t});\n\t\t\tcase \"skills\":\n\t\t\t\treturn await this.getSkills(joinPath(wsUri, \".github\", \"skills\"));\n\t\t\tcase \"scripts\":\n\t\t\t\treturn await this.getScripts(wsUri, false);\n\t\t\tcase \"templates\":\n\t\t\t\treturn await this.getTemplates(wsUri, false);\n\t\t\tdefault:\n\t\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate async readDisplayName(uri: Uri, filename: string): Promise<string> {\n\t\ttry {\n\t\t\t// Read first 1KB to find frontmatter or H1\n\t\t\tconst fileData = await workspace.fs.readFile(uri);\n\t\t\tconst content = new TextDecoder().decode(fileData.slice(0, 1024));\n\n\t\t\t// 1. Try Frontmatter name: ...\n\t\t\tconst frontmatterMatch = FRONTMATTER_REGEXP.exec(content);\n\t\t\tif (frontmatterMatch?.[1]) {\n\t\t\t\treturn frontmatterMatch[1].trim();\n\t\t\t}\n\n\t\t\t// 2. Try H1: # Title\n\t\t\tconst h1Match = H1_REGEXP.exec(content);\n\t\t\tif (h1Match?.[1]) {\n\t\t\t\treturn h1Match[1].trim();\n\t\t\t}\n\n\t\t\t// 3. Fallback: Normalize filename\n\t\t\treturn this.normalizeName(filename);\n\t\t} catch {\n\t\t\treturn this.normalizeName(filename);\n\t\t}\n\t}\n\n\tprivate normalizeName(name: string): string {\n\t\t// Remove extensions\n\t\tlet normalized = name.replace(EXTENSIONS_REGEXP, \"\");\n\t\t// Remove speckit prefix if present\n\t\tnormalized = normalized.replace(SPECKIT_PREFIX_REGEXP, \"\");\n\t\treturn normalized\n\t\t\t.split(SEPARATOR_REGEXP)\n\t\t\t.map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n\t\t\t.join(\" \");\n\t}\n\n\tprivate async getFiles(options: {\n\t\troot: Uri;\n\t\tpatterns: string[];\n\t\tcontextValue: string;\n\t\tcategory: ActionCategory;\n\t\tisAgent?: boolean;\n\t\tisSpecKit?: boolean;\n\t}): Promise<ActionItem[]> {\n\t\tconst files: ActionItem[] = [];\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(options.root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.File) {\n\t\t\t\t\tconst isMatch = options.patterns.some((p) => {\n\t\t\t\t\t\tif (p.startsWith(\"*\")) {\n\t\t\t\t\t\t\treturn name.endsWith(p.slice(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn name === p;\n\t\t\t\t\t});\n\n\t\t\t\t\t// Filter for SpecKit\n\t\t\t\t\tconst isSpecKitFile = name.startsWith(\"speckit.\");\n\t\t\t\t\tif (options.isSpecKit && !isSpecKitFile) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!options.isSpecKit && isSpecKitFile) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isMatch) {\n\t\t\t\t\t\tconst displayName = await this.readDisplayName(\n\t\t\t\t\t\t\tjoinPath(options.root, name),\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\t\t\t\t\t\tfiles.push(\n\t\t\t\t\t\t\tnew ActionItem(\n\t\t\t\t\t\t\t\tdisplayName,\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\toptions.contextValue,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceUri: joinPath(options.root, name),\n\t\t\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\t\t\ttitle: \"Open File\",\n\t\t\t\t\t\t\t\t\t\targuments: [joinPath(options.root, name)],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcategory: options.category,\n\t\t\t\t\t\t\t\t\tisAgent: options.isAgent,\n\t\t\t\t\t\t\t\t\tdescription: name, // Show original filename as description\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn files;\n\t}\n\n\tprivate async getSkills(root: Uri): Promise<ActionItem[]> {\n\t\t// Skills are generic, so no SpecKit filtering for now, but keeping normalization if needed\n\t\tconst skills: ActionItem[] = [];\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.Directory) {\n\t\t\t\t\tconst skillMd = joinPath(root, name, \"SKILL.md\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait workspace.fs.stat(skillMd);\n\t\t\t\t\t\tconst displayName = await this.readDisplayName(skillMd, name);\n\t\t\t\t\t\tskills.push(\n\t\t\t\t\t\t\tnew ActionItem(\n\t\t\t\t\t\t\t\tdisplayName,\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\t\"action-skill\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceUri: skillMd,\n\t\t\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\t\t\ttitle: \"Open Skill\",\n\t\t\t\t\t\t\t\t\t\targuments: [skillMd],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcategory: \"skills\",\n\t\t\t\t\t\t\t\t\tisSkill: true,\n\t\t\t\t\t\t\t\t\tdescription: name,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t/* not a skill */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn skills;\n\t}\n\n\tprivate async getScripts(\n\t\twsUri: Uri,\n\t\tisSpecKit: boolean\n\t): Promise<ActionItem[]> {\n\t\tconst items: ActionItem[] = [];\n\t\tconst scriptExtensions = [\".sh\", \".ps1\", \".py\", \".js\", \".ts\"];\n\n\t\tif (isSpecKit) {\n\t\t\t// SpecKit Scripts: .specify/scripts/**/*\n\t\t\tconst root = joinPath(wsUri, \".specify\", \"scripts\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: scriptExtensions,\n\t\t\t\tcontextValue: \"action-script\",\n\t\t\t\tcategory: \"scripts\",\n\t\t\t\titems,\n\t\t\t});\n\t\t} else {\n\t\t\t// Regular Scripts: .github/scripts\n\t\t\tconst root = joinPath(wsUri, \".github\", \"scripts\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: scriptExtensions,\n\t\t\t\tcontextValue: \"action-script\",\n\t\t\t\tcategory: \"scripts\",\n\t\t\t\titems,\n\t\t\t});\n\n\t\t\t// Also look into skills for regular scripts\n\t\t\tconst skillsRoot = joinPath(wsUri, \".github\", \"skills\");\n\t\t\ttry {\n\t\t\t\tconst skillDirs = await workspace.fs.readDirectory(skillsRoot);\n\t\t\t\tfor (const [name, ftype] of skillDirs) {\n\t\t\t\t\tif (ftype === FileType.Directory) {\n\t\t\t\t\t\tawait this.collectFilesRecursive({\n\t\t\t\t\t\t\troot: joinPath(skillsRoot, name, \"scripts\"),\n\t\t\t\t\t\t\textensions: scriptExtensions,\n\t\t\t\t\t\t\tcontextValue: \"action-script\",\n\t\t\t\t\t\t\tcategory: \"scripts\",\n\t\t\t\t\t\t\titems,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t/* ignore */\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}\n\n\tprivate async getTemplates(\n\t\twsUri: Uri,\n\t\tisSpecKit: boolean\n\t): Promise<ActionItem[]> {\n\t\tconst items: ActionItem[] = [];\n\t\tconst templateExtensions = [\".md\", \".yaml\", \".json\", \".handlebars\", \".hbs\"];\n\n\t\tif (isSpecKit) {\n\t\t\t// SpecKit Templates: .specify/templates\n\t\t\tconst root = joinPath(wsUri, \".specify\", \"templates\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: templateExtensions,\n\t\t\t\tcontextValue: \"action-template\",\n\t\t\t\tcategory: \"templates\",\n\t\t\t\titems,\n\t\t\t});\n\t\t} else {\n\t\t\t// Regular Templates: .github/templates\n\t\t\tconst root = joinPath(wsUri, \".github\", \"templates\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: templateExtensions,\n\t\t\t\tcontextValue: \"action-template\",\n\t\t\t\tcategory: \"templates\",\n\t\t\t\titems,\n\t\t\t});\n\n\t\t\t// Also look into skills for regular templates\n\t\t\tconst skillsRoot = joinPath(wsUri, \".github\", \"skills\");\n\t\t\ttry {\n\t\t\t\tconst skillDirs = await workspace.fs.readDirectory(skillsRoot);\n\t\t\t\tfor (const [name, ftype] of skillDirs) {\n\t\t\t\t\tif (ftype === FileType.Directory) {\n\t\t\t\t\t\tawait this.collectFilesRecursive({\n\t\t\t\t\t\t\troot: joinPath(skillsRoot, name, \"templates\"),\n\t\t\t\t\t\t\textensions: templateExtensions,\n\t\t\t\t\t\t\tcontextValue: \"action-template\",\n\t\t\t\t\t\t\tcategory: \"templates\",\n\t\t\t\t\t\t\titems,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t/* ignore */\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}\n\n\tprivate async collectFilesRecursive(options: {\n\t\troot: Uri;\n\t\textensions: string[];\n\t\tcontextValue: string;\n\t\tcategory: ActionCategory;\n\t\titems: ActionItem[];\n\t}): Promise<void> {\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(options.root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.Directory) {\n\t\t\t\t\tawait this.collectFilesRecursive({\n\t\t\t\t\t\troot: joinPath(options.root, name),\n\t\t\t\t\t\textensions: options.extensions,\n\t\t\t\t\t\tcontextValue: options.contextValue,\n\t\t\t\t\t\tcategory: options.category,\n\t\t\t\t\t\titems: options.items,\n\t\t\t\t\t});\n\t\t\t\t} else if (\n\t\t\t\t\ttype === FileType.File &&\n\t\t\t\t\toptions.extensions.some((ext) => name.endsWith(ext))\n\t\t\t\t) {\n\t\t\t\t\t// Note: scripts inside .specify/scripts don't necessarily start with speckit., they are defined by location\n\t\t\t\t\t// However, if we were in .github, we would check prefix.\n\t\t\t\t\t// The instruction says: \"para scripts e templates, basta verificar o diretrio .specify\"\n\t\t\t\t\t// So location based for SpecKit scripts/templates.\n\n\t\t\t\t\tconst displayName = await this.readDisplayName(\n\t\t\t\t\t\tjoinPath(options.root, name),\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\toptions.items.push(\n\t\t\t\t\t\tnew ActionItem(\n\t\t\t\t\t\t\tdisplayName,\n\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\toptions.contextValue,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresourceUri: joinPath(options.root, name),\n\t\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\t\ttitle: \"Open File\",\n\t\t\t\t\t\t\t\t\targuments: [joinPath(options.root, name)],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcategory: options.category,\n\t\t\t\t\t\t\t\tdescription: workspace.asRelativePath(\n\t\t\t\t\t\t\t\t\tjoinPath(options.root, name)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t}\n\n\tasync renamePrompt(item?: ActionItem): Promise<void> {\n\t\tif (!item?.resourceUri) {\n\t\t\treturn;\n\t\t}\n\t\tconst newName = await window.showInputBox({\n\t\t\tprompt: \"New name\",\n\t\t\tvalue: basename(item.resourceUri.fsPath),\n\t\t});\n\t\tif (newName) {\n\t\t\tconst target = joinPath(\n\t\t\t\tUri.file(dirname(item.resourceUri.fsPath)),\n\t\t\t\tnewName\n\t\t\t);\n\t\t\tawait workspace.fs.rename(item.resourceUri, target);\n\t\t\tthis.refresh();\n\t\t}\n\t}\n}",
    "start_line": 137,
    "end_line": 651,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ActionsExplorerProvider",
    "component_id": "src.providers.actions-explorer-provider.ActionsExplorerProvider"
  },
  "src.providers.actions-explorer-provider.refresh": {
    "id": "src.providers.actions-explorer-provider.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "refresh(): void {\n\t\tthis.changeEmitter.fire();\n\t}",
    "start_line": 154,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method refresh",
    "component_id": "src.providers.actions-explorer-provider.refresh"
  },
  "src.providers.actions-explorer-provider.getTreeItem": {
    "id": "src.providers.actions-explorer-provider.getTreeItem",
    "name": "getTreeItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getTreeItem(element: ActionItem): TreeItem {\n\t\treturn element;\n\t}",
    "start_line": 158,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTreeItem",
    "component_id": "src.providers.actions-explorer-provider.getTreeItem"
  },
  "src.providers.actions-explorer-provider.getChildren": {
    "id": "src.providers.actions-explorer-provider.getChildren",
    "name": "getChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "async getChildren(element?: ActionItem): Promise<ActionItem[]> {\n\t\tif (!element) {\n\t\t\treturn this.getRootItems();\n\t\t}\n\n\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\tif (!ws) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (element.category === \"speckit\") {\n\t\t\treturn this.getSpeckitRootItems();\n\t\t}\n\n\t\t// SpecKit Children\n\t\tif (element.category?.startsWith(\"speckit-\")) {\n\t\t\treturn await this.getSpeckitChildren(element, ws.uri);\n\t\t}\n\n\t\t// Regular Children\n\t\tif (element.category) {\n\t\t\treturn await this.getRegularChildren(element, ws.uri);\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 162,
    "end_line": 187,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getChildren",
    "component_id": "src.providers.actions-explorer-provider.getChildren"
  },
  "src.providers.actions-explorer-provider.getRootItems": {
    "id": "src.providers.actions-explorer-provider.getRootItems",
    "name": "getRootItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getRootItems(): ActionItem[] {\n\t\treturn [\n\t\t\tnew ActionItem(\n\t\t\t\t\"SpecKit\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit\",\n\t\t\t\t{ category: \"speckit\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Prompts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-prompts\",\n\t\t\t\t{ category: \"prompts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Agents\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-agents\",\n\t\t\t\t{ category: \"agents\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Skills\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-skills\",\n\t\t\t\t{ category: \"skills\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Scripts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-scripts\",\n\t\t\t\t{ category: \"scripts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Templates\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-templates\",\n\t\t\t\t{ category: \"templates\" }\n\t\t\t),\n\t\t];\n\t}",
    "start_line": 189,
    "end_line": 228,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRootItems",
    "component_id": "src.providers.actions-explorer-provider.getRootItems"
  },
  "src.providers.actions-explorer-provider.getSpeckitRootItems": {
    "id": "src.providers.actions-explorer-provider.getSpeckitRootItems",
    "name": "getSpeckitRootItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getSpeckitRootItems(): ActionItem[] {\n\t\treturn [\n\t\t\tnew ActionItem(\n\t\t\t\t\"Prompts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-prompts\",\n\t\t\t\t{ category: \"speckit-prompts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Agents\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-agents\",\n\t\t\t\t{ category: \"speckit-agents\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Instructions\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-instructions\",\n\t\t\t\t{ category: \"speckit-instructions\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Scripts\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-scripts\",\n\t\t\t\t{ category: \"speckit-scripts\" }\n\t\t\t),\n\t\t\tnew ActionItem(\n\t\t\t\t\"Templates\",\n\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\"group-speckit-templates\",\n\t\t\t\t{ category: \"speckit-templates\" }\n\t\t\t),\n\t\t];\n\t}",
    "start_line": 230,
    "end_line": 263,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpeckitRootItems",
    "component_id": "src.providers.actions-explorer-provider.getSpeckitRootItems"
  },
  "src.providers.actions-explorer-provider.getSpeckitChildren": {
    "id": "src.providers.actions-explorer-provider.getSpeckitChildren",
    "name": "getSpeckitChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getSpeckitChildren(\n\t\telement: ActionItem,\n\t\twsUri: Uri\n\t): Promise<ActionItem[]> {\n\t\tswitch (element.category) {\n\t\t\tcase \"speckit-prompts\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"prompts\"),\n\t\t\t\t\tpatterns: [\"*.prompt.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"prompts\",\n\t\t\t\t\tisAgent: false,\n\t\t\t\t\tisSpecKit: true,\n\t\t\t\t});\n\t\t\tcase \"speckit-agents\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"agents\"),\n\t\t\t\t\tpatterns: [\"*.agent.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"agents\",\n\t\t\t\t\tisAgent: true,\n\t\t\t\t\tisSpecKit: true,\n\t\t\t\t});\n\t\t\tcase \"speckit-instructions\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"instructions\"),\n\t\t\t\t\tpatterns: [\"*.instructions.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"instructions\",\n\t\t\t\t\tisAgent: false,\n\t\t\t\t\tisSpecKit: true,\n\t\t\t\t});\n\t\t\tcase \"speckit-scripts\":\n\t\t\t\treturn await this.getScripts(wsUri, true);\n\t\t\tcase \"speckit-templates\":\n\t\t\t\treturn await this.getTemplates(wsUri, true);\n\t\t\tdefault:\n\t\t\t\treturn [];\n\t\t}\n\t}",
    "start_line": 265,
    "end_line": 304,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element",
      "wsUri"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getSpeckitChildren",
    "component_id": "src.providers.actions-explorer-provider.getSpeckitChildren"
  },
  "src.providers.actions-explorer-provider.getRegularChildren": {
    "id": "src.providers.actions-explorer-provider.getRegularChildren",
    "name": "getRegularChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getRegularChildren(\n\t\telement: ActionItem,\n\t\twsUri: Uri\n\t): Promise<ActionItem[]> {\n\t\tswitch (element.category) {\n\t\t\tcase \"prompts\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"prompts\"),\n\t\t\t\t\tpatterns: [\"*.prompt.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"prompts\",\n\t\t\t\t\tisAgent: false,\n\t\t\t\t\tisSpecKit: false,\n\t\t\t\t});\n\t\t\tcase \"agents\":\n\t\t\t\treturn await this.getFiles({\n\t\t\t\t\troot: joinPath(wsUri, \".github\", \"agents\"),\n\t\t\t\t\tpatterns: [\"*.agent.md\"],\n\t\t\t\t\tcontextValue: \"action-runnable\",\n\t\t\t\t\tcategory: \"agents\",\n\t\t\t\t\tisAgent: true,\n\t\t\t\t\tisSpecKit: false,\n\t\t\t\t});\n\t\t\tcase \"skills\":\n\t\t\t\treturn await this.getSkills(joinPath(wsUri, \".github\", \"skills\"));\n\t\t\tcase \"scripts\":\n\t\t\t\treturn await this.getScripts(wsUri, false);\n\t\t\tcase \"templates\":\n\t\t\t\treturn await this.getTemplates(wsUri, false);\n\t\t\tdefault:\n\t\t\t\treturn [];\n\t\t}\n\t}",
    "start_line": 306,
    "end_line": 338,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element",
      "wsUri"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getRegularChildren",
    "component_id": "src.providers.actions-explorer-provider.getRegularChildren"
  },
  "src.providers.actions-explorer-provider.readDisplayName": {
    "id": "src.providers.actions-explorer-provider.readDisplayName",
    "name": "readDisplayName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async readDisplayName(uri: Uri, filename: string): Promise<string> {\n\t\ttry {\n\t\t\t// Read first 1KB to find frontmatter or H1\n\t\t\tconst fileData = await workspace.fs.readFile(uri);\n\t\t\tconst content = new TextDecoder().decode(fileData.slice(0, 1024));\n\n\t\t\t// 1. Try Frontmatter name: ...\n\t\t\tconst frontmatterMatch = FRONTMATTER_REGEXP.exec(content);\n\t\t\tif (frontmatterMatch?.[1]) {\n\t\t\t\treturn frontmatterMatch[1].trim();\n\t\t\t}\n\n\t\t\t// 2. Try H1: # Title\n\t\t\tconst h1Match = H1_REGEXP.exec(content);\n\t\t\tif (h1Match?.[1]) {\n\t\t\t\treturn h1Match[1].trim();\n\t\t\t}\n\n\t\t\t// 3. Fallback: Normalize filename\n\t\t\treturn this.normalizeName(filename);\n\t\t} catch {\n\t\t\treturn this.normalizeName(filename);\n\t\t}\n\t}",
    "start_line": 340,
    "end_line": 363,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "filename"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method readDisplayName",
    "component_id": "src.providers.actions-explorer-provider.readDisplayName"
  },
  "src.providers.actions-explorer-provider.normalizeName": {
    "id": "src.providers.actions-explorer-provider.normalizeName",
    "name": "normalizeName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private normalizeName(name: string): string {\n\t\t// Remove extensions\n\t\tlet normalized = name.replace(EXTENSIONS_REGEXP, \"\");\n\t\t// Remove speckit prefix if present\n\t\tnormalized = normalized.replace(SPECKIT_PREFIX_REGEXP, \"\");\n\t\treturn normalized\n\t\t\t.split(SEPARATOR_REGEXP)\n\t\t\t.map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n\t\t\t.join(\" \");\n\t}",
    "start_line": 365,
    "end_line": 374,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method normalizeName",
    "component_id": "src.providers.actions-explorer-provider.normalizeName"
  },
  "src.providers.actions-explorer-provider.getFiles": {
    "id": "src.providers.actions-explorer-provider.getFiles",
    "name": "getFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getFiles(options: {\n\t\troot: Uri;\n\t\tpatterns: string[];\n\t\tcontextValue: string;\n\t\tcategory: ActionCategory;\n\t\tisAgent?: boolean;\n\t\tisSpecKit?: boolean;\n\t}): Promise<ActionItem[]> {\n\t\tconst files: ActionItem[] = [];\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(options.root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.File) {\n\t\t\t\t\tconst isMatch = options.patterns.some((p) => {\n\t\t\t\t\t\tif (p.startsWith(\"*\")) {\n\t\t\t\t\t\t\treturn name.endsWith(p.slice(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn name === p;\n\t\t\t\t\t});\n\n\t\t\t\t\t// Filter for SpecKit\n\t\t\t\t\tconst isSpecKitFile = name.startsWith(\"speckit.\");\n\t\t\t\t\tif (options.isSpecKit && !isSpecKitFile) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!options.isSpecKit && isSpecKitFile) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isMatch) {\n\t\t\t\t\t\tconst displayName = await this.readDisplayName(\n\t\t\t\t\t\t\tjoinPath(options.root, name),\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\t\t\t\t\t\tfiles.push(\n\t\t\t\t\t\t\tnew ActionItem(\n\t\t\t\t\t\t\t\tdisplayName,\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\toptions.contextValue,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceUri: joinPath(options.root, name),\n\t\t\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\t\t\ttitle: \"Open File\",\n\t\t\t\t\t\t\t\t\t\targuments: [joinPath(options.root, name)],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcategory: options.category,\n\t\t\t\t\t\t\t\t\tisAgent: options.isAgent,\n\t\t\t\t\t\t\t\t\tdescription: name, // Show original filename as description\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn files;\n\t}",
    "start_line": 376,
    "end_line": 435,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getFiles",
    "component_id": "src.providers.actions-explorer-provider.getFiles"
  },
  "src.providers.actions-explorer-provider.getSkills": {
    "id": "src.providers.actions-explorer-provider.getSkills",
    "name": "getSkills",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getSkills(root: Uri): Promise<ActionItem[]> {\n\t\t// Skills are generic, so no SpecKit filtering for now, but keeping normalization if needed\n\t\tconst skills: ActionItem[] = [];\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.Directory) {\n\t\t\t\t\tconst skillMd = joinPath(root, name, \"SKILL.md\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait workspace.fs.stat(skillMd);\n\t\t\t\t\t\tconst displayName = await this.readDisplayName(skillMd, name);\n\t\t\t\t\t\tskills.push(\n\t\t\t\t\t\t\tnew ActionItem(\n\t\t\t\t\t\t\t\tdisplayName,\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\t\"action-skill\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceUri: skillMd,\n\t\t\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\t\t\ttitle: \"Open Skill\",\n\t\t\t\t\t\t\t\t\t\targuments: [skillMd],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcategory: \"skills\",\n\t\t\t\t\t\t\t\t\tisSkill: true,\n\t\t\t\t\t\t\t\t\tdescription: name,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t/* not a skill */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn skills;\n\t}",
    "start_line": 437,
    "end_line": 475,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getSkills",
    "component_id": "src.providers.actions-explorer-provider.getSkills"
  },
  "src.providers.actions-explorer-provider.getScripts": {
    "id": "src.providers.actions-explorer-provider.getScripts",
    "name": "getScripts",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getScripts(\n\t\twsUri: Uri,\n\t\tisSpecKit: boolean\n\t): Promise<ActionItem[]> {\n\t\tconst items: ActionItem[] = [];\n\t\tconst scriptExtensions = [\".sh\", \".ps1\", \".py\", \".js\", \".ts\"];\n\n\t\tif (isSpecKit) {\n\t\t\t// SpecKit Scripts: .specify/scripts/**/*\n\t\t\tconst root = joinPath(wsUri, \".specify\", \"scripts\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: scriptExtensions,\n\t\t\t\tcontextValue: \"action-script\",\n\t\t\t\tcategory: \"scripts\",\n\t\t\t\titems,\n\t\t\t});\n\t\t} else {\n\t\t\t// Regular Scripts: .github/scripts\n\t\t\tconst root = joinPath(wsUri, \".github\", \"scripts\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: scriptExtensions,\n\t\t\t\tcontextValue: \"action-script\",\n\t\t\t\tcategory: \"scripts\",\n\t\t\t\titems,\n\t\t\t});\n\n\t\t\t// Also look into skills for regular scripts\n\t\t\tconst skillsRoot = joinPath(wsUri, \".github\", \"skills\");\n\t\t\ttry {\n\t\t\t\tconst skillDirs = await workspace.fs.readDirectory(skillsRoot);\n\t\t\t\tfor (const [name, ftype] of skillDirs) {\n\t\t\t\t\tif (ftype === FileType.Directory) {\n\t\t\t\t\t\tawait this.collectFilesRecursive({\n\t\t\t\t\t\t\troot: joinPath(skillsRoot, name, \"scripts\"),\n\t\t\t\t\t\t\textensions: scriptExtensions,\n\t\t\t\t\t\t\tcontextValue: \"action-script\",\n\t\t\t\t\t\t\tcategory: \"scripts\",\n\t\t\t\t\t\t\titems,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t/* ignore */\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}",
    "start_line": 477,
    "end_line": 525,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "wsUri",
      "isSpecKit"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getScripts",
    "component_id": "src.providers.actions-explorer-provider.getScripts"
  },
  "src.providers.actions-explorer-provider.getTemplates": {
    "id": "src.providers.actions-explorer-provider.getTemplates",
    "name": "getTemplates",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getTemplates(\n\t\twsUri: Uri,\n\t\tisSpecKit: boolean\n\t): Promise<ActionItem[]> {\n\t\tconst items: ActionItem[] = [];\n\t\tconst templateExtensions = [\".md\", \".yaml\", \".json\", \".handlebars\", \".hbs\"];\n\n\t\tif (isSpecKit) {\n\t\t\t// SpecKit Templates: .specify/templates\n\t\t\tconst root = joinPath(wsUri, \".specify\", \"templates\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: templateExtensions,\n\t\t\t\tcontextValue: \"action-template\",\n\t\t\t\tcategory: \"templates\",\n\t\t\t\titems,\n\t\t\t});\n\t\t} else {\n\t\t\t// Regular Templates: .github/templates\n\t\t\tconst root = joinPath(wsUri, \".github\", \"templates\");\n\t\t\tawait this.collectFilesRecursive({\n\t\t\t\troot,\n\t\t\t\textensions: templateExtensions,\n\t\t\t\tcontextValue: \"action-template\",\n\t\t\t\tcategory: \"templates\",\n\t\t\t\titems,\n\t\t\t});\n\n\t\t\t// Also look into skills for regular templates\n\t\t\tconst skillsRoot = joinPath(wsUri, \".github\", \"skills\");\n\t\t\ttry {\n\t\t\t\tconst skillDirs = await workspace.fs.readDirectory(skillsRoot);\n\t\t\t\tfor (const [name, ftype] of skillDirs) {\n\t\t\t\t\tif (ftype === FileType.Directory) {\n\t\t\t\t\t\tawait this.collectFilesRecursive({\n\t\t\t\t\t\t\troot: joinPath(skillsRoot, name, \"templates\"),\n\t\t\t\t\t\t\textensions: templateExtensions,\n\t\t\t\t\t\t\tcontextValue: \"action-template\",\n\t\t\t\t\t\t\tcategory: \"templates\",\n\t\t\t\t\t\t\titems,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t/* ignore */\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}",
    "start_line": 527,
    "end_line": 575,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "wsUri",
      "isSpecKit"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getTemplates",
    "component_id": "src.providers.actions-explorer-provider.getTemplates"
  },
  "src.providers.actions-explorer-provider.collectFilesRecursive": {
    "id": "src.providers.actions-explorer-provider.collectFilesRecursive",
    "name": "collectFilesRecursive",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async collectFilesRecursive(options: {\n\t\troot: Uri;\n\t\textensions: string[];\n\t\tcontextValue: string;\n\t\tcategory: ActionCategory;\n\t\titems: ActionItem[];\n\t}): Promise<void> {\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(options.root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.Directory) {\n\t\t\t\t\tawait this.collectFilesRecursive({\n\t\t\t\t\t\troot: joinPath(options.root, name),\n\t\t\t\t\t\textensions: options.extensions,\n\t\t\t\t\t\tcontextValue: options.contextValue,\n\t\t\t\t\t\tcategory: options.category,\n\t\t\t\t\t\titems: options.items,\n\t\t\t\t\t});\n\t\t\t\t} else if (\n\t\t\t\t\ttype === FileType.File &&\n\t\t\t\t\toptions.extensions.some((ext) => name.endsWith(ext))\n\t\t\t\t) {\n\t\t\t\t\t// Note: scripts inside .specify/scripts don't necessarily start with speckit., they are defined by location\n\t\t\t\t\t// However, if we were in .github, we would check prefix.\n\t\t\t\t\t// The instruction says: \"para scripts e templates, basta verificar o diretrio .specify\"\n\t\t\t\t\t// So location based for SpecKit scripts/templates.\n\n\t\t\t\t\tconst displayName = await this.readDisplayName(\n\t\t\t\t\t\tjoinPath(options.root, name),\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\toptions.items.push(\n\t\t\t\t\t\tnew ActionItem(\n\t\t\t\t\t\t\tdisplayName,\n\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\toptions.contextValue,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresourceUri: joinPath(options.root, name),\n\t\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\t\ttitle: \"Open File\",\n\t\t\t\t\t\t\t\t\targuments: [joinPath(options.root, name)],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcategory: options.category,\n\t\t\t\t\t\t\t\tdescription: workspace.asRelativePath(\n\t\t\t\t\t\t\t\t\tjoinPath(options.root, name)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t}",
    "start_line": 577,
    "end_line": 632,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method collectFilesRecursive",
    "component_id": "src.providers.actions-explorer-provider.collectFilesRecursive"
  },
  "src.providers.actions-explorer-provider.renamePrompt": {
    "id": "src.providers.actions-explorer-provider.renamePrompt",
    "name": "renamePrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/actions-explorer-provider.ts",
    "relative_path": "src/providers/actions-explorer-provider.ts",
    "depends_on": [],
    "source_code": "async renamePrompt(item?: ActionItem): Promise<void> {\n\t\tif (!item?.resourceUri) {\n\t\t\treturn;\n\t\t}\n\t\tconst newName = await window.showInputBox({\n\t\t\tprompt: \"New name\",\n\t\t\tvalue: basename(item.resourceUri.fsPath),\n\t\t});\n\t\tif (newName) {\n\t\t\tconst target = joinPath(\n\t\t\t\tUri.file(dirname(item.resourceUri.fsPath)),\n\t\t\t\tnewName\n\t\t\t);\n\t\t\tawait workspace.fs.rename(item.resourceUri, target);\n\t\t\tthis.refresh();\n\t\t}\n\t}",
    "start_line": 634,
    "end_line": 650,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "item"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method renamePrompt",
    "component_id": "src.providers.actions-explorer-provider.renamePrompt"
  },
  "src.providers.copilot-provider.CopilotAvailabilityResult": {
    "id": "src.providers.copilot-provider.CopilotAvailabilityResult",
    "name": "CopilotAvailabilityResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "interface CopilotAvailabilityResult {\n\tisAvailable: boolean;\n\tisInstalled: boolean;\n\tversion: string | null;\n\tisCompatible: boolean;\n\terrorMessage: string | null;\n\tsetupGuidance: string | null;\n}",
    "start_line": 16,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CopilotAvailabilityResult",
    "component_id": "src.providers.copilot-provider.CopilotAvailabilityResult"
  },
  "src.providers.copilot-provider.CopilotProvider": {
    "id": "src.providers.copilot-provider.CopilotProvider",
    "name": "CopilotProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      "src.utils.config-manager.getTerminalDelay",
      "src.providers.copilot-provider.convertPathIfWsl",
      "src.providers.welcome-screen-provider.executeCommand",
      "src.services.agent-service.dispose",
      "src.utils.spec-kit-adapter.getInstance",
      "src.providers.copilot-provider.createTempFile",
      "src.utils.config-manager.loadSettings",
      "src.utils.config-manager.ConfigManager",
      "src.providers.dependencies-view-provider.show"
    ],
    "source_code": "class CopilotProvider {\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly configManager: ConfigManager;\n\n\tconstructor(context: ExtensionContext, outputChannel: OutputChannel) {\n\t\tthis.context = context;\n\t\tthis.outputChannel = outputChannel;\n\n\t\tthis.configManager = ConfigManager.getInstance();\n\t\tthis.configManager.loadSettings();\n\t\t// Listen for configuration changes\n\t\tworkspace.onDidChangeConfiguration((e) => {\n\t\t\tif (e.affectsConfiguration(VSC_CONFIG_NAMESPACE)) {\n\t\t\t\tthis.configManager.loadSettings();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Create a temporary file with content\n\t */\n\tprivate async createTempFile(\n\t\tcontent: string,\n\t\tprefix = \"prompt\"\n\t): Promise<string> {\n\t\tconst tempDir = this.context.globalStorageUri.fsPath;\n\t\tawait workspace.fs.createDirectory(this.context.globalStorageUri);\n\n\t\tconst tempFile = join(tempDir, `${prefix}-${Date.now()}.md`);\n\t\tawait fs.promises.writeFile(tempFile, content);\n\n\t\treturn this.convertPathIfWsl({ filePath: tempFile });\n\t}\n\n\t/**\n\t * Convert Windows path to WSL path if needed\n\t * Example: C:\\Users\\username\\file.txt -> /mnt/c/Users/username/file.txt\n\t */\n\tprivate convertPathIfWsl({ filePath }: { filePath: string }): string {\n\t\t// Check if running on Windows and path is a Windows path\n\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\tif (process.platform === \"win32\" && filePath.match(/^[A-Za-z]:\\\\/)) {\n\t\t\t// Replace backslashes with forward slashes\n\t\t\tlet wslPath = filePath.replace(/\\\\/g, \"/\");\n\t\t\t// Convert drive letter to WSL format (C: -> /mnt/c)\n\t\t\twslPath = wslPath.replace(\n\t\t\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\t\t\t/^([A-Za-z]):/,\n\t\t\t\t(_match, drive) => `/mnt/${drive.toLowerCase()}`\n\t\t\t);\n\t\t\treturn wslPath;\n\t\t}\n\n\t\t// Return original path if not on Windows or not a Windows path\n\t\treturn filePath;\n\t}\n\n\t/**\n\t * Invokes Copilot in a new terminal on the right side (split view) with the given prompt\n\t * Returns the terminal instance for potential renaming\n\t */\n\tasync invokeCopilotSplitView(\n\t\tprompt: string,\n\t\ttitle = \"GatomIA for Copilot\"\n\t): Promise<Terminal> {\n\t\ttry {\n\t\t\t// Create temp file with the prompt\n\t\t\tconst promptFilePath = await this.createTempFile(prompt, \"prompt\");\n\n\t\t\t// Build the command - simple now, just copilot with input redirection\n\t\t\tconst command = `copilot --permission-mode bypassPermissions < \"${promptFilePath}\"`;\n\n\t\t\t// Create a new terminal in the editor area (right side)\n\t\t\tconst terminal = window.createTerminal({\n\t\t\t\tname: title,\n\t\t\t\tcwd: workspace.workspaceFolders?.[0]?.uri.fsPath,\n\t\t\t\tlocation: {\n\t\t\t\t\tviewColumn: ViewColumn.Two, // Open in the second column (right side)\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Show the terminal\n\t\t\tterminal.show();\n\n\t\t\t// Send the command directly without echo messages\n\t\t\tconst delay = this.configManager.getTerminalDelay();\n\t\t\tsetTimeout(() => {\n\t\t\t\tterminal.sendText(command, true); // true = add newline to execute\n\t\t\t}, delay); // Configurable delay to allow venv activation\n\n\t\t\t// Clean up temp files after a delay\n\t\t\tsetTimeout(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait fs.promises.unlink(promptFilePath);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`Cleaned up prompt file: ${promptFilePath}`\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Ignore cleanup errors\n\t\t\t\t\tthis.outputChannel.appendLine(`Failed to cleanup temp file: ${e}`);\n\t\t\t\t}\n\t\t\t}, 30_000); // 30 seconds delay to give Copilot time to read the file\n\n\t\t\t// Return the terminal for potential renaming\n\t\t\treturn terminal;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`ERROR: Failed to send to Copilot: ${error}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to run Copilot: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Rename a terminal\n\t */\n\tasync renameTerminal(terminal: Terminal, newName: string): Promise<void> {\n\t\t// Make sure the terminal is active\n\t\tterminal.show();\n\n\t\t// Small delay to ensure terminal is focused\n\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[CopilotProvider] ${terminal.name} Terminal renamed to: ${newName}`\n\t\t);\n\n\t\t// Execute the rename command\n\t\tawait commands.executeCommand(\"workbench.action.terminal.renameWithArg\", {\n\t\t\tname: newName,\n\t\t});\n\t}\n\n\t/**\n\t * Execute Copilot command with specific tools in background\n\t * Returns a promise that resolves when the command completes\n\t */\n\tasync invokeCopilotHeadless(\n\t\tprompt: string\n\t): Promise<{ exitCode: number | undefined; output?: string }> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[CopilotProvider] Invoking Copilot in headless mode\"\n\t\t);\n\t\tthis.outputChannel.appendLine(\"========================================\");\n\t\tthis.outputChannel.appendLine(prompt);\n\t\tthis.outputChannel.appendLine(\"========================================\");\n\n\t\t// Get the workspace folder\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tconst cwd = workspaceFolder?.uri.fsPath;\n\n\t\t// Create temp file with the prompt\n\t\tconst promptFilePath = await this.createTempFile(\n\t\t\tprompt,\n\t\t\t\"background-prompt\"\n\t\t);\n\n\t\t// Build command using file redirection\n\t\tconst commandLine = `copilot --permission-mode bypassPermissions < \"${promptFilePath}\"`;\n\n\t\t// Create hidden terminal for background execution\n\t\tconst terminal = window.createTerminal({\n\t\t\tname: \"Copilot Background\",\n\t\t\tcwd,\n\t\t\thideFromUser: true,\n\t\t});\n\n\t\treturn new Promise((resolve) => {\n\t\t\tlet shellIntegrationChecks = 0;\n\t\t\t// Wait for shell integration to be available\n\t\t\tconst checkShellIntegration = setInterval(() => {\n\t\t\t\tshellIntegrationChecks += 1;\n\n\t\t\t\tif (terminal.shellIntegration) {\n\t\t\t\t\tclearInterval(checkShellIntegration);\n\n\t\t\t\t\t// Execute command with shell integration\n\t\t\t\t\tconst execution =\n\t\t\t\t\t\tterminal.shellIntegration.executeCommand(commandLine);\n\n\t\t\t\t\t// Listen for command completion\n\t\t\t\t\tconst disposable = window.onDidEndTerminalShellExecution((event) => {\n\t\t\t\t\t\tif (event.terminal === terminal && event.execution === execution) {\n\t\t\t\t\t\t\tdisposable.dispose();\n\n\t\t\t\t\t\t\t// Only log errors\n\t\t\t\t\t\t\tif (event.exitCode !== 0) {\n\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t`[Copilot] Command failed with exit code: ${event.exitCode}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t`[Copilot] Command was: ${commandLine}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\t\texitCode: event.exitCode,\n\t\t\t\t\t\t\t\toutput: undefined,\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Clean up terminal and temp file after a short delay\n\t\t\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\t\t\tterminal.dispose();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait fs.promises.unlink(promptFilePath);\n\t\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t\t`[Copilot] Cleaned up temp file: ${promptFilePath}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t// Ignore cleanup errors\n\t\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t\t`[Copilot] Failed to cleanup temp file: ${e}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else if (shellIntegrationChecks > 20) {\n\t\t\t\t\t// After 2 seconds\n\t\t\t\t\t// Fallback: execute without shell integration\n\t\t\t\t\tclearInterval(checkShellIntegration);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\"[Copilot] Shell integration not available, using fallback mode\"\n\t\t\t\t\t);\n\t\t\t\t\tterminal.sendText(commandLine);\n\n\t\t\t\t\t// Resolve after a reasonable delay since we can't track completion\n\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\tresolve({ exitCode: undefined });\n\t\t\t\t\t\tterminal.dispose();\n\t\t\t\t\t\t// Clean up temp file\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait fs.promises.unlink(promptFilePath);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// Ignore cleanup errors\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 5000);\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t});\n\t}\n\n\tasync executePlan(prompt: string): Promise<void> {\n\t\t// TODO: Implement plan execution logic\n\t}\n}",
    "start_line": 25,
    "end_line": 271,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CopilotProvider",
    "component_id": "src.providers.copilot-provider.CopilotProvider"
  },
  "src.providers.copilot-provider.createTempFile": {
    "id": "src.providers.copilot-provider.createTempFile",
    "name": "createTempFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "private async createTempFile(\n\t\tcontent: string,\n\t\tprefix = \"prompt\"\n\t): Promise<string> {\n\t\tconst tempDir = this.context.globalStorageUri.fsPath;\n\t\tawait workspace.fs.createDirectory(this.context.globalStorageUri);\n\n\t\tconst tempFile = join(tempDir, `${prefix}-${Date.now()}.md`);\n\t\tawait fs.promises.writeFile(tempFile, content);\n\n\t\treturn this.convertPathIfWsl({ filePath: tempFile });\n\t}",
    "start_line": 47,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content",
      "prefix"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method createTempFile",
    "component_id": "src.providers.copilot-provider.createTempFile"
  },
  "src.providers.copilot-provider.convertPathIfWsl": {
    "id": "src.providers.copilot-provider.convertPathIfWsl",
    "name": "convertPathIfWsl",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "private convertPathIfWsl({ filePath }: { filePath: string }): string {\n\t\t// Check if running on Windows and path is a Windows path\n\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\tif (process.platform === \"win32\" && filePath.match(/^[A-Za-z]:\\\\/)) {\n\t\t\t// Replace backslashes with forward slashes\n\t\t\tlet wslPath = filePath.replace(/\\\\/g, \"/\");\n\t\t\t// Convert drive letter to WSL format (C: -> /mnt/c)\n\t\t\twslPath = wslPath.replace(\n\t\t\t\t// biome-ignore lint/performance/useTopLevelRegex: ignore\n\t\t\t\t/^([A-Za-z]):/,\n\t\t\t\t(_match, drive) => `/mnt/${drive.toLowerCase()}`\n\t\t\t);\n\t\t\treturn wslPath;\n\t\t}\n\n\t\t// Return original path if not on Windows or not a Windows path\n\t\treturn filePath;\n\t}",
    "start_line": 64,
    "end_line": 81,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method convertPathIfWsl",
    "component_id": "src.providers.copilot-provider.convertPathIfWsl"
  },
  "src.providers.copilot-provider.invokeCopilotSplitView": {
    "id": "src.providers.copilot-provider.invokeCopilotSplitView",
    "name": "invokeCopilotSplitView",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "async invokeCopilotSplitView(\n\t\tprompt: string,\n\t\ttitle = \"GatomIA for Copilot\"\n\t): Promise<Terminal> {\n\t\ttry {\n\t\t\t// Create temp file with the prompt\n\t\t\tconst promptFilePath = await this.createTempFile(prompt, \"prompt\");\n\n\t\t\t// Build the command - simple now, just copilot with input redirection\n\t\t\tconst command = `copilot --permission-mode bypassPermissions < \"${promptFilePath}\"`;\n\n\t\t\t// Create a new terminal in the editor area (right side)\n\t\t\tconst terminal = window.createTerminal({\n\t\t\t\tname: title,\n\t\t\t\tcwd: workspace.workspaceFolders?.[0]?.uri.fsPath,\n\t\t\t\tlocation: {\n\t\t\t\t\tviewColumn: ViewColumn.Two, // Open in the second column (right side)\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Show the terminal\n\t\t\tterminal.show();\n\n\t\t\t// Send the command directly without echo messages\n\t\t\tconst delay = this.configManager.getTerminalDelay();\n\t\t\tsetTimeout(() => {\n\t\t\t\tterminal.sendText(command, true); // true = add newline to execute\n\t\t\t}, delay); // Configurable delay to allow venv activation\n\n\t\t\t// Clean up temp files after a delay\n\t\t\tsetTimeout(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait fs.promises.unlink(promptFilePath);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`Cleaned up prompt file: ${promptFilePath}`\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Ignore cleanup errors\n\t\t\t\t\tthis.outputChannel.appendLine(`Failed to cleanup temp file: ${e}`);\n\t\t\t\t}\n\t\t\t}, 30_000); // 30 seconds delay to give Copilot time to read the file\n\n\t\t\t// Return the terminal for potential renaming\n\t\t\treturn terminal;\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`ERROR: Failed to send to Copilot: ${error}`\n\t\t\t);\n\t\t\twindow.showErrorMessage(`Failed to run Copilot: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}",
    "start_line": 87,
    "end_line": 138,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "prompt",
      "title"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method invokeCopilotSplitView",
    "component_id": "src.providers.copilot-provider.invokeCopilotSplitView"
  },
  "src.providers.copilot-provider.renameTerminal": {
    "id": "src.providers.copilot-provider.renameTerminal",
    "name": "renameTerminal",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "async renameTerminal(terminal: Terminal, newName: string): Promise<void> {\n\t\t// Make sure the terminal is active\n\t\tterminal.show();\n\n\t\t// Small delay to ensure terminal is focused\n\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[CopilotProvider] ${terminal.name} Terminal renamed to: ${newName}`\n\t\t);\n\n\t\t// Execute the rename command\n\t\tawait commands.executeCommand(\"workbench.action.terminal.renameWithArg\", {\n\t\t\tname: newName,\n\t\t});\n\t}",
    "start_line": 143,
    "end_line": 157,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "terminal",
      "newName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method renameTerminal",
    "component_id": "src.providers.copilot-provider.renameTerminal"
  },
  "src.providers.copilot-provider.invokeCopilotHeadless": {
    "id": "src.providers.copilot-provider.invokeCopilotHeadless",
    "name": "invokeCopilotHeadless",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "async invokeCopilotHeadless(\n\t\tprompt: string\n\t): Promise<{ exitCode: number | undefined; output?: string }> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[CopilotProvider] Invoking Copilot in headless mode\"\n\t\t);\n\t\tthis.outputChannel.appendLine(\"========================================\");\n\t\tthis.outputChannel.appendLine(prompt);\n\t\tthis.outputChannel.appendLine(\"========================================\");\n\n\t\t// Get the workspace folder\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tconst cwd = workspaceFolder?.uri.fsPath;\n\n\t\t// Create temp file with the prompt\n\t\tconst promptFilePath = await this.createTempFile(\n\t\t\tprompt,\n\t\t\t\"background-prompt\"\n\t\t);\n\n\t\t// Build command using file redirection\n\t\tconst commandLine = `copilot --permission-mode bypassPermissions < \"${promptFilePath}\"`;\n\n\t\t// Create hidden terminal for background execution\n\t\tconst terminal = window.createTerminal({\n\t\t\tname: \"Copilot Background\",\n\t\t\tcwd,\n\t\t\thideFromUser: true,\n\t\t});\n\n\t\treturn new Promise((resolve) => {\n\t\t\tlet shellIntegrationChecks = 0;\n\t\t\t// Wait for shell integration to be available\n\t\t\tconst checkShellIntegration = setInterval(() => {\n\t\t\t\tshellIntegrationChecks += 1;\n\n\t\t\t\tif (terminal.shellIntegration) {\n\t\t\t\t\tclearInterval(checkShellIntegration);\n\n\t\t\t\t\t// Execute command with shell integration\n\t\t\t\t\tconst execution =\n\t\t\t\t\t\tterminal.shellIntegration.executeCommand(commandLine);\n\n\t\t\t\t\t// Listen for command completion\n\t\t\t\t\tconst disposable = window.onDidEndTerminalShellExecution((event) => {\n\t\t\t\t\t\tif (event.terminal === terminal && event.execution === execution) {\n\t\t\t\t\t\t\tdisposable.dispose();\n\n\t\t\t\t\t\t\t// Only log errors\n\t\t\t\t\t\t\tif (event.exitCode !== 0) {\n\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t`[Copilot] Command failed with exit code: ${event.exitCode}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t`[Copilot] Command was: ${commandLine}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\t\texitCode: event.exitCode,\n\t\t\t\t\t\t\t\toutput: undefined,\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Clean up terminal and temp file after a short delay\n\t\t\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\t\t\tterminal.dispose();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait fs.promises.unlink(promptFilePath);\n\t\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t\t`[Copilot] Cleaned up temp file: ${promptFilePath}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t// Ignore cleanup errors\n\t\t\t\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\t\t\t`[Copilot] Failed to cleanup temp file: ${e}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else if (shellIntegrationChecks > 20) {\n\t\t\t\t\t// After 2 seconds\n\t\t\t\t\t// Fallback: execute without shell integration\n\t\t\t\t\tclearInterval(checkShellIntegration);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\"[Copilot] Shell integration not available, using fallback mode\"\n\t\t\t\t\t);\n\t\t\t\t\tterminal.sendText(commandLine);\n\n\t\t\t\t\t// Resolve after a reasonable delay since we can't track completion\n\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\tresolve({ exitCode: undefined });\n\t\t\t\t\t\tterminal.dispose();\n\t\t\t\t\t\t// Clean up temp file\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait fs.promises.unlink(promptFilePath);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// Ignore cleanup errors\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 5000);\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t});\n\t}",
    "start_line": 163,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "prompt"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method invokeCopilotHeadless",
    "component_id": "src.providers.copilot-provider.invokeCopilotHeadless"
  },
  "src.providers.copilot-provider.executePlan": {
    "id": "src.providers.copilot-provider.executePlan",
    "name": "executePlan",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/copilot-provider.ts",
    "relative_path": "src/providers/copilot-provider.ts",
    "depends_on": [],
    "source_code": "async executePlan(prompt: string): Promise<void> {\n\t\t// TODO: Implement plan execution logic\n\t}",
    "start_line": 268,
    "end_line": 270,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "prompt"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executePlan",
    "component_id": "src.providers.copilot-provider.executePlan"
  },
  "src.providers.dependencies-view-provider.DependencyStatus": {
    "id": "src.providers.dependencies-view-provider.DependencyStatus",
    "name": "DependencyStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependencyStatus {\n\tname: string;\n\tinstalled: boolean;\n\tversion?: string;\n\terror?: string;\n\tcommand: string;\n}",
    "start_line": 22,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependencyStatus",
    "component_id": "src.providers.dependencies-view-provider.DependencyStatus"
  },
  "src.providers.dependencies-view-provider.InstallationStep": {
    "id": "src.providers.dependencies-view-provider.InstallationStep",
    "name": "InstallationStep",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface InstallationStep {\n\tid: string;\n\ttitle: string;\n\tdescription: string;\n\tcommand: string;\n\tplatform?: \"darwin\" | \"linux\" | \"win32\" | \"all\";\n}",
    "start_line": 33,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InstallationStep",
    "component_id": "src.providers.dependencies-view-provider.InstallationStep"
  },
  "src.providers.dependencies-view-provider.WebviewMessage": {
    "id": "src.providers.dependencies-view-provider.WebviewMessage",
    "name": "WebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "type WebviewMessage =\n\t| DependenciesReadyMessage\n\t| DependenciesCheckMessage\n\t| DependenciesCheckOneMessage\n\t| DependenciesCopyMessage\n\t| DependenciesPasteMessage\n\t| DependenciesExecuteMessage;",
    "start_line": 44,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type WebviewMessage",
    "component_id": "src.providers.dependencies-view-provider.WebviewMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesReadyMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesReadyMessage",
    "name": "DependenciesReadyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesReadyMessage {\n\ttype: \"dependencies/ready\";\n}",
    "start_line": 52,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesReadyMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesReadyMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesCheckMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesCheckMessage",
    "name": "DependenciesCheckMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesCheckMessage {\n\ttype: \"dependencies/check\";\n}",
    "start_line": 56,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesCheckMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesCheckMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesCheckOneMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesCheckOneMessage",
    "name": "DependenciesCheckOneMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesCheckOneMessage {\n\ttype: \"dependencies/check-one\";\n\tpayload: { name: string };\n}",
    "start_line": 60,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesCheckOneMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesCheckOneMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesCopyMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesCopyMessage",
    "name": "DependenciesCopyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesCopyMessage {\n\ttype: \"dependencies/copy\";\n\tpayload: { command: string };\n}",
    "start_line": 65,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesCopyMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesCopyMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesPasteMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesPasteMessage",
    "name": "DependenciesPasteMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesPasteMessage {\n\ttype: \"dependencies/paste\";\n\tpayload: { command: string };\n}",
    "start_line": 70,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesPasteMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesPasteMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesExecuteMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesExecuteMessage",
    "name": "DependenciesExecuteMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesExecuteMessage {\n\ttype: \"dependencies/execute\";\n\tpayload: { command: string };\n}",
    "start_line": 75,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesExecuteMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesExecuteMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesStatusMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesStatusMessage",
    "name": "DependenciesStatusMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [
      "src.providers.dependencies-view-provider.InstallationStep",
      "src.providers.dependencies-view-provider.DependencyStatus"
    ],
    "source_code": "interface DependenciesStatusMessage {\n\ttype: \"dependencies/status\";\n\tpayload: {\n\t\tdependencies: DependencyStatus[];\n\t\tsteps: InstallationStep[];\n\t};\n}",
    "start_line": 83,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesStatusMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesStatusMessage"
  },
  "src.providers.dependencies-view-provider.DependencyUpdatedMessage": {
    "id": "src.providers.dependencies-view-provider.DependencyUpdatedMessage",
    "name": "DependencyUpdatedMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [
      "src.providers.dependencies-view-provider.DependencyStatus"
    ],
    "source_code": "interface DependencyUpdatedMessage {\n\ttype: \"dependencies/updated\";\n\tpayload: DependencyStatus;\n}",
    "start_line": 91,
    "end_line": 94,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependencyUpdatedMessage",
    "component_id": "src.providers.dependencies-view-provider.DependencyUpdatedMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesCheckingMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesCheckingMessage",
    "name": "DependenciesCheckingMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesCheckingMessage {\n\ttype: \"dependencies/checking\";\n\tpayload: { name?: string };\n}",
    "start_line": 96,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesCheckingMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesCheckingMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesErrorMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesErrorMessage",
    "name": "DependenciesErrorMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesErrorMessage {\n\ttype: \"dependencies/error\";\n\tpayload: { message: string };\n}",
    "start_line": 101,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesErrorMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesErrorMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesActionResultMessage": {
    "id": "src.providers.dependencies-view-provider.DependenciesActionResultMessage",
    "name": "DependenciesActionResultMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "interface DependenciesActionResultMessage {\n\ttype: \"dependencies/action-result\";\n\tpayload: { action: string; success: boolean; message?: string };\n}",
    "start_line": 106,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependenciesActionResultMessage",
    "component_id": "src.providers.dependencies-view-provider.DependenciesActionResultMessage"
  },
  "src.providers.dependencies-view-provider.ExtensionMessage": {
    "id": "src.providers.dependencies-view-provider.ExtensionMessage",
    "name": "ExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "type ExtensionMessage =\n\t| DependenciesStatusMessage\n\t| DependencyUpdatedMessage\n\t| DependenciesCheckingMessage\n\t| DependenciesErrorMessage\n\t| DependenciesActionResultMessage;",
    "start_line": 111,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExtensionMessage",
    "component_id": "src.providers.dependencies-view-provider.ExtensionMessage"
  },
  "src.providers.dependencies-view-provider.DependenciesViewProvider": {
    "id": "src.providers.dependencies-view-provider.DependenciesViewProvider",
    "name": "DependenciesViewProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [
      "src.providers.hook-view-provider.handleWebviewMessage",
      "src.providers.dependencies-view-provider.getHtmlForWebview",
      "src.providers.dependencies-view-provider.getOrCreateTerminal",
      "src.providers.hook-view-provider.ensurePanel",
      "src.providers.dependencies-view-provider.checkAllDependencies",
      "src.providers.dependencies-view-provider.sendMessageToWebview",
      "src.providers.dependencies-view-provider.webview",
      "src.providers.hook-view-provider.sendMessageToWebview",
      "src.providers.hook-view-provider.getHtmlForWebview",
      "src.providers.dependencies-view-provider.ensurePanel",
      "src.utils.cli-detector.extractVersion",
      "src.providers.dependencies-view-provider.checkSingleDependency",
      "src.providers.dependencies-view-provider.flushPendingMessages",
      "src.providers.dependencies-view-provider.dispose",
      "src.utils.cli-detector.getExtendedPath",
      "src.providers.hook-view-provider.flushPendingMessages",
      "src.services.agent-service.dispose",
      "src.providers.dependencies-view-provider.ExtensionMessage",
      "src.providers.dependencies-view-provider.pasteToTerminal",
      "src.providers.dependencies-view-provider.DependencyStatus",
      "src.utils.get-webview-content.getWebviewContent",
      "src.providers.dependencies-view-provider.WebviewMessage",
      "src.panels.welcome-screen-panel.postMessage",
      "src.providers.dependencies-view-provider.executeInTerminal",
      "src.providers.dependencies-view-provider.handleWebviewMessage",
      "src.providers.dependencies-view-provider.copyCommand",
      "src.providers.dependencies-view-provider.show",
      "src.providers.dependencies-view-provider.checkDependency"
    ],
    "source_code": "class DependenciesViewProvider {\n\tstatic readonly panelType = \"gatomia.dependenciesPanel\";\n\n\tprivate panel?: WebviewPanel;\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly disposables: Disposable[] = [];\n\tprivate isWebviewReady = false;\n\tprivate readonly pendingMessages: ExtensionMessage[] = [];\n\tprivate terminal?: Terminal;\n\n\tconstructor(context: ExtensionContext, outputChannel: OutputChannel) {\n\t\tthis.context = context;\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\tdispose(): void {\n\t\tthis.panel?.dispose();\n\t\tthis.panel = undefined;\n\t\tthis.isWebviewReady = false;\n\t\twhile (this.disposables.length > 0) {\n\t\t\tthis.disposables.pop()?.dispose();\n\t\t}\n\t\tthis.outputChannel.appendLine(\"[DependenciesViewProvider] Disposed\");\n\t}\n\n\tprivate get webview(): Webview | undefined {\n\t\treturn this.panel?.webview;\n\t}\n\n\tasync show(): Promise<void> {\n\t\tawait this.ensurePanel();\n\t}\n\n\tprivate ensurePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.reveal(ViewColumn.Active, false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tDependenciesViewProvider.panelType,\n\t\t\t\"Install Dependencies\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\tpreserveFocus: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tthis.isWebviewReady = false;\n\t\tpanel.webview.html = this.getHtmlForWebview(panel.webview);\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\t(message) => this.handleWebviewMessage(message),\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\t\tpanel.onDidDispose(\n\t\t\t() => {\n\t\t\t\tthis.panel = undefined;\n\t\t\t\tthis.isWebviewReady = false;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[DependenciesViewProvider] Panel disposed\"\n\t\t\t\t);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\n\t\tthis.panel = panel;\n\t\tthis.outputChannel.appendLine(\"[DependenciesViewProvider] Panel created\");\n\t}\n\n\tprivate getHtmlForWebview(webview: Webview): string {\n\t\treturn getWebviewContent(\n\t\t\twebview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"dependencies\"\n\t\t);\n\t}\n\n\tprivate async handleWebviewMessage(message: WebviewMessage): Promise<void> {\n\t\ttry {\n\t\t\tswitch (message.type) {\n\t\t\t\tcase \"dependencies/ready\":\n\t\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\t\tthis.flushPendingMessages();\n\t\t\t\t\tawait this.checkAllDependencies();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/check\":\n\t\t\t\t\tawait this.checkAllDependencies();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/check-one\":\n\t\t\t\t\tawait this.checkSingleDependency(message.payload.name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/copy\":\n\t\t\t\t\tawait this.copyCommand(message.payload.command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/paste\":\n\t\t\t\t\tawait this.pasteToTerminal(message.payload.command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/execute\":\n\t\t\t\t\tawait this.executeInTerminal(message.payload.command);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[DependenciesViewProvider] Unknown message type: ${(message as any).type}`\n\t\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconst errorMessage =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tawait this.sendMessageToWebview({\n\t\t\t\ttype: \"dependencies/error\",\n\t\t\t\tpayload: { message: errorMessage },\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate async checkAllDependencies(): Promise<void> {\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/checking\",\n\t\t\tpayload: {},\n\t\t});\n\n\t\tconst dependencies: DependencyStatus[] = [];\n\n\t\tfor (const dep of DEPENDENCIES_TO_CHECK) {\n\t\t\tconst status = await this.checkDependency(dep.name, dep.command);\n\t\t\tdependencies.push(status);\n\t\t}\n\n\t\tconst platform = process.platform as \"darwin\" | \"linux\" | \"win32\";\n\t\tconst steps = INSTALLATION_STEPS.filter(\n\t\t\t(step) => step.platform === \"all\" || step.platform === platform\n\t\t);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/status\",\n\t\t\tpayload: { dependencies, steps },\n\t\t});\n\t}\n\n\tprivate async checkSingleDependency(name: string): Promise<void> {\n\t\tconst dep = DEPENDENCIES_TO_CHECK.find((d) => d.name === name);\n\t\tif (!dep) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/checking\",\n\t\t\tpayload: { name },\n\t\t});\n\n\t\tconst status = await this.checkDependency(dep.name, dep.command);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/updated\",\n\t\t\tpayload: status,\n\t\t});\n\t}\n\n\tprivate async checkDependency(\n\t\tname: string,\n\t\tcommand: string\n\t): Promise<DependencyStatus> {\n\t\ttry {\n\t\t\tconst { stdout, stderr } = await execAsync(command, {\n\t\t\t\ttimeout: 10_000,\n\t\t\t\tencoding: \"utf8\",\n\t\t\t\tenv: {\n\t\t\t\t\t...process.env,\n\t\t\t\t\tPATH: getExtendedPath(),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst output = stdout.trim() || stderr.trim();\n\t\t\tconst version = extractVersion(output);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependenciesViewProvider] ${name}: ${version || output}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tinstalled: true,\n\t\t\t\tversion: version || output,\n\t\t\t\tcommand,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst errorMessage =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependenciesViewProvider] ${name}: not found - ${errorMessage}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tinstalled: false,\n\t\t\t\terror: \"Not installed\",\n\t\t\t\tcommand,\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async copyCommand(command: string): Promise<void> {\n\t\tawait env.clipboard.writeText(command);\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/action-result\",\n\t\t\tpayload: {\n\t\t\t\taction: \"copy\",\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Command copied to clipboard\",\n\t\t\t},\n\t\t});\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependenciesViewProvider] Copied command: ${command}`\n\t\t);\n\t}\n\n\tprivate async pasteToTerminal(command: string): Promise<void> {\n\t\tconst terminal = this.getOrCreateTerminal();\n\t\tterminal.show(true);\n\t\tterminal.sendText(command, false);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/action-result\",\n\t\t\tpayload: {\n\t\t\t\taction: \"paste\",\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Command pasted to terminal\",\n\t\t\t},\n\t\t});\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependenciesViewProvider] Pasted to terminal: ${command}`\n\t\t);\n\t}\n\n\tprivate async executeInTerminal(command: string): Promise<void> {\n\t\tconst terminal = this.getOrCreateTerminal();\n\t\tterminal.show(true);\n\t\tterminal.sendText(command, true);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/action-result\",\n\t\t\tpayload: {\n\t\t\t\taction: \"execute\",\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Command executed in terminal\",\n\t\t\t},\n\t\t});\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependenciesViewProvider] Executed in terminal: ${command}`\n\t\t);\n\t}\n\n\tprivate getOrCreateTerminal(): Terminal {\n\t\tif (this.terminal && !this.terminal.exitStatus) {\n\t\t\treturn this.terminal;\n\t\t}\n\n\t\tthis.terminal = window.createTerminal({\n\t\t\tname: \"GatomIA - Dependencies\",\n\t\t});\n\n\t\treturn this.terminal;\n\t}\n\n\tprivate flushPendingMessages(): void {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (this.pendingMessages.length > 0) {\n\t\t\tconst message = this.pendingMessages.shift();\n\t\t\tif (message) {\n\t\t\t\tthis.webview.postMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendMessageToWebview(message: ExtensionMessage): Promise<void> {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.webview.postMessage(message);\n\t}\n}",
    "start_line": 194,
    "end_line": 487,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DependenciesViewProvider",
    "component_id": "src.providers.dependencies-view-provider.DependenciesViewProvider"
  },
  "src.providers.dependencies-view-provider.dispose": {
    "id": "src.providers.dependencies-view-provider.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.panel?.dispose();\n\t\tthis.panel = undefined;\n\t\tthis.isWebviewReady = false;\n\t\twhile (this.disposables.length > 0) {\n\t\t\tthis.disposables.pop()?.dispose();\n\t\t}\n\t\tthis.outputChannel.appendLine(\"[DependenciesViewProvider] Disposed\");\n\t}",
    "start_line": 210,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.providers.dependencies-view-provider.dispose"
  },
  "src.providers.dependencies-view-provider.webview": {
    "id": "src.providers.dependencies-view-provider.webview",
    "name": "webview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private get webview(): Webview | undefined {\n\t\treturn this.panel?.webview;\n\t}",
    "start_line": 220,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method webview",
    "component_id": "src.providers.dependencies-view-provider.webview"
  },
  "src.providers.dependencies-view-provider.show": {
    "id": "src.providers.dependencies-view-provider.show",
    "name": "show",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "async show(): Promise<void> {\n\t\tawait this.ensurePanel();\n\t}",
    "start_line": 224,
    "end_line": 226,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method show",
    "component_id": "src.providers.dependencies-view-provider.show"
  },
  "src.providers.dependencies-view-provider.ensurePanel": {
    "id": "src.providers.dependencies-view-provider.ensurePanel",
    "name": "ensurePanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private ensurePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.reveal(ViewColumn.Active, false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tDependenciesViewProvider.panelType,\n\t\t\t\"Install Dependencies\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\tpreserveFocus: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tthis.isWebviewReady = false;\n\t\tpanel.webview.html = this.getHtmlForWebview(panel.webview);\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\t(message) => this.handleWebviewMessage(message),\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\t\tpanel.onDidDispose(\n\t\t\t() => {\n\t\t\t\tthis.panel = undefined;\n\t\t\t\tthis.isWebviewReady = false;\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[DependenciesViewProvider] Panel disposed\"\n\t\t\t\t);\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\n\t\tthis.panel = panel;\n\t\tthis.outputChannel.appendLine(\"[DependenciesViewProvider] Panel created\");\n\t}",
    "start_line": 228,
    "end_line": 269,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ensurePanel",
    "component_id": "src.providers.dependencies-view-provider.ensurePanel"
  },
  "src.providers.dependencies-view-provider.getHtmlForWebview": {
    "id": "src.providers.dependencies-view-provider.getHtmlForWebview",
    "name": "getHtmlForWebview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private getHtmlForWebview(webview: Webview): string {\n\t\treturn getWebviewContent(\n\t\t\twebview,\n\t\t\tthis.context.extensionUri,\n\t\t\t\"dependencies\"\n\t\t);\n\t}",
    "start_line": 271,
    "end_line": 277,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webview"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getHtmlForWebview",
    "component_id": "src.providers.dependencies-view-provider.getHtmlForWebview"
  },
  "src.providers.dependencies-view-provider.handleWebviewMessage": {
    "id": "src.providers.dependencies-view-provider.handleWebviewMessage",
    "name": "handleWebviewMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleWebviewMessage(message: WebviewMessage): Promise<void> {\n\t\ttry {\n\t\t\tswitch (message.type) {\n\t\t\t\tcase \"dependencies/ready\":\n\t\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\t\tthis.flushPendingMessages();\n\t\t\t\t\tawait this.checkAllDependencies();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/check\":\n\t\t\t\t\tawait this.checkAllDependencies();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/check-one\":\n\t\t\t\t\tawait this.checkSingleDependency(message.payload.name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/copy\":\n\t\t\t\t\tawait this.copyCommand(message.payload.command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/paste\":\n\t\t\t\t\tawait this.pasteToTerminal(message.payload.command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dependencies/execute\":\n\t\t\t\t\tawait this.executeInTerminal(message.payload.command);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[DependenciesViewProvider] Unknown message type: ${(message as any).type}`\n\t\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconst errorMessage =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tawait this.sendMessageToWebview({\n\t\t\t\ttype: \"dependencies/error\",\n\t\t\t\tpayload: { message: errorMessage },\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 279,
    "end_line": 315,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleWebviewMessage",
    "component_id": "src.providers.dependencies-view-provider.handleWebviewMessage"
  },
  "src.providers.dependencies-view-provider.checkAllDependencies": {
    "id": "src.providers.dependencies-view-provider.checkAllDependencies",
    "name": "checkAllDependencies",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async checkAllDependencies(): Promise<void> {\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/checking\",\n\t\t\tpayload: {},\n\t\t});\n\n\t\tconst dependencies: DependencyStatus[] = [];\n\n\t\tfor (const dep of DEPENDENCIES_TO_CHECK) {\n\t\t\tconst status = await this.checkDependency(dep.name, dep.command);\n\t\t\tdependencies.push(status);\n\t\t}\n\n\t\tconst platform = process.platform as \"darwin\" | \"linux\" | \"win32\";\n\t\tconst steps = INSTALLATION_STEPS.filter(\n\t\t\t(step) => step.platform === \"all\" || step.platform === platform\n\t\t);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/status\",\n\t\t\tpayload: { dependencies, steps },\n\t\t});\n\t}",
    "start_line": 317,
    "end_line": 339,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkAllDependencies",
    "component_id": "src.providers.dependencies-view-provider.checkAllDependencies"
  },
  "src.providers.dependencies-view-provider.checkSingleDependency": {
    "id": "src.providers.dependencies-view-provider.checkSingleDependency",
    "name": "checkSingleDependency",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async checkSingleDependency(name: string): Promise<void> {\n\t\tconst dep = DEPENDENCIES_TO_CHECK.find((d) => d.name === name);\n\t\tif (!dep) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/checking\",\n\t\t\tpayload: { name },\n\t\t});\n\n\t\tconst status = await this.checkDependency(dep.name, dep.command);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/updated\",\n\t\t\tpayload: status,\n\t\t});\n\t}",
    "start_line": 341,
    "end_line": 358,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkSingleDependency",
    "component_id": "src.providers.dependencies-view-provider.checkSingleDependency"
  },
  "src.providers.dependencies-view-provider.checkDependency": {
    "id": "src.providers.dependencies-view-provider.checkDependency",
    "name": "checkDependency",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async checkDependency(\n\t\tname: string,\n\t\tcommand: string\n\t): Promise<DependencyStatus> {\n\t\ttry {\n\t\t\tconst { stdout, stderr } = await execAsync(command, {\n\t\t\t\ttimeout: 10_000,\n\t\t\t\tencoding: \"utf8\",\n\t\t\t\tenv: {\n\t\t\t\t\t...process.env,\n\t\t\t\t\tPATH: getExtendedPath(),\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst output = stdout.trim() || stderr.trim();\n\t\t\tconst version = extractVersion(output);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependenciesViewProvider] ${name}: ${version || output}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tinstalled: true,\n\t\t\t\tversion: version || output,\n\t\t\t\tcommand,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst errorMessage =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependenciesViewProvider] ${name}: not found - ${errorMessage}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tinstalled: false,\n\t\t\t\terror: \"Not installed\",\n\t\t\t\tcommand,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 360,
    "end_line": 401,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "command"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkDependency",
    "component_id": "src.providers.dependencies-view-provider.checkDependency"
  },
  "src.providers.dependencies-view-provider.copyCommand": {
    "id": "src.providers.dependencies-view-provider.copyCommand",
    "name": "copyCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async copyCommand(command: string): Promise<void> {\n\t\tawait env.clipboard.writeText(command);\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/action-result\",\n\t\t\tpayload: {\n\t\t\t\taction: \"copy\",\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Command copied to clipboard\",\n\t\t\t},\n\t\t});\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependenciesViewProvider] Copied command: ${command}`\n\t\t);\n\t}",
    "start_line": 403,
    "end_line": 416,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method copyCommand",
    "component_id": "src.providers.dependencies-view-provider.copyCommand"
  },
  "src.providers.dependencies-view-provider.pasteToTerminal": {
    "id": "src.providers.dependencies-view-provider.pasteToTerminal",
    "name": "pasteToTerminal",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async pasteToTerminal(command: string): Promise<void> {\n\t\tconst terminal = this.getOrCreateTerminal();\n\t\tterminal.show(true);\n\t\tterminal.sendText(command, false);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/action-result\",\n\t\t\tpayload: {\n\t\t\t\taction: \"paste\",\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Command pasted to terminal\",\n\t\t\t},\n\t\t});\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependenciesViewProvider] Pasted to terminal: ${command}`\n\t\t);\n\t}",
    "start_line": 418,
    "end_line": 434,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method pasteToTerminal",
    "component_id": "src.providers.dependencies-view-provider.pasteToTerminal"
  },
  "src.providers.dependencies-view-provider.executeInTerminal": {
    "id": "src.providers.dependencies-view-provider.executeInTerminal",
    "name": "executeInTerminal",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async executeInTerminal(command: string): Promise<void> {\n\t\tconst terminal = this.getOrCreateTerminal();\n\t\tterminal.show(true);\n\t\tterminal.sendText(command, true);\n\n\t\tawait this.sendMessageToWebview({\n\t\t\ttype: \"dependencies/action-result\",\n\t\t\tpayload: {\n\t\t\t\taction: \"execute\",\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Command executed in terminal\",\n\t\t\t},\n\t\t});\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependenciesViewProvider] Executed in terminal: ${command}`\n\t\t);\n\t}",
    "start_line": 436,
    "end_line": 452,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeInTerminal",
    "component_id": "src.providers.dependencies-view-provider.executeInTerminal"
  },
  "src.providers.dependencies-view-provider.getOrCreateTerminal": {
    "id": "src.providers.dependencies-view-provider.getOrCreateTerminal",
    "name": "getOrCreateTerminal",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private getOrCreateTerminal(): Terminal {\n\t\tif (this.terminal && !this.terminal.exitStatus) {\n\t\t\treturn this.terminal;\n\t\t}\n\n\t\tthis.terminal = window.createTerminal({\n\t\t\tname: \"GatomIA - Dependencies\",\n\t\t});\n\n\t\treturn this.terminal;\n\t}",
    "start_line": 454,
    "end_line": 464,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getOrCreateTerminal",
    "component_id": "src.providers.dependencies-view-provider.getOrCreateTerminal"
  },
  "src.providers.dependencies-view-provider.flushPendingMessages": {
    "id": "src.providers.dependencies-view-provider.flushPendingMessages",
    "name": "flushPendingMessages",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private flushPendingMessages(): void {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (this.pendingMessages.length > 0) {\n\t\t\tconst message = this.pendingMessages.shift();\n\t\t\tif (message) {\n\t\t\t\tthis.webview.postMessage(message);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 466,
    "end_line": 477,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flushPendingMessages",
    "component_id": "src.providers.dependencies-view-provider.flushPendingMessages"
  },
  "src.providers.dependencies-view-provider.sendMessageToWebview": {
    "id": "src.providers.dependencies-view-provider.sendMessageToWebview",
    "name": "sendMessageToWebview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/dependencies-view-provider.ts",
    "relative_path": "src/providers/dependencies-view-provider.ts",
    "depends_on": [],
    "source_code": "private async sendMessageToWebview(message: ExtensionMessage): Promise<void> {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.webview.postMessage(message);\n\t}",
    "start_line": 479,
    "end_line": 486,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method sendMessageToWebview",
    "component_id": "src.providers.dependencies-view-provider.sendMessageToWebview"
  },
  "src.providers.hook-view-provider.WebviewMessage": {
    "id": "src.providers.hook-view-provider.WebviewMessage",
    "name": "WebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "type WebviewMessage =\n\t| HookCreateMessage\n\t| HookUpdateMessage\n\t| HookDeleteMessage\n\t| HookToggleMessage\n\t| HookListRequestMessage\n\t| HookReadyMessage\n\t| HookLogsRequestMessage\n\t| MCPDiscoveryRequestMessage\n\t| AgentListRequestMessage;",
    "start_line": 23,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type WebviewMessage",
    "component_id": "src.providers.hook-view-provider.WebviewMessage"
  },
  "src.providers.hook-view-provider.HookCreateMessage": {
    "id": "src.providers.hook-view-provider.HookCreateMessage",
    "name": "HookCreateMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "interface HookCreateMessage {\n\tcommand?: \"hooks.create\";\n\ttype?: \"hooks/create\";\n\tdata: Omit<Hook, \"id\" | \"createdAt\" | \"modifiedAt\" | \"executionCount\">;\n}",
    "start_line": 34,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookCreateMessage",
    "component_id": "src.providers.hook-view-provider.HookCreateMessage"
  },
  "src.providers.hook-view-provider.HookUpdateMessage": {
    "id": "src.providers.hook-view-provider.HookUpdateMessage",
    "name": "HookUpdateMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "interface HookUpdateMessage {\n\tcommand?: \"hooks.update\";\n\ttype?: \"hooks/update\";\n\tdata: {\n\t\tid: string;\n\t\tupdates: Partial<Hook>;\n\t};\n}",
    "start_line": 40,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookUpdateMessage",
    "component_id": "src.providers.hook-view-provider.HookUpdateMessage"
  },
  "src.providers.hook-view-provider.HookDeleteMessage": {
    "id": "src.providers.hook-view-provider.HookDeleteMessage",
    "name": "HookDeleteMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookDeleteMessage {\n\tcommand?: \"hooks.delete\";\n\ttype?: \"hooks/delete\";\n\tdata: { id: string };\n}",
    "start_line": 49,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookDeleteMessage",
    "component_id": "src.providers.hook-view-provider.HookDeleteMessage"
  },
  "src.providers.hook-view-provider.HookToggleMessage": {
    "id": "src.providers.hook-view-provider.HookToggleMessage",
    "name": "HookToggleMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookToggleMessage {\n\tcommand?: \"hooks.toggle\";\n\ttype?: \"hooks/toggle\";\n\tdata: { id: string; enabled: boolean };\n}",
    "start_line": 55,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookToggleMessage",
    "component_id": "src.providers.hook-view-provider.HookToggleMessage"
  },
  "src.providers.hook-view-provider.HookListRequestMessage": {
    "id": "src.providers.hook-view-provider.HookListRequestMessage",
    "name": "HookListRequestMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookListRequestMessage {\n\tcommand?: \"hooks.list\";\n\ttype?: \"hooks/list\";\n}",
    "start_line": 61,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookListRequestMessage",
    "component_id": "src.providers.hook-view-provider.HookListRequestMessage"
  },
  "src.providers.hook-view-provider.HookReadyMessage": {
    "id": "src.providers.hook-view-provider.HookReadyMessage",
    "name": "HookReadyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookReadyMessage {\n\tcommand?: \"hooks.ready\";\n\ttype?: \"hooks/ready\";\n}",
    "start_line": 66,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookReadyMessage",
    "component_id": "src.providers.hook-view-provider.HookReadyMessage"
  },
  "src.providers.hook-view-provider.HookLogsRequestMessage": {
    "id": "src.providers.hook-view-provider.HookLogsRequestMessage",
    "name": "HookLogsRequestMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookLogsRequestMessage {\n\tcommand?: \"hooks.logs\";\n\ttype?: \"hooks/logs\";\n\tdata?: { hookId?: string };\n\tpayload?: { hookId?: string };\n}",
    "start_line": 71,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookLogsRequestMessage",
    "component_id": "src.providers.hook-view-provider.HookLogsRequestMessage"
  },
  "src.providers.hook-view-provider.MCPDiscoveryRequestMessage": {
    "id": "src.providers.hook-view-provider.MCPDiscoveryRequestMessage",
    "name": "MCPDiscoveryRequestMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface MCPDiscoveryRequestMessage {\n\tcommand?: \"hooks.mcp-discover\";\n\ttype?: \"hooks/mcp-discover\";\n\tdata?: { forceRefresh?: boolean };\n\tpayload?: { forceRefresh?: boolean };\n}",
    "start_line": 78,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPDiscoveryRequestMessage",
    "component_id": "src.providers.hook-view-provider.MCPDiscoveryRequestMessage"
  },
  "src.providers.hook-view-provider.AgentListRequestMessage": {
    "id": "src.providers.hook-view-provider.AgentListRequestMessage",
    "name": "AgentListRequestMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface AgentListRequestMessage {\n\tcommand?: \"hooks.agents-list\";\n\ttype?: \"hooks/agents-list\";\n\tdata?: { forceRefresh?: boolean };\n\tpayload?: { forceRefresh?: boolean };\n}",
    "start_line": 85,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentListRequestMessage",
    "component_id": "src.providers.hook-view-provider.AgentListRequestMessage"
  },
  "src.providers.hook-view-provider.HooksSyncMessage": {
    "id": "src.providers.hook-view-provider.HooksSyncMessage",
    "name": "HooksSyncMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "interface HooksSyncMessage {\n\tcommand: \"hooks.sync\";\n\ttype: \"hooks/sync\";\n\tdata: { hooks: Hook[] };\n}",
    "start_line": 95,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HooksSyncMessage",
    "component_id": "src.providers.hook-view-provider.HooksSyncMessage"
  },
  "src.providers.hook-view-provider.HookCreatedMessage": {
    "id": "src.providers.hook-view-provider.HookCreatedMessage",
    "name": "HookCreatedMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "interface HookCreatedMessage {\n\tcommand: \"hooks.created\";\n\ttype: \"hooks/created\";\n\tdata: { hook: Hook };\n}",
    "start_line": 101,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookCreatedMessage",
    "component_id": "src.providers.hook-view-provider.HookCreatedMessage"
  },
  "src.providers.hook-view-provider.HookUpdatedMessage": {
    "id": "src.providers.hook-view-provider.HookUpdatedMessage",
    "name": "HookUpdatedMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "interface HookUpdatedMessage {\n\tcommand: \"hooks.updated\";\n\ttype: \"hooks/updated\";\n\tdata: { hook: Hook };\n}",
    "start_line": 107,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookUpdatedMessage",
    "component_id": "src.providers.hook-view-provider.HookUpdatedMessage"
  },
  "src.providers.hook-view-provider.HookDeletedMessage": {
    "id": "src.providers.hook-view-provider.HookDeletedMessage",
    "name": "HookDeletedMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookDeletedMessage {\n\tcommand: \"hooks.deleted\";\n\ttype: \"hooks/deleted\";\n\tdata: { id: string };\n}",
    "start_line": 113,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookDeletedMessage",
    "component_id": "src.providers.hook-view-provider.HookDeletedMessage"
  },
  "src.providers.hook-view-provider.ErrorMessage": {
    "id": "src.providers.hook-view-provider.ErrorMessage",
    "name": "ErrorMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface ErrorMessage {\n\tcommand: \"hooks.error\";\n\ttype: \"hooks/error\";\n\tdata: {\n\t\tmessage: string;\n\t\tcode?: string;\n\t};\n}",
    "start_line": 119,
    "end_line": 126,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ErrorMessage",
    "component_id": "src.providers.hook-view-provider.ErrorMessage"
  },
  "src.providers.hook-view-provider.ExecutionStatusMessage": {
    "id": "src.providers.hook-view-provider.ExecutionStatusMessage",
    "name": "ExecutionStatusMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "src.providers.hook-view-provider.HookExecutionStatusPayload"
    ],
    "source_code": "interface ExecutionStatusMessage {\n\tcommand: \"hooks.execution-status\";\n\ttype: \"hooks/execution-status\";\n\tdata: HookExecutionStatusPayload;\n}",
    "start_line": 128,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionStatusMessage",
    "component_id": "src.providers.hook-view-provider.ExecutionStatusMessage"
  },
  "src.providers.hook-view-provider.HookExecutionStatusPayload": {
    "id": "src.providers.hook-view-provider.HookExecutionStatusPayload",
    "name": "HookExecutionStatusPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface HookExecutionStatusPayload {\n\thookId: string;\n\tstatus: \"executing\" | \"completed\" | \"failed\";\n\terrorMessage?: string;\n}",
    "start_line": 134,
    "end_line": 138,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookExecutionStatusPayload",
    "component_id": "src.providers.hook-view-provider.HookExecutionStatusPayload"
  },
  "src.providers.hook-view-provider.ExecutionLogsMessage": {
    "id": "src.providers.hook-view-provider.ExecutionLogsMessage",
    "name": "ExecutionLogsMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.HookExecutionLog"
    ],
    "source_code": "interface ExecutionLogsMessage {\n\tcommand: \"hooks.logs\";\n\ttype: \"hooks/logs\";\n\tdata: { logs: HookExecutionLog[] };\n}",
    "start_line": 140,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionLogsMessage",
    "component_id": "src.providers.hook-view-provider.ExecutionLogsMessage"
  },
  "src.providers.hook-view-provider.MCPServersMessage": {
    "id": "src.providers.hook-view-provider.MCPServersMessage",
    "name": "MCPServersMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer"
    ],
    "source_code": "interface MCPServersMessage {\n\tcommand: \"hooks.mcp-servers\";\n\ttype: \"hooks/mcp-servers\";\n\tdata: { servers: MCPServer[] };\n}",
    "start_line": 146,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServersMessage",
    "component_id": "src.providers.hook-view-provider.MCPServersMessage"
  },
  "src.providers.hook-view-provider.MCPErrorMessage": {
    "id": "src.providers.hook-view-provider.MCPErrorMessage",
    "name": "MCPErrorMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface MCPErrorMessage {\n\tcommand: \"hooks.mcp-error\";\n\ttype: \"hooks/mcp-error\";\n\tdata: { message: string };\n}",
    "start_line": 152,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPErrorMessage",
    "component_id": "src.providers.hook-view-provider.MCPErrorMessage"
  },
  "src.providers.hook-view-provider.AgentListMessage": {
    "id": "src.providers.hook-view-provider.AgentListMessage",
    "name": "AgentListMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface AgentListMessage {\n\tcommand: \"hooks.agents-list\";\n\ttype: \"hooks/agents-list\";\n\tdata: {\n\t\tlocal: Array<{\n\t\t\tid: string;\n\t\t\tname: string;\n\t\t\tdisplayName: string;\n\t\t\tdescription?: string;\n\t\t}>;\n\t\tbackground: Array<{\n\t\t\tid: string;\n\t\t\tname: string;\n\t\t\tdisplayName: string;\n\t\t\tdescription?: string;\n\t\t}>;\n\t};\n}",
    "start_line": 158,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentListMessage",
    "component_id": "src.providers.hook-view-provider.AgentListMessage"
  },
  "src.providers.hook-view-provider.AgentErrorMessage": {
    "id": "src.providers.hook-view-provider.AgentErrorMessage",
    "name": "AgentErrorMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface AgentErrorMessage {\n\tcommand: \"hooks.agents-error\";\n\ttype: \"hooks/agents-error\";\n\tdata: { message: string };\n}",
    "start_line": 177,
    "end_line": 181,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentErrorMessage",
    "component_id": "src.providers.hook-view-provider.AgentErrorMessage"
  },
  "src.providers.hook-view-provider.ExtensionMessage": {
    "id": "src.providers.hook-view-provider.ExtensionMessage",
    "name": "ExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "type ExtensionMessage =\n\t| HooksSyncMessage\n\t| HookCreatedMessage\n\t| HookUpdatedMessage\n\t| HookDeletedMessage\n\t| ErrorMessage\n\t| ExecutionStatusMessage\n\t| ExecutionLogsMessage\n\t| MCPServersMessage\n\t| MCPErrorMessage\n\t| AgentListMessage\n\t| AgentErrorMessage\n\t| ShowFormMessage\n\t| ShowLogsPanelMessage;",
    "start_line": 183,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExtensionMessage",
    "component_id": "src.providers.hook-view-provider.ExtensionMessage"
  },
  "src.providers.hook-view-provider.ShowFormMessage": {
    "id": "src.providers.hook-view-provider.ShowFormMessage",
    "name": "ShowFormMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "interface ShowFormMessage {\n\tcommand: \"hooks.show-form\";\n\ttype: \"hooks/show-form\";\n\tdata?: { mode?: \"create\" | \"edit\"; hook?: Hook };\n}",
    "start_line": 198,
    "end_line": 202,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ShowFormMessage",
    "component_id": "src.providers.hook-view-provider.ShowFormMessage"
  },
  "src.providers.hook-view-provider.ShowLogsPanelMessage": {
    "id": "src.providers.hook-view-provider.ShowLogsPanelMessage",
    "name": "ShowLogsPanelMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "interface ShowLogsPanelMessage {\n\tcommand: \"hooks.show-logs\";\n\ttype: \"hooks/show-logs\";\n\tdata: { visible: boolean; hookId?: string };\n}",
    "start_line": 204,
    "end_line": 208,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ShowLogsPanelMessage",
    "component_id": "src.providers.hook-view-provider.ShowLogsPanelMessage"
  },
  "src.providers.hook-view-provider.HookViewProvider": {
    "id": "src.providers.hook-view-provider.HookViewProvider",
    "name": "HookViewProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [
      "src.providers.hook-view-provider.sendExecutionLogs",
      "src.providers.hook-view-provider.handleUpdateHook",
      "src.providers.hook-view-provider.HookExecutionStatusPayload",
      "src.features.hooks.hook-manager.updateHook",
      "src.features.hooks.hook-executor.getExecutionLogsForHook",
      "src.providers.hook-view-provider.ensurePanel",
      "src.features.hooks.services.mcp-contracts.IMCPDiscoveryService",
      "src.providers.hook-view-provider.webview",
      "src.providers.hook-view-provider.sendMessageToWebview",
      "src.providers.hook-view-provider.getHtmlForWebview",
      "src.providers.hook-view-provider.handleAgentListRequest",
      "src.providers.hook-view-provider.AgentListMessage",
      "src.providers.hook-view-provider.handleDeleteHook",
      "src.providers.welcome-screen-provider.sendError",
      "src.features.hooks.hook-executor.HookExecutor",
      "src.providers.hook-view-provider.flushPendingMessages",
      "src.features.hooks.hook-manager.deleteHook",
      "src.features.hooks.services.mcp-discovery.discoverServers",
      "src.providers.hook-view-provider.flushExecutionStatuses",
      "src.providers.hook-view-provider.handleExecutionStatus",
      "src.services.agent-service.dispose",
      "src.providers.hook-view-provider.sendError",
      "src.providers.hook-view-provider.AgentErrorMessage",
      "src.providers.hook-view-provider.handleCreateHook",
      "ui.src.features.hooks-view.types.Hook",
      "src.providers.hook-view-provider.ExtensionMessage",
      "src.utils.get-webview-content.getWebviewContent",
      "src.providers.hook-view-provider.syncHooksToWebview",
      "src.providers.hook-view-provider.handleMCPDiscovery",
      "src.panels.welcome-screen-panel.postMessage",
      "src.providers.hook-view-provider.dispose",
      "src.features.hooks.hook-manager.HookManager",
      "src.features.hooks.hook-executor.getExecutionLogs",
      "src.providers.hook-view-provider.handleToggleHook",
      "src.providers.hook-view-provider.WebviewMessage",
      "src.features.hooks.hook-manager.createHook",
      "src.providers.hook-view-provider.handleWebviewMessage",
      "src.features.hooks.hook-manager.getAllHooks"
    ],
    "source_code": "class HookViewProvider {\n\tstatic readonly panelType = \"gatomia.hooksPanel\";\n\n\tprivate panel?: WebviewPanel;\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly hookManager: HookManager;\n\tprivate readonly hookExecutor: HookExecutor;\n\tprivate readonly mcpDiscoveryService: IMCPDiscoveryService;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly disposables: Disposable[] = [];\n\tprivate readonly executionStatusCache = new Map<\n\t\tstring,\n\t\tHookExecutionStatusPayload\n\t>();\n\tprivate readonly pendingMessages: ExtensionMessage[] = [];\n\tprivate isWebviewReady = false;\n\n\tconstructor(options: {\n\t\tcontext: ExtensionContext;\n\t\thookManager: HookManager;\n\t\thookExecutor: HookExecutor;\n\t\tmcpDiscoveryService: IMCPDiscoveryService;\n\t\toutputChannel: OutputChannel;\n\t}) {\n\t\tthis.context = options.context;\n\t\tthis.hookManager = options.hookManager;\n\t\tthis.hookExecutor = options.hookExecutor;\n\t\tthis.mcpDiscoveryService = options.mcpDiscoveryService;\n\t\tthis.outputChannel = options.outputChannel;\n\t}\n\n\tinitialize(): void {\n\t\tthis.disposables.push(\n\t\t\tthis.hookManager.onHooksChanged(() => {\n\t\t\t\tthis.syncHooksToWebview();\n\t\t\t}),\n\t\t\tthis.hookExecutor.onExecutionStarted((event) => {\n\t\t\t\tthis.handleExecutionStatus({\n\t\t\t\t\thookId: event.hook.id,\n\t\t\t\t\tstatus: \"executing\",\n\t\t\t\t});\n\t\t\t}),\n\t\t\tthis.hookExecutor.onExecutionCompleted((event) => {\n\t\t\t\tthis.handleExecutionStatus({\n\t\t\t\t\thookId: event.hook.id,\n\t\t\t\t\tstatus: \"completed\",\n\t\t\t\t});\n\t\t\t}),\n\t\t\tthis.hookExecutor.onExecutionFailed((event) => {\n\t\t\t\tthis.handleExecutionStatus({\n\t\t\t\t\thookId: event.hook.id,\n\t\t\t\t\tstatus: \"failed\",\n\t\t\t\t\terrorMessage: event.result?.error?.message,\n\t\t\t\t});\n\t\t\t})\n\t\t);\n\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Initialized\");\n\t}\n\n\tdispose(): void {\n\t\tthis.panel?.dispose();\n\t\tthis.panel = undefined;\n\t\tthis.isWebviewReady = false;\n\t\twhile (this.disposables.length > 0) {\n\t\t\tthis.disposables.pop()?.dispose();\n\t\t}\n\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Disposed\");\n\t}\n\n\tprivate get webview(): Webview | undefined {\n\t\treturn this.panel?.webview;\n\t}\n\n\tasync syncHooksToWebview(): Promise<void> {\n\t\tconst hooks = await this.hookManager.getAllHooks();\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.sync\",\n\t\t\ttype: \"hooks/sync\",\n\t\t\tdata: { hooks },\n\t\t} as HooksSyncMessage);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookViewProvider] Synced ${hooks.length} hooks to webview`\n\t\t);\n\t}\n\n\tprivate async handleWebviewMessage(message: WebviewMessage): Promise<void> {\n\t\ttry {\n\t\t\tconst normalizedCommand =\n\t\t\t\tmessage.command ??\n\t\t\t\t(\"type\" in message && message.type\n\t\t\t\t\t? (message.type as string).replace(/\\//g, \".\")\n\t\t\t\t\t: undefined);\n\t\t\tconst messageData = (message as any).data ?? (message as any).payload;\n\n\t\t\tswitch (normalizedCommand) {\n\t\t\t\tcase \"hooks.create\":\n\t\t\t\t\tawait this.handleCreateHook(messageData);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.update\":\n\t\t\t\t\tawait this.handleUpdateHook(messageData.id, messageData.updates);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.delete\":\n\t\t\t\t\tawait this.handleDeleteHook(messageData.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.toggle\":\n\t\t\t\t\tawait this.handleToggleHook(messageData.id, messageData.enabled);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.list\":\n\t\t\t\t\tawait this.syncHooksToWebview();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.logs\":\n\t\t\t\t\tawait this.sendExecutionLogs(messageData?.hookId);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.ready\":\n\t\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\t\tthis.flushPendingMessages();\n\t\t\t\t\tthis.flushExecutionStatuses();\n\t\t\t\t\tawait this.syncHooksToWebview();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.mcp-discover\":\n\t\t\t\t\tawait this.handleMCPDiscovery(messageData?.forceRefresh ?? false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.agents-list\":\n\t\t\t\t\tawait this.handleAgentListRequest(messageData?.forceRefresh ?? false);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookViewProvider] Unknown command: ${(message as any).command ?? (message as any).type}`\n\t\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tawait this.sendError(error as Error);\n\t\t}\n\t}\n\n\tprivate async handleCreateHook(\n\t\thookData: Omit<Hook, \"id\" | \"createdAt\" | \"modifiedAt\" | \"executionCount\">\n\t): Promise<void> {\n\t\tawait this.hookManager.createHook(hookData);\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}\n\n\tprivate async handleUpdateHook(\n\t\thookId: string,\n\t\tupdates: Partial<Hook>\n\t): Promise<void> {\n\t\tawait this.hookManager.updateHook(hookId, updates);\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}\n\n\tprivate async handleDeleteHook(hookId: string): Promise<void> {\n\t\tawait this.hookManager.deleteHook(hookId);\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}\n\n\tprivate async handleToggleHook(\n\t\thookId: string,\n\t\tenabled: boolean\n\t): Promise<void> {\n\t\tawait this.hookManager.updateHook(hookId, { enabled });\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}\n\n\tprivate async sendExecutionLogs(hookId?: string): Promise<void> {\n\t\tconst logs = hookId\n\t\t\t? this.hookExecutor.getExecutionLogsForHook(hookId)\n\t\t\t: this.hookExecutor.getExecutionLogs();\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.logs\",\n\t\t\ttype: \"hooks/logs\",\n\t\t\tdata: { logs },\n\t\t} as ExecutionLogsMessage);\n\t}\n\n\tprivate async sendError(error: Error): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookViewProvider] Webview error: ${error.message}`\n\t\t);\n\n\t\t// Extract validation errors if this is a HookValidationError\n\t\tconst validationErrors =\n\t\t\t(error as any).errors &&\n\t\t\tArray.isArray((error as any).errors) &&\n\t\t\t(error as any).errors.length > 0\n\t\t\t\t? (error as any).errors\n\t\t\t\t: undefined;\n\n\t\tif (validationErrors) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Validation errors: ${JSON.stringify(validationErrors)}`\n\t\t\t);\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.error\",\n\t\t\ttype: \"hooks/error\",\n\t\t\tdata: {\n\t\t\t\tmessage: error.message,\n\t\t\t\tcode: (error as any).code,\n\t\t\t\tvalidationErrors,\n\t\t\t},\n\t\t} as ErrorMessage);\n\t}\n\n\tprivate async handleMCPDiscovery(forceRefresh: boolean): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] MCP discovery requested (forceRefresh: ${forceRefresh})`\n\t\t\t);\n\n\t\t\tconst servers =\n\t\t\t\tawait this.mcpDiscoveryService.discoverServers(forceRefresh);\n\n\t\t\tawait this.sendMessageToWebview({\n\t\t\t\tcommand: \"hooks.mcp-servers\",\n\t\t\t\ttype: \"hooks/mcp-servers\",\n\t\t\t\tdata: { servers },\n\t\t\t} as MCPServersMessage);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Sent ${servers.length} MCP servers to webview`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] MCP discovery error: ${(error as Error).message}`\n\t\t\t);\n\n\t\t\tawait this.sendMessageToWebview({\n\t\t\t\tcommand: \"hooks.mcp-error\",\n\t\t\t\ttype: \"hooks/mcp-error\",\n\t\t\t\tdata: {\n\t\t\t\t\tmessage: (error as Error).message || \"Failed to discover MCP servers\",\n\t\t\t\t},\n\t\t\t} as MCPErrorMessage);\n\t\t}\n\t}\n\n\tprivate async handleAgentListRequest(forceRefresh: boolean): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Agent list requested (forceRefresh: ${forceRefresh})`\n\t\t\t);\n\n\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\tconst { join } = await import(\"node:path\");\n\t\t\tconst matter = (await import(\"gray-matter\")).default;\n\t\t\tconst { workspace } = await import(\"vscode\");\n\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Workspace root: ${workspaceRoot}`\n\t\t\t);\n\n\t\t\tconst agentsDir = join(workspaceRoot, \".github\", \"agents\");\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Looking for agents in: ${agentsDir}`\n\t\t\t);\n\n\t\t\tconst files = await fs.readdir(agentsDir).catch((err) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookViewProvider] Error reading directory: ${err.message}`\n\t\t\t\t);\n\t\t\t\treturn [];\n\t\t\t});\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Found ${files.length} files in directory`\n\t\t\t);\n\n\t\t\tconst agentFiles = files.filter(\n\t\t\t\t(file) => file.endsWith(\".agent.md\") && !file.startsWith(\".\")\n\t\t\t);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Filtered to ${agentFiles.length} .agent.md files`\n\t\t\t);\n\n\t\t\tconst agents = await Promise.all(\n\t\t\t\tagentFiles.map(async (filename) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst filePath = join(agentsDir, filename);\n\t\t\t\t\t\tconst content = await fs.readFile(filePath, \"utf-8\");\n\t\t\t\t\t\tconst parsed = matter(content);\n\t\t\t\t\t\t// Extract agent ID from frontmatter, fallback to filename\n\t\t\t\t\t\tconst agentId =\n\t\t\t\t\t\t\ttypeof parsed.data.id === \"string\"\n\t\t\t\t\t\t\t\t? parsed.data.id\n\t\t\t\t\t\t\t\t: filename.replace(\".agent.md\", \"\");\n\t\t\t\t\t\tconst name = filename.replace(\".agent.md\", \"\");\n\t\t\t\t\t\tconst description =\n\t\t\t\t\t\t\ttypeof parsed.data.description === \"string\"\n\t\t\t\t\t\t\t\t? parsed.data.description\n\t\t\t\t\t\t\t\t: \"No description available\";\n\t\t\t\t\t\t// Use 'local:' prefix to match AgentRegistry convention (AGENT_ID_PREFIX.FILE = \"local\")\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: `local:${agentId}`,\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tdisplayName: name,\n\t\t\t\t\t\t\tdescription,\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookViewProvider] Failed to parse ${filename}: ${(error as Error).message}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tconst validAgents = agents.filter(\n\t\t\t\t(a): a is NonNullable<typeof a> => a !== null\n\t\t\t);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Sending ${validAgents.length} agents to webview`\n\t\t\t);\n\n\t\t\t// Send directly to webview if available, bypassing ready check\n\t\t\t// This is needed because AgentDropdown mounts before hooks.ready is sent\n\t\t\tconst message: AgentListMessage = {\n\t\t\t\tcommand: \"hooks.agents-list\",\n\t\t\t\ttype: \"hooks/agents-list\",\n\t\t\t\tdata: { local: validAgents, background: [] },\n\t\t\t};\n\n\t\t\tif (this.webview) {\n\t\t\t\tawait this.webview.postMessage(message);\n\t\t\t} else {\n\t\t\t\t// If webview doesn't exist yet, queue it\n\t\t\t\tthis.pendingMessages.push(message);\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Sent ${validAgents.length} agents from .github/agents/ to webview`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Agent list error: ${(error as Error).message}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Stack: ${(error as Error).stack}`\n\t\t\t);\n\n\t\t\t// Send error directly to webview if available\n\t\t\tconst errorMessage: AgentErrorMessage = {\n\t\t\t\tcommand: \"hooks.agents-error\",\n\t\t\t\ttype: \"hooks/agents-error\",\n\t\t\t\tdata: {\n\t\t\t\t\tmessage: (error as Error).message || \"Failed to load agents\",\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (this.webview) {\n\t\t\t\tawait this.webview.postMessage(errorMessage);\n\t\t\t} else {\n\t\t\t\tthis.pendingMessages.push(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleExecutionStatus(payload: HookExecutionStatusPayload): void {\n\t\tif (!this.webview) {\n\t\t\tthis.executionStatusCache.set(payload.hookId, payload);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.webview.postMessage({\n\t\t\tcommand: \"hooks.execution-status\",\n\t\t\ttype: \"hooks/execution-status\",\n\t\t\tdata: payload,\n\t\t} as ExecutionStatusMessage);\n\t}\n\n\tprivate flushExecutionStatuses(): void {\n\t\tif (!this.webview) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const payload of this.executionStatusCache.values()) {\n\t\t\tthis.webview.postMessage({\n\t\t\t\tcommand: \"hooks.execution-status\",\n\t\t\t\ttype: \"hooks/execution-status\",\n\t\t\t\tdata: payload,\n\t\t\t} as ExecutionStatusMessage);\n\t\t}\n\t}\n\n\tprivate flushPendingMessages(): void {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (this.pendingMessages.length > 0) {\n\t\t\tconst message = this.pendingMessages.shift();\n\t\t\tif (message) {\n\t\t\t\tthis.webview.postMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendMessageToWebview(message: ExtensionMessage): Promise<void> {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.webview.postMessage(message);\n\t}\n\n\tasync showCreateHookForm(): Promise<void> {\n\t\tconst panelExisted = !!this.panel;\n\t\tawait this.ensurePanel();\n\n\t\t// Only sync if panel was just created (webview needs initial data)\n\t\t// If panel already existed, avoid sync to prevent race condition\n\t\tif (!panelExisted) {\n\t\t\tawait this.syncHooksToWebview();\n\t\t\t// Wait for webview to be fully ready after panel creation\n\t\t\tif (!this.isWebviewReady) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.show-form\",\n\t\t\ttype: \"hooks/show-form\",\n\t\t\tdata: { mode: \"create\" },\n\t\t} as ShowFormMessage);\n\t}\n\n\tasync showEditHookForm(hook: Hook): Promise<void> {\n\t\tconst panelExisted = !!this.panel;\n\t\tawait this.ensurePanel();\n\n\t\t// Only sync if panel was just created (webview needs initial data)\n\t\t// If panel already existed, avoid sync to prevent race condition\n\t\tif (!panelExisted) {\n\t\t\tawait this.syncHooksToWebview();\n\t\t\t// Wait for webview to be fully ready after panel creation\n\t\t\tif (!this.isWebviewReady) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.show-form\",\n\t\t\ttype: \"hooks/show-form\",\n\t\t\tdata: { mode: \"edit\", hook },\n\t\t} as ShowFormMessage);\n\t}\n\n\tasync showLogsPanel(hookId?: string): Promise<void> {\n\t\tconst panelExisted = !!this.panel;\n\t\tawait this.ensurePanel();\n\n\t\t// Only sync if panel was just created (webview needs initial data)\n\t\t// If panel already existed, avoid sync to prevent race condition\n\t\tif (!panelExisted) {\n\t\t\tawait this.syncHooksToWebview();\n\t\t\t// Wait for webview to be fully ready after panel creation\n\t\t\tif (!this.isWebviewReady) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.show-logs\",\n\t\t\ttype: \"hooks/show-logs\",\n\t\t\tdata: { visible: true, hookId },\n\t\t} as ShowLogsPanelMessage);\n\t}\n\n\tprivate ensurePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.reveal(ViewColumn.Active, false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tHookViewProvider.panelType,\n\t\t\t\"Hooks\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\tpreserveFocus: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tthis.isWebviewReady = false;\n\t\tpanel.webview.html = this.getHtmlForWebview(panel.webview);\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\t(message) => this.handleWebviewMessage(message),\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\t\tpanel.onDidDispose(\n\t\t\t() => {\n\t\t\t\tthis.panel = undefined;\n\t\t\t\tthis.isWebviewReady = false;\n\t\t\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Panel disposed\");\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\n\t\tthis.panel = panel;\n\t\tthis.flushPendingMessages();\n\t\tthis.flushExecutionStatuses();\n\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Panel created\");\n\t}\n\n\tprivate getHtmlForWebview(webview: Webview): string {\n\t\treturn getWebviewContent(webview, this.context.extensionUri, \"hooks\");\n\t}\n}",
    "start_line": 219,
    "end_line": 741,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HookViewProvider",
    "component_id": "src.providers.hook-view-provider.HookViewProvider"
  },
  "src.providers.hook-view-provider.initialize": {
    "id": "src.providers.hook-view-provider.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "initialize(): void {\n\t\tthis.disposables.push(\n\t\t\tthis.hookManager.onHooksChanged(() => {\n\t\t\t\tthis.syncHooksToWebview();\n\t\t\t}),\n\t\t\tthis.hookExecutor.onExecutionStarted((event) => {\n\t\t\t\tthis.handleExecutionStatus({\n\t\t\t\t\thookId: event.hook.id,\n\t\t\t\t\tstatus: \"executing\",\n\t\t\t\t});\n\t\t\t}),\n\t\t\tthis.hookExecutor.onExecutionCompleted((event) => {\n\t\t\t\tthis.handleExecutionStatus({\n\t\t\t\t\thookId: event.hook.id,\n\t\t\t\t\tstatus: \"completed\",\n\t\t\t\t});\n\t\t\t}),\n\t\t\tthis.hookExecutor.onExecutionFailed((event) => {\n\t\t\t\tthis.handleExecutionStatus({\n\t\t\t\t\thookId: event.hook.id,\n\t\t\t\t\tstatus: \"failed\",\n\t\t\t\t\terrorMessage: event.result?.error?.message,\n\t\t\t\t});\n\t\t\t})\n\t\t);\n\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Initialized\");\n\t}",
    "start_line": 250,
    "end_line": 276,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initialize",
    "component_id": "src.providers.hook-view-provider.initialize"
  },
  "src.providers.hook-view-provider.dispose": {
    "id": "src.providers.hook-view-provider.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.panel?.dispose();\n\t\tthis.panel = undefined;\n\t\tthis.isWebviewReady = false;\n\t\twhile (this.disposables.length > 0) {\n\t\t\tthis.disposables.pop()?.dispose();\n\t\t}\n\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Disposed\");\n\t}",
    "start_line": 278,
    "end_line": 286,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.providers.hook-view-provider.dispose"
  },
  "src.providers.hook-view-provider.webview": {
    "id": "src.providers.hook-view-provider.webview",
    "name": "webview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private get webview(): Webview | undefined {\n\t\treturn this.panel?.webview;\n\t}",
    "start_line": 288,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method webview",
    "component_id": "src.providers.hook-view-provider.webview"
  },
  "src.providers.hook-view-provider.syncHooksToWebview": {
    "id": "src.providers.hook-view-provider.syncHooksToWebview",
    "name": "syncHooksToWebview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "async syncHooksToWebview(): Promise<void> {\n\t\tconst hooks = await this.hookManager.getAllHooks();\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.sync\",\n\t\t\ttype: \"hooks/sync\",\n\t\t\tdata: { hooks },\n\t\t} as HooksSyncMessage);\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookViewProvider] Synced ${hooks.length} hooks to webview`\n\t\t);\n\t}",
    "start_line": 292,
    "end_line": 302,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method syncHooksToWebview",
    "component_id": "src.providers.hook-view-provider.syncHooksToWebview"
  },
  "src.providers.hook-view-provider.handleWebviewMessage": {
    "id": "src.providers.hook-view-provider.handleWebviewMessage",
    "name": "handleWebviewMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleWebviewMessage(message: WebviewMessage): Promise<void> {\n\t\ttry {\n\t\t\tconst normalizedCommand =\n\t\t\t\tmessage.command ??\n\t\t\t\t(\"type\" in message && message.type\n\t\t\t\t\t? (message.type as string).replace(/\\//g, \".\")\n\t\t\t\t\t: undefined);\n\t\t\tconst messageData = (message as any).data ?? (message as any).payload;\n\n\t\t\tswitch (normalizedCommand) {\n\t\t\t\tcase \"hooks.create\":\n\t\t\t\t\tawait this.handleCreateHook(messageData);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.update\":\n\t\t\t\t\tawait this.handleUpdateHook(messageData.id, messageData.updates);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.delete\":\n\t\t\t\t\tawait this.handleDeleteHook(messageData.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.toggle\":\n\t\t\t\t\tawait this.handleToggleHook(messageData.id, messageData.enabled);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.list\":\n\t\t\t\t\tawait this.syncHooksToWebview();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.logs\":\n\t\t\t\t\tawait this.sendExecutionLogs(messageData?.hookId);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.ready\":\n\t\t\t\t\tthis.isWebviewReady = true;\n\t\t\t\t\tthis.flushPendingMessages();\n\t\t\t\t\tthis.flushExecutionStatuses();\n\t\t\t\t\tawait this.syncHooksToWebview();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.mcp-discover\":\n\t\t\t\t\tawait this.handleMCPDiscovery(messageData?.forceRefresh ?? false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"hooks.agents-list\":\n\t\t\t\t\tawait this.handleAgentListRequest(messageData?.forceRefresh ?? false);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[HookViewProvider] Unknown command: ${(message as any).command ?? (message as any).type}`\n\t\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tawait this.sendError(error as Error);\n\t\t}\n\t}",
    "start_line": 304,
    "end_line": 352,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleWebviewMessage",
    "component_id": "src.providers.hook-view-provider.handleWebviewMessage"
  },
  "src.providers.hook-view-provider.handleCreateHook": {
    "id": "src.providers.hook-view-provider.handleCreateHook",
    "name": "handleCreateHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleCreateHook(\n\t\thookData: Omit<Hook, \"id\" | \"createdAt\" | \"modifiedAt\" | \"executionCount\">\n\t): Promise<void> {\n\t\tawait this.hookManager.createHook(hookData);\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}",
    "start_line": 354,
    "end_line": 359,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookData"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleCreateHook",
    "component_id": "src.providers.hook-view-provider.handleCreateHook"
  },
  "src.providers.hook-view-provider.handleUpdateHook": {
    "id": "src.providers.hook-view-provider.handleUpdateHook",
    "name": "handleUpdateHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleUpdateHook(\n\t\thookId: string,\n\t\tupdates: Partial<Hook>\n\t): Promise<void> {\n\t\tawait this.hookManager.updateHook(hookId, updates);\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}",
    "start_line": 361,
    "end_line": 367,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId",
      "updates"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleUpdateHook",
    "component_id": "src.providers.hook-view-provider.handleUpdateHook"
  },
  "src.providers.hook-view-provider.handleDeleteHook": {
    "id": "src.providers.hook-view-provider.handleDeleteHook",
    "name": "handleDeleteHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleDeleteHook(hookId: string): Promise<void> {\n\t\tawait this.hookManager.deleteHook(hookId);\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}",
    "start_line": 369,
    "end_line": 372,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleDeleteHook",
    "component_id": "src.providers.hook-view-provider.handleDeleteHook"
  },
  "src.providers.hook-view-provider.handleToggleHook": {
    "id": "src.providers.hook-view-provider.handleToggleHook",
    "name": "handleToggleHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleToggleHook(\n\t\thookId: string,\n\t\tenabled: boolean\n\t): Promise<void> {\n\t\tawait this.hookManager.updateHook(hookId, { enabled });\n\t\t// Hook list is automatically synced via onHooksChanged event\n\t}",
    "start_line": 374,
    "end_line": 380,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId",
      "enabled"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleToggleHook",
    "component_id": "src.providers.hook-view-provider.handleToggleHook"
  },
  "src.providers.hook-view-provider.sendExecutionLogs": {
    "id": "src.providers.hook-view-provider.sendExecutionLogs",
    "name": "sendExecutionLogs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async sendExecutionLogs(hookId?: string): Promise<void> {\n\t\tconst logs = hookId\n\t\t\t? this.hookExecutor.getExecutionLogsForHook(hookId)\n\t\t\t: this.hookExecutor.getExecutionLogs();\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.logs\",\n\t\t\ttype: \"hooks/logs\",\n\t\t\tdata: { logs },\n\t\t} as ExecutionLogsMessage);\n\t}",
    "start_line": 382,
    "end_line": 391,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method sendExecutionLogs",
    "component_id": "src.providers.hook-view-provider.sendExecutionLogs"
  },
  "src.providers.hook-view-provider.sendError": {
    "id": "src.providers.hook-view-provider.sendError",
    "name": "sendError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async sendError(error: Error): Promise<void> {\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[HookViewProvider] Webview error: ${error.message}`\n\t\t);\n\n\t\t// Extract validation errors if this is a HookValidationError\n\t\tconst validationErrors =\n\t\t\t(error as any).errors &&\n\t\t\tArray.isArray((error as any).errors) &&\n\t\t\t(error as any).errors.length > 0\n\t\t\t\t? (error as any).errors\n\t\t\t\t: undefined;\n\n\t\tif (validationErrors) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Validation errors: ${JSON.stringify(validationErrors)}`\n\t\t\t);\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.error\",\n\t\t\ttype: \"hooks/error\",\n\t\t\tdata: {\n\t\t\t\tmessage: error.message,\n\t\t\t\tcode: (error as any).code,\n\t\t\t\tvalidationErrors,\n\t\t\t},\n\t\t} as ErrorMessage);\n\t}",
    "start_line": 393,
    "end_line": 421,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "error"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method sendError",
    "component_id": "src.providers.hook-view-provider.sendError"
  },
  "src.providers.hook-view-provider.handleMCPDiscovery": {
    "id": "src.providers.hook-view-provider.handleMCPDiscovery",
    "name": "handleMCPDiscovery",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleMCPDiscovery(forceRefresh: boolean): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] MCP discovery requested (forceRefresh: ${forceRefresh})`\n\t\t\t);\n\n\t\t\tconst servers =\n\t\t\t\tawait this.mcpDiscoveryService.discoverServers(forceRefresh);\n\n\t\t\tawait this.sendMessageToWebview({\n\t\t\t\tcommand: \"hooks.mcp-servers\",\n\t\t\t\ttype: \"hooks/mcp-servers\",\n\t\t\t\tdata: { servers },\n\t\t\t} as MCPServersMessage);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Sent ${servers.length} MCP servers to webview`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] MCP discovery error: ${(error as Error).message}`\n\t\t\t);\n\n\t\t\tawait this.sendMessageToWebview({\n\t\t\t\tcommand: \"hooks.mcp-error\",\n\t\t\t\ttype: \"hooks/mcp-error\",\n\t\t\t\tdata: {\n\t\t\t\t\tmessage: (error as Error).message || \"Failed to discover MCP servers\",\n\t\t\t\t},\n\t\t\t} as MCPErrorMessage);\n\t\t}\n\t}",
    "start_line": 423,
    "end_line": 454,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "forceRefresh"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleMCPDiscovery",
    "component_id": "src.providers.hook-view-provider.handleMCPDiscovery"
  },
  "src.providers.hook-view-provider.handleAgentListRequest": {
    "id": "src.providers.hook-view-provider.handleAgentListRequest",
    "name": "handleAgentListRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async handleAgentListRequest(forceRefresh: boolean): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Agent list requested (forceRefresh: ${forceRefresh})`\n\t\t\t);\n\n\t\t\tconst { promises: fs } = await import(\"node:fs\");\n\t\t\tconst { join } = await import(\"node:path\");\n\t\t\tconst matter = (await import(\"gray-matter\")).default;\n\t\t\tconst { workspace } = await import(\"vscode\");\n\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0]?.uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Workspace root: ${workspaceRoot}`\n\t\t\t);\n\n\t\t\tconst agentsDir = join(workspaceRoot, \".github\", \"agents\");\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Looking for agents in: ${agentsDir}`\n\t\t\t);\n\n\t\t\tconst files = await fs.readdir(agentsDir).catch((err) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[HookViewProvider] Error reading directory: ${err.message}`\n\t\t\t\t);\n\t\t\t\treturn [];\n\t\t\t});\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Found ${files.length} files in directory`\n\t\t\t);\n\n\t\t\tconst agentFiles = files.filter(\n\t\t\t\t(file) => file.endsWith(\".agent.md\") && !file.startsWith(\".\")\n\t\t\t);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Filtered to ${agentFiles.length} .agent.md files`\n\t\t\t);\n\n\t\t\tconst agents = await Promise.all(\n\t\t\t\tagentFiles.map(async (filename) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst filePath = join(agentsDir, filename);\n\t\t\t\t\t\tconst content = await fs.readFile(filePath, \"utf-8\");\n\t\t\t\t\t\tconst parsed = matter(content);\n\t\t\t\t\t\t// Extract agent ID from frontmatter, fallback to filename\n\t\t\t\t\t\tconst agentId =\n\t\t\t\t\t\t\ttypeof parsed.data.id === \"string\"\n\t\t\t\t\t\t\t\t? parsed.data.id\n\t\t\t\t\t\t\t\t: filename.replace(\".agent.md\", \"\");\n\t\t\t\t\t\tconst name = filename.replace(\".agent.md\", \"\");\n\t\t\t\t\t\tconst description =\n\t\t\t\t\t\t\ttypeof parsed.data.description === \"string\"\n\t\t\t\t\t\t\t\t? parsed.data.description\n\t\t\t\t\t\t\t\t: \"No description available\";\n\t\t\t\t\t\t// Use 'local:' prefix to match AgentRegistry convention (AGENT_ID_PREFIX.FILE = \"local\")\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: `local:${agentId}`,\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tdisplayName: name,\n\t\t\t\t\t\t\tdescription,\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t`[HookViewProvider] Failed to parse ${filename}: ${(error as Error).message}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tconst validAgents = agents.filter(\n\t\t\t\t(a): a is NonNullable<typeof a> => a !== null\n\t\t\t);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Sending ${validAgents.length} agents to webview`\n\t\t\t);\n\n\t\t\t// Send directly to webview if available, bypassing ready check\n\t\t\t// This is needed because AgentDropdown mounts before hooks.ready is sent\n\t\t\tconst message: AgentListMessage = {\n\t\t\t\tcommand: \"hooks.agents-list\",\n\t\t\t\ttype: \"hooks/agents-list\",\n\t\t\t\tdata: { local: validAgents, background: [] },\n\t\t\t};\n\n\t\t\tif (this.webview) {\n\t\t\t\tawait this.webview.postMessage(message);\n\t\t\t} else {\n\t\t\t\t// If webview doesn't exist yet, queue it\n\t\t\t\tthis.pendingMessages.push(message);\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Sent ${validAgents.length} agents from .github/agents/ to webview`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Agent list error: ${(error as Error).message}`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[HookViewProvider] Stack: ${(error as Error).stack}`\n\t\t\t);\n\n\t\t\t// Send error directly to webview if available\n\t\t\tconst errorMessage: AgentErrorMessage = {\n\t\t\t\tcommand: \"hooks.agents-error\",\n\t\t\t\ttype: \"hooks/agents-error\",\n\t\t\t\tdata: {\n\t\t\t\t\tmessage: (error as Error).message || \"Failed to load agents\",\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (this.webview) {\n\t\t\t\tawait this.webview.postMessage(errorMessage);\n\t\t\t} else {\n\t\t\t\tthis.pendingMessages.push(errorMessage);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 456,
    "end_line": 581,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "forceRefresh"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method handleAgentListRequest",
    "component_id": "src.providers.hook-view-provider.handleAgentListRequest"
  },
  "src.providers.hook-view-provider.handleExecutionStatus": {
    "id": "src.providers.hook-view-provider.handleExecutionStatus",
    "name": "handleExecutionStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private handleExecutionStatus(payload: HookExecutionStatusPayload): void {\n\t\tif (!this.webview) {\n\t\t\tthis.executionStatusCache.set(payload.hookId, payload);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.webview.postMessage({\n\t\t\tcommand: \"hooks.execution-status\",\n\t\t\ttype: \"hooks/execution-status\",\n\t\t\tdata: payload,\n\t\t} as ExecutionStatusMessage);\n\t}",
    "start_line": 583,
    "end_line": 594,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleExecutionStatus",
    "component_id": "src.providers.hook-view-provider.handleExecutionStatus"
  },
  "src.providers.hook-view-provider.flushExecutionStatuses": {
    "id": "src.providers.hook-view-provider.flushExecutionStatuses",
    "name": "flushExecutionStatuses",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private flushExecutionStatuses(): void {\n\t\tif (!this.webview) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const payload of this.executionStatusCache.values()) {\n\t\t\tthis.webview.postMessage({\n\t\t\t\tcommand: \"hooks.execution-status\",\n\t\t\t\ttype: \"hooks/execution-status\",\n\t\t\t\tdata: payload,\n\t\t\t} as ExecutionStatusMessage);\n\t\t}\n\t}",
    "start_line": 596,
    "end_line": 608,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flushExecutionStatuses",
    "component_id": "src.providers.hook-view-provider.flushExecutionStatuses"
  },
  "src.providers.hook-view-provider.flushPendingMessages": {
    "id": "src.providers.hook-view-provider.flushPendingMessages",
    "name": "flushPendingMessages",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private flushPendingMessages(): void {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (this.pendingMessages.length > 0) {\n\t\t\tconst message = this.pendingMessages.shift();\n\t\t\tif (message) {\n\t\t\t\tthis.webview.postMessage(message);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 610,
    "end_line": 621,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flushPendingMessages",
    "component_id": "src.providers.hook-view-provider.flushPendingMessages"
  },
  "src.providers.hook-view-provider.sendMessageToWebview": {
    "id": "src.providers.hook-view-provider.sendMessageToWebview",
    "name": "sendMessageToWebview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private async sendMessageToWebview(message: ExtensionMessage): Promise<void> {\n\t\tif (!(this.webview && this.isWebviewReady)) {\n\t\t\tthis.pendingMessages.push(message);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.webview.postMessage(message);\n\t}",
    "start_line": 623,
    "end_line": 630,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method sendMessageToWebview",
    "component_id": "src.providers.hook-view-provider.sendMessageToWebview"
  },
  "src.providers.hook-view-provider.showCreateHookForm": {
    "id": "src.providers.hook-view-provider.showCreateHookForm",
    "name": "showCreateHookForm",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "async showCreateHookForm(): Promise<void> {\n\t\tconst panelExisted = !!this.panel;\n\t\tawait this.ensurePanel();\n\n\t\t// Only sync if panel was just created (webview needs initial data)\n\t\t// If panel already existed, avoid sync to prevent race condition\n\t\tif (!panelExisted) {\n\t\t\tawait this.syncHooksToWebview();\n\t\t\t// Wait for webview to be fully ready after panel creation\n\t\t\tif (!this.isWebviewReady) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.show-form\",\n\t\t\ttype: \"hooks/show-form\",\n\t\t\tdata: { mode: \"create\" },\n\t\t} as ShowFormMessage);\n\t}",
    "start_line": 632,
    "end_line": 651,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method showCreateHookForm",
    "component_id": "src.providers.hook-view-provider.showCreateHookForm"
  },
  "src.providers.hook-view-provider.showEditHookForm": {
    "id": "src.providers.hook-view-provider.showEditHookForm",
    "name": "showEditHookForm",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "async showEditHookForm(hook: Hook): Promise<void> {\n\t\tconst panelExisted = !!this.panel;\n\t\tawait this.ensurePanel();\n\n\t\t// Only sync if panel was just created (webview needs initial data)\n\t\t// If panel already existed, avoid sync to prevent race condition\n\t\tif (!panelExisted) {\n\t\t\tawait this.syncHooksToWebview();\n\t\t\t// Wait for webview to be fully ready after panel creation\n\t\t\tif (!this.isWebviewReady) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.show-form\",\n\t\t\ttype: \"hooks/show-form\",\n\t\t\tdata: { mode: \"edit\", hook },\n\t\t} as ShowFormMessage);\n\t}",
    "start_line": 653,
    "end_line": 672,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method showEditHookForm",
    "component_id": "src.providers.hook-view-provider.showEditHookForm"
  },
  "src.providers.hook-view-provider.showLogsPanel": {
    "id": "src.providers.hook-view-provider.showLogsPanel",
    "name": "showLogsPanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "async showLogsPanel(hookId?: string): Promise<void> {\n\t\tconst panelExisted = !!this.panel;\n\t\tawait this.ensurePanel();\n\n\t\t// Only sync if panel was just created (webview needs initial data)\n\t\t// If panel already existed, avoid sync to prevent race condition\n\t\tif (!panelExisted) {\n\t\t\tawait this.syncHooksToWebview();\n\t\t\t// Wait for webview to be fully ready after panel creation\n\t\t\tif (!this.isWebviewReady) {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendMessageToWebview({\n\t\t\tcommand: \"hooks.show-logs\",\n\t\t\ttype: \"hooks/show-logs\",\n\t\t\tdata: { visible: true, hookId },\n\t\t} as ShowLogsPanelMessage);\n\t}",
    "start_line": 674,
    "end_line": 693,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method showLogsPanel",
    "component_id": "src.providers.hook-view-provider.showLogsPanel"
  },
  "src.providers.hook-view-provider.ensurePanel": {
    "id": "src.providers.hook-view-provider.ensurePanel",
    "name": "ensurePanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private ensurePanel(): void {\n\t\tif (this.panel) {\n\t\t\tthis.panel.reveal(ViewColumn.Active, false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst panel = window.createWebviewPanel(\n\t\t\tHookViewProvider.panelType,\n\t\t\t\"Hooks\",\n\t\t\t{\n\t\t\t\tviewColumn: ViewColumn.Active,\n\t\t\t\tpreserveFocus: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tretainContextWhenHidden: true,\n\t\t\t\tlocalResourceRoots: [this.context.extensionUri],\n\t\t\t}\n\t\t);\n\n\t\tthis.isWebviewReady = false;\n\t\tpanel.webview.html = this.getHtmlForWebview(panel.webview);\n\t\tpanel.webview.onDidReceiveMessage(\n\t\t\t(message) => this.handleWebviewMessage(message),\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\t\tpanel.onDidDispose(\n\t\t\t() => {\n\t\t\t\tthis.panel = undefined;\n\t\t\t\tthis.isWebviewReady = false;\n\t\t\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Panel disposed\");\n\t\t\t},\n\t\t\tundefined,\n\t\t\tthis.disposables\n\t\t);\n\n\t\tthis.panel = panel;\n\t\tthis.flushPendingMessages();\n\t\tthis.flushExecutionStatuses();\n\t\tthis.outputChannel.appendLine(\"[HookViewProvider] Panel created\");\n\t}",
    "start_line": 695,
    "end_line": 736,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method ensurePanel",
    "component_id": "src.providers.hook-view-provider.ensurePanel"
  },
  "src.providers.hook-view-provider.getHtmlForWebview": {
    "id": "src.providers.hook-view-provider.getHtmlForWebview",
    "name": "getHtmlForWebview",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hook-view-provider.ts",
    "relative_path": "src/providers/hook-view-provider.ts",
    "depends_on": [],
    "source_code": "private getHtmlForWebview(webview: Webview): string {\n\t\treturn getWebviewContent(webview, this.context.extensionUri, \"hooks\");\n\t}",
    "start_line": 738,
    "end_line": 740,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webview"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getHtmlForWebview",
    "component_id": "src.providers.hook-view-provider.getHtmlForWebview"
  },
  "src.providers.hooks-explorer-provider.test.createHooksFixture": {
    "id": "src.providers.hooks-explorer-provider.test.createHooksFixture",
    "name": "createHooksFixture",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.test.ts",
    "relative_path": "src/providers/hooks-explorer-provider.test.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "function createHooksFixture(): Hook[] {\n\treturn [\n\t\t{\n\t\t\tid: \"1\",\n\t\t\tname: \"Validate Plan\",\n\t\t\tenabled: true,\n\t\t\ttrigger: { agent: \"speckit\", operation: \"plan\", timing: \"after\" },\n\t\t\taction: { type: \"agent\", parameters: { command: \"/speckit.checklist\" } },\n\t\t\tcreatedAt: 1,\n\t\t\tmodifiedAt: 1,\n\t\t\texecutionCount: 0,\n\t\t},\n\t\t{\n\t\t\tid: \"2\",\n\t\t\tname: \"Auto Clarify\",\n\t\t\tenabled: true,\n\t\t\ttrigger: { agent: \"speckit\", operation: \"specify\", timing: \"after\" },\n\t\t\taction: { type: \"agent\", parameters: { command: \"/speckit.clarify\" } },\n\t\t\tcreatedAt: 2,\n\t\t\tmodifiedAt: 2,\n\t\t\texecutionCount: 0,\n\t\t},\n\t\t{\n\t\t\tid: \"3\",\n\t\t\tname: \"Push draft branch\",\n\t\t\tenabled: false,\n\t\t\ttrigger: { agent: \"openspec\", operation: \"plan\", timing: \"after\" },\n\t\t\taction: {\n\t\t\t\ttype: \"git\",\n\t\t\t\tparameters: { operation: \"push\", messageTemplate: \"{feature}\" },\n\t\t\t},\n\t\t\tcreatedAt: 3,\n\t\t\tmodifiedAt: 3,\n\t\t\texecutionCount: 0,\n\t\t},\n\t];\n}",
    "start_line": 78,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createHooksFixture",
    "component_id": "src.providers.hooks-explorer-provider.test.createHooksFixture"
  },
  "src.providers.hooks-explorer-provider.HookGroupDefinition": {
    "id": "src.providers.hooks-explorer-provider.HookGroupDefinition",
    "name": "HookGroupDefinition",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.ActionType"
    ],
    "source_code": "interface HookGroupDefinition {\n\ttype: ActionType;\n\tlabel: string;\n\tdescription: string;\n\ticon: ThemeIcon;\n}",
    "start_line": 21,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookGroupDefinition",
    "component_id": "src.providers.hooks-explorer-provider.HookGroupDefinition"
  },
  "src.providers.hooks-explorer-provider.TreeEventPayload": {
    "id": "src.providers.hooks-explorer-provider.TreeEventPayload",
    "name": "TreeEventPayload",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "type TreeEventPayload = HookTreeItem | undefined | null | void;",
    "start_line": 61,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TreeEventPayload",
    "component_id": "src.providers.hooks-explorer-provider.TreeEventPayload"
  },
  "src.providers.hooks-explorer-provider.HooksExplorerProvider": {
    "id": "src.providers.hooks-explorer-provider.HooksExplorerProvider",
    "name": "HooksExplorerProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [
      "src.features.hooks.hook-manager.HookManager",
      "src.providers.hooks-explorer-provider.HookTreeItem",
      "src.providers.steering-explorer-provider.refresh",
      "src.services.agent-service.dispose",
      "src.providers.hooks-explorer-provider.createGroup",
      "src.providers.hooks-explorer-provider.createEmptyState",
      "src.providers.hooks-explorer-provider.createGroupPlaceholder",
      "ui.src.features.hooks-view.types.Hook",
      "src.providers.hooks-explorer-provider.refresh",
      "src.providers.hooks-explorer-provider.TreeEventPayload",
      "src.providers.quick-access-explorer-provider.createGroup",
      "src.providers.hooks-explorer-provider.fromHook",
      "src.providers.hooks-explorer-provider.dispose",
      "src.features.hooks.hook-manager.getAllHooks"
    ],
    "source_code": "class HooksExplorerProvider implements TreeDataProvider<HookTreeItem> {\n\tstatic readonly viewId = \"gatomia.views.hooksExplorer\";\n\n\tprivate readonly changeEmitter = new EventEmitter<TreeEventPayload>();\n\treadonly onDidChangeTreeData: Event<TreeEventPayload> =\n\t\tthis.changeEmitter.event;\n\n\tprivate readonly hookManager: HookManager;\n\tprivate hooks: Hook[] = [];\n\tprivate readonly disposables: Array<{ dispose(): void }> = [];\n\n\tconstructor(hookManager: HookManager) {\n\t\tthis.hookManager = hookManager;\n\t}\n\n\tinitialize(): void {\n\t\tthis.hooks = this.hookManager.getAllHooks();\n\t\tthis.disposables.push(\n\t\t\tthis.hookManager.onHooksChanged(() => {\n\t\t\t\tthis.hooks = this.hookManager.getAllHooks();\n\t\t\t\tthis.refresh();\n\t\t\t})\n\t\t);\n\t}\n\n\tdispose(): void {\n\t\tthis.changeEmitter.dispose();\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}\n\n\trefresh(): void {\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tgetTreeItem(element: HookTreeItem): TreeItem {\n\t\treturn element;\n\t}\n\n\tgetChildren(element?: HookTreeItem): HookTreeItem[] {\n\t\tif (!element) {\n\t\t\tif (this.hooks.length === 0) {\n\t\t\t\treturn HookTreeItem.createEmptyState();\n\t\t\t}\n\t\t\treturn GROUPS.map((group) =>\n\t\t\t\tHookTreeItem.createGroup(\n\t\t\t\t\tgroup,\n\t\t\t\t\tthis.hooks.filter((hook) => hook.action.type === group.type).length\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"hook-group\" && element.groupType) {\n\t\t\tconst hooks = this.hooks\n\t\t\t\t.filter((hook) => hook.action.type === element.groupType)\n\t\t\t\t.sort((a, b) => a.name.localeCompare(b.name));\n\n\t\t\tif (hooks.length === 0) {\n\t\t\t\treturn [HookTreeItem.createGroupPlaceholder(element.groupType)];\n\t\t\t}\n\n\t\t\treturn hooks.map((hook) => HookTreeItem.fromHook(hook));\n\t\t}\n\n\t\treturn [];\n\t}\n}",
    "start_line": 63,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HooksExplorerProvider",
    "component_id": "src.providers.hooks-explorer-provider.HooksExplorerProvider"
  },
  "src.providers.hooks-explorer-provider.initialize": {
    "id": "src.providers.hooks-explorer-provider.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "initialize(): void {\n\t\tthis.hooks = this.hookManager.getAllHooks();\n\t\tthis.disposables.push(\n\t\t\tthis.hookManager.onHooksChanged(() => {\n\t\t\t\tthis.hooks = this.hookManager.getAllHooks();\n\t\t\t\tthis.refresh();\n\t\t\t})\n\t\t);\n\t}",
    "start_line": 78,
    "end_line": 86,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initialize",
    "component_id": "src.providers.hooks-explorer-provider.initialize"
  },
  "src.providers.hooks-explorer-provider.dispose": {
    "id": "src.providers.hooks-explorer-provider.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.changeEmitter.dispose();\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}",
    "start_line": 88,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.providers.hooks-explorer-provider.dispose"
  },
  "src.providers.hooks-explorer-provider.refresh": {
    "id": "src.providers.hooks-explorer-provider.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "refresh(): void {\n\t\tthis.changeEmitter.fire();\n\t}",
    "start_line": 95,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method refresh",
    "component_id": "src.providers.hooks-explorer-provider.refresh"
  },
  "src.providers.hooks-explorer-provider.getTreeItem": {
    "id": "src.providers.hooks-explorer-provider.getTreeItem",
    "name": "getTreeItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getTreeItem(element: HookTreeItem): TreeItem {\n\t\treturn element;\n\t}",
    "start_line": 99,
    "end_line": 101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTreeItem",
    "component_id": "src.providers.hooks-explorer-provider.getTreeItem"
  },
  "src.providers.hooks-explorer-provider.getChildren": {
    "id": "src.providers.hooks-explorer-provider.getChildren",
    "name": "getChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getChildren(element?: HookTreeItem): HookTreeItem[] {\n\t\tif (!element) {\n\t\t\tif (this.hooks.length === 0) {\n\t\t\t\treturn HookTreeItem.createEmptyState();\n\t\t\t}\n\t\t\treturn GROUPS.map((group) =>\n\t\t\t\tHookTreeItem.createGroup(\n\t\t\t\t\tgroup,\n\t\t\t\t\tthis.hooks.filter((hook) => hook.action.type === group.type).length\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"hook-group\" && element.groupType) {\n\t\t\tconst hooks = this.hooks\n\t\t\t\t.filter((hook) => hook.action.type === element.groupType)\n\t\t\t\t.sort((a, b) => a.name.localeCompare(b.name));\n\n\t\t\tif (hooks.length === 0) {\n\t\t\t\treturn [HookTreeItem.createGroupPlaceholder(element.groupType)];\n\t\t\t}\n\n\t\t\treturn hooks.map((hook) => HookTreeItem.fromHook(hook));\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 103,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getChildren",
    "component_id": "src.providers.hooks-explorer-provider.getChildren"
  },
  "src.providers.hooks-explorer-provider.HookTreeItem": {
    "id": "src.providers.hooks-explorer-provider.HookTreeItem",
    "name": "HookTreeItem",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [
      "src.providers.hooks-explorer-provider.HookGroupDefinition",
      "ui.src.features.hooks-view.types.ActionType",
      "src.providers.hooks-explorer-provider.HookTreeItem",
      "src.providers.hooks-explorer-provider.describeAction",
      "src.providers.hooks-explorer-provider.createEmptyMessage",
      "src.providers.quick-access-explorer-provider.createAction",
      "src.providers.hooks-explorer-provider.createAction",
      "ui.src.features.hooks-view.types.Hook",
      "src.providers.hooks-explorer-provider.formatDescription",
      "src.providers.hooks-explorer-provider.buildEditCommand",
      "src.providers.hooks-explorer-provider.buildTooltip"
    ],
    "source_code": "class HookTreeItem extends TreeItem {\n\treadonly hookId?: string;\n\treadonly groupType?: ActionType;\n\n\tprivate constructor(\n\t\tlabel: string,\n\t\tcollapsibleState: TreeItemCollapsibleState,\n\t\tcontextValue: string\n\t) {\n\t\tsuper(label, collapsibleState);\n\t\tthis.contextValue = contextValue;\n\t}\n\n\tstatic createEmptyMessage(): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\t\"No hooks configured yet\",\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"hook-empty\"\n\t\t);\n\t\titem.iconPath = new ThemeIcon(\"info\");\n\t\titem.tooltip = \"Use Add Hook to create your first automation.\";\n\t\treturn item;\n\t}\n\n\tstatic createEmptyState(): HookTreeItem[] {\n\t\treturn [\n\t\t\tHookTreeItem.createEmptyMessage(),\n\t\t\tHookTreeItem.createAction(\n\t\t\t\t\"Add Hook\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.hooks.addHook\",\n\t\t\t\t\ttitle: \"Add Hook\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"plus\"),\n\t\t\t\t\"Create a new automation hook.\"\n\t\t\t),\n\t\t\tHookTreeItem.createAction(\n\t\t\t\t\"Import Hooks\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.hooks.import\",\n\t\t\t\t\ttitle: \"Import Hooks\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"cloud-download\"),\n\t\t\t\t\"Import hooks from a JSON export.\"\n\t\t\t),\n\t\t];\n\t}\n\n\tstatic createGroup(\n\t\tdefinition: HookGroupDefinition,\n\t\tcount: number\n\t): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\tdefinition.label,\n\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\"hook-group\"\n\t\t);\n\t\titem.iconPath = definition.icon;\n\t\titem.tooltip = definition.description;\n\t\titem.description = count === 1 ? \"1 hook\" : `${count} hooks`;\n\t\titem.groupType = definition.type;\n\t\treturn item;\n\t}\n\n\tstatic createGroupPlaceholder(groupType: ActionType): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\t\"No hooks configured for this action type\",\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"hook-group-empty\"\n\t\t);\n\t\titem.iconPath = new ThemeIcon(\"circle-slash\");\n\t\titem.tooltip = \"Create a hook to see it in this group.\";\n\t\titem.groupType = groupType;\n\t\treturn item;\n\t}\n\n\tstatic createAction(\n\t\tlabel: string,\n\t\tcommand: Command,\n\t\ticon: ThemeIcon,\n\t\ttooltip?: string\n\t): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"hook-action\"\n\t\t);\n\t\titem.iconPath = icon;\n\t\titem.command = command;\n\t\titem.tooltip = tooltip;\n\t\treturn item;\n\t}\n\n\tstatic fromHook(hook: Hook): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\thook.name,\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\thook.enabled ? \"hook-enabled\" : \"hook-disabled\"\n\t\t);\n\t\titem.hookId = hook.id;\n\t\titem.iconPath = hook.enabled\n\t\t\t? new ThemeIcon(\"play\")\n\t\t\t: new ThemeIcon(\"debug-pause\");\n\t\titem.description = HookTreeItem.formatDescription(hook);\n\t\titem.tooltip = HookTreeItem.buildTooltip(hook);\n\t\titem.command = HookTreeItem.buildEditCommand(hook.id);\n\t\treturn item;\n\t}\n\n\tprivate static buildEditCommand(hookId: string): Command {\n\t\treturn {\n\t\t\tcommand: \"gatomia.hooks.edit\",\n\t\t\ttitle: \"Edit Hook\",\n\t\t\targuments: [hookId],\n\t\t};\n\t}\n\n\tprivate static formatDescription(hook: Hook): string {\n\t\tconst trigger = `${hook.trigger.agent}.${hook.trigger.operation}`;\n\t\tconst actionSummary = HookTreeItem.describeAction(hook);\n\t\tconst status = hook.enabled ? \"Active\" : \"Paused\";\n\t\treturn `${trigger}  ${actionSummary}  ${status}`;\n\t}\n\n\tprivate static describeAction(hook: Hook): string {\n\t\tswitch (hook.action.type) {\n\t\t\tcase \"agent\": {\n\t\t\t\tconst params = hook.action.parameters as AgentActionParams;\n\t\t\t\treturn params.command;\n\t\t\t}\n\t\t\tcase \"git\": {\n\t\t\t\tconst params = hook.action.parameters as GitActionParams;\n\t\t\t\treturn params.operation === \"commit\" ? \"Git Commit\" : \"Git Push\";\n\t\t\t}\n\t\t\tcase \"github\": {\n\t\t\t\tconst params = hook.action.parameters as GitHubActionParams;\n\t\t\t\treturn `GitHub ${params.operation}`;\n\t\t\t}\n\t\t\tcase \"custom\": {\n\t\t\t\tconst params = hook.action.parameters as CustomActionParams;\n\t\t\t\treturn params.agentName\n\t\t\t\t\t? `Custom: ${params.agentName}`\n\t\t\t\t\t: \"Custom Agent\";\n\t\t\t}\n\t\t\tcase \"mcp\": {\n\t\t\t\tconst params = hook.action.parameters as MCPActionParams;\n\t\t\t\tconst toolCount = params.selectedTools?.length || 0;\n\t\t\t\treturn toolCount > 0 ? `MCP Tools (${toolCount})` : \"MCP Action\";\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn \"Action\";\n\t\t}\n\t}\n\n\tprivate static buildTooltip(hook: Hook): string {\n\t\tconst parts = [\n\t\t\t`Trigger: ${hook.trigger.agent}.${hook.trigger.operation}`,\n\t\t\t`Action: ${HookTreeItem.describeAction(hook)}`,\n\t\t];\n\t\tif (hook.action.type === \"git\") {\n\t\t\tconst params = hook.action.parameters as GitActionParams;\n\t\t\tif (params.operation === \"commit\") {\n\t\t\t\tparts.push(`Message template: ${params.messageTemplate}`);\n\t\t\t}\n\t\t}\n\t\tif (hook.action.type === \"github\") {\n\t\t\tconst params = hook.action.parameters as GitHubActionParams;\n\t\t\tparts.push(`Repository: ${params.repository}`);\n\t\t}\n\t\tparts.push(`Status: ${hook.enabled ? \"Active\" : \"Paused\"}`);\n\t\treturn parts.join(\"\\n\");\n\t}\n}",
    "start_line": 132,
    "end_line": 304,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class HookTreeItem",
    "component_id": "src.providers.hooks-explorer-provider.HookTreeItem"
  },
  "src.providers.hooks-explorer-provider.createEmptyMessage": {
    "id": "src.providers.hooks-explorer-provider.createEmptyMessage",
    "name": "createEmptyMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createEmptyMessage(): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\t\"No hooks configured yet\",\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"hook-empty\"\n\t\t);\n\t\titem.iconPath = new ThemeIcon(\"info\");\n\t\titem.tooltip = \"Use Add Hook to create your first automation.\";\n\t\treturn item;\n\t}",
    "start_line": 145,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createEmptyMessage",
    "component_id": "src.providers.hooks-explorer-provider.createEmptyMessage"
  },
  "src.providers.hooks-explorer-provider.createEmptyState": {
    "id": "src.providers.hooks-explorer-provider.createEmptyState",
    "name": "createEmptyState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createEmptyState(): HookTreeItem[] {\n\t\treturn [\n\t\t\tHookTreeItem.createEmptyMessage(),\n\t\t\tHookTreeItem.createAction(\n\t\t\t\t\"Add Hook\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.hooks.addHook\",\n\t\t\t\t\ttitle: \"Add Hook\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"plus\"),\n\t\t\t\t\"Create a new automation hook.\"\n\t\t\t),\n\t\t\tHookTreeItem.createAction(\n\t\t\t\t\"Import Hooks\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.hooks.import\",\n\t\t\t\t\ttitle: \"Import Hooks\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"cloud-download\"),\n\t\t\t\t\"Import hooks from a JSON export.\"\n\t\t\t),\n\t\t];\n\t}",
    "start_line": 156,
    "end_line": 178,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createEmptyState",
    "component_id": "src.providers.hooks-explorer-provider.createEmptyState"
  },
  "src.providers.hooks-explorer-provider.createGroup": {
    "id": "src.providers.hooks-explorer-provider.createGroup",
    "name": "createGroup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createGroup(\n\t\tdefinition: HookGroupDefinition,\n\t\tcount: number\n\t): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\tdefinition.label,\n\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\"hook-group\"\n\t\t);\n\t\titem.iconPath = definition.icon;\n\t\titem.tooltip = definition.description;\n\t\titem.description = count === 1 ? \"1 hook\" : `${count} hooks`;\n\t\titem.groupType = definition.type;\n\t\treturn item;\n\t}",
    "start_line": 180,
    "end_line": 194,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "definition",
      "count"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createGroup",
    "component_id": "src.providers.hooks-explorer-provider.createGroup"
  },
  "src.providers.hooks-explorer-provider.createGroupPlaceholder": {
    "id": "src.providers.hooks-explorer-provider.createGroupPlaceholder",
    "name": "createGroupPlaceholder",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createGroupPlaceholder(groupType: ActionType): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\t\"No hooks configured for this action type\",\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"hook-group-empty\"\n\t\t);\n\t\titem.iconPath = new ThemeIcon(\"circle-slash\");\n\t\titem.tooltip = \"Create a hook to see it in this group.\";\n\t\titem.groupType = groupType;\n\t\treturn item;\n\t}",
    "start_line": 196,
    "end_line": 206,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "groupType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createGroupPlaceholder",
    "component_id": "src.providers.hooks-explorer-provider.createGroupPlaceholder"
  },
  "src.providers.hooks-explorer-provider.createAction": {
    "id": "src.providers.hooks-explorer-provider.createAction",
    "name": "createAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createAction(\n\t\tlabel: string,\n\t\tcommand: Command,\n\t\ticon: ThemeIcon,\n\t\ttooltip?: string\n\t): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"hook-action\"\n\t\t);\n\t\titem.iconPath = icon;\n\t\titem.command = command;\n\t\titem.tooltip = tooltip;\n\t\treturn item;\n\t}",
    "start_line": 208,
    "end_line": 223,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "label",
      "command",
      "icon",
      "tooltip"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createAction",
    "component_id": "src.providers.hooks-explorer-provider.createAction"
  },
  "src.providers.hooks-explorer-provider.fromHook": {
    "id": "src.providers.hooks-explorer-provider.fromHook",
    "name": "fromHook",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static fromHook(hook: Hook): HookTreeItem {\n\t\tconst item = new HookTreeItem(\n\t\t\thook.name,\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\thook.enabled ? \"hook-enabled\" : \"hook-disabled\"\n\t\t);\n\t\titem.hookId = hook.id;\n\t\titem.iconPath = hook.enabled\n\t\t\t? new ThemeIcon(\"play\")\n\t\t\t: new ThemeIcon(\"debug-pause\");\n\t\titem.description = HookTreeItem.formatDescription(hook);\n\t\titem.tooltip = HookTreeItem.buildTooltip(hook);\n\t\titem.command = HookTreeItem.buildEditCommand(hook.id);\n\t\treturn item;\n\t}",
    "start_line": 225,
    "end_line": 239,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method fromHook",
    "component_id": "src.providers.hooks-explorer-provider.fromHook"
  },
  "src.providers.hooks-explorer-provider.buildEditCommand": {
    "id": "src.providers.hooks-explorer-provider.buildEditCommand",
    "name": "buildEditCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private static buildEditCommand(hookId: string): Command {\n\t\treturn {\n\t\t\tcommand: \"gatomia.hooks.edit\",\n\t\t\ttitle: \"Edit Hook\",\n\t\t\targuments: [hookId],\n\t\t};\n\t}",
    "start_line": 241,
    "end_line": 247,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hookId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method buildEditCommand",
    "component_id": "src.providers.hooks-explorer-provider.buildEditCommand"
  },
  "src.providers.hooks-explorer-provider.formatDescription": {
    "id": "src.providers.hooks-explorer-provider.formatDescription",
    "name": "formatDescription",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private static formatDescription(hook: Hook): string {\n\t\tconst trigger = `${hook.trigger.agent}.${hook.trigger.operation}`;\n\t\tconst actionSummary = HookTreeItem.describeAction(hook);\n\t\tconst status = hook.enabled ? \"Active\" : \"Paused\";\n\t\treturn `${trigger}  ${actionSummary}  ${status}`;\n\t}",
    "start_line": 249,
    "end_line": 254,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method formatDescription",
    "component_id": "src.providers.hooks-explorer-provider.formatDescription"
  },
  "src.providers.hooks-explorer-provider.describeAction": {
    "id": "src.providers.hooks-explorer-provider.describeAction",
    "name": "describeAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private static describeAction(hook: Hook): string {\n\t\tswitch (hook.action.type) {\n\t\t\tcase \"agent\": {\n\t\t\t\tconst params = hook.action.parameters as AgentActionParams;\n\t\t\t\treturn params.command;\n\t\t\t}\n\t\t\tcase \"git\": {\n\t\t\t\tconst params = hook.action.parameters as GitActionParams;\n\t\t\t\treturn params.operation === \"commit\" ? \"Git Commit\" : \"Git Push\";\n\t\t\t}\n\t\t\tcase \"github\": {\n\t\t\t\tconst params = hook.action.parameters as GitHubActionParams;\n\t\t\t\treturn `GitHub ${params.operation}`;\n\t\t\t}\n\t\t\tcase \"custom\": {\n\t\t\t\tconst params = hook.action.parameters as CustomActionParams;\n\t\t\t\treturn params.agentName\n\t\t\t\t\t? `Custom: ${params.agentName}`\n\t\t\t\t\t: \"Custom Agent\";\n\t\t\t}\n\t\t\tcase \"mcp\": {\n\t\t\t\tconst params = hook.action.parameters as MCPActionParams;\n\t\t\t\tconst toolCount = params.selectedTools?.length || 0;\n\t\t\t\treturn toolCount > 0 ? `MCP Tools (${toolCount})` : \"MCP Action\";\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn \"Action\";\n\t\t}\n\t}",
    "start_line": 256,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method describeAction",
    "component_id": "src.providers.hooks-explorer-provider.describeAction"
  },
  "src.providers.hooks-explorer-provider.buildTooltip": {
    "id": "src.providers.hooks-explorer-provider.buildTooltip",
    "name": "buildTooltip",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/hooks-explorer-provider.ts",
    "relative_path": "src/providers/hooks-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private static buildTooltip(hook: Hook): string {\n\t\tconst parts = [\n\t\t\t`Trigger: ${hook.trigger.agent}.${hook.trigger.operation}`,\n\t\t\t`Action: ${HookTreeItem.describeAction(hook)}`,\n\t\t];\n\t\tif (hook.action.type === \"git\") {\n\t\t\tconst params = hook.action.parameters as GitActionParams;\n\t\t\tif (params.operation === \"commit\") {\n\t\t\t\tparts.push(`Message template: ${params.messageTemplate}`);\n\t\t\t}\n\t\t}\n\t\tif (hook.action.type === \"github\") {\n\t\t\tconst params = hook.action.parameters as GitHubActionParams;\n\t\t\tparts.push(`Repository: ${params.repository}`);\n\t\t}\n\t\tparts.push(`Status: ${hook.enabled ? \"Active\" : \"Paused\"}`);\n\t\treturn parts.join(\"\\n\");\n\t}",
    "start_line": 286,
    "end_line": 303,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "hook"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method buildTooltip",
    "component_id": "src.providers.hooks-explorer-provider.buildTooltip"
  },
  "src.providers.interactive-view-provider.InteractiveViewProvider": {
    "id": "src.providers.interactive-view-provider.InteractiveViewProvider",
    "name": "InteractiveViewProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/interactive-view-provider.ts",
    "relative_path": "src/providers/interactive-view-provider.ts",
    "depends_on": [
      "src.providers.hook-view-provider.webview",
      "src.panels.welcome-screen-panel.postMessage",
      "src.utils.get-webview-content.getWebviewContent"
    ],
    "source_code": "class InteractiveViewProvider implements WebviewViewProvider {\n\tstatic readonly viewId = \"gatomia.interactiveView\";\n\n\tprivate _view?: WebviewView;\n\tprivate readonly _extensionUri: Uri;\n\n\tconstructor(extensionUri: Uri) {\n\t\tthis._extensionUri = extensionUri;\n\t}\n\n\tresolveWebviewView(\n\t\twebviewView: WebviewView,\n\t\tcontext: WebviewViewResolveContext,\n\t\t_token: CancellationToken\n\t) {\n\t\tthis._view = webviewView;\n\n\t\twebviewView.webview.options = {\n\t\t\tenableScripts: true,\n\t\t\tlocalResourceRoots: [this._extensionUri],\n\t\t};\n\n\t\twebviewView.webview.html = getWebviewContent(\n\t\t\twebviewView.webview,\n\t\t\tthis._extensionUri,\n\t\t\t\"interactive\"\n\t\t);\n\n\t\twebviewView.webview.onDidReceiveMessage((message) => {\n\t\t\tswitch (message.command) {\n\t\t\t\tcase \"interactive-view.sendMessage\": {\n\t\t\t\t\tconst reversedText = message.text.split(\"\").reverse().join(\"\");\n\t\t\t\t\tthis._view?.webview.postMessage({\n\t\t\t\t\t\tcommand: \"interactive-view.showMessage\",\n\t\t\t\t\t\ttext: `Reversed text: ${reversedText}`,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\t}\n}",
    "start_line": 10,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class InteractiveViewProvider",
    "component_id": "src.providers.interactive-view-provider.InteractiveViewProvider"
  },
  "src.providers.interactive-view-provider.resolveWebviewView": {
    "id": "src.providers.interactive-view-provider.resolveWebviewView",
    "name": "resolveWebviewView",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/interactive-view-provider.ts",
    "relative_path": "src/providers/interactive-view-provider.ts",
    "depends_on": [],
    "source_code": "resolveWebviewView(\n\t\twebviewView: WebviewView,\n\t\tcontext: WebviewViewResolveContext,\n\t\t_token: CancellationToken\n\t) {\n\t\tthis._view = webviewView;\n\n\t\twebviewView.webview.options = {\n\t\t\tenableScripts: true,\n\t\t\tlocalResourceRoots: [this._extensionUri],\n\t\t};\n\n\t\twebviewView.webview.html = getWebviewContent(\n\t\t\twebviewView.webview,\n\t\t\tthis._extensionUri,\n\t\t\t\"interactive\"\n\t\t);\n\n\t\twebviewView.webview.onDidReceiveMessage((message) => {\n\t\t\tswitch (message.command) {\n\t\t\t\tcase \"interactive-view.sendMessage\": {\n\t\t\t\t\tconst reversedText = message.text.split(\"\").reverse().join(\"\");\n\t\t\t\t\tthis._view?.webview.postMessage({\n\t\t\t\t\t\tcommand: \"interactive-view.showMessage\",\n\t\t\t\t\t\ttext: `Reversed text: ${reversedText}`,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\t}",
    "start_line": 20,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webviewView",
      "context",
      "_token"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveWebviewView",
    "component_id": "src.providers.interactive-view-provider.resolveWebviewView"
  },
  "src.providers.overview-provider.OverviewProvider": {
    "id": "src.providers.overview-provider.OverviewProvider",
    "name": "OverviewProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/overview-provider.ts",
    "relative_path": "src/providers/overview-provider.ts",
    "depends_on": [
      "src.providers.overview-provider.OverviewItem"
    ],
    "source_code": "class OverviewProvider implements TreeDataProvider<OverviewItem> {\n\tprivate readonly _onDidChangeTreeData: EventEmitter<\n\t\tOverviewItem | undefined | null | void\n\t> = new EventEmitter<OverviewItem | undefined | null | void>();\n\treadonly onDidChangeTreeData: Event<OverviewItem | undefined | null | void> =\n\t\tthis._onDidChangeTreeData.event;\n\tprivate readonly context: ExtensionContext;\n\n\tconstructor(context: ExtensionContext) {\n\t\tthis.context = context;\n\t}\n\n\trefresh(): void {\n\t\tthis._onDidChangeTreeData.fire();\n\t}\n\n\tgetTreeItem(element: OverviewItem): TreeItem {\n\t\treturn element;\n\t}\n\n\t// biome-ignore lint/suspicious/useAwait: ignore\n\tasync getChildren(element?: OverviewItem): Promise<OverviewItem[]> {\n\t\tif (!element) {\n\t\t\t// Return empty array to show viewsWelcome content\n\t\t\treturn [];\n\t\t}\n\t\treturn [];\n\t}\n}",
    "start_line": 10,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class OverviewProvider",
    "component_id": "src.providers.overview-provider.OverviewProvider"
  },
  "src.providers.overview-provider.refresh": {
    "id": "src.providers.overview-provider.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/overview-provider.ts",
    "relative_path": "src/providers/overview-provider.ts",
    "depends_on": [],
    "source_code": "refresh(): void {\n\t\tthis._onDidChangeTreeData.fire();\n\t}",
    "start_line": 22,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method refresh",
    "component_id": "src.providers.overview-provider.refresh"
  },
  "src.providers.overview-provider.getTreeItem": {
    "id": "src.providers.overview-provider.getTreeItem",
    "name": "getTreeItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/overview-provider.ts",
    "relative_path": "src/providers/overview-provider.ts",
    "depends_on": [],
    "source_code": "getTreeItem(element: OverviewItem): TreeItem {\n\t\treturn element;\n\t}",
    "start_line": 26,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTreeItem",
    "component_id": "src.providers.overview-provider.getTreeItem"
  },
  "src.providers.overview-provider.getChildren": {
    "id": "src.providers.overview-provider.getChildren",
    "name": "getChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/overview-provider.ts",
    "relative_path": "src/providers/overview-provider.ts",
    "depends_on": [],
    "source_code": "async getChildren(element?: OverviewItem): Promise<OverviewItem[]> {\n\t\tif (!element) {\n\t\t\t// Return empty array to show viewsWelcome content\n\t\t\treturn [];\n\t\t}\n\t\treturn [];\n\t}",
    "start_line": 31,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getChildren",
    "component_id": "src.providers.overview-provider.getChildren"
  },
  "src.providers.overview-provider.OverviewItem": {
    "id": "src.providers.overview-provider.OverviewItem",
    "name": "OverviewItem",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/overview-provider.ts",
    "relative_path": "src/providers/overview-provider.ts",
    "depends_on": [],
    "source_code": "class OverviewItem extends TreeItem {\n\t// biome-ignore lint/complexity/noUselessConstructor: ignore\n\tconstructor(label: string, collapsibleState: TreeItemCollapsibleState) {\n\t\tsuper(label, collapsibleState);\n\t}\n}",
    "start_line": 40,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class OverviewItem",
    "component_id": "src.providers.overview-provider.OverviewItem"
  },
  "src.providers.quick-access-explorer-provider.QuickAccessGroupDefinition": {
    "id": "src.providers.quick-access-explorer-provider.QuickAccessGroupDefinition",
    "name": "QuickAccessGroupDefinition",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "interface QuickAccessGroupDefinition {\n\tid: string;\n\tlabel: string;\n\tdescription: string;\n\ticon: ThemeIcon;\n}",
    "start_line": 13,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface QuickAccessGroupDefinition",
    "component_id": "src.providers.quick-access-explorer-provider.QuickAccessGroupDefinition"
  },
  "src.providers.quick-access-explorer-provider.TreeEventPayload": {
    "id": "src.providers.quick-access-explorer-provider.TreeEventPayload",
    "name": "TreeEventPayload",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "type TreeEventPayload = QuickAccessTreeItem | undefined | null | void;",
    "start_line": 41,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TreeEventPayload",
    "component_id": "src.providers.quick-access-explorer-provider.TreeEventPayload"
  },
  "src.providers.quick-access-explorer-provider.QuickAccessExplorerProvider": {
    "id": "src.providers.quick-access-explorer-provider.QuickAccessExplorerProvider",
    "name": "QuickAccessExplorerProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [
      "src.providers.quick-access-explorer-provider.formatSpecSystemLabel",
      "src.utils.config-manager.getSettings",
      "src.providers.quick-access-explorer-provider.getSpecSystemItems",
      "src.providers.quick-access-explorer-provider.getConfigurationItems",
      "src.providers.quick-access-explorer-provider.TreeEventPayload",
      "src.providers.quick-access-explorer-provider.createAction",
      "src.providers.quick-access-explorer-provider.dispose",
      "src.services.agent-service.dispose",
      "src.providers.quick-access-explorer-provider.QuickAccessTreeItem",
      "src.utils.spec-kit-adapter.getInstance",
      "src.providers.quick-access-explorer-provider.createGroup",
      "src.utils.config-manager.ConfigManager",
      "src.providers.quick-access-explorer-provider.getGroupChildren",
      "src.providers.quick-access-explorer-provider.getResourceItems"
    ],
    "source_code": "class QuickAccessExplorerProvider\n\timplements TreeDataProvider<QuickAccessTreeItem>\n{\n\tstatic readonly viewId = \"gatomia.views.overview\";\n\n\tprivate readonly changeEmitter = new EventEmitter<TreeEventPayload>();\n\treadonly onDidChangeTreeData: Event<TreeEventPayload> =\n\t\tthis.changeEmitter.event;\n\n\tprivate readonly configManager: ConfigManager;\n\n\tconstructor() {\n\t\tthis.configManager = ConfigManager.getInstance();\n\t}\n\n\tdispose(): void {\n\t\tthis.changeEmitter.dispose();\n\t}\n\n\trefresh(): void {\n\t\tthis.changeEmitter.fire();\n\t}\n\n\tgetTreeItem(element: QuickAccessTreeItem): TreeItem {\n\t\treturn element;\n\t}\n\n\tgetChildren(element?: QuickAccessTreeItem): QuickAccessTreeItem[] {\n\t\tif (!element) {\n\t\t\treturn GROUPS.map((group) => QuickAccessTreeItem.createGroup(group));\n\t\t}\n\n\t\tif (element.contextValue === \"quick-access-group\") {\n\t\t\treturn this.getGroupChildren(element.groupId);\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate getGroupChildren(groupId: string | undefined): QuickAccessTreeItem[] {\n\t\tif (groupId === \"spec-system\") {\n\t\t\treturn this.getSpecSystemItems();\n\t\t}\n\n\t\tif (groupId === \"configuration\") {\n\t\t\treturn this.getConfigurationItems();\n\t\t}\n\n\t\tif (groupId === \"resources\") {\n\t\t\treturn this.getResourceItems();\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate getSpecSystemItems(): QuickAccessTreeItem[] {\n\t\tconst currentSystem = this.configManager.getSettings().specSystem;\n\t\tconst systemLabel = this.formatSpecSystemLabel(currentSystem);\n\n\t\treturn [\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Select Spec Agent\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.settings.selectSpecSystem\",\n\t\t\t\t\ttitle: \"Select Spec Agent\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"settings-gear\"),\n\t\t\t\t`Current: ${systemLabel}. Click to change the active spec system.`\n\t\t\t),\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Install Dependencies\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.dependencies.check\",\n\t\t\t\t\ttitle: \"Install Dependencies\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"desktop-download\"),\n\t\t\t\t\"Check and install required dependencies for SpecKit and OpenSpec.\"\n\t\t\t),\n\t\t];\n\t}\n\n\tprivate getConfigurationItems(): QuickAccessTreeItem[] {\n\t\treturn [\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Open Settings\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.settings.open\",\n\t\t\t\t\ttitle: \"Open Settings\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"gear\"),\n\t\t\t\t\"Open GatomIA extension settings.\"\n\t\t\t),\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Open MCP Config\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.settings.openGlobalConfig\",\n\t\t\t\t\ttitle: \"Open MCP Config\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"mcp\"),\n\t\t\t\t\"Open the MCP configuration file (mcp.json).\"\n\t\t\t),\n\t\t];\n\t}\n\n\tprivate getResourceItems(): QuickAccessTreeItem[] {\n\t\treturn [\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Help\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.help.open\",\n\t\t\t\t\ttitle: \"Help\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"question\"),\n\t\t\t\t\"Open GatomIA documentation and help.\"\n\t\t\t),\n\t\t];\n\t}\n\n\tprivate formatSpecSystemLabel(system: string): string {\n\t\tif (system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn \"SpecKit\";\n\t\t}\n\t\tif (system === SPEC_SYSTEM_MODE.OPENSPEC) {\n\t\t\treturn \"OpenSpec\";\n\t\t}\n\t\treturn \"Auto-detect\";\n\t}\n}",
    "start_line": 43,
    "end_line": 170,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class QuickAccessExplorerProvider",
    "component_id": "src.providers.quick-access-explorer-provider.QuickAccessExplorerProvider"
  },
  "src.providers.quick-access-explorer-provider.dispose": {
    "id": "src.providers.quick-access-explorer-provider.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.changeEmitter.dispose();\n\t}",
    "start_line": 58,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.providers.quick-access-explorer-provider.dispose"
  },
  "src.providers.quick-access-explorer-provider.refresh": {
    "id": "src.providers.quick-access-explorer-provider.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "refresh(): void {\n\t\tthis.changeEmitter.fire();\n\t}",
    "start_line": 62,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method refresh",
    "component_id": "src.providers.quick-access-explorer-provider.refresh"
  },
  "src.providers.quick-access-explorer-provider.getTreeItem": {
    "id": "src.providers.quick-access-explorer-provider.getTreeItem",
    "name": "getTreeItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getTreeItem(element: QuickAccessTreeItem): TreeItem {\n\t\treturn element;\n\t}",
    "start_line": 66,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTreeItem",
    "component_id": "src.providers.quick-access-explorer-provider.getTreeItem"
  },
  "src.providers.quick-access-explorer-provider.getChildren": {
    "id": "src.providers.quick-access-explorer-provider.getChildren",
    "name": "getChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getChildren(element?: QuickAccessTreeItem): QuickAccessTreeItem[] {\n\t\tif (!element) {\n\t\t\treturn GROUPS.map((group) => QuickAccessTreeItem.createGroup(group));\n\t\t}\n\n\t\tif (element.contextValue === \"quick-access-group\") {\n\t\t\treturn this.getGroupChildren(element.groupId);\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 70,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getChildren",
    "component_id": "src.providers.quick-access-explorer-provider.getChildren"
  },
  "src.providers.quick-access-explorer-provider.getGroupChildren": {
    "id": "src.providers.quick-access-explorer-provider.getGroupChildren",
    "name": "getGroupChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getGroupChildren(groupId: string | undefined): QuickAccessTreeItem[] {\n\t\tif (groupId === \"spec-system\") {\n\t\t\treturn this.getSpecSystemItems();\n\t\t}\n\n\t\tif (groupId === \"configuration\") {\n\t\t\treturn this.getConfigurationItems();\n\t\t}\n\n\t\tif (groupId === \"resources\") {\n\t\t\treturn this.getResourceItems();\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 82,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "groupId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getGroupChildren",
    "component_id": "src.providers.quick-access-explorer-provider.getGroupChildren"
  },
  "src.providers.quick-access-explorer-provider.getSpecSystemItems": {
    "id": "src.providers.quick-access-explorer-provider.getSpecSystemItems",
    "name": "getSpecSystemItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getSpecSystemItems(): QuickAccessTreeItem[] {\n\t\tconst currentSystem = this.configManager.getSettings().specSystem;\n\t\tconst systemLabel = this.formatSpecSystemLabel(currentSystem);\n\n\t\treturn [\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Select Spec Agent\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.settings.selectSpecSystem\",\n\t\t\t\t\ttitle: \"Select Spec Agent\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"settings-gear\"),\n\t\t\t\t`Current: ${systemLabel}. Click to change the active spec system.`\n\t\t\t),\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Install Dependencies\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.dependencies.check\",\n\t\t\t\t\ttitle: \"Install Dependencies\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"desktop-download\"),\n\t\t\t\t\"Check and install required dependencies for SpecKit and OpenSpec.\"\n\t\t\t),\n\t\t];\n\t}",
    "start_line": 98,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecSystemItems",
    "component_id": "src.providers.quick-access-explorer-provider.getSpecSystemItems"
  },
  "src.providers.quick-access-explorer-provider.getConfigurationItems": {
    "id": "src.providers.quick-access-explorer-provider.getConfigurationItems",
    "name": "getConfigurationItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getConfigurationItems(): QuickAccessTreeItem[] {\n\t\treturn [\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Open Settings\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.settings.open\",\n\t\t\t\t\ttitle: \"Open Settings\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"gear\"),\n\t\t\t\t\"Open GatomIA extension settings.\"\n\t\t\t),\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Open MCP Config\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.settings.openGlobalConfig\",\n\t\t\t\t\ttitle: \"Open MCP Config\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"mcp\"),\n\t\t\t\t\"Open the MCP configuration file (mcp.json).\"\n\t\t\t),\n\t\t];\n\t}",
    "start_line": 124,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getConfigurationItems",
    "component_id": "src.providers.quick-access-explorer-provider.getConfigurationItems"
  },
  "src.providers.quick-access-explorer-provider.getResourceItems": {
    "id": "src.providers.quick-access-explorer-provider.getResourceItems",
    "name": "getResourceItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getResourceItems(): QuickAccessTreeItem[] {\n\t\treturn [\n\t\t\tQuickAccessTreeItem.createAction(\n\t\t\t\t\"Help\",\n\t\t\t\t{\n\t\t\t\t\tcommand: \"gatomia.help.open\",\n\t\t\t\t\ttitle: \"Help\",\n\t\t\t\t},\n\t\t\t\tnew ThemeIcon(\"question\"),\n\t\t\t\t\"Open GatomIA documentation and help.\"\n\t\t\t),\n\t\t];\n\t}",
    "start_line": 147,
    "end_line": 159,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getResourceItems",
    "component_id": "src.providers.quick-access-explorer-provider.getResourceItems"
  },
  "src.providers.quick-access-explorer-provider.formatSpecSystemLabel": {
    "id": "src.providers.quick-access-explorer-provider.formatSpecSystemLabel",
    "name": "formatSpecSystemLabel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private formatSpecSystemLabel(system: string): string {\n\t\tif (system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn \"SpecKit\";\n\t\t}\n\t\tif (system === SPEC_SYSTEM_MODE.OPENSPEC) {\n\t\t\treturn \"OpenSpec\";\n\t\t}\n\t\treturn \"Auto-detect\";\n\t}",
    "start_line": 161,
    "end_line": 169,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "system"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method formatSpecSystemLabel",
    "component_id": "src.providers.quick-access-explorer-provider.formatSpecSystemLabel"
  },
  "src.providers.quick-access-explorer-provider.QuickAccessTreeItem": {
    "id": "src.providers.quick-access-explorer-provider.QuickAccessTreeItem",
    "name": "QuickAccessTreeItem",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [
      "src.providers.quick-access-explorer-provider.QuickAccessGroupDefinition",
      "src.providers.quick-access-explorer-provider.QuickAccessTreeItem"
    ],
    "source_code": "class QuickAccessTreeItem extends TreeItem {\n\treadonly groupId?: string;\n\n\tprivate constructor(\n\t\tlabel: string,\n\t\tcollapsibleState: TreeItemCollapsibleState,\n\t\tcontextValue: string\n\t) {\n\t\tsuper(label, collapsibleState);\n\t\tthis.contextValue = contextValue;\n\t}\n\n\tstatic createGroup(\n\t\tdefinition: QuickAccessGroupDefinition\n\t): QuickAccessTreeItem {\n\t\tconst item = new QuickAccessTreeItem(\n\t\t\tdefinition.label,\n\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\"quick-access-group\"\n\t\t);\n\t\titem.iconPath = definition.icon;\n\t\titem.tooltip = definition.description;\n\t\titem.groupId = definition.id;\n\t\treturn item;\n\t}\n\n\tstatic createAction(\n\t\tlabel: string,\n\t\tcommand: Command,\n\t\ticon: ThemeIcon,\n\t\ttooltip?: string\n\t): QuickAccessTreeItem {\n\t\tconst item = new QuickAccessTreeItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"quick-access-action\"\n\t\t);\n\t\titem.iconPath = icon;\n\t\titem.command = command;\n\t\titem.tooltip = tooltip;\n\t\treturn item;\n\t}\n}",
    "start_line": 172,
    "end_line": 214,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class QuickAccessTreeItem",
    "component_id": "src.providers.quick-access-explorer-provider.QuickAccessTreeItem"
  },
  "src.providers.quick-access-explorer-provider.createGroup": {
    "id": "src.providers.quick-access-explorer-provider.createGroup",
    "name": "createGroup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createGroup(\n\t\tdefinition: QuickAccessGroupDefinition\n\t): QuickAccessTreeItem {\n\t\tconst item = new QuickAccessTreeItem(\n\t\t\tdefinition.label,\n\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\"quick-access-group\"\n\t\t);\n\t\titem.iconPath = definition.icon;\n\t\titem.tooltip = definition.description;\n\t\titem.groupId = definition.id;\n\t\treturn item;\n\t}",
    "start_line": 184,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "definition"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createGroup",
    "component_id": "src.providers.quick-access-explorer-provider.createGroup"
  },
  "src.providers.quick-access-explorer-provider.createAction": {
    "id": "src.providers.quick-access-explorer-provider.createAction",
    "name": "createAction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/quick-access-explorer-provider.ts",
    "relative_path": "src/providers/quick-access-explorer-provider.ts",
    "depends_on": [],
    "source_code": "static createAction(\n\t\tlabel: string,\n\t\tcommand: Command,\n\t\ticon: ThemeIcon,\n\t\ttooltip?: string\n\t): QuickAccessTreeItem {\n\t\tconst item = new QuickAccessTreeItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\"quick-access-action\"\n\t\t);\n\t\titem.iconPath = icon;\n\t\titem.command = command;\n\t\titem.tooltip = tooltip;\n\t\treturn item;\n\t}",
    "start_line": 198,
    "end_line": 213,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "label",
      "command",
      "icon",
      "tooltip"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method createAction",
    "component_id": "src.providers.quick-access-explorer-provider.createAction"
  },
  "src.providers.simple-view-provider.SimpleViewProvider": {
    "id": "src.providers.simple-view-provider.SimpleViewProvider",
    "name": "SimpleViewProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/simple-view-provider.ts",
    "relative_path": "src/providers/simple-view-provider.ts",
    "depends_on": [
      "src.providers.hook-view-provider.webview",
      "src.utils.get-webview-content.getWebviewContent"
    ],
    "source_code": "class SimpleViewProvider implements WebviewViewProvider {\n\tstatic readonly viewId = \"gatomia.simpleView\";\n\n\tprivate _view?: WebviewView;\n\tprivate readonly _extensionUri: Uri;\n\n\tconstructor(extensionUri: Uri) {\n\t\tthis._extensionUri = extensionUri;\n\t}\n\n\tresolveWebviewView(\n\t\twebviewView: WebviewView,\n\t\tcontext: WebviewViewResolveContext,\n\t\t_token: CancellationToken\n\t) {\n\t\tthis._view = webviewView;\n\n\t\twebviewView.webview.options = {\n\t\t\tenableScripts: true,\n\t\t\tlocalResourceRoots: [this._extensionUri],\n\t\t};\n\n\t\twebviewView.webview.html = getWebviewContent(\n\t\t\twebviewView.webview,\n\t\t\tthis._extensionUri,\n\t\t\t\"simple\"\n\t\t);\n\t}\n}",
    "start_line": 10,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SimpleViewProvider",
    "component_id": "src.providers.simple-view-provider.SimpleViewProvider"
  },
  "src.providers.simple-view-provider.resolveWebviewView": {
    "id": "src.providers.simple-view-provider.resolveWebviewView",
    "name": "resolveWebviewView",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/simple-view-provider.ts",
    "relative_path": "src/providers/simple-view-provider.ts",
    "depends_on": [],
    "source_code": "resolveWebviewView(\n\t\twebviewView: WebviewView,\n\t\tcontext: WebviewViewResolveContext,\n\t\t_token: CancellationToken\n\t) {\n\t\tthis._view = webviewView;\n\n\t\twebviewView.webview.options = {\n\t\t\tenableScripts: true,\n\t\t\tlocalResourceRoots: [this._extensionUri],\n\t\t};\n\n\t\twebviewView.webview.html = getWebviewContent(\n\t\t\twebviewView.webview,\n\t\t\tthis._extensionUri,\n\t\t\t\"simple\"\n\t\t);\n\t}",
    "start_line": 20,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webviewView",
      "context",
      "_token"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveWebviewView",
    "component_id": "src.providers.simple-view-provider.resolveWebviewView"
  },
  "src.providers.spec-explorer-provider.SpecExplorerProvider": {
    "id": "src.providers.spec-explorer-provider.SpecExplorerProvider",
    "name": "SpecExplorerProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [
      "src.features.spec.review-flow.state.getSpecState",
      "src.providers.spec-explorer-provider.SpecItem",
      "src.providers.spec-explorer-provider.createReviewSpecItem",
      "src.features.spec.spec-manager.getActiveChangeRequests",
      "src.utils.checklist-parser.getChecklistStatusFromFile",
      "ui.src.services.spec-explorer.Specification",
      "src.utils.spec-kit-adapter.getSpecFiles",
      "src.features.spec.spec-manager.SpecManager",
      "src.constants.SpecSystemMode",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter",
      "src.providers.spec-explorer-provider.createSpecItem",
      "src.utils.task-parser.TaskStatus",
      "src.providers.steering-explorer-provider.refresh",
      "src.utils.task-parser.calculateGroupStatus",
      "src.providers.spec-explorer-provider.createArchivedSpecItem",
      "src.utils.task-parser.parseTasksFromFile",
      "src.features.spec.spec-manager.getChangeSpecs",
      "src.features.spec.spec-manager.getAllSpecsUnified",
      "src.providers.spec-explorer-provider.getReviewExitTooltip",
      "src.utils.task-parser.calculateOverallStatus",
      "src.providers.spec-explorer-provider.describeReviewSpec",
      "src.providers.spec-explorer-provider.refresh",
      "src.providers.spec-explorer-provider.calculateChecklistsFolderStatus"
    ],
    "source_code": "class SpecExplorerProvider implements TreeDataProvider<SpecItem> {\n\tstatic readonly viewId = \"gatomia.views.specExplorer\";\n\tstatic readonly navigateRequirementsCommandId =\n\t\t\"gatomia.spec.navigate.requirements\";\n\tstatic readonly navigateDesignCommandId = \"gatomia.spec.navigate.design\";\n\tstatic readonly navigateTasksCommandId = \"gatomia.spec.navigate.tasks\";\n\tstatic readonly openSpecCommandId = \"gatomia.spec.open\";\n\n\tprivate readonly _onDidChangeTreeData: EventEmitter<\n\t\tSpecItem | undefined | null | void\n\t> = new EventEmitter<SpecItem | undefined | null | void>();\n\treadonly onDidChangeTreeData: Event<SpecItem | undefined | null | void> =\n\t\tthis._onDidChangeTreeData.event;\n\n\tprivate specManager!: SpecManager;\n\tprivate readonly context: ExtensionContext;\n\n\tconstructor(context: ExtensionContext) {\n\t\tthis.context = context;\n\t\t// Listen for review flow state changes (e.g. status updates, change requests)\n\t\t// and refresh the tree view to reflect the new state.\n\t\tcontext.subscriptions.push(\n\t\t\tonReviewFlowStateChange(() => {\n\t\t\t\tthis.refresh();\n\t\t\t})\n\t\t);\n\t}\n\n\tprivate createSpecItem(\n\t\tlabel: string,\n\t\tspecId: string,\n\t\tsystem?: SpecSystemMode\n\t): SpecItem {\n\t\tconst item = new SpecItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\"spec-current\",\n\t\t\tthis.context,\n\t\t\tspecId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tsystem\n\t\t);\n\t\tconst state = getSpecState(specId);\n\t\tif (state) {\n\t\t\tconst reviewExitTooltip = this.getReviewExitTooltip(state);\n\t\t\tif (reviewExitTooltip) {\n\t\t\t\titem.tooltip = reviewExitTooltip;\n\t\t\t}\n\t\t}\n\t\treturn item;\n\t}\n\n\tprivate createReviewSpecItem(\n\t\tlabel: string,\n\t\tspecId: string,\n\t\tsystem?: SpecSystemMode\n\t): SpecItem {\n\t\tconst item = new SpecItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\"spec-review\",\n\t\t\tthis.context,\n\t\t\tspecId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tsystem\n\t\t);\n\t\tconst state = getSpecState(specId);\n\t\tif (state) {\n\t\t\titem.description = this.describeReviewSpec(state);\n\t\t} else {\n\t\t\titem.description = \"Awaiting review metadata\";\n\t\t}\n\t\treturn item;\n\t}\n\n\tprivate createArchivedSpecItem(\n\t\tlabel: string,\n\t\tspecId: string,\n\t\tsystem?: SpecSystemMode\n\t): SpecItem {\n\t\tconst item = new SpecItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\"spec-archived\",\n\t\t\tthis.context,\n\t\t\tspecId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tsystem\n\t\t);\n\t\tconst state = getSpecState(specId);\n\t\tif (state?.archivedAt) {\n\t\t\titem.description = `Archived ${state.archivedAt.toLocaleDateString()}`;\n\t\t} else {\n\t\t\titem.description = \"Archived\";\n\t\t}\n\t\treturn item;\n\t}\n\n\tprivate describeReviewSpec(state: Specification): string {\n\t\tconst pendingTasks = state.pendingTasks ?? 0;\n\t\tconst pendingChecklistItems = state.pendingChecklistItems ?? 0;\n\t\tconst openChangeRequests =\n\t\t\tstate.changeRequests?.filter((cr) => cr.status !== \"addressed\").length ??\n\t\t\t0;\n\t\tconst parts: string[] = [];\n\t\tif (pendingTasks > 0) {\n\t\t\tparts.push(`${pendingTasks} task${pendingTasks === 1 ? \"\" : \"s\"}`);\n\t\t}\n\t\tif (pendingChecklistItems > 0) {\n\t\t\tparts.push(\n\t\t\t\t`${pendingChecklistItems} checklist item${pendingChecklistItems === 1 ? \"\" : \"s\"}`\n\t\t\t);\n\t\t}\n\t\tif (openChangeRequests > 0) {\n\t\t\tparts.push(\n\t\t\t\t`${openChangeRequests} change request${openChangeRequests === 1 ? \"\" : \"s\"}`\n\t\t\t);\n\t\t}\n\t\treturn parts.length > 0 ? parts.join(\" | \") : \"Ready for reviewers\";\n\t}\n\n\tprivate getReviewExitTooltip(state: Specification): string | null {\n\t\tif (!(state.status === \"current\" || state.status === \"reopened\")) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!state.reviewEnteredAt) {\n\t\t\treturn null;\n\t\t}\n\t\tconst pendingTasks = state.pendingTasks ?? 0;\n\t\tconst pendingChecklistItems = state.pendingChecklistItems ?? 0;\n\t\tif (pendingTasks === 0 && pendingChecklistItems === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst parts: string[] = [];\n\t\tif (pendingTasks > 0) {\n\t\t\tparts.push(`${pendingTasks} task${pendingTasks === 1 ? \"\" : \"s\"}`);\n\t\t}\n\t\tif (pendingChecklistItems > 0) {\n\t\t\tparts.push(\n\t\t\t\t`${pendingChecklistItems} checklist item${pendingChecklistItems === 1 ? \"\" : \"s\"}`\n\t\t\t);\n\t\t}\n\t\treturn `Returned from Review: ${parts.join(\" | \")}`;\n\t}\n\n\tsetSpecManager(specManager: SpecManager) {\n\t\tthis.specManager = specManager;\n\t}\n\n\trefresh(): void {\n\t\tthis._onDidChangeTreeData.fire();\n\t}\n\n\tgetTreeItem(element: SpecItem): TreeItem {\n\t\treturn element;\n\t}\n\n\t/**\n\t * Calculate aggregate status for all checklists in a folder\n\t */\n\tprivate async calculateChecklistsFolderStatus(\n\t\tfolderPath: string\n\t): Promise<TaskStatus> {\n\t\ttry {\n\t\t\tconst { readdirSync, statSync } = await import(\"node:fs\");\n\t\t\tconst entries = readdirSync(folderPath);\n\n\t\t\tlet totalItems = 0;\n\t\t\tlet completedItems = 0;\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tif (entry.endsWith(\".md\")) {\n\t\t\t\t\tconst filePath = join(folderPath, entry);\n\t\t\t\t\tconst stat = statSync(filePath);\n\n\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\tconst status = getChecklistStatusFromFile(filePath);\n\t\t\t\t\t\ttotalItems += status.total;\n\t\t\t\t\t\tcompletedItems += status.completed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totalItems === 0) {\n\t\t\t\treturn \"not-started\";\n\t\t\t}\n\n\t\t\tif (completedItems === totalItems) {\n\t\t\t\treturn \"completed\";\n\t\t\t}\n\n\t\t\tif (completedItems > 0) {\n\t\t\t\treturn \"in-progress\";\n\t\t\t}\n\n\t\t\treturn \"not-started\";\n\t\t} catch {\n\t\t\treturn \"not-started\";\n\t\t}\n\t}\n\n\t// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Tree provider maps multiple node types without a simpler branching model.\n\tasync getChildren(element?: SpecItem): Promise<SpecItem[]> {\n\t\tif (!(workspace.workspaceFolders && this.specManager)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (!element) {\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Current Specs\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-current-specs\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Review\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-review-specs\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Archived\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-archived-specs\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Changes\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-changes\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\tconst unifiedSpecs = await this.specManager.getAllSpecsUnified();\n\n\t\tif (element.contextValue === \"group-current-specs\") {\n\t\t\treturn unifiedSpecs\n\t\t\t\t.filter((spec) => {\n\t\t\t\t\tconst state = getSpecState(spec.id);\n\t\t\t\t\treturn (\n\t\t\t\t\t\t!state || state.status === \"current\" || state.status === \"reopened\"\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.map((spec) => this.createSpecItem(spec.name, spec.id, spec.system));\n\t\t}\n\n\t\tif (element.contextValue === \"group-review-specs\") {\n\t\t\treturn unifiedSpecs\n\t\t\t\t.filter((spec) => getSpecState(spec.id)?.status === \"review\")\n\t\t\t\t.map((spec) =>\n\t\t\t\t\tthis.createReviewSpecItem(spec.name, spec.id, spec.system)\n\t\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"group-archived-specs\") {\n\t\t\treturn unifiedSpecs\n\t\t\t\t.filter((spec) => getSpecState(spec.id)?.status === \"archived\")\n\t\t\t\t.map((spec) =>\n\t\t\t\t\tthis.createArchivedSpecItem(spec.name, spec.id, spec.system)\n\t\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"group-changes\") {\n\t\t\tconst activeChangeRequests =\n\t\t\t\tawait this.specManager.getActiveChangeRequests();\n\t\t\treturn activeChangeRequests.map(\n\t\t\t\t({ specId, specTitle, changeRequest }) => {\n\t\t\t\t\tconst item = new SpecItem(\n\t\t\t\t\t\tchangeRequest.title,\n\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\"change-request\",\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tspecId,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tchangeRequest.id\n\t\t\t\t\t);\n\t\t\t\t\t// Pass the change request and spec title for enhanced display\n\t\t\t\t\titem.changeRequest = changeRequest;\n\t\t\t\t\titem.specTitle = specTitle;\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\telement.contextValue === \"spec\" ||\n\t\t\telement.contextValue === \"spec-current\" ||\n\t\t\telement.contextValue === \"spec-review\" ||\n\t\t\telement.contextValue === \"spec-archived\"\n\t\t) {\n\t\t\t// Handle SpecKit System\n\t\t\tif (element.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t\tconst adapter = getSpecSystemAdapter();\n\t\t\t\t// Get files for this spec (returns absolute paths)\n\t\t\t\tconst files = adapter.getSpecFiles(element.specName!);\n\n\t\t\t\tconst items: SpecItem[] = [];\n\n\t\t\t\t// Map of filenames to display labels and types\n\t\t\t\tconst fileMap: Record<string, { label: string; type: string }> = {\n\t\t\t\t\t\"spec.md\": { label: \"Spec\", type: \"spec\" },\n\t\t\t\t\t\"plan.md\": { label: \"Plan\", type: \"plan\" },\n\t\t\t\t\t\"design.md\": { label: \"Design\", type: \"design\" },\n\t\t\t\t\t\"requirements.md\": { label: \"Requirements\", type: \"requirements\" },\n\t\t\t\t\t\"research.md\": { label: \"Research\", type: \"research\" },\n\t\t\t\t\t\"data-model.md\": { label: \"Data Model\", type: \"data-model\" },\n\t\t\t\t\t\"quickstart.md\": { label: \"Quickstart\", type: \"quickstart\" },\n\t\t\t\t};\n\n\t\t\t\tfor (const [docType, absolutePath] of Object.entries(files)) {\n\t\t\t\t\tconst fileName = basename(absolutePath);\n\n\t\t\t\t\t// Handle tasks.md as a folder with task items\n\t\t\t\t\tif (fileName === \"tasks.md\") {\n\t\t\t\t\t\tconst relativePath = workspace.asRelativePath(absolutePath);\n\t\t\t\t\t\t// Calculate overall status for tasks folder\n\t\t\t\t\t\tconst taskGroups = parseTasksFromFile(absolutePath);\n\t\t\t\t\t\tconst overallStatus = calculateOverallStatus(taskGroups);\n\t\t\t\t\t\titems.push(\n\t\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\t\t\"Tasks\",\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\t\t\t\"tasks-folder\",\n\t\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\t\t\"tasks\",\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\telement.system,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\toverallStatus\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle checklists folder\n\t\t\t\t\tif (docType === \"checklists\") {\n\t\t\t\t\t\tconst relativePath = workspace.asRelativePath(absolutePath);\n\t\t\t\t\t\t// Calculate overall status for checklists folder\n\t\t\t\t\t\tconst checklistsStatus =\n\t\t\t\t\t\t\tawait this.calculateChecklistsFolderStatus(absolutePath);\n\t\t\t\t\t\titems.push(\n\t\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\t\t\"Checklists\",\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\t\t\t\"checklists-folder\",\n\t\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\t\t\"checklists\",\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\telement.system,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tchecklistsStatus\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst fileInfo = fileMap[fileName] || {\n\t\t\t\t\t\tlabel: fileName,\n\t\t\t\t\t\ttype: \"file\",\n\t\t\t\t\t};\n\n\t\t\t\t\t// Convert absolute path to relative path for the command\n\t\t\t\t\tconst relativePath = workspace.asRelativePath(absolutePath);\n\n\t\t\t\t\titems.push(\n\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\tfileInfo.label,\n\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\"spec-document\",\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\tfileInfo.type,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\t\t\ttitle: `Open ${fileInfo.label}`,\n\t\t\t\t\t\t\t\targuments: [relativePath, fileInfo.type],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trelativePath\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t}\n\n\t\t\t// Handle OpenSpec System\n\t\t\tconst specPath = `openspec/specs/${element.specName}/spec.md`;\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Spec\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"spec\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Spec\",\n\t\t\t\t\t\targuments: [specPath, \"spec\"],\n\t\t\t\t\t},\n\t\t\t\t\tspecPath\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\t// Handle tasks folder - show task groups and tasks\n\t\tif (element.contextValue === \"tasks-folder\") {\n\t\t\tconst tasksFilePath = element.filePath;\n\t\t\tif (!tasksFilePath) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get absolute path\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst absolutePath = join(workspaceRoot, tasksFilePath);\n\t\t\tconst taskGroups = parseTasksFromFile(absolutePath);\n\n\t\t\tif (taskGroups.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Return task groups as collapsible items\n\t\t\treturn taskGroups.map((group) => {\n\t\t\t\tconst groupStatus = calculateGroupStatus(group.tasks);\n\t\t\t\treturn new SpecItem(\n\t\t\t\t\tgroup.name,\n\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\"task-group\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"task-group\",\n\t\t\t\t\tundefined, // No command - clicking only expands/collapses\n\t\t\t\t\ttasksFilePath,\n\t\t\t\t\tgroup.name,\n\t\t\t\t\telement.system,\n\t\t\t\t\tundefined,\n\t\t\t\t\tgroupStatus\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\t// Handle task group - show individual tasks\n\t\tif (element.contextValue === \"task-group\") {\n\t\t\tconst tasksFilePath = element.filePath;\n\t\t\tconst groupName = element.parentName;\n\t\t\tif (!(tasksFilePath && groupName)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get absolute path\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst absolutePath = join(workspaceRoot, tasksFilePath);\n\t\t\tconst taskGroups = parseTasksFromFile(absolutePath);\n\n\t\t\t// Find the matching group\n\t\t\tconst group = taskGroups.find((g) => g.name === groupName);\n\t\t\tif (!group) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Return individual tasks\n\t\t\treturn group.tasks.map(\n\t\t\t\t(task) =>\n\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t`${task.id}: ${task.title}`,\n\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\"task-item\",\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\"task\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\t\ttitle: \"Open Tasks\",\n\t\t\t\t\t\t\targuments: [tasksFilePath, \"tasks\", task.line],\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttasksFilePath,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\telement.system,\n\t\t\t\t\t\ttask\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Handle checklists folder - show individual checklist files\n\t\tif (element.contextValue === \"checklists-folder\") {\n\t\t\tconst checklistsFolderPath = element.filePath;\n\t\t\tif (!checklistsFolderPath) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get absolute path\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst absolutePath = join(workspaceRoot, checklistsFolderPath);\n\n\t\t\ttry {\n\t\t\t\tconst { readdirSync, statSync } = await import(\"node:fs\");\n\t\t\t\tconst entries = readdirSync(absolutePath);\n\t\t\t\tconst checklistItems: SpecItem[] = [];\n\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tif (entry.endsWith(\".md\")) {\n\t\t\t\t\t\tconst filePath = join(absolutePath, entry);\n\t\t\t\t\t\tconst stat = statSync(filePath);\n\n\t\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\t\tconst relativePath = workspace.asRelativePath(filePath);\n\t\t\t\t\t\t\tconst displayName = entry.replace(MARKDOWN_EXTENSION_PATTERN, \"\");\n\t\t\t\t\t\t\tconst formattedName =\n\t\t\t\t\t\t\t\tdisplayName.charAt(0).toUpperCase() +\n\t\t\t\t\t\t\t\tdisplayName.slice(1).replace(/-/g, \" \");\n\n\t\t\t\t\t\t\t// Calculate checklist status for icon\n\t\t\t\t\t\t\tconst checklistStatus = getChecklistStatusFromFile(filePath);\n\n\t\t\t\t\t\t\tchecklistItems.push(\n\t\t\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\t\t\tformattedName,\n\t\t\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\t\t\"checklist-item\",\n\t\t\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\t\t\t\"checklist\",\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\t\t\t\t\ttitle: `Open ${formattedName}`,\n\t\t\t\t\t\t\t\t\t\targuments: [relativePath, \"checklist\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\telement.system,\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tchecklistStatus.status\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn checklistItems;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Error reading checklists folder:\", error);\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\tif (element.contextValue === \"change\") {\n\t\t\tconst basePath = `openspec/changes/${element.specName}`;\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Proposal\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"proposal\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Proposal\",\n\t\t\t\t\t\targuments: [`${basePath}/proposal.md`, \"proposal\"],\n\t\t\t\t\t},\n\t\t\t\t\t`${basePath}/proposal.md`\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Tasks\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"tasks\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Tasks\",\n\t\t\t\t\t\targuments: [`${basePath}/tasks.md`, \"tasks\"],\n\t\t\t\t\t},\n\t\t\t\t\t`${basePath}/tasks.md`\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Design\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"design\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Design\",\n\t\t\t\t\t\targuments: [`${basePath}/design.md`, \"design\"],\n\t\t\t\t\t},\n\t\t\t\t\t`${basePath}/design.md`\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Specs\",\n\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\"change-specs-group\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\tif (element.contextValue === \"change-specs-group\") {\n\t\t\tconst specs = await this.specManager.getChangeSpecs(element.specName!);\n\t\t\treturn specs.map(\n\t\t\t\t(name) =>\n\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\t\"change-spec\",\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\telement.specName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"change-spec\") {\n\t\t\tconst changeName = element.parentName!;\n\t\t\tconst specName = element.specName!;\n\t\t\tconst specPath = `openspec/changes/${changeName}/specs/${specName}/spec.md`;\n\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Spec\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\tspecName,\n\t\t\t\t\t\"spec\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Spec\",\n\t\t\t\t\t\targuments: [specPath, \"spec\"],\n\t\t\t\t\t},\n\t\t\t\t\tspecPath\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\treturn [];\n\t}\n}",
    "start_line": 36,
    "end_line": 711,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecExplorerProvider",
    "component_id": "src.providers.spec-explorer-provider.SpecExplorerProvider"
  },
  "src.providers.spec-explorer-provider.createSpecItem": {
    "id": "src.providers.spec-explorer-provider.createSpecItem",
    "name": "createSpecItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private createSpecItem(\n\t\tlabel: string,\n\t\tspecId: string,\n\t\tsystem?: SpecSystemMode\n\t): SpecItem {\n\t\tconst item = new SpecItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\"spec-current\",\n\t\t\tthis.context,\n\t\t\tspecId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tsystem\n\t\t);\n\t\tconst state = getSpecState(specId);\n\t\tif (state) {\n\t\t\tconst reviewExitTooltip = this.getReviewExitTooltip(state);\n\t\t\tif (reviewExitTooltip) {\n\t\t\t\titem.tooltip = reviewExitTooltip;\n\t\t\t}\n\t\t}\n\t\treturn item;\n\t}",
    "start_line": 64,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "label",
      "specId",
      "system"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createSpecItem",
    "component_id": "src.providers.spec-explorer-provider.createSpecItem"
  },
  "src.providers.spec-explorer-provider.createReviewSpecItem": {
    "id": "src.providers.spec-explorer-provider.createReviewSpecItem",
    "name": "createReviewSpecItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private createReviewSpecItem(\n\t\tlabel: string,\n\t\tspecId: string,\n\t\tsystem?: SpecSystemMode\n\t): SpecItem {\n\t\tconst item = new SpecItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\"spec-review\",\n\t\t\tthis.context,\n\t\t\tspecId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tsystem\n\t\t);\n\t\tconst state = getSpecState(specId);\n\t\tif (state) {\n\t\t\titem.description = this.describeReviewSpec(state);\n\t\t} else {\n\t\t\titem.description = \"Awaiting review metadata\";\n\t\t}\n\t\treturn item;\n\t}",
    "start_line": 91,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "label",
      "specId",
      "system"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createReviewSpecItem",
    "component_id": "src.providers.spec-explorer-provider.createReviewSpecItem"
  },
  "src.providers.spec-explorer-provider.createArchivedSpecItem": {
    "id": "src.providers.spec-explorer-provider.createArchivedSpecItem",
    "name": "createArchivedSpecItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private createArchivedSpecItem(\n\t\tlabel: string,\n\t\tspecId: string,\n\t\tsystem?: SpecSystemMode\n\t): SpecItem {\n\t\tconst item = new SpecItem(\n\t\t\tlabel,\n\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\"spec-archived\",\n\t\t\tthis.context,\n\t\t\tspecId,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tsystem\n\t\t);\n\t\tconst state = getSpecState(specId);\n\t\tif (state?.archivedAt) {\n\t\t\titem.description = `Archived ${state.archivedAt.toLocaleDateString()}`;\n\t\t} else {\n\t\t\titem.description = \"Archived\";\n\t\t}\n\t\treturn item;\n\t}",
    "start_line": 117,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "label",
      "specId",
      "system"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createArchivedSpecItem",
    "component_id": "src.providers.spec-explorer-provider.createArchivedSpecItem"
  },
  "src.providers.spec-explorer-provider.describeReviewSpec": {
    "id": "src.providers.spec-explorer-provider.describeReviewSpec",
    "name": "describeReviewSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private describeReviewSpec(state: Specification): string {\n\t\tconst pendingTasks = state.pendingTasks ?? 0;\n\t\tconst pendingChecklistItems = state.pendingChecklistItems ?? 0;\n\t\tconst openChangeRequests =\n\t\t\tstate.changeRequests?.filter((cr) => cr.status !== \"addressed\").length ??\n\t\t\t0;\n\t\tconst parts: string[] = [];\n\t\tif (pendingTasks > 0) {\n\t\t\tparts.push(`${pendingTasks} task${pendingTasks === 1 ? \"\" : \"s\"}`);\n\t\t}\n\t\tif (pendingChecklistItems > 0) {\n\t\t\tparts.push(\n\t\t\t\t`${pendingChecklistItems} checklist item${pendingChecklistItems === 1 ? \"\" : \"s\"}`\n\t\t\t);\n\t\t}\n\t\tif (openChangeRequests > 0) {\n\t\t\tparts.push(\n\t\t\t\t`${openChangeRequests} change request${openChangeRequests === 1 ? \"\" : \"s\"}`\n\t\t\t);\n\t\t}\n\t\treturn parts.length > 0 ? parts.join(\" | \") : \"Ready for reviewers\";\n\t}",
    "start_line": 143,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method describeReviewSpec",
    "component_id": "src.providers.spec-explorer-provider.describeReviewSpec"
  },
  "src.providers.spec-explorer-provider.getReviewExitTooltip": {
    "id": "src.providers.spec-explorer-provider.getReviewExitTooltip",
    "name": "getReviewExitTooltip",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getReviewExitTooltip(state: Specification): string | null {\n\t\tif (!(state.status === \"current\" || state.status === \"reopened\")) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!state.reviewEnteredAt) {\n\t\t\treturn null;\n\t\t}\n\t\tconst pendingTasks = state.pendingTasks ?? 0;\n\t\tconst pendingChecklistItems = state.pendingChecklistItems ?? 0;\n\t\tif (pendingTasks === 0 && pendingChecklistItems === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst parts: string[] = [];\n\t\tif (pendingTasks > 0) {\n\t\t\tparts.push(`${pendingTasks} task${pendingTasks === 1 ? \"\" : \"s\"}`);\n\t\t}\n\t\tif (pendingChecklistItems > 0) {\n\t\t\tparts.push(\n\t\t\t\t`${pendingChecklistItems} checklist item${pendingChecklistItems === 1 ? \"\" : \"s\"}`\n\t\t\t);\n\t\t}\n\t\treturn `Returned from Review: ${parts.join(\" | \")}`;\n\t}",
    "start_line": 166,
    "end_line": 188,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getReviewExitTooltip",
    "component_id": "src.providers.spec-explorer-provider.getReviewExitTooltip"
  },
  "src.providers.spec-explorer-provider.setSpecManager": {
    "id": "src.providers.spec-explorer-provider.setSpecManager",
    "name": "setSpecManager",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "setSpecManager(specManager: SpecManager) {\n\t\tthis.specManager = specManager;\n\t}",
    "start_line": 190,
    "end_line": 192,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specManager"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setSpecManager",
    "component_id": "src.providers.spec-explorer-provider.setSpecManager"
  },
  "src.providers.spec-explorer-provider.refresh": {
    "id": "src.providers.spec-explorer-provider.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "refresh(): void {\n\t\tthis._onDidChangeTreeData.fire();\n\t}",
    "start_line": 194,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method refresh",
    "component_id": "src.providers.spec-explorer-provider.refresh"
  },
  "src.providers.spec-explorer-provider.getTreeItem": {
    "id": "src.providers.spec-explorer-provider.getTreeItem",
    "name": "getTreeItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getTreeItem(element: SpecItem): TreeItem {\n\t\treturn element;\n\t}",
    "start_line": 198,
    "end_line": 200,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTreeItem",
    "component_id": "src.providers.spec-explorer-provider.getTreeItem"
  },
  "src.providers.spec-explorer-provider.calculateChecklistsFolderStatus": {
    "id": "src.providers.spec-explorer-provider.calculateChecklistsFolderStatus",
    "name": "calculateChecklistsFolderStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async calculateChecklistsFolderStatus(\n\t\tfolderPath: string\n\t): Promise<TaskStatus> {\n\t\ttry {\n\t\t\tconst { readdirSync, statSync } = await import(\"node:fs\");\n\t\t\tconst entries = readdirSync(folderPath);\n\n\t\t\tlet totalItems = 0;\n\t\t\tlet completedItems = 0;\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tif (entry.endsWith(\".md\")) {\n\t\t\t\t\tconst filePath = join(folderPath, entry);\n\t\t\t\t\tconst stat = statSync(filePath);\n\n\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\tconst status = getChecklistStatusFromFile(filePath);\n\t\t\t\t\t\ttotalItems += status.total;\n\t\t\t\t\t\tcompletedItems += status.completed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totalItems === 0) {\n\t\t\t\treturn \"not-started\";\n\t\t\t}\n\n\t\t\tif (completedItems === totalItems) {\n\t\t\t\treturn \"completed\";\n\t\t\t}\n\n\t\t\tif (completedItems > 0) {\n\t\t\t\treturn \"in-progress\";\n\t\t\t}\n\n\t\t\treturn \"not-started\";\n\t\t} catch {\n\t\t\treturn \"not-started\";\n\t\t}\n\t}",
    "start_line": 205,
    "end_line": 244,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "folderPath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method calculateChecklistsFolderStatus",
    "component_id": "src.providers.spec-explorer-provider.calculateChecklistsFolderStatus"
  },
  "src.providers.spec-explorer-provider.getChildren": {
    "id": "src.providers.spec-explorer-provider.getChildren",
    "name": "getChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "async getChildren(element?: SpecItem): Promise<SpecItem[]> {\n\t\tif (!(workspace.workspaceFolders && this.specManager)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (!element) {\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Current Specs\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-current-specs\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Review\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-review-specs\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Archived\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-archived-specs\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Changes\",\n\t\t\t\t\tTreeItemCollapsibleState.Expanded,\n\t\t\t\t\t\"group-changes\",\n\t\t\t\t\tthis.context\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\tconst unifiedSpecs = await this.specManager.getAllSpecsUnified();\n\n\t\tif (element.contextValue === \"group-current-specs\") {\n\t\t\treturn unifiedSpecs\n\t\t\t\t.filter((spec) => {\n\t\t\t\t\tconst state = getSpecState(spec.id);\n\t\t\t\t\treturn (\n\t\t\t\t\t\t!state || state.status === \"current\" || state.status === \"reopened\"\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.map((spec) => this.createSpecItem(spec.name, spec.id, spec.system));\n\t\t}\n\n\t\tif (element.contextValue === \"group-review-specs\") {\n\t\t\treturn unifiedSpecs\n\t\t\t\t.filter((spec) => getSpecState(spec.id)?.status === \"review\")\n\t\t\t\t.map((spec) =>\n\t\t\t\t\tthis.createReviewSpecItem(spec.name, spec.id, spec.system)\n\t\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"group-archived-specs\") {\n\t\t\treturn unifiedSpecs\n\t\t\t\t.filter((spec) => getSpecState(spec.id)?.status === \"archived\")\n\t\t\t\t.map((spec) =>\n\t\t\t\t\tthis.createArchivedSpecItem(spec.name, spec.id, spec.system)\n\t\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"group-changes\") {\n\t\t\tconst activeChangeRequests =\n\t\t\t\tawait this.specManager.getActiveChangeRequests();\n\t\t\treturn activeChangeRequests.map(\n\t\t\t\t({ specId, specTitle, changeRequest }) => {\n\t\t\t\t\tconst item = new SpecItem(\n\t\t\t\t\t\tchangeRequest.title,\n\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\"change-request\",\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tspecId,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tchangeRequest.id\n\t\t\t\t\t);\n\t\t\t\t\t// Pass the change request and spec title for enhanced display\n\t\t\t\t\titem.changeRequest = changeRequest;\n\t\t\t\t\titem.specTitle = specTitle;\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\telement.contextValue === \"spec\" ||\n\t\t\telement.contextValue === \"spec-current\" ||\n\t\t\telement.contextValue === \"spec-review\" ||\n\t\t\telement.contextValue === \"spec-archived\"\n\t\t) {\n\t\t\t// Handle SpecKit System\n\t\t\tif (element.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t\tconst adapter = getSpecSystemAdapter();\n\t\t\t\t// Get files for this spec (returns absolute paths)\n\t\t\t\tconst files = adapter.getSpecFiles(element.specName!);\n\n\t\t\t\tconst items: SpecItem[] = [];\n\n\t\t\t\t// Map of filenames to display labels and types\n\t\t\t\tconst fileMap: Record<string, { label: string; type: string }> = {\n\t\t\t\t\t\"spec.md\": { label: \"Spec\", type: \"spec\" },\n\t\t\t\t\t\"plan.md\": { label: \"Plan\", type: \"plan\" },\n\t\t\t\t\t\"design.md\": { label: \"Design\", type: \"design\" },\n\t\t\t\t\t\"requirements.md\": { label: \"Requirements\", type: \"requirements\" },\n\t\t\t\t\t\"research.md\": { label: \"Research\", type: \"research\" },\n\t\t\t\t\t\"data-model.md\": { label: \"Data Model\", type: \"data-model\" },\n\t\t\t\t\t\"quickstart.md\": { label: \"Quickstart\", type: \"quickstart\" },\n\t\t\t\t};\n\n\t\t\t\tfor (const [docType, absolutePath] of Object.entries(files)) {\n\t\t\t\t\tconst fileName = basename(absolutePath);\n\n\t\t\t\t\t// Handle tasks.md as a folder with task items\n\t\t\t\t\tif (fileName === \"tasks.md\") {\n\t\t\t\t\t\tconst relativePath = workspace.asRelativePath(absolutePath);\n\t\t\t\t\t\t// Calculate overall status for tasks folder\n\t\t\t\t\t\tconst taskGroups = parseTasksFromFile(absolutePath);\n\t\t\t\t\t\tconst overallStatus = calculateOverallStatus(taskGroups);\n\t\t\t\t\t\titems.push(\n\t\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\t\t\"Tasks\",\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\t\t\t\"tasks-folder\",\n\t\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\t\t\"tasks\",\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\telement.system,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\toverallStatus\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle checklists folder\n\t\t\t\t\tif (docType === \"checklists\") {\n\t\t\t\t\t\tconst relativePath = workspace.asRelativePath(absolutePath);\n\t\t\t\t\t\t// Calculate overall status for checklists folder\n\t\t\t\t\t\tconst checklistsStatus =\n\t\t\t\t\t\t\tawait this.calculateChecklistsFolderStatus(absolutePath);\n\t\t\t\t\t\titems.push(\n\t\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\t\t\"Checklists\",\n\t\t\t\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\t\t\t\"checklists-folder\",\n\t\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\t\t\"checklists\",\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\telement.system,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tchecklistsStatus\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst fileInfo = fileMap[fileName] || {\n\t\t\t\t\t\tlabel: fileName,\n\t\t\t\t\t\ttype: \"file\",\n\t\t\t\t\t};\n\n\t\t\t\t\t// Convert absolute path to relative path for the command\n\t\t\t\t\tconst relativePath = workspace.asRelativePath(absolutePath);\n\n\t\t\t\t\titems.push(\n\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\tfileInfo.label,\n\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\"spec-document\",\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\tfileInfo.type,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\t\t\ttitle: `Open ${fileInfo.label}`,\n\t\t\t\t\t\t\t\targuments: [relativePath, fileInfo.type],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trelativePath\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t}\n\n\t\t\t// Handle OpenSpec System\n\t\t\tconst specPath = `openspec/specs/${element.specName}/spec.md`;\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Spec\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"spec\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Spec\",\n\t\t\t\t\t\targuments: [specPath, \"spec\"],\n\t\t\t\t\t},\n\t\t\t\t\tspecPath\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\t// Handle tasks folder - show task groups and tasks\n\t\tif (element.contextValue === \"tasks-folder\") {\n\t\t\tconst tasksFilePath = element.filePath;\n\t\t\tif (!tasksFilePath) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get absolute path\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst absolutePath = join(workspaceRoot, tasksFilePath);\n\t\t\tconst taskGroups = parseTasksFromFile(absolutePath);\n\n\t\t\tif (taskGroups.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Return task groups as collapsible items\n\t\t\treturn taskGroups.map((group) => {\n\t\t\t\tconst groupStatus = calculateGroupStatus(group.tasks);\n\t\t\t\treturn new SpecItem(\n\t\t\t\t\tgroup.name,\n\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\"task-group\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"task-group\",\n\t\t\t\t\tundefined, // No command - clicking only expands/collapses\n\t\t\t\t\ttasksFilePath,\n\t\t\t\t\tgroup.name,\n\t\t\t\t\telement.system,\n\t\t\t\t\tundefined,\n\t\t\t\t\tgroupStatus\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\t// Handle task group - show individual tasks\n\t\tif (element.contextValue === \"task-group\") {\n\t\t\tconst tasksFilePath = element.filePath;\n\t\t\tconst groupName = element.parentName;\n\t\t\tif (!(tasksFilePath && groupName)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get absolute path\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst absolutePath = join(workspaceRoot, tasksFilePath);\n\t\t\tconst taskGroups = parseTasksFromFile(absolutePath);\n\n\t\t\t// Find the matching group\n\t\t\tconst group = taskGroups.find((g) => g.name === groupName);\n\t\t\tif (!group) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Return individual tasks\n\t\t\treturn group.tasks.map(\n\t\t\t\t(task) =>\n\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t`${task.id}: ${task.title}`,\n\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\"task-item\",\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\"task\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\t\ttitle: \"Open Tasks\",\n\t\t\t\t\t\t\targuments: [tasksFilePath, \"tasks\", task.line],\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttasksFilePath,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\telement.system,\n\t\t\t\t\t\ttask\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Handle checklists folder - show individual checklist files\n\t\tif (element.contextValue === \"checklists-folder\") {\n\t\t\tconst checklistsFolderPath = element.filePath;\n\t\t\tif (!checklistsFolderPath) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Get absolute path\n\t\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\t\tif (!workspaceRoot) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst absolutePath = join(workspaceRoot, checklistsFolderPath);\n\n\t\t\ttry {\n\t\t\t\tconst { readdirSync, statSync } = await import(\"node:fs\");\n\t\t\t\tconst entries = readdirSync(absolutePath);\n\t\t\t\tconst checklistItems: SpecItem[] = [];\n\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tif (entry.endsWith(\".md\")) {\n\t\t\t\t\t\tconst filePath = join(absolutePath, entry);\n\t\t\t\t\t\tconst stat = statSync(filePath);\n\n\t\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\t\tconst relativePath = workspace.asRelativePath(filePath);\n\t\t\t\t\t\t\tconst displayName = entry.replace(MARKDOWN_EXTENSION_PATTERN, \"\");\n\t\t\t\t\t\t\tconst formattedName =\n\t\t\t\t\t\t\t\tdisplayName.charAt(0).toUpperCase() +\n\t\t\t\t\t\t\t\tdisplayName.slice(1).replace(/-/g, \" \");\n\n\t\t\t\t\t\t\t// Calculate checklist status for icon\n\t\t\t\t\t\t\tconst checklistStatus = getChecklistStatusFromFile(filePath);\n\n\t\t\t\t\t\t\tchecklistItems.push(\n\t\t\t\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\t\t\t\tformattedName,\n\t\t\t\t\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\t\t\t\t\"checklist-item\",\n\t\t\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\t\t\telement.specName,\n\t\t\t\t\t\t\t\t\t\"checklist\",\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\t\t\t\t\ttitle: `Open ${formattedName}`,\n\t\t\t\t\t\t\t\t\t\targuments: [relativePath, \"checklist\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\telement.system,\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tchecklistStatus.status\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn checklistItems;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Error reading checklists folder:\", error);\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\tif (element.contextValue === \"change\") {\n\t\t\tconst basePath = `openspec/changes/${element.specName}`;\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Proposal\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"proposal\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Proposal\",\n\t\t\t\t\t\targuments: [`${basePath}/proposal.md`, \"proposal\"],\n\t\t\t\t\t},\n\t\t\t\t\t`${basePath}/proposal.md`\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Tasks\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"tasks\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Tasks\",\n\t\t\t\t\t\targuments: [`${basePath}/tasks.md`, \"tasks\"],\n\t\t\t\t\t},\n\t\t\t\t\t`${basePath}/tasks.md`\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Design\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName,\n\t\t\t\t\t\"design\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Design\",\n\t\t\t\t\t\targuments: [`${basePath}/design.md`, \"design\"],\n\t\t\t\t\t},\n\t\t\t\t\t`${basePath}/design.md`\n\t\t\t\t),\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Specs\",\n\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\"change-specs-group\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\telement.specName\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\tif (element.contextValue === \"change-specs-group\") {\n\t\t\tconst specs = await this.specManager.getChangeSpecs(element.specName!);\n\t\t\treturn specs.map(\n\t\t\t\t(name) =>\n\t\t\t\t\tnew SpecItem(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tTreeItemCollapsibleState.Collapsed,\n\t\t\t\t\t\t\"change-spec\",\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\telement.specName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (element.contextValue === \"change-spec\") {\n\t\t\tconst changeName = element.parentName!;\n\t\t\tconst specName = element.specName!;\n\t\t\tconst specPath = `openspec/changes/${changeName}/specs/${specName}/spec.md`;\n\n\t\t\treturn [\n\t\t\t\tnew SpecItem(\n\t\t\t\t\t\"Spec\",\n\t\t\t\t\tTreeItemCollapsibleState.None,\n\t\t\t\t\t\"spec-document\",\n\t\t\t\t\tthis.context,\n\t\t\t\t\tspecName,\n\t\t\t\t\t\"spec\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: SpecExplorerProvider.openSpecCommandId,\n\t\t\t\t\t\ttitle: \"Open Spec\",\n\t\t\t\t\t\targuments: [specPath, \"spec\"],\n\t\t\t\t\t},\n\t\t\t\t\tspecPath\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 247,
    "end_line": 710,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getChildren",
    "component_id": "src.providers.spec-explorer-provider.getChildren"
  },
  "src.providers.spec-explorer-provider.SpecItem": {
    "id": "src.providers.spec-explorer-provider.SpecItem",
    "name": "SpecItem",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "src.utils.task-parser.TaskStatus",
      "src.utils.task-parser.getGroupStatusIcon",
      "src.providers.spec-explorer-provider.handleTaskItemIcon",
      "src.providers.spec-explorer-provider.handleTasksFolderIcon",
      "src.providers.spec-explorer-provider.handleChecklistItemIcon",
      "src.providers.spec-explorer-provider.updateDocumentIcon",
      "src.providers.spec-explorer-provider.getContextHandler",
      "src.constants.SpecSystemMode",
      "src.providers.spec-explorer-provider.handleSpecIcon",
      "src.providers.spec-explorer-provider.handleTaskGroupIcon",
      "src.providers.spec-explorer-provider.handleChecklistsFolderIcon",
      "src.providers.spec-explorer-provider.handleChangeRequestIcon",
      "src.providers.spec-explorer-provider.getTaskStatusColor",
      "src.utils.task-parser.ParsedTask",
      "src.utils.task-parser.getTaskStatusTooltip",
      "src.providers.spec-explorer-provider.updateIconAndTooltip",
      "src.utils.task-parser.getTaskStatusIcon"
    ],
    "source_code": "class SpecItem extends TreeItem {\n\treadonly label: string;\n\treadonly collapsibleState: TreeItemCollapsibleState;\n\treadonly contextValue: string;\n\tprivate readonly context: ExtensionContext;\n\treadonly specName?: string;\n\treadonly documentType?: string;\n\treadonly command?: Command;\n\treadonly filePath?: string;\n\treadonly parentName?: string;\n\treadonly system?: SpecSystemMode;\n\treadonly task?: ParsedTask;\n\treadonly groupStatus?: TaskStatus;\n\tchangeRequest?: import(\"../features/spec/review-flow/types\").ChangeRequest;\n\tspecTitle?: string;\n\n\t// biome-ignore lint/nursery/useMaxParams: ignore\n\tconstructor(\n\t\tlabel: string,\n\t\tcollapsibleState: TreeItemCollapsibleState,\n\t\tcontextValue: string,\n\t\tcontext: ExtensionContext,\n\t\tspecName?: string,\n\t\tdocumentType?: string,\n\t\tcommand?: Command,\n\t\tfilePath?: string,\n\t\tparentName?: string,\n\t\tsystem?: SpecSystemMode,\n\t\ttask?: ParsedTask,\n\t\tgroupStatus?: TaskStatus\n\t) {\n\t\tsuper(label, collapsibleState);\n\t\tthis.label = label;\n\t\tthis.collapsibleState = collapsibleState;\n\t\tthis.contextValue = contextValue;\n\t\tthis.context = context;\n\t\tthis.specName = specName;\n\t\tthis.documentType = documentType;\n\t\tthis.command = command;\n\t\tthis.filePath = filePath;\n\t\tthis.parentName = parentName;\n\t\tthis.system = system;\n\t\tthis.task = task;\n\t\tthis.groupStatus = groupStatus;\n\n\t\tthis.updateIconAndTooltip();\n\t}\n\n\tprivate updateIconAndTooltip() {\n\t\tconst handler = this.getContextHandler();\n\t\tif (handler) {\n\t\t\thandler();\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.contextValue.startsWith(\"group-\") ||\n\t\t\tthis.contextValue === \"change-specs-group\"\n\t\t) {\n\t\t\tthis.iconPath = new ThemeIcon(\"folder\");\n\t\t}\n\t}\n\n\tprivate getContextHandler(): (() => void) | undefined {\n\t\tconst handlers: Record<string, () => void> = {\n\t\t\tspec: () => this.handleSpecIcon(),\n\t\t\t\"spec-current\": () => this.handleSpecIcon(),\n\t\t\t\"spec-review\": () => this.handleSpecIcon(),\n\t\t\t\"spec-archived\": () => this.handleSpecIcon(),\n\t\t\tchange: () => this.handleSpecIcon(),\n\t\t\t\"change-spec\": () => this.handleSpecIcon(),\n\t\t\t\"spec-document\": () => this.updateDocumentIcon(),\n\t\t\t\"tasks-folder\": () => this.handleTasksFolderIcon(),\n\t\t\t\"task-group\": () => this.handleTaskGroupIcon(),\n\t\t\t\"task-item\": () => this.handleTaskItemIcon(),\n\t\t\t\"checklists-folder\": () => this.handleChecklistsFolderIcon(),\n\t\t\t\"checklist-item\": () => this.handleChecklistItemIcon(),\n\t\t\t\"change-request\": () => this.handleChangeRequestIcon(),\n\t\t};\n\n\t\treturn handlers[this.contextValue];\n\t}\n\n\tprivate handleSpecIcon(): void {\n\t\tthis.iconPath = new ThemeIcon(\"package\");\n\t\tconst systemLabel = this.system ? ` (${this.system})` : \"\";\n\t\tthis.tooltip = `${this.contextValue}${systemLabel}: ${this.label}`;\n\t}\n\n\tprivate handleTasksFolderIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\t\tthis.tooltip = \"Tasks - Click to expand\";\n\t}\n\n\tprivate handleTaskGroupIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\t\tthis.tooltip = `${this.label} - Click to expand or run /speckit.implement`;\n\t}\n\n\tprivate handleTaskItemIcon(): void {\n\t\tif (!this.task) {\n\t\t\treturn;\n\t\t}\n\t\tconst statusIcon = getTaskStatusIcon(this.task.status);\n\t\tconst statusColor = this.getTaskStatusColor(this.task.status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\n\t\tconst statusText = getTaskStatusTooltip(this.task.status);\n\t\tconst priorityText = this.task.priority\n\t\t\t? ` | Priority: ${this.task.priority}`\n\t\t\t: \"\";\n\t\tconst complexityText = this.task.complexity\n\t\t\t? ` | Complexity: ${this.task.complexity}`\n\t\t\t: \"\";\n\t\tthis.tooltip = `${statusText}${priorityText}${complexityText}\\n\\nClick to open at line ${this.task.line}`;\n\t\tthis.description = statusText;\n\t}\n\n\tprivate handleChecklistsFolderIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\t\tconst statusText = getTaskStatusTooltip(status);\n\t\tthis.tooltip = `Checklists - ${statusText}`;\n\t}\n\n\tprivate handleChecklistItemIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\n\t\tconst statusText = getTaskStatusTooltip(status);\n\t\tthis.tooltip = `Checklist: ${this.label} - ${statusText}`;\n\t\tthis.description = statusText;\n\t}\n\n\tprivate handleChangeRequestIcon(): void {\n\t\tif (!this.changeRequest) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Icon based on severity\n\t\tconst severityIcons = {\n\t\t\tcritical: \"error\",\n\t\t\thigh: \"warning\",\n\t\t\tmedium: \"info\",\n\t\t\tlow: \"circle-outline\",\n\t\t};\n\t\tconst icon = severityIcons[this.changeRequest.severity];\n\n\t\t// Color based on severity\n\t\tconst severityColors = {\n\t\t\tcritical: new ThemeColor(\"errorForeground\"),\n\t\t\thigh: new ThemeColor(\"editorWarning.foreground\"),\n\t\t\tmedium: new ThemeColor(\"editorInfo.foreground\"),\n\t\t\tlow: new ThemeColor(\"descriptionForeground\"),\n\t\t};\n\t\tconst color = severityColors[this.changeRequest.severity];\n\n\t\tthis.iconPath = new ThemeIcon(icon, color);\n\n\t\t// Build tooltip with details\n\t\tconst statusEmoji = {\n\t\t\topen: \"\",\n\t\t\tinProgress: \"\",\n\t\t\taddressed: \"\",\n\t\t};\n\t\tconst emoji = statusEmoji[this.changeRequest.status];\n\n\t\tconst blockerText = this.changeRequest.archivalBlocker\n\t\t\t? \" [BLOCKS ARCHIVAL]\"\n\t\t\t: \"\";\n\n\t\tthis.tooltip = `${emoji} ${this.changeRequest.title}\\n\\nSpec: ${this.specTitle}\\nSeverity: ${this.changeRequest.severity}\\nStatus: ${this.changeRequest.status}${blockerText}\\nSubmitted: ${this.changeRequest.createdAt.toLocaleString()}\\nSubmitter: ${this.changeRequest.submitter}`;\n\n\t\t// Set description to show spec name and severity\n\t\tthis.description = `${this.specTitle} | ${this.changeRequest.severity}`;\n\t}\n\n\tprivate getTaskStatusColor(status?: TaskStatus): ThemeColor | undefined {\n\t\tswitch (status) {\n\t\t\tcase \"completed\":\n\t\t\t\treturn new ThemeColor(\"terminal.ansiGreen\");\n\t\t\tcase \"in-progress\":\n\t\t\t\treturn new ThemeColor(\"terminal.ansiYellow\");\n\t\t\tcase \"not-started\":\n\t\t\t\treturn new ThemeColor(\"descriptionForeground\");\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate updateDocumentIcon() {\n\t\t// Different icons for different document types\n\t\tif (this.documentType === \"requirements\" || this.documentType === \"spec\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"chip\");\n\t\t} else if (this.documentType === \"design\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"layers\");\n\t\t} else if (this.documentType === \"tasks\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"tasklist\");\n\t\t} else if (this.documentType === \"proposal\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"lightbulb\");\n\t\t} else if (this.documentType === \"plan\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"calendar\");\n\t\t} else if (this.documentType === \"research\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"search\");\n\t\t} else if (this.documentType === \"data-model\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"database\");\n\t\t} else if (this.documentType === \"quickstart\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"rocket\");\n\t\t} else {\n\t\t\tthis.iconPath = new ThemeIcon(\"file\");\n\t\t}\n\n\t\tthis.tooltip = `${this.documentType}: ${this.label}`;\n\n\t\t// Set description to file path\n\t\tif (this.filePath) {\n\t\t\tthis.description = this.filePath;\n\t\t}\n\t}\n}",
    "start_line": 713,
    "end_line": 942,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecItem",
    "component_id": "src.providers.spec-explorer-provider.SpecItem"
  },
  "src.providers.spec-explorer-provider.updateIconAndTooltip": {
    "id": "src.providers.spec-explorer-provider.updateIconAndTooltip",
    "name": "updateIconAndTooltip",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private updateIconAndTooltip() {\n\t\tconst handler = this.getContextHandler();\n\t\tif (handler) {\n\t\t\thandler();\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tthis.contextValue.startsWith(\"group-\") ||\n\t\t\tthis.contextValue === \"change-specs-group\"\n\t\t) {\n\t\t\tthis.iconPath = new ThemeIcon(\"folder\");\n\t\t}\n\t}",
    "start_line": 761,
    "end_line": 774,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method updateIconAndTooltip",
    "component_id": "src.providers.spec-explorer-provider.updateIconAndTooltip"
  },
  "src.providers.spec-explorer-provider.getContextHandler": {
    "id": "src.providers.spec-explorer-provider.getContextHandler",
    "name": "getContextHandler",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getContextHandler(): (() => void) | undefined {\n\t\tconst handlers: Record<string, () => void> = {\n\t\t\tspec: () => this.handleSpecIcon(),\n\t\t\t\"spec-current\": () => this.handleSpecIcon(),\n\t\t\t\"spec-review\": () => this.handleSpecIcon(),\n\t\t\t\"spec-archived\": () => this.handleSpecIcon(),\n\t\t\tchange: () => this.handleSpecIcon(),\n\t\t\t\"change-spec\": () => this.handleSpecIcon(),\n\t\t\t\"spec-document\": () => this.updateDocumentIcon(),\n\t\t\t\"tasks-folder\": () => this.handleTasksFolderIcon(),\n\t\t\t\"task-group\": () => this.handleTaskGroupIcon(),\n\t\t\t\"task-item\": () => this.handleTaskItemIcon(),\n\t\t\t\"checklists-folder\": () => this.handleChecklistsFolderIcon(),\n\t\t\t\"checklist-item\": () => this.handleChecklistItemIcon(),\n\t\t\t\"change-request\": () => this.handleChangeRequestIcon(),\n\t\t};\n\n\t\treturn handlers[this.contextValue];\n\t}",
    "start_line": 776,
    "end_line": 794,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getContextHandler",
    "component_id": "src.providers.spec-explorer-provider.getContextHandler"
  },
  "src.providers.spec-explorer-provider.handleSpecIcon": {
    "id": "src.providers.spec-explorer-provider.handleSpecIcon",
    "name": "handleSpecIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleSpecIcon(): void {\n\t\tthis.iconPath = new ThemeIcon(\"package\");\n\t\tconst systemLabel = this.system ? ` (${this.system})` : \"\";\n\t\tthis.tooltip = `${this.contextValue}${systemLabel}: ${this.label}`;\n\t}",
    "start_line": 796,
    "end_line": 800,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleSpecIcon",
    "component_id": "src.providers.spec-explorer-provider.handleSpecIcon"
  },
  "src.providers.spec-explorer-provider.handleTasksFolderIcon": {
    "id": "src.providers.spec-explorer-provider.handleTasksFolderIcon",
    "name": "handleTasksFolderIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleTasksFolderIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\t\tthis.tooltip = \"Tasks - Click to expand\";\n\t}",
    "start_line": 802,
    "end_line": 808,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleTasksFolderIcon",
    "component_id": "src.providers.spec-explorer-provider.handleTasksFolderIcon"
  },
  "src.providers.spec-explorer-provider.handleTaskGroupIcon": {
    "id": "src.providers.spec-explorer-provider.handleTaskGroupIcon",
    "name": "handleTaskGroupIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleTaskGroupIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\t\tthis.tooltip = `${this.label} - Click to expand or run /speckit.implement`;\n\t}",
    "start_line": 810,
    "end_line": 816,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleTaskGroupIcon",
    "component_id": "src.providers.spec-explorer-provider.handleTaskGroupIcon"
  },
  "src.providers.spec-explorer-provider.handleTaskItemIcon": {
    "id": "src.providers.spec-explorer-provider.handleTaskItemIcon",
    "name": "handleTaskItemIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleTaskItemIcon(): void {\n\t\tif (!this.task) {\n\t\t\treturn;\n\t\t}\n\t\tconst statusIcon = getTaskStatusIcon(this.task.status);\n\t\tconst statusColor = this.getTaskStatusColor(this.task.status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\n\t\tconst statusText = getTaskStatusTooltip(this.task.status);\n\t\tconst priorityText = this.task.priority\n\t\t\t? ` | Priority: ${this.task.priority}`\n\t\t\t: \"\";\n\t\tconst complexityText = this.task.complexity\n\t\t\t? ` | Complexity: ${this.task.complexity}`\n\t\t\t: \"\";\n\t\tthis.tooltip = `${statusText}${priorityText}${complexityText}\\n\\nClick to open at line ${this.task.line}`;\n\t\tthis.description = statusText;\n\t}",
    "start_line": 818,
    "end_line": 835,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleTaskItemIcon",
    "component_id": "src.providers.spec-explorer-provider.handleTaskItemIcon"
  },
  "src.providers.spec-explorer-provider.handleChecklistsFolderIcon": {
    "id": "src.providers.spec-explorer-provider.handleChecklistsFolderIcon",
    "name": "handleChecklistsFolderIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleChecklistsFolderIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\t\tconst statusText = getTaskStatusTooltip(status);\n\t\tthis.tooltip = `Checklists - ${statusText}`;\n\t}",
    "start_line": 837,
    "end_line": 844,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleChecklistsFolderIcon",
    "component_id": "src.providers.spec-explorer-provider.handleChecklistsFolderIcon"
  },
  "src.providers.spec-explorer-provider.handleChecklistItemIcon": {
    "id": "src.providers.spec-explorer-provider.handleChecklistItemIcon",
    "name": "handleChecklistItemIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleChecklistItemIcon(): void {\n\t\tconst status = this.groupStatus ?? \"not-started\";\n\t\tconst statusIcon = getGroupStatusIcon(status);\n\t\tconst statusColor = this.getTaskStatusColor(status);\n\t\tthis.iconPath = new ThemeIcon(statusIcon, statusColor);\n\n\t\tconst statusText = getTaskStatusTooltip(status);\n\t\tthis.tooltip = `Checklist: ${this.label} - ${statusText}`;\n\t\tthis.description = statusText;\n\t}",
    "start_line": 846,
    "end_line": 855,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleChecklistItemIcon",
    "component_id": "src.providers.spec-explorer-provider.handleChecklistItemIcon"
  },
  "src.providers.spec-explorer-provider.handleChangeRequestIcon": {
    "id": "src.providers.spec-explorer-provider.handleChangeRequestIcon",
    "name": "handleChangeRequestIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private handleChangeRequestIcon(): void {\n\t\tif (!this.changeRequest) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Icon based on severity\n\t\tconst severityIcons = {\n\t\t\tcritical: \"error\",\n\t\t\thigh: \"warning\",\n\t\t\tmedium: \"info\",\n\t\t\tlow: \"circle-outline\",\n\t\t};\n\t\tconst icon = severityIcons[this.changeRequest.severity];\n\n\t\t// Color based on severity\n\t\tconst severityColors = {\n\t\t\tcritical: new ThemeColor(\"errorForeground\"),\n\t\t\thigh: new ThemeColor(\"editorWarning.foreground\"),\n\t\t\tmedium: new ThemeColor(\"editorInfo.foreground\"),\n\t\t\tlow: new ThemeColor(\"descriptionForeground\"),\n\t\t};\n\t\tconst color = severityColors[this.changeRequest.severity];\n\n\t\tthis.iconPath = new ThemeIcon(icon, color);\n\n\t\t// Build tooltip with details\n\t\tconst statusEmoji = {\n\t\t\topen: \"\",\n\t\t\tinProgress: \"\",\n\t\t\taddressed: \"\",\n\t\t};\n\t\tconst emoji = statusEmoji[this.changeRequest.status];\n\n\t\tconst blockerText = this.changeRequest.archivalBlocker\n\t\t\t? \" [BLOCKS ARCHIVAL]\"\n\t\t\t: \"\";\n\n\t\tthis.tooltip = `${emoji} ${this.changeRequest.title}\\n\\nSpec: ${this.specTitle}\\nSeverity: ${this.changeRequest.severity}\\nStatus: ${this.changeRequest.status}${blockerText}\\nSubmitted: ${this.changeRequest.createdAt.toLocaleString()}\\nSubmitter: ${this.changeRequest.submitter}`;\n\n\t\t// Set description to show spec name and severity\n\t\tthis.description = `${this.specTitle} | ${this.changeRequest.severity}`;\n\t}",
    "start_line": 857,
    "end_line": 898,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleChangeRequestIcon",
    "component_id": "src.providers.spec-explorer-provider.handleChangeRequestIcon"
  },
  "src.providers.spec-explorer-provider.getTaskStatusColor": {
    "id": "src.providers.spec-explorer-provider.getTaskStatusColor",
    "name": "getTaskStatusColor",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getTaskStatusColor(status?: TaskStatus): ThemeColor | undefined {\n\t\tswitch (status) {\n\t\t\tcase \"completed\":\n\t\t\t\treturn new ThemeColor(\"terminal.ansiGreen\");\n\t\t\tcase \"in-progress\":\n\t\t\t\treturn new ThemeColor(\"terminal.ansiYellow\");\n\t\t\tcase \"not-started\":\n\t\t\t\treturn new ThemeColor(\"descriptionForeground\");\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}",
    "start_line": 900,
    "end_line": 911,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTaskStatusColor",
    "component_id": "src.providers.spec-explorer-provider.getTaskStatusColor"
  },
  "src.providers.spec-explorer-provider.updateDocumentIcon": {
    "id": "src.providers.spec-explorer-provider.updateDocumentIcon",
    "name": "updateDocumentIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-explorer-provider.ts",
    "relative_path": "src/providers/spec-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private updateDocumentIcon() {\n\t\t// Different icons for different document types\n\t\tif (this.documentType === \"requirements\" || this.documentType === \"spec\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"chip\");\n\t\t} else if (this.documentType === \"design\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"layers\");\n\t\t} else if (this.documentType === \"tasks\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"tasklist\");\n\t\t} else if (this.documentType === \"proposal\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"lightbulb\");\n\t\t} else if (this.documentType === \"plan\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"calendar\");\n\t\t} else if (this.documentType === \"research\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"search\");\n\t\t} else if (this.documentType === \"data-model\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"database\");\n\t\t} else if (this.documentType === \"quickstart\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"rocket\");\n\t\t} else {\n\t\t\tthis.iconPath = new ThemeIcon(\"file\");\n\t\t}\n\n\t\tthis.tooltip = `${this.documentType}: ${this.label}`;\n\n\t\t// Set description to file path\n\t\tif (this.filePath) {\n\t\t\tthis.description = this.filePath;\n\t\t}\n\t}",
    "start_line": 913,
    "end_line": 941,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method updateDocumentIcon",
    "component_id": "src.providers.spec-explorer-provider.updateDocumentIcon"
  },
  "src.providers.spec-task-code-lens-provider.SpecTaskCodeLensProvider": {
    "id": "src.providers.spec-task-code-lens-provider.SpecTaskCodeLensProvider",
    "name": "SpecTaskCodeLensProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-task-code-lens-provider.ts",
    "relative_path": "src/providers/spec-task-code-lens-provider.ts",
    "depends_on": [
      "src.utils.config-manager.getAbsolutePath",
      "src.providers.spec-task-code-lens-provider.isSpecTaskDocument",
      "src.utils.spec-kit-adapter.getInstance",
      "src.utils.config-manager.loadSettings",
      "src.utils.config-manager.ConfigManager"
    ],
    "source_code": "class SpecTaskCodeLensProvider implements CodeLensProvider {\n\tprivate readonly _onDidChangeCodeLenses: EventEmitter<void> =\n\t\tnew EventEmitter<void>();\n\treadonly onDidChangeCodeLenses: Event<void> =\n\t\tthis._onDidChangeCodeLenses.event;\n\tprivate readonly configManager: ConfigManager;\n\n\tconstructor() {\n\t\tthis.configManager = ConfigManager.getInstance();\n\t\tworkspace.onDidChangeConfiguration((event) => {\n\t\t\tif (event.affectsConfiguration(VSC_CONFIG_NAMESPACE)) {\n\t\t\t\t// biome-ignore lint/complexity/noVoid: ignore\n\t\t\t\tvoid this.configManager.loadSettings();\n\t\t\t}\n\t\t\tthis._onDidChangeCodeLenses.fire();\n\t\t});\n\t}\n\n\tprovideCodeLenses(\n\t\tdocument: TextDocument,\n\t\ttoken: CancellationToken\n\t): CodeLens[] | Thenable<CodeLens[]> {\n\t\tif (!this.isSpecTaskDocument(document)) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create a single CodeLens at the top of the file\n\t\tconst range = new Range(0, 0, 0, 0);\n\t\tconst text = document.getText();\n\t\tconst hasIncompleteTasks = text.includes(\"- [ ]\");\n\t\tconst hasCompletedTasks = text.includes(\"- [x]\");\n\n\t\tif (hasIncompleteTasks) {\n\t\t\treturn [\n\t\t\t\tnew CodeLens(range, {\n\t\t\t\t\ttitle: \"$(play) Start All Tasks\",\n\t\t\t\t\ttooltip: \"Click to generate OpenSpec apply prompt\",\n\t\t\t\t\tcommand: \"gatomia.spec.implTask\",\n\t\t\t\t\targuments: [document.uri],\n\t\t\t\t}),\n\t\t\t];\n\t\t}\n\n\t\tif (hasCompletedTasks) {\n\t\t\treturn [\n\t\t\t\tnew CodeLens(range, {\n\t\t\t\t\ttitle: \"$(check) All Tasks Completed\",\n\t\t\t\t\ttooltip: \"All tasks are completed\",\n\t\t\t\t\tcommand: \"gatomia.noop\",\n\t\t\t\t}),\n\t\t\t];\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate isSpecTaskDocument(document: TextDocument): boolean {\n\t\tif (!document.fileName.endsWith(\"tasks.md\")) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if inside configured specs path\n\t\ttry {\n\t\t\tconst specBasePath = this.configManager.getAbsolutePath(\"specs\");\n\t\t\tconst relativePath = relative(specBasePath, document.uri.fsPath);\n\t\t\tif (relativePath && !relativePath.startsWith(\"..\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\t// Check if inside \"openspec\" folder in workspace (standard OpenSpec structure)\n\t\tconst workspaceFolder = workspace.getWorkspaceFolder(document.uri);\n\t\tif (workspaceFolder) {\n\t\t\tconst openspecPath = join(workspaceFolder.uri.fsPath, \"openspec\");\n\t\t\tconst relativePath = relative(openspecPath, document.uri.fsPath);\n\t\t\tif (relativePath && !relativePath.startsWith(\"..\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tresolveCodeLens(codeLens: CodeLens, token: CancellationToken) {\n\t\treturn codeLens;\n\t}\n}",
    "start_line": 16,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecTaskCodeLensProvider",
    "component_id": "src.providers.spec-task-code-lens-provider.SpecTaskCodeLensProvider"
  },
  "src.providers.spec-task-code-lens-provider.provideCodeLenses": {
    "id": "src.providers.spec-task-code-lens-provider.provideCodeLenses",
    "name": "provideCodeLenses",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-task-code-lens-provider.ts",
    "relative_path": "src/providers/spec-task-code-lens-provider.ts",
    "depends_on": [],
    "source_code": "provideCodeLenses(\n\t\tdocument: TextDocument,\n\t\ttoken: CancellationToken\n\t): CodeLens[] | Thenable<CodeLens[]> {\n\t\tif (!this.isSpecTaskDocument(document)) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create a single CodeLens at the top of the file\n\t\tconst range = new Range(0, 0, 0, 0);\n\t\tconst text = document.getText();\n\t\tconst hasIncompleteTasks = text.includes(\"- [ ]\");\n\t\tconst hasCompletedTasks = text.includes(\"- [x]\");\n\n\t\tif (hasIncompleteTasks) {\n\t\t\treturn [\n\t\t\t\tnew CodeLens(range, {\n\t\t\t\t\ttitle: \"$(play) Start All Tasks\",\n\t\t\t\t\ttooltip: \"Click to generate OpenSpec apply prompt\",\n\t\t\t\t\tcommand: \"gatomia.spec.implTask\",\n\t\t\t\t\targuments: [document.uri],\n\t\t\t\t}),\n\t\t\t];\n\t\t}\n\n\t\tif (hasCompletedTasks) {\n\t\t\treturn [\n\t\t\t\tnew CodeLens(range, {\n\t\t\t\t\ttitle: \"$(check) All Tasks Completed\",\n\t\t\t\t\ttooltip: \"All tasks are completed\",\n\t\t\t\t\tcommand: \"gatomia.noop\",\n\t\t\t\t}),\n\t\t\t];\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 34,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "document",
      "token"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method provideCodeLenses",
    "component_id": "src.providers.spec-task-code-lens-provider.provideCodeLenses"
  },
  "src.providers.spec-task-code-lens-provider.isSpecTaskDocument": {
    "id": "src.providers.spec-task-code-lens-provider.isSpecTaskDocument",
    "name": "isSpecTaskDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-task-code-lens-provider.ts",
    "relative_path": "src/providers/spec-task-code-lens-provider.ts",
    "depends_on": [],
    "source_code": "private isSpecTaskDocument(document: TextDocument): boolean {\n\t\tif (!document.fileName.endsWith(\"tasks.md\")) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if inside configured specs path\n\t\ttry {\n\t\t\tconst specBasePath = this.configManager.getAbsolutePath(\"specs\");\n\t\t\tconst relativePath = relative(specBasePath, document.uri.fsPath);\n\t\t\tif (relativePath && !relativePath.startsWith(\"..\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\t// Check if inside \"openspec\" folder in workspace (standard OpenSpec structure)\n\t\tconst workspaceFolder = workspace.getWorkspaceFolder(document.uri);\n\t\tif (workspaceFolder) {\n\t\t\tconst openspecPath = join(workspaceFolder.uri.fsPath, \"openspec\");\n\t\t\tconst relativePath = relative(openspecPath, document.uri.fsPath);\n\t\t\tif (relativePath && !relativePath.startsWith(\"..\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}",
    "start_line": 72,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "document"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isSpecTaskDocument",
    "component_id": "src.providers.spec-task-code-lens-provider.isSpecTaskDocument"
  },
  "src.providers.spec-task-code-lens-provider.resolveCodeLens": {
    "id": "src.providers.spec-task-code-lens-provider.resolveCodeLens",
    "name": "resolveCodeLens",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/spec-task-code-lens-provider.ts",
    "relative_path": "src/providers/spec-task-code-lens-provider.ts",
    "depends_on": [],
    "source_code": "resolveCodeLens(codeLens: CodeLens, token: CancellationToken) {\n\t\treturn codeLens;\n\t}",
    "start_line": 101,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "codeLens",
      "token"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method resolveCodeLens",
    "component_id": "src.providers.spec-task-code-lens-provider.resolveCodeLens"
  },
  "src.providers.steering-explorer-provider.SteeringExplorerProvider": {
    "id": "src.providers.steering-explorer-provider.SteeringExplorerProvider",
    "name": "SteeringExplorerProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [
      "src.providers.steering-explorer-provider.getGroupUserItems",
      "src.providers.steering-explorer-provider.getRootItems",
      "src.features.steering.steering-manager.SteeringManager",
      "src.utils.config-manager.getSettings",
      "src.providers.steering-explorer-provider.SteeringItem",
      "src.providers.steering-explorer-provider.exists",
      "src.providers.steering-explorer-provider.getInstructionRules",
      "src.providers.steering-explorer-provider.getGroupProjectItems",
      "src.providers.steering-explorer-provider.readDisplayName",
      "src.utils.spec-kit-adapter.getInstance",
      "src.utils.config-manager.ConfigManager",
      "src.providers.steering-explorer-provider.getGroupRulesItems",
      "src.providers.steering-explorer-provider.normalizeName"
    ],
    "source_code": "class SteeringExplorerProvider\n\timplements TreeDataProvider<SteeringItem>\n{\n\tstatic readonly viewId = \"gatomia.views.steeringExplorer\";\n\tstatic readonly createProjectRuleCommandId =\n\t\t\"gatomia.steering.createProjectRule\";\n\n\tprivate readonly _onDidChangeTreeData = new EventEmitter<\n\t\tSteeringItem | undefined | null | void\n\t>();\n\treadonly onDidChangeTreeData: Event<SteeringItem | undefined | null | void> =\n\t\tthis._onDidChangeTreeData.event;\n\n\tprivate steeringManager!: SteeringManager;\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly configManager: ConfigManager;\n\n\tconstructor(context: ExtensionContext) {\n\t\tthis.context = context;\n\t\tthis.configManager = ConfigManager.getInstance();\n\t}\n\n\tsetSteeringManager(steeringManager: SteeringManager) {\n\t\tthis.steeringManager = steeringManager;\n\t}\n\n\trefresh(): void {\n\t\tthis._onDidChangeTreeData.fire();\n\t}\n\n\tgetTreeItem(element: SteeringItem): TreeItem {\n\t\treturn element;\n\t}\n\n\tasync getChildren(element?: SteeringItem): Promise<SteeringItem[]> {\n\t\tif (!element) {\n\t\t\treturn this.getRootItems();\n\t\t}\n\n\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\tif (!ws) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (element.contextValue === \"group-user\") {\n\t\t\treturn await this.getGroupUserItems();\n\t\t}\n\n\t\tif (element.contextValue === \"group-project\") {\n\t\t\treturn await this.getGroupProjectItems(ws.uri.fsPath);\n\t\t}\n\n\t\tif (element.contextValue === \"group-rules\") {\n\t\t\treturn await this.getGroupRulesItems(ws.uri);\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate getRootItems(): SteeringItem[] {\n\t\treturn [\n\t\t\tnew SteeringItem({\n\t\t\t\tlabel: \"Rules\",\n\t\t\t\tcollapsibleState: TreeItemCollapsibleState.Expanded,\n\t\t\t\tcontextValue: \"group-project\",\n\t\t\t\tresourcePath: \"\",\n\t\t\t\tcontext: this.context,\n\t\t\t}),\n\t\t\tnew SteeringItem({\n\t\t\t\tlabel: \"Custom Instructions\",\n\t\t\t\tcollapsibleState: TreeItemCollapsibleState.Expanded,\n\t\t\t\tcontextValue: \"group-rules\",\n\t\t\t\tresourcePath: \"\",\n\t\t\t\tcontext: this.context,\n\t\t\t}),\n\t\t\tnew SteeringItem({\n\t\t\t\tlabel: \"User Instructions\",\n\t\t\t\tcollapsibleState: TreeItemCollapsibleState.Expanded,\n\t\t\t\tcontextValue: \"group-user\",\n\t\t\t\tresourcePath: \"\",\n\t\t\t\tcontext: this.context,\n\t\t\t}),\n\t\t];\n\t}\n\n\tprivate async getGroupUserItems(): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\tconst globalCopilotMd = join(homeDir, \".github\", \"copilot-instructions.md\");\n\t\tif (await this.exists(globalCopilotMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Global Instructions\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"instruction-file\",\n\t\t\t\t\tresourcePath: globalCopilotMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(globalCopilotMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"copilot-instructions.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tconst rulesRoot = joinPath(Uri.file(homeDir), \".github\", \"instructions\");\n\t\titems.push(...(await this.getInstructionRules(rulesRoot)));\n\t\treturn items;\n\t}\n\n\tprivate async getGroupProjectItems(\n\t\tworkspaceRoot: string\n\t): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\tconst specSystem = this.configManager.getSettings().specSystem;\n\n\t\t// Project Copilot Instructions\n\t\tconst projectCopilotMd = join(\n\t\t\tworkspaceRoot,\n\t\t\t\".github\",\n\t\t\t\"copilot-instructions.md\"\n\t\t);\n\t\tif (await this.exists(projectCopilotMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Project Instructions\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"instruction-file\",\n\t\t\t\t\tresourcePath: projectCopilotMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(projectCopilotMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \".github/copilot-instructions.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// Constitution\n\t\tconst constitutionMd = join(workspaceRoot, \".github\", \"constitution.md\");\n\t\tif (await this.exists(constitutionMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Constitution\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"constitution-file\",\n\t\t\t\t\tresourcePath: constitutionMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(constitutionMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"constitution.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// AGENTS.md\n\t\tconst agentsMd = join(workspaceRoot, \"AGENTS.md\");\n\t\tif (await this.exists(agentsMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Rules (General)\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"agent-file\",\n\t\t\t\t\tresourcePath: agentsMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(agentsMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"AGENTS.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// OpenSpec AGENTS.md\n\t\tconst osAgentsMd = join(workspaceRoot, \"openspec\", \"AGENTS.md\");\n\t\tif (\n\t\t\tspecSystem === SPEC_SYSTEM_MODE.OPENSPEC &&\n\t\t\t(await this.exists(osAgentsMd))\n\t\t) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Rules (OpenSpec)\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"agent-file\",\n\t\t\t\t\tresourcePath: osAgentsMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(osAgentsMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"openspec/AGENTS.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tprivate async getGroupRulesItems(workspaceUri: Uri): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\t// Project Instruction Rules (*.instructions.md)\n\t\tconst rulesRoot = joinPath(workspaceUri, \".github\", \"instructions\");\n\t\titems.push(...(await this.getInstructionRules(rulesRoot)));\n\t\treturn items;\n\t}\n\n\tprivate async exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait workspace.fs.stat(Uri.file(path));\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate async getInstructionRules(root: Uri): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.File && name.endsWith(INSTRUCTION_RULE_SUFFIX)) {\n\t\t\t\t\tconst displayName = await this.readDisplayName(\n\t\t\t\t\t\tjoinPath(root, name),\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\titems.push(\n\t\t\t\t\t\tnew SteeringItem({\n\t\t\t\t\t\t\tlabel: displayName,\n\t\t\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\t\t\tcontextValue: \"instruction-rule\",\n\t\t\t\t\t\t\tresourcePath: join(root.fsPath, name),\n\t\t\t\t\t\t\tcontext: this.context,\n\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\t\t\targuments: [joinPath(root, name)],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfilename: name,\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn items;\n\t}\n\n\tprivate async readDisplayName(uri: Uri, filename: string): Promise<string> {\n\t\ttry {\n\t\t\t// Read first 1KB to find frontmatter or H1\n\t\t\tconst fileData = await workspace.fs.readFile(uri);\n\t\t\tconst content = new TextDecoder().decode(fileData.slice(0, 1024));\n\n\t\t\t// 1. Try Frontmatter name: ...\n\t\t\tconst frontmatterMatch = FRONTMATTER_REGEXP.exec(content);\n\t\t\tif (frontmatterMatch?.[1]) {\n\t\t\t\treturn frontmatterMatch[1].trim();\n\t\t\t}\n\n\t\t\t// 2. Try H1: # Title\n\t\t\tconst h1Match = H1_REGEXP.exec(content);\n\t\t\tif (h1Match?.[1]) {\n\t\t\t\treturn h1Match[1].trim();\n\t\t\t}\n\n\t\t\t// 3. Fallback: Normalize filename\n\t\t\treturn this.normalizeName(filename);\n\t\t} catch {\n\t\t\treturn this.normalizeName(filename);\n\t\t}\n\t}\n\n\tprivate normalizeName(name: string): string {\n\t\t// Remove suffix and extension\n\t\tconst normalized = name.replace(INSTRUCTION_RULE_SUFFIX, \"\");\n\t\t// Kebab/Snake to Title Case\n\t\treturn normalized\n\t\t\t.split(SEPARATOR_REGEXP)\n\t\t\t.map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n\t\t\t.join(\" \");\n\t}\n}",
    "start_line": 31,
    "end_line": 322,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SteeringExplorerProvider",
    "component_id": "src.providers.steering-explorer-provider.SteeringExplorerProvider"
  },
  "src.providers.steering-explorer-provider.setSteeringManager": {
    "id": "src.providers.steering-explorer-provider.setSteeringManager",
    "name": "setSteeringManager",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "setSteeringManager(steeringManager: SteeringManager) {\n\t\tthis.steeringManager = steeringManager;\n\t}",
    "start_line": 53,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "steeringManager"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setSteeringManager",
    "component_id": "src.providers.steering-explorer-provider.setSteeringManager"
  },
  "src.providers.steering-explorer-provider.refresh": {
    "id": "src.providers.steering-explorer-provider.refresh",
    "name": "refresh",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "refresh(): void {\n\t\tthis._onDidChangeTreeData.fire();\n\t}",
    "start_line": 57,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method refresh",
    "component_id": "src.providers.steering-explorer-provider.refresh"
  },
  "src.providers.steering-explorer-provider.getTreeItem": {
    "id": "src.providers.steering-explorer-provider.getTreeItem",
    "name": "getTreeItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "getTreeItem(element: SteeringItem): TreeItem {\n\t\treturn element;\n\t}",
    "start_line": 61,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTreeItem",
    "component_id": "src.providers.steering-explorer-provider.getTreeItem"
  },
  "src.providers.steering-explorer-provider.getChildren": {
    "id": "src.providers.steering-explorer-provider.getChildren",
    "name": "getChildren",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "async getChildren(element?: SteeringItem): Promise<SteeringItem[]> {\n\t\tif (!element) {\n\t\t\treturn this.getRootItems();\n\t\t}\n\n\t\tconst ws = workspace.workspaceFolders?.[0];\n\t\tif (!ws) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (element.contextValue === \"group-user\") {\n\t\t\treturn await this.getGroupUserItems();\n\t\t}\n\n\t\tif (element.contextValue === \"group-project\") {\n\t\t\treturn await this.getGroupProjectItems(ws.uri.fsPath);\n\t\t}\n\n\t\tif (element.contextValue === \"group-rules\") {\n\t\t\treturn await this.getGroupRulesItems(ws.uri);\n\t\t}\n\n\t\treturn [];\n\t}",
    "start_line": 65,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "element"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getChildren",
    "component_id": "src.providers.steering-explorer-provider.getChildren"
  },
  "src.providers.steering-explorer-provider.getRootItems": {
    "id": "src.providers.steering-explorer-provider.getRootItems",
    "name": "getRootItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private getRootItems(): SteeringItem[] {\n\t\treturn [\n\t\t\tnew SteeringItem({\n\t\t\t\tlabel: \"Rules\",\n\t\t\t\tcollapsibleState: TreeItemCollapsibleState.Expanded,\n\t\t\t\tcontextValue: \"group-project\",\n\t\t\t\tresourcePath: \"\",\n\t\t\t\tcontext: this.context,\n\t\t\t}),\n\t\t\tnew SteeringItem({\n\t\t\t\tlabel: \"Custom Instructions\",\n\t\t\t\tcollapsibleState: TreeItemCollapsibleState.Expanded,\n\t\t\t\tcontextValue: \"group-rules\",\n\t\t\t\tresourcePath: \"\",\n\t\t\t\tcontext: this.context,\n\t\t\t}),\n\t\t\tnew SteeringItem({\n\t\t\t\tlabel: \"User Instructions\",\n\t\t\t\tcollapsibleState: TreeItemCollapsibleState.Expanded,\n\t\t\t\tcontextValue: \"group-user\",\n\t\t\t\tresourcePath: \"\",\n\t\t\t\tcontext: this.context,\n\t\t\t}),\n\t\t];\n\t}",
    "start_line": 90,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRootItems",
    "component_id": "src.providers.steering-explorer-provider.getRootItems"
  },
  "src.providers.steering-explorer-provider.getGroupUserItems": {
    "id": "src.providers.steering-explorer-provider.getGroupUserItems",
    "name": "getGroupUserItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getGroupUserItems(): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\tconst globalCopilotMd = join(homeDir, \".github\", \"copilot-instructions.md\");\n\t\tif (await this.exists(globalCopilotMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Global Instructions\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"instruction-file\",\n\t\t\t\t\tresourcePath: globalCopilotMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(globalCopilotMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"copilot-instructions.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tconst rulesRoot = joinPath(Uri.file(homeDir), \".github\", \"instructions\");\n\t\titems.push(...(await this.getInstructionRules(rulesRoot)));\n\t\treturn items;\n\t}",
    "start_line": 116,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getGroupUserItems",
    "component_id": "src.providers.steering-explorer-provider.getGroupUserItems"
  },
  "src.providers.steering-explorer-provider.getGroupProjectItems": {
    "id": "src.providers.steering-explorer-provider.getGroupProjectItems",
    "name": "getGroupProjectItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getGroupProjectItems(\n\t\tworkspaceRoot: string\n\t): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\tconst specSystem = this.configManager.getSettings().specSystem;\n\n\t\t// Project Copilot Instructions\n\t\tconst projectCopilotMd = join(\n\t\t\tworkspaceRoot,\n\t\t\t\".github\",\n\t\t\t\"copilot-instructions.md\"\n\t\t);\n\t\tif (await this.exists(projectCopilotMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Project Instructions\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"instruction-file\",\n\t\t\t\t\tresourcePath: projectCopilotMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(projectCopilotMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \".github/copilot-instructions.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// Constitution\n\t\tconst constitutionMd = join(workspaceRoot, \".github\", \"constitution.md\");\n\t\tif (await this.exists(constitutionMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Constitution\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"constitution-file\",\n\t\t\t\t\tresourcePath: constitutionMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(constitutionMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"constitution.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// AGENTS.md\n\t\tconst agentsMd = join(workspaceRoot, \"AGENTS.md\");\n\t\tif (await this.exists(agentsMd)) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Rules (General)\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"agent-file\",\n\t\t\t\t\tresourcePath: agentsMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(agentsMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"AGENTS.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// OpenSpec AGENTS.md\n\t\tconst osAgentsMd = join(workspaceRoot, \"openspec\", \"AGENTS.md\");\n\t\tif (\n\t\t\tspecSystem === SPEC_SYSTEM_MODE.OPENSPEC &&\n\t\t\t(await this.exists(osAgentsMd))\n\t\t) {\n\t\t\titems.push(\n\t\t\t\tnew SteeringItem({\n\t\t\t\t\tlabel: \"Rules (OpenSpec)\",\n\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\tcontextValue: \"agent-file\",\n\t\t\t\t\tresourcePath: osAgentsMd,\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tcommand: {\n\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\targuments: [Uri.file(osAgentsMd)],\n\t\t\t\t\t},\n\t\t\t\t\tfilename: \"openspec/AGENTS.md\",\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\treturn items;\n\t}",
    "start_line": 142,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspaceRoot"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getGroupProjectItems",
    "component_id": "src.providers.steering-explorer-provider.getGroupProjectItems"
  },
  "src.providers.steering-explorer-provider.getGroupRulesItems": {
    "id": "src.providers.steering-explorer-provider.getGroupRulesItems",
    "name": "getGroupRulesItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getGroupRulesItems(workspaceUri: Uri): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\t// Project Instruction Rules (*.instructions.md)\n\t\tconst rulesRoot = joinPath(workspaceUri, \".github\", \"instructions\");\n\t\titems.push(...(await this.getInstructionRules(rulesRoot)));\n\t\treturn items;\n\t}",
    "start_line": 238,
    "end_line": 244,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspaceUri"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getGroupRulesItems",
    "component_id": "src.providers.steering-explorer-provider.getGroupRulesItems"
  },
  "src.providers.steering-explorer-provider.exists": {
    "id": "src.providers.steering-explorer-provider.exists",
    "name": "exists",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait workspace.fs.stat(Uri.file(path));\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}",
    "start_line": 246,
    "end_line": 253,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method exists",
    "component_id": "src.providers.steering-explorer-provider.exists"
  },
  "src.providers.steering-explorer-provider.getInstructionRules": {
    "id": "src.providers.steering-explorer-provider.getInstructionRules",
    "name": "getInstructionRules",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async getInstructionRules(root: Uri): Promise<SteeringItem[]> {\n\t\tconst items: SteeringItem[] = [];\n\t\ttry {\n\t\t\tconst entries = await workspace.fs.readDirectory(root);\n\t\t\tfor (const [name, type] of entries) {\n\t\t\t\tif (type === FileType.File && name.endsWith(INSTRUCTION_RULE_SUFFIX)) {\n\t\t\t\t\tconst displayName = await this.readDisplayName(\n\t\t\t\t\t\tjoinPath(root, name),\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\titems.push(\n\t\t\t\t\t\tnew SteeringItem({\n\t\t\t\t\t\t\tlabel: displayName,\n\t\t\t\t\t\t\tcollapsibleState: TreeItemCollapsibleState.None,\n\t\t\t\t\t\t\tcontextValue: \"instruction-rule\",\n\t\t\t\t\t\t\tresourcePath: join(root.fsPath, name),\n\t\t\t\t\t\t\tcontext: this.context,\n\t\t\t\t\t\t\tcommand: {\n\t\t\t\t\t\t\t\tcommand: \"vscode.open\",\n\t\t\t\t\t\t\t\ttitle: \"Open\",\n\t\t\t\t\t\t\t\targuments: [joinPath(root, name)],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfilename: name,\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn items;\n\t}",
    "start_line": 255,
    "end_line": 286,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getInstructionRules",
    "component_id": "src.providers.steering-explorer-provider.getInstructionRules"
  },
  "src.providers.steering-explorer-provider.readDisplayName": {
    "id": "src.providers.steering-explorer-provider.readDisplayName",
    "name": "readDisplayName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private async readDisplayName(uri: Uri, filename: string): Promise<string> {\n\t\ttry {\n\t\t\t// Read first 1KB to find frontmatter or H1\n\t\t\tconst fileData = await workspace.fs.readFile(uri);\n\t\t\tconst content = new TextDecoder().decode(fileData.slice(0, 1024));\n\n\t\t\t// 1. Try Frontmatter name: ...\n\t\t\tconst frontmatterMatch = FRONTMATTER_REGEXP.exec(content);\n\t\t\tif (frontmatterMatch?.[1]) {\n\t\t\t\treturn frontmatterMatch[1].trim();\n\t\t\t}\n\n\t\t\t// 2. Try H1: # Title\n\t\t\tconst h1Match = H1_REGEXP.exec(content);\n\t\t\tif (h1Match?.[1]) {\n\t\t\t\treturn h1Match[1].trim();\n\t\t\t}\n\n\t\t\t// 3. Fallback: Normalize filename\n\t\t\treturn this.normalizeName(filename);\n\t\t} catch {\n\t\t\treturn this.normalizeName(filename);\n\t\t}\n\t}",
    "start_line": 288,
    "end_line": 311,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "filename"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method readDisplayName",
    "component_id": "src.providers.steering-explorer-provider.readDisplayName"
  },
  "src.providers.steering-explorer-provider.normalizeName": {
    "id": "src.providers.steering-explorer-provider.normalizeName",
    "name": "normalizeName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "private normalizeName(name: string): string {\n\t\t// Remove suffix and extension\n\t\tconst normalized = name.replace(INSTRUCTION_RULE_SUFFIX, \"\");\n\t\t// Kebab/Snake to Title Case\n\t\treturn normalized\n\t\t\t.split(SEPARATOR_REGEXP)\n\t\t\t.map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n\t\t\t.join(\" \");\n\t}",
    "start_line": 313,
    "end_line": 321,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method normalizeName",
    "component_id": "src.providers.steering-explorer-provider.normalizeName"
  },
  "src.providers.steering-explorer-provider.SteeringItemOptions": {
    "id": "src.providers.steering-explorer-provider.SteeringItemOptions",
    "name": "SteeringItemOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [],
    "source_code": "interface SteeringItemOptions {\n\tlabel: string;\n\tcollapsibleState: TreeItemCollapsibleState;\n\tcontextValue: string;\n\tresourcePath: string;\n\tcontext: ExtensionContext;\n\tcommand?: Command;\n\tfilename?: string;\n}",
    "start_line": 324,
    "end_line": 332,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SteeringItemOptions",
    "component_id": "src.providers.steering-explorer-provider.SteeringItemOptions"
  },
  "src.providers.steering-explorer-provider.SteeringItem": {
    "id": "src.providers.steering-explorer-provider.SteeringItem",
    "name": "SteeringItem",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/steering-explorer-provider.ts",
    "relative_path": "src/providers/steering-explorer-provider.ts",
    "depends_on": [
      "src.providers.steering-explorer-provider.SteeringItemOptions"
    ],
    "source_code": "class SteeringItem extends TreeItem {\n\treadonly label: string;\n\treadonly collapsibleState: TreeItemCollapsibleState;\n\treadonly contextValue: string;\n\treadonly resourcePath: string;\n\treadonly command?: Command;\n\treadonly filename?: string;\n\tprivate readonly context: ExtensionContext;\n\n\tconstructor(options: SteeringItemOptions) {\n\t\tsuper(options.label, options.collapsibleState);\n\t\tthis.label = options.label;\n\t\tthis.collapsibleState = options.collapsibleState;\n\t\tthis.contextValue = options.contextValue;\n\t\tthis.resourcePath = options.resourcePath;\n\t\tthis.context = options.context;\n\t\tthis.command = options.command;\n\t\tthis.filename = options.filename;\n\n\t\tthis.resourceUri = options.resourcePath\n\t\t\t? Uri.file(options.resourcePath)\n\t\t\t: undefined;\n\t\tthis.description = options.filename;\n\n\t\tif (options.contextValue === \"group-user\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"account\");\n\t\t} else if (options.contextValue === \"group-project\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"folder-active\");\n\t\t} else if (options.contextValue === \"group-rules\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"folder-library\");\n\t\t} else if (\n\t\t\toptions.contextValue === \"instruction-file\" ||\n\t\t\toptions.contextValue === \"instruction-rule\"\n\t\t) {\n\t\t\tthis.iconPath = new ThemeIcon(\"book\");\n\t\t} else if (options.contextValue === \"agent-file\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"robot\");\n\t\t} else if (options.contextValue === \"constitution-file\") {\n\t\t\tthis.iconPath = new ThemeIcon(\"law\");\n\t\t}\n\t}\n}",
    "start_line": 334,
    "end_line": 375,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SteeringItem",
    "component_id": "src.providers.steering-explorer-provider.SteeringItem"
  },
  "src.providers.welcome-screen-provider.WelcomeScreenProvider": {
    "id": "src.providers.welcome-screen-provider.WelcomeScreenProvider",
    "name": "WelcomeScreenProvider",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [
      "src.services.system-diagnostics.getRecentDiagnostics",
      "src.utils.workspace-state.getDontShowOnStartup",
      "src.services.dependency-checker.checkAll",
      "src.providers.welcome-screen-provider.getFeatureActions",
      "src.services.system-diagnostics.SystemDiagnostics",
      "src.services.learning-resources.searchByKeyword",
      "src.services.learning-resources.LearningResources",
      "src.providers.welcome-screen-provider.openExternal",
      "src.panels.welcome-screen-panel.WelcomeScreenPanelCallbacks",
      "src.providers.welcome-screen-provider.getWelcomeState",
      "src.providers.welcome-screen-provider.refreshDependencies",
      "src.providers.welcome-screen-provider.sendError",
      "src.services.dependency-checker.DependencyChecker",
      "src.services.dependency-checker.invalidateCache",
      "ui.src.features.welcome.types.FeatureAction",
      "src.providers.welcome-screen-provider.updateConfiguration",
      "src.panels.welcome-screen-panel.WelcomeScreenPanel",
      "src.types.welcome.WelcomeErrorCodeType",
      "src.providers.welcome-screen-provider.installDependency",
      "src.utils.workspace-state.getWelcomeState",
      "src.features.agents.resource-cache.get",
      "src.services.learning-resources.getAll",
      "ui.src.features.welcome.types.ConfigurationState",
      "src.panels.welcome-screen-panel.postMessage",
      "src.services.learning-resources.loadResources",
      "src.providers.welcome-screen-provider.isEditableConfigKey",
      "src.services.learning-resources.isLoaded",
      "src.providers.welcome-screen-provider.recordError",
      "src.providers.welcome-screen-provider.getConfiguration",
      "src.utils.workspace-state.hasShownWelcomeBefore",
      "src.providers.welcome-screen-provider.executeCommand",
      "src.services.configuration-service.getConfiguration",
      "ui.src.features.welcome.types.WelcomeScreenState",
      "ui.src.features.welcome.types.LearningResource",
      "src.services.system-diagnostics.recordError"
    ],
    "source_code": "class WelcomeScreenProvider {\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly dependencyChecker: DependencyChecker;\n\tprivate readonly systemDiagnostics: SystemDiagnostics;\n\tprivate readonly learningResources: LearningResources;\n\n\tconstructor(context: ExtensionContext, outputChannel: OutputChannel) {\n\t\tthis.context = context;\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.dependencyChecker = new DependencyChecker(outputChannel);\n\t\tthis.systemDiagnostics = new SystemDiagnostics();\n\t\tthis.learningResources = new LearningResources();\n\t}\n\n\t/**\n\t * Get complete welcome screen state\n\t *\n\t * Aggregates all necessary data for rendering the welcome screen, including:\n\t * - First-time activation status\n\t * - User preference for showing on startup\n\t * - Current view selection\n\t * - Dependency status with version information\n\t * - Editable configuration settings\n\t * - Recent system diagnostics (last 5 from 24 hours)\n\t * - Learning resources catalog\n\t * - Available feature actions\n\t * - Extension and VS Code version information\n\t *\n\t * @returns Complete state object for welcome screen rendering\n\t * @throws Never throws - handles all errors internally with OutputChannel logging\n\t *\n\t * @performance Typically completes in <100ms. Uses parallel Promise.all for efficiency.\n\t * @caching DependencyChecker caches results for 60 seconds\n\t *\n\t * @example\n\t * ```typescript\n\t * const state = await provider.getWelcomeState();\n\t * panel.postMessage({ type: 'welcome/state', ...state });\n\t * ```\n\t */\n\tasync getWelcomeState(): Promise<WelcomeScreenState> {\n\t\tconst dependencies = await this.dependencyChecker.checkAll();\n\t\tconst configuration = this.getConfiguration();\n\n\t\t// Lazily load learning resources\n\t\tthis.learningResources.loadResources(this.context.extensionPath);\n\n\t\t// Get extension version from package.json\n\t\tconst extensionVersion =\n\t\t\tthis.context.extension?.packageJSON?.version || \"0.25.6\";\n\n\t\treturn {\n\t\t\thasShownBefore: hasShownWelcomeBefore(this.context),\n\t\t\tdontShowOnStartup: getDontShowOnStartup(this.context),\n\t\t\tcurrentView: \"setup\",\n\t\t\textensionVersion,\n\t\t\tvscodeVersion: version,\n\t\t\tdependencies,\n\t\t\tconfiguration,\n\t\t\tdiagnostics: this.systemDiagnostics.getRecentDiagnostics(),\n\t\t\tlearningResources: this.learningResources.getAll(),\n\t\t\tfeatureActions: this.getFeatureActions(),\n\t\t};\n\t}\n\n\t/**\n\t * Update configuration value\n\t * Validates key is editable and persists to VS Code settings\n\t */\n\tasync updateConfiguration(\n\t\tkey: string,\n\t\tvalue: string | boolean,\n\t\tpanel: WelcomeScreenPanel\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// Validate key is editable\n\t\t\tif (!this.isEditableConfigKey(key)) {\n\t\t\t\tthis.systemDiagnostics.recordError(\n\t\t\t\t\t\"error\",\n\t\t\t\t\t`Invalid configuration key: ${key}`,\n\t\t\t\t\t\"config-updates\",\n\t\t\t\t\t`Only spec system-related settings can be modified: ${EDITABLE_CONFIG_KEYS.join(\", \")}`\n\t\t\t\t);\n\t\t\t\tawait this.sendError(\n\t\t\t\t\tpanel,\n\t\t\t\t\tWelcomeErrorCode.INVALID_CONFIG_KEY,\n\t\t\t\t\t`Configuration key '${key}' is not editable from welcome screen`,\n\t\t\t\t\t`Only spec system-related settings can be modified: ${EDITABLE_CONFIG_KEYS.join(\", \")}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate value type (path configurations must be strings)\n\t\t\tif (key.toLowerCase().includes(\"path\") && typeof value !== \"string\") {\n\t\t\t\tthis.systemDiagnostics.recordError(\n\t\t\t\t\t\"error\",\n\t\t\t\t\t`Invalid configuration value type for ${key}`,\n\t\t\t\t\t\"config-updates\",\n\t\t\t\t\t\"Path configuration must be a string\"\n\t\t\t\t);\n\t\t\t\tawait this.sendError(\n\t\t\t\t\tpanel,\n\t\t\t\t\tWelcomeErrorCode.INVALID_CONFIG_VALUE,\n\t\t\t\t\t`Path configuration '${key}' must be a string`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get configuration and update\n\t\t\tconst config = workspace.getConfiguration();\n\t\t\tawait config.update(key, value, ConfigurationTarget.Workspace);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Updated configuration: ${key} = ${value}`\n\t\t\t);\n\n\t\t\t// Send confirmation to webview\n\t\t\tawait panel.postMessage({\n\t\t\t\ttype: \"welcome/config-updated\",\n\t\t\t\tkey,\n\t\t\t\tnewValue: value,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconst errorMessage =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Configuration update failed: ${errorMessage}`\n\t\t\t);\n\t\t\tthis.systemDiagnostics.recordError(\n\t\t\t\t\"error\",\n\t\t\t\t`Failed to update configuration ${key}`,\n\t\t\t\t\"config-updates\",\n\t\t\t\terrorMessage\n\t\t\t);\n\t\t\tawait this.sendError(\n\t\t\t\tpanel,\n\t\t\t\tWelcomeErrorCode.CONFIG_UPDATE_FAILED,\n\t\t\t\t\"Failed to update configuration\",\n\t\t\t\terrorMessage\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Execute VS Code command\n\t */\n\tasync executeCommand(\n\t\tcommandId: string,\n\t\targs: unknown[],\n\t\tpanel: WelcomeScreenPanel\n\t): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Executing command: ${commandId}`\n\t\t\t);\n\t\t\tawait commands.executeCommand(commandId, ...args);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Command execution failed: ${error}`\n\t\t\t);\n\t\t\tawait this.sendError(\n\t\t\t\tpanel,\n\t\t\t\tWelcomeErrorCode.COMMAND_EXECUTION_FAILED,\n\t\t\t\t`Failed to execute command: ${commandId}`,\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Handle dependency install action\n\t */\n\tasync installDependency(\n\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\",\n\t\tpanel: WelcomeScreenPanel\n\t): Promise<void> {\n\t\tswitch (dependency) {\n\t\t\tcase \"copilot-chat\":\n\t\t\t\t// Open Extensions marketplace\n\t\t\t\tawait commands.executeCommand(\n\t\t\t\t\t\"workbench.extensions.search\",\n\t\t\t\t\t\"@id:github.copilot-chat\"\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase \"speckit\":\n\t\t\t\t// Copy install command to clipboard\n\t\t\t\tawait env.clipboard.writeText(\n\t\t\t\t\t\"uv tool install specify-cli --from git+https://github.com/github/spec-kit.git\"\n\t\t\t\t);\n\t\t\t\twindow\n\t\t\t\t\t.showInformationMessage(\n\t\t\t\t\t\t\"SpecKit CLI install command copied to clipboard. Paste and run in your terminal.\",\n\t\t\t\t\t\t\"Open Terminal\"\n\t\t\t\t\t)\n\t\t\t\t\t.then((selection) => {\n\t\t\t\t\t\tif (selection === \"Open Terminal\") {\n\t\t\t\t\t\t\tcommands.executeCommand(\"workbench.action.terminal.new\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase \"openspec\":\n\t\t\t\t// Copy install command to clipboard\n\t\t\t\tawait env.clipboard.writeText(\n\t\t\t\t\t\"npm install -g @fission-ai/openspec@latest\"\n\t\t\t\t);\n\t\t\t\twindow\n\t\t\t\t\t.showInformationMessage(\n\t\t\t\t\t\t\"OpenSpec CLI install command copied to clipboard. Paste and run in your terminal.\",\n\t\t\t\t\t\t\"Open Terminal\"\n\t\t\t\t\t)\n\t\t\t\t\t.then((selection) => {\n\t\t\t\t\t\tif (selection === \"Open Terminal\") {\n\t\t\t\t\t\t\tcommands.executeCommand(\"workbench.action.terminal.new\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Should never reach here due to TypeScript type checking\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Unknown dependency: ${dependency}`\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Refresh dependency status (invalidate cache and re-check)\n\t */\n\tasync refreshDependencies(panel: WelcomeScreenPanel): Promise<void> {\n\t\tthis.dependencyChecker.invalidateCache();\n\t\tconst dependencies = await this.dependencyChecker.checkAll(true);\n\n\t\tawait panel.postMessage({\n\t\t\ttype: \"welcome/dependency-status\",\n\t\t\t...dependencies,\n\t\t});\n\t}\n\n\t/**\n\t * Open external URL with validation\n\t */\n\tasync openExternal(url: string): Promise<void> {\n\t\ttry {\n\t\t\t// Validate HTTPS only\n\t\t\tif (!url.startsWith(\"https://\")) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Blocked non-HTTPS URL: ${url}`\n\t\t\t\t);\n\t\t\t\twindow.showWarningMessage(\"Only HTTPS URLs can be opened for security\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait env.openExternal(Uri.parse(url));\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Opened external URL: ${url}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Failed to open URL: ${error}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Search learning resources by keyword\n\t */\n\tsearchResources(query: string): LearningResource[] {\n\t\t// Ensure resources are loaded before searching\n\t\tif (!this.learningResources.isLoaded()) {\n\t\t\tthis.learningResources.loadResources(this.context.extensionPath);\n\t\t}\n\t\treturn this.learningResources.searchByKeyword(query);\n\t}\n\n\t/**\n\t * Record error for diagnostics\n\t */\n\trecordError(\n\t\tseverity: \"error\" | \"warning\",\n\t\tmessage: string,\n\t\tsource: string,\n\t\tsuggestedAction?: string\n\t): void {\n\t\tthis.systemDiagnostics.recordError(\n\t\t\tseverity,\n\t\t\tmessage,\n\t\t\tsource,\n\t\t\tsuggestedAction\n\t\t);\n\t}\n\n\t/**\n\t * Get system diagnostics service (for external use)\n\t */\n\tgetSystemDiagnostics(): SystemDiagnostics {\n\t\treturn this.systemDiagnostics;\n\t}\n\n\t/**\n\t * Get configuration state for welcome screen\n\t */\n\tprivate getConfiguration(): ConfigurationState {\n\t\tconst config = workspace.getConfiguration(\"gatomia\");\n\n\t\treturn {\n\t\t\tspecSystem: {\n\t\t\t\tkey: \"gatomia.specSystem\",\n\t\t\t\tlabel: \"Spec System\",\n\t\t\t\tcurrentValue: (config.get<string>(\"specSystem\") || \"auto\") as\n\t\t\t\t\t| \"auto\"\n\t\t\t\t\t| \"speckit\"\n\t\t\t\t\t| \"openspec\",\n\t\t\t\toptions: [\"auto\", \"speckit\", \"openspec\"],\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tspeckitSpecsPath: {\n\t\t\t\tkey: \"gatomia.speckit.specsPath\",\n\t\t\t\tlabel: \"SpecKit Specs Path\",\n\t\t\t\tcurrentValue: config.get<string>(\"speckit.specsPath\") || \"specs\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tspeckitMemoryPath: {\n\t\t\t\tkey: \"gatomia.speckit.memoryPath\",\n\t\t\t\tlabel: \"SpecKit Memory Path\",\n\t\t\t\tcurrentValue:\n\t\t\t\t\tconfig.get<string>(\"speckit.memoryPath\") || \".specify/memory\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tspeckitTemplatesPath: {\n\t\t\t\tkey: \"gatomia.speckit.templatesPath\",\n\t\t\t\tlabel: \"SpecKit Templates Path\",\n\t\t\t\tcurrentValue:\n\t\t\t\t\tconfig.get<string>(\"speckit.templatesPath\") || \".specify/templates\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\topenspecPath: {\n\t\t\t\tkey: \"gatomia.openspec.path\",\n\t\t\t\tlabel: \"OpenSpec Path\",\n\t\t\t\tcurrentValue: config.get<string>(\"openspec.path\") || \".openspec\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tpromptsPath: {\n\t\t\t\tkey: \"gatomia.prompts.path\",\n\t\t\t\tlabel: \"Prompts Path\",\n\t\t\t\tcurrentValue: config.get<string>(\"prompts.path\") || \".prompts\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\totherSettings: [],\n\t\t};\n\t}\n\n\t/**\n\t * Get feature actions for welcome screen\n\t */\n\tprivate getFeatureActions(): FeatureAction[] {\n\t\treturn [\n\t\t\t// Specs (T046)\n\t\t\t{\n\t\t\t\tid: \"create-spec\",\n\t\t\t\tfeatureArea: \"Specs\",\n\t\t\t\tlabel: \"Create New Spec\",\n\t\t\t\tdescription: \"Start a new specification document\",\n\t\t\t\tcommandId: \"gatomia.spec.create\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-file-add\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"view-specs\",\n\t\t\t\tfeatureArea: \"Specs\",\n\t\t\t\tlabel: \"Refresh Specs\",\n\t\t\t\tdescription: \"Reload specification list\",\n\t\t\t\tcommandId: \"gatomia.spec.refresh\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-refresh\",\n\t\t\t},\n\t\t\t// Actions (T047)\n\t\t\t{\n\t\t\t\tid: \"create-prompt\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Create Prompt\",\n\t\t\t\tdescription: \"Create a new custom prompt file\",\n\t\t\t\tcommandId: \"gatomia.actions.create\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-add\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"create-agent\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Create Agent\",\n\t\t\t\tdescription: \"Create a new agent definition file\",\n\t\t\t\tcommandId: \"gatomia.actions.createAgentFile\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-robot\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"create-skill\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Create Skill\",\n\t\t\t\tdescription: \"Create a new reusable skill directory\",\n\t\t\t\tcommandId: \"gatomia.actions.createSkill\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-tools\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"refresh-actions\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Refresh Actions\",\n\t\t\t\tdescription: \"Reload actions from workspace\",\n\t\t\t\tcommandId: \"gatomia.actions.refresh\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-refresh\",\n\t\t\t},\n\t\t\t// Hooks (T048)\n\t\t\t{\n\t\t\t\tid: \"add-hook\",\n\t\t\t\tfeatureArea: \"Hooks\",\n\t\t\t\tlabel: \"Add Hook\",\n\t\t\t\tdescription: \"Create a new automation hook\",\n\t\t\t\tcommandId: \"gatomia.hooks.addHook\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-add\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"view-hook-logs\",\n\t\t\t\tfeatureArea: \"Hooks\",\n\t\t\t\tlabel: \"View Hook Logs\",\n\t\t\t\tdescription: \"Check hook execution history\",\n\t\t\t\tcommandId: \"gatomia.hooks.viewLogs\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-output\",\n\t\t\t},\n\t\t\t// Steering (T049)\n\t\t\t{\n\t\t\t\tid: \"create-project-rule\",\n\t\t\t\tfeatureArea: \"Steering\",\n\t\t\t\tlabel: \"Create Project Rule\",\n\t\t\t\tdescription: \"Define project-level steering rules\",\n\t\t\t\tcommandId: \"gatomia.steering.createProjectRule\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-folder\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"create-user-rule\",\n\t\t\t\tfeatureArea: \"Steering\",\n\t\t\t\tlabel: \"Create User Rule\",\n\t\t\t\tdescription: \"Define user-level steering rules\",\n\t\t\t\tcommandId: \"gatomia.steering.createUserRule\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-person\",\n\t\t\t},\n\t\t];\n\t}\n\n\t/**\n\t * Get panel callbacks for WelcomeScreenPanel\n\t * T028-T032: Implement callbacks with panel interaction using lazy evaluation\n\t */\n\tgetCallbacks(): import(\"../panels/welcome-screen-panel\").WelcomeScreenPanelCallbacks {\n\t\t// Panel will be set by the caller via a closure\n\t\tlet panelRef: WelcomeScreenPanel | null = null;\n\n\t\t// Helper to get panel (will be set after panel creation)\n\t\tconst getPanel = () => {\n\t\t\tif (!panelRef) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"[WelcomeScreenProvider] Panel reference not set in callbacks\"\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn panelRef;\n\t\t};\n\n\t\tconst callbacks = {\n\t\t\tonReady: async () => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[WelcomeScreenProvider] Webview ready, sending initial state\"\n\t\t\t\t);\n\n\t\t\t\t// Wait for panel reference to be set (race condition guard)\n\t\t\t\tif (!panelRef) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\"[WelcomeScreenProvider] Panel not yet set, waiting...\"\n\t\t\t\t\t);\n\t\t\t\t\t// Poll for panel with timeout\n\t\t\t\t\tconst maxAttempts = 50; // 5 seconds total\n\t\t\t\t\tfor (let i = 0; i < maxAttempts; i++) {\n\t\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t\t\t\tif (panelRef) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!panelRef) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\"[WelcomeScreenProvider] ERROR: Panel reference never set!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// T032: Send welcome/state message with initial data\n\t\t\t\tconst state = await this.getWelcomeState();\n\t\t\t\tawait getPanel().postMessage({\n\t\t\t\t\ttype: \"welcome/state\",\n\t\t\t\t\t...state,\n\t\t\t\t});\n\t\t\t},\n\t\t\tonExecuteCommand: async (commandId: string, args?: unknown[]) => {\n\t\t\t\t// T052: OutputChannel logging for command execution\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Execute command: ${commandId}`\n\t\t\t\t);\n\t\t\t\ttry {\n\t\t\t\t\t// T050: Execute command via commands.executeCommand\n\t\t\t\t\tawait commands.executeCommand(commandId, ...(args || []));\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[WelcomeScreenProvider] Command executed successfully: ${commandId}`\n\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// T051: Error handling for failed command execution\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[WelcomeScreenProvider] Command execution failed: ${commandId} - ${message}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Send user-facing error message\n\t\t\t\t\tawait getPanel().postMessage({\n\t\t\t\t\t\ttype: \"welcome/error\",\n\t\t\t\t\t\tcode: WelcomeErrorCode.COMMAND_EXECUTION_FAILED,\n\t\t\t\t\t\tmessage: `Failed to execute command: ${commandId}`,\n\t\t\t\t\t\tcontext: message,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Show notification to user\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`Failed to execute command \"${commandId}\": ${message}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonUpdateConfig: async (key: string, value: string | boolean) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Update config: ${key} = ${value}`\n\t\t\t\t);\n\t\t\t\tawait this.updateConfiguration(key, value, getPanel());\n\t\t\t},\n\t\t\t// T030: Handle welcome/install-dependency message\n\t\t\tonInstallDependency: async (\n\t\t\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\"\n\t\t\t) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Install dependency: ${dependency}`\n\t\t\t\t);\n\t\t\t\tawait this.installDependency(dependency, getPanel());\n\t\t\t},\n\t\t\t// T031: Handle welcome/refresh-dependencies message\n\t\t\tonRefreshDependencies: async () => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[WelcomeScreenProvider] Refresh dependencies (T028)\"\n\t\t\t\t);\n\t\t\t\tawait this.refreshDependencies(getPanel());\n\t\t\t},\n\t\t\tonOpenExternal: async (url: string) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Open external: ${url}`\n\t\t\t\t);\n\t\t\t\tawait this.openExternal(url);\n\t\t\t},\n\t\t\t// T121: Handle welcome/update-preference message\n\t\t\tonUpdatePreference: async (\n\t\t\t\tpreference: \"dontShowOnStartup\",\n\t\t\t\tvalue: boolean\n\t\t\t) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Update preference: ${preference} = ${value}`\n\t\t\t\t);\n\t\t\t\t// Store preference in workspace state\n\t\t\t\tawait this.context.workspaceState.update(\n\t\t\t\t\t\"gatomia.welcomeScreen.dontShowOnStartup\",\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t},\n\t\t\t// T129: Handle welcome/navigate-section message for telemetry\n\t\t\tonNavigateSection: (section: string) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Navigate to section: ${section}`\n\t\t\t\t);\n\t\t\t\t// T128: Telemetry logging if enabled\n\t\t\t\t// Placeholder for future telemetry implementation\n\t\t\t},\n\t\t\t// Handle welcome/search-resources message\n\t\t\tonSearchResources: (query: string) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Search resources: ${query}`\n\t\t\t\t);\n\t\t\t\t// Placeholder for future search implementation\n\t\t\t},\n\t\t\t// Setter for panel reference (called by extension.ts after panel creation)\n\t\t\tsetPanel: (panel: WelcomeScreenPanel) => {\n\t\t\t\tpanelRef = panel;\n\t\t\t},\n\t\t};\n\n\t\treturn callbacks;\n\t}\n\n\t/**\n\t * Check if configuration key is editable\n\t */\n\tprivate isEditableConfigKey(key: string): boolean {\n\t\treturn EDITABLE_CONFIG_KEYS.includes(key as any);\n\t}\n\n\t/**\n\t * Send error message to webview\n\t */\n\tprivate async sendError(\n\t\tpanel: WelcomeScreenPanel,\n\t\tcode: WelcomeErrorCodeType,\n\t\tmessage: string,\n\t\tcontext?: string\n\t): Promise<void> {\n\t\tawait panel.postMessage({\n\t\t\ttype: \"welcome/error\",\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\tcontext,\n\t\t});\n\t}\n}",
    "start_line": 68,
    "end_line": 697,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class WelcomeScreenProvider",
    "component_id": "src.providers.welcome-screen-provider.WelcomeScreenProvider"
  },
  "src.providers.welcome-screen-provider.getWelcomeState": {
    "id": "src.providers.welcome-screen-provider.getWelcomeState",
    "name": "getWelcomeState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "async getWelcomeState(): Promise<WelcomeScreenState> {\n\t\tconst dependencies = await this.dependencyChecker.checkAll();\n\t\tconst configuration = this.getConfiguration();\n\n\t\t// Lazily load learning resources\n\t\tthis.learningResources.loadResources(this.context.extensionPath);\n\n\t\t// Get extension version from package.json\n\t\tconst extensionVersion =\n\t\t\tthis.context.extension?.packageJSON?.version || \"0.25.6\";\n\n\t\treturn {\n\t\t\thasShownBefore: hasShownWelcomeBefore(this.context),\n\t\t\tdontShowOnStartup: getDontShowOnStartup(this.context),\n\t\t\tcurrentView: \"setup\",\n\t\t\textensionVersion,\n\t\t\tvscodeVersion: version,\n\t\t\tdependencies,\n\t\t\tconfiguration,\n\t\t\tdiagnostics: this.systemDiagnostics.getRecentDiagnostics(),\n\t\t\tlearningResources: this.learningResources.getAll(),\n\t\t\tfeatureActions: this.getFeatureActions(),\n\t\t};\n\t}",
    "start_line": 109,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getWelcomeState",
    "component_id": "src.providers.welcome-screen-provider.getWelcomeState"
  },
  "src.providers.welcome-screen-provider.updateConfiguration": {
    "id": "src.providers.welcome-screen-provider.updateConfiguration",
    "name": "updateConfiguration",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "async updateConfiguration(\n\t\tkey: string,\n\t\tvalue: string | boolean,\n\t\tpanel: WelcomeScreenPanel\n\t): Promise<void> {\n\t\ttry {\n\t\t\t// Validate key is editable\n\t\t\tif (!this.isEditableConfigKey(key)) {\n\t\t\t\tthis.systemDiagnostics.recordError(\n\t\t\t\t\t\"error\",\n\t\t\t\t\t`Invalid configuration key: ${key}`,\n\t\t\t\t\t\"config-updates\",\n\t\t\t\t\t`Only spec system-related settings can be modified: ${EDITABLE_CONFIG_KEYS.join(\", \")}`\n\t\t\t\t);\n\t\t\t\tawait this.sendError(\n\t\t\t\t\tpanel,\n\t\t\t\t\tWelcomeErrorCode.INVALID_CONFIG_KEY,\n\t\t\t\t\t`Configuration key '${key}' is not editable from welcome screen`,\n\t\t\t\t\t`Only spec system-related settings can be modified: ${EDITABLE_CONFIG_KEYS.join(\", \")}`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate value type (path configurations must be strings)\n\t\t\tif (key.toLowerCase().includes(\"path\") && typeof value !== \"string\") {\n\t\t\t\tthis.systemDiagnostics.recordError(\n\t\t\t\t\t\"error\",\n\t\t\t\t\t`Invalid configuration value type for ${key}`,\n\t\t\t\t\t\"config-updates\",\n\t\t\t\t\t\"Path configuration must be a string\"\n\t\t\t\t);\n\t\t\t\tawait this.sendError(\n\t\t\t\t\tpanel,\n\t\t\t\t\tWelcomeErrorCode.INVALID_CONFIG_VALUE,\n\t\t\t\t\t`Path configuration '${key}' must be a string`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get configuration and update\n\t\t\tconst config = workspace.getConfiguration();\n\t\t\tawait config.update(key, value, ConfigurationTarget.Workspace);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Updated configuration: ${key} = ${value}`\n\t\t\t);\n\n\t\t\t// Send confirmation to webview\n\t\t\tawait panel.postMessage({\n\t\t\t\ttype: \"welcome/config-updated\",\n\t\t\t\tkey,\n\t\t\t\tnewValue: value,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconst errorMessage =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Configuration update failed: ${errorMessage}`\n\t\t\t);\n\t\t\tthis.systemDiagnostics.recordError(\n\t\t\t\t\"error\",\n\t\t\t\t`Failed to update configuration ${key}`,\n\t\t\t\t\"config-updates\",\n\t\t\t\terrorMessage\n\t\t\t);\n\t\t\tawait this.sendError(\n\t\t\t\tpanel,\n\t\t\t\tWelcomeErrorCode.CONFIG_UPDATE_FAILED,\n\t\t\t\t\"Failed to update configuration\",\n\t\t\t\terrorMessage\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 138,
    "end_line": 210,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "key",
      "value",
      "panel"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method updateConfiguration",
    "component_id": "src.providers.welcome-screen-provider.updateConfiguration"
  },
  "src.providers.welcome-screen-provider.executeCommand": {
    "id": "src.providers.welcome-screen-provider.executeCommand",
    "name": "executeCommand",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "async executeCommand(\n\t\tcommandId: string,\n\t\targs: unknown[],\n\t\tpanel: WelcomeScreenPanel\n\t): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Executing command: ${commandId}`\n\t\t\t);\n\t\t\tawait commands.executeCommand(commandId, ...args);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Command execution failed: ${error}`\n\t\t\t);\n\t\t\tawait this.sendError(\n\t\t\t\tpanel,\n\t\t\t\tWelcomeErrorCode.COMMAND_EXECUTION_FAILED,\n\t\t\t\t`Failed to execute command: ${commandId}`,\n\t\t\t\terror instanceof Error ? error.message : String(error)\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 215,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commandId",
      "args",
      "panel"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method executeCommand",
    "component_id": "src.providers.welcome-screen-provider.executeCommand"
  },
  "src.providers.welcome-screen-provider.installDependency": {
    "id": "src.providers.welcome-screen-provider.installDependency",
    "name": "installDependency",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "async installDependency(\n\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\",\n\t\tpanel: WelcomeScreenPanel\n\t): Promise<void> {\n\t\tswitch (dependency) {\n\t\t\tcase \"copilot-chat\":\n\t\t\t\t// Open Extensions marketplace\n\t\t\t\tawait commands.executeCommand(\n\t\t\t\t\t\"workbench.extensions.search\",\n\t\t\t\t\t\"@id:github.copilot-chat\"\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase \"speckit\":\n\t\t\t\t// Copy install command to clipboard\n\t\t\t\tawait env.clipboard.writeText(\n\t\t\t\t\t\"uv tool install specify-cli --from git+https://github.com/github/spec-kit.git\"\n\t\t\t\t);\n\t\t\t\twindow\n\t\t\t\t\t.showInformationMessage(\n\t\t\t\t\t\t\"SpecKit CLI install command copied to clipboard. Paste and run in your terminal.\",\n\t\t\t\t\t\t\"Open Terminal\"\n\t\t\t\t\t)\n\t\t\t\t\t.then((selection) => {\n\t\t\t\t\t\tif (selection === \"Open Terminal\") {\n\t\t\t\t\t\t\tcommands.executeCommand(\"workbench.action.terminal.new\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase \"openspec\":\n\t\t\t\t// Copy install command to clipboard\n\t\t\t\tawait env.clipboard.writeText(\n\t\t\t\t\t\"npm install -g @fission-ai/openspec@latest\"\n\t\t\t\t);\n\t\t\t\twindow\n\t\t\t\t\t.showInformationMessage(\n\t\t\t\t\t\t\"OpenSpec CLI install command copied to clipboard. Paste and run in your terminal.\",\n\t\t\t\t\t\t\"Open Terminal\"\n\t\t\t\t\t)\n\t\t\t\t\t.then((selection) => {\n\t\t\t\t\t\tif (selection === \"Open Terminal\") {\n\t\t\t\t\t\t\tcommands.executeCommand(\"workbench.action.terminal.new\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Should never reach here due to TypeScript type checking\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Unknown dependency: ${dependency}`\n\t\t\t\t);\n\t\t}\n\t}",
    "start_line": 241,
    "end_line": 293,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dependency",
      "panel"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method installDependency",
    "component_id": "src.providers.welcome-screen-provider.installDependency"
  },
  "src.providers.welcome-screen-provider.refreshDependencies": {
    "id": "src.providers.welcome-screen-provider.refreshDependencies",
    "name": "refreshDependencies",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "async refreshDependencies(panel: WelcomeScreenPanel): Promise<void> {\n\t\tthis.dependencyChecker.invalidateCache();\n\t\tconst dependencies = await this.dependencyChecker.checkAll(true);\n\n\t\tawait panel.postMessage({\n\t\t\ttype: \"welcome/dependency-status\",\n\t\t\t...dependencies,\n\t\t});\n\t}",
    "start_line": 298,
    "end_line": 306,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "panel"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method refreshDependencies",
    "component_id": "src.providers.welcome-screen-provider.refreshDependencies"
  },
  "src.providers.welcome-screen-provider.openExternal": {
    "id": "src.providers.welcome-screen-provider.openExternal",
    "name": "openExternal",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "async openExternal(url: string): Promise<void> {\n\t\ttry {\n\t\t\t// Validate HTTPS only\n\t\t\tif (!url.startsWith(\"https://\")) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Blocked non-HTTPS URL: ${url}`\n\t\t\t\t);\n\t\t\t\twindow.showWarningMessage(\"Only HTTPS URLs can be opened for security\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait env.openExternal(Uri.parse(url));\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Opened external URL: ${url}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[WelcomeScreenProvider] Failed to open URL: ${error}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 311,
    "end_line": 331,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method openExternal",
    "component_id": "src.providers.welcome-screen-provider.openExternal"
  },
  "src.providers.welcome-screen-provider.searchResources": {
    "id": "src.providers.welcome-screen-provider.searchResources",
    "name": "searchResources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "searchResources(query: string): LearningResource[] {\n\t\t// Ensure resources are loaded before searching\n\t\tif (!this.learningResources.isLoaded()) {\n\t\t\tthis.learningResources.loadResources(this.context.extensionPath);\n\t\t}\n\t\treturn this.learningResources.searchByKeyword(query);\n\t}",
    "start_line": 336,
    "end_line": 342,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "query"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method searchResources",
    "component_id": "src.providers.welcome-screen-provider.searchResources"
  },
  "src.providers.welcome-screen-provider.recordError": {
    "id": "src.providers.welcome-screen-provider.recordError",
    "name": "recordError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "recordError(\n\t\tseverity: \"error\" | \"warning\",\n\t\tmessage: string,\n\t\tsource: string,\n\t\tsuggestedAction?: string\n\t): void {\n\t\tthis.systemDiagnostics.recordError(\n\t\t\tseverity,\n\t\t\tmessage,\n\t\t\tsource,\n\t\t\tsuggestedAction\n\t\t);\n\t}",
    "start_line": 347,
    "end_line": 359,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "severity",
      "message",
      "source",
      "suggestedAction"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method recordError",
    "component_id": "src.providers.welcome-screen-provider.recordError"
  },
  "src.providers.welcome-screen-provider.getSystemDiagnostics": {
    "id": "src.providers.welcome-screen-provider.getSystemDiagnostics",
    "name": "getSystemDiagnostics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "getSystemDiagnostics(): SystemDiagnostics {\n\t\treturn this.systemDiagnostics;\n\t}",
    "start_line": 364,
    "end_line": 366,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSystemDiagnostics",
    "component_id": "src.providers.welcome-screen-provider.getSystemDiagnostics"
  },
  "src.providers.welcome-screen-provider.getConfiguration": {
    "id": "src.providers.welcome-screen-provider.getConfiguration",
    "name": "getConfiguration",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "private getConfiguration(): ConfigurationState {\n\t\tconst config = workspace.getConfiguration(\"gatomia\");\n\n\t\treturn {\n\t\t\tspecSystem: {\n\t\t\t\tkey: \"gatomia.specSystem\",\n\t\t\t\tlabel: \"Spec System\",\n\t\t\t\tcurrentValue: (config.get<string>(\"specSystem\") || \"auto\") as\n\t\t\t\t\t| \"auto\"\n\t\t\t\t\t| \"speckit\"\n\t\t\t\t\t| \"openspec\",\n\t\t\t\toptions: [\"auto\", \"speckit\", \"openspec\"],\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tspeckitSpecsPath: {\n\t\t\t\tkey: \"gatomia.speckit.specsPath\",\n\t\t\t\tlabel: \"SpecKit Specs Path\",\n\t\t\t\tcurrentValue: config.get<string>(\"speckit.specsPath\") || \"specs\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tspeckitMemoryPath: {\n\t\t\t\tkey: \"gatomia.speckit.memoryPath\",\n\t\t\t\tlabel: \"SpecKit Memory Path\",\n\t\t\t\tcurrentValue:\n\t\t\t\t\tconfig.get<string>(\"speckit.memoryPath\") || \".specify/memory\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tspeckitTemplatesPath: {\n\t\t\t\tkey: \"gatomia.speckit.templatesPath\",\n\t\t\t\tlabel: \"SpecKit Templates Path\",\n\t\t\t\tcurrentValue:\n\t\t\t\t\tconfig.get<string>(\"speckit.templatesPath\") || \".specify/templates\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\topenspecPath: {\n\t\t\t\tkey: \"gatomia.openspec.path\",\n\t\t\t\tlabel: \"OpenSpec Path\",\n\t\t\t\tcurrentValue: config.get<string>(\"openspec.path\") || \".openspec\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\tpromptsPath: {\n\t\t\t\tkey: \"gatomia.prompts.path\",\n\t\t\t\tlabel: \"Prompts Path\",\n\t\t\t\tcurrentValue: config.get<string>(\"prompts.path\") || \".prompts\",\n\t\t\t\teditable: true,\n\t\t\t},\n\t\t\totherSettings: [],\n\t\t};\n\t}",
    "start_line": 371,
    "end_line": 419,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getConfiguration",
    "component_id": "src.providers.welcome-screen-provider.getConfiguration"
  },
  "src.providers.welcome-screen-provider.getFeatureActions": {
    "id": "src.providers.welcome-screen-provider.getFeatureActions",
    "name": "getFeatureActions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "private getFeatureActions(): FeatureAction[] {\n\t\treturn [\n\t\t\t// Specs (T046)\n\t\t\t{\n\t\t\t\tid: \"create-spec\",\n\t\t\t\tfeatureArea: \"Specs\",\n\t\t\t\tlabel: \"Create New Spec\",\n\t\t\t\tdescription: \"Start a new specification document\",\n\t\t\t\tcommandId: \"gatomia.spec.create\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-file-add\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"view-specs\",\n\t\t\t\tfeatureArea: \"Specs\",\n\t\t\t\tlabel: \"Refresh Specs\",\n\t\t\t\tdescription: \"Reload specification list\",\n\t\t\t\tcommandId: \"gatomia.spec.refresh\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-refresh\",\n\t\t\t},\n\t\t\t// Actions (T047)\n\t\t\t{\n\t\t\t\tid: \"create-prompt\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Create Prompt\",\n\t\t\t\tdescription: \"Create a new custom prompt file\",\n\t\t\t\tcommandId: \"gatomia.actions.create\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-add\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"create-agent\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Create Agent\",\n\t\t\t\tdescription: \"Create a new agent definition file\",\n\t\t\t\tcommandId: \"gatomia.actions.createAgentFile\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-robot\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"create-skill\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Create Skill\",\n\t\t\t\tdescription: \"Create a new reusable skill directory\",\n\t\t\t\tcommandId: \"gatomia.actions.createSkill\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-tools\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"refresh-actions\",\n\t\t\t\tfeatureArea: \"Actions\",\n\t\t\t\tlabel: \"Refresh Actions\",\n\t\t\t\tdescription: \"Reload actions from workspace\",\n\t\t\t\tcommandId: \"gatomia.actions.refresh\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-refresh\",\n\t\t\t},\n\t\t\t// Hooks (T048)\n\t\t\t{\n\t\t\t\tid: \"add-hook\",\n\t\t\t\tfeatureArea: \"Hooks\",\n\t\t\t\tlabel: \"Add Hook\",\n\t\t\t\tdescription: \"Create a new automation hook\",\n\t\t\t\tcommandId: \"gatomia.hooks.addHook\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-add\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"view-hook-logs\",\n\t\t\t\tfeatureArea: \"Hooks\",\n\t\t\t\tlabel: \"View Hook Logs\",\n\t\t\t\tdescription: \"Check hook execution history\",\n\t\t\t\tcommandId: \"gatomia.hooks.viewLogs\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-output\",\n\t\t\t},\n\t\t\t// Steering (T049)\n\t\t\t{\n\t\t\t\tid: \"create-project-rule\",\n\t\t\t\tfeatureArea: \"Steering\",\n\t\t\t\tlabel: \"Create Project Rule\",\n\t\t\t\tdescription: \"Define project-level steering rules\",\n\t\t\t\tcommandId: \"gatomia.steering.createProjectRule\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-folder\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"create-user-rule\",\n\t\t\t\tfeatureArea: \"Steering\",\n\t\t\t\tlabel: \"Create User Rule\",\n\t\t\t\tdescription: \"Define user-level steering rules\",\n\t\t\t\tcommandId: \"gatomia.steering.createUserRule\",\n\t\t\t\tenabled: true,\n\t\t\t\ticon: \"codicon-person\",\n\t\t\t},\n\t\t];\n\t}",
    "start_line": 424,
    "end_line": 521,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getFeatureActions",
    "component_id": "src.providers.welcome-screen-provider.getFeatureActions"
  },
  "src.providers.welcome-screen-provider.getCallbacks": {
    "id": "src.providers.welcome-screen-provider.getCallbacks",
    "name": "getCallbacks",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "getCallbacks(): import(\"../panels/welcome-screen-panel\").WelcomeScreenPanelCallbacks {\n\t\t// Panel will be set by the caller via a closure\n\t\tlet panelRef: WelcomeScreenPanel | null = null;\n\n\t\t// Helper to get panel (will be set after panel creation)\n\t\tconst getPanel = () => {\n\t\t\tif (!panelRef) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"[WelcomeScreenProvider] Panel reference not set in callbacks\"\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn panelRef;\n\t\t};\n\n\t\tconst callbacks = {\n\t\t\tonReady: async () => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[WelcomeScreenProvider] Webview ready, sending initial state\"\n\t\t\t\t);\n\n\t\t\t\t// Wait for panel reference to be set (race condition guard)\n\t\t\t\tif (!panelRef) {\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\"[WelcomeScreenProvider] Panel not yet set, waiting...\"\n\t\t\t\t\t);\n\t\t\t\t\t// Poll for panel with timeout\n\t\t\t\t\tconst maxAttempts = 50; // 5 seconds total\n\t\t\t\t\tfor (let i = 0; i < maxAttempts; i++) {\n\t\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100));\n\t\t\t\t\t\tif (panelRef) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!panelRef) {\n\t\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t\t\"[WelcomeScreenProvider] ERROR: Panel reference never set!\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// T032: Send welcome/state message with initial data\n\t\t\t\tconst state = await this.getWelcomeState();\n\t\t\t\tawait getPanel().postMessage({\n\t\t\t\t\ttype: \"welcome/state\",\n\t\t\t\t\t...state,\n\t\t\t\t});\n\t\t\t},\n\t\t\tonExecuteCommand: async (commandId: string, args?: unknown[]) => {\n\t\t\t\t// T052: OutputChannel logging for command execution\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Execute command: ${commandId}`\n\t\t\t\t);\n\t\t\t\ttry {\n\t\t\t\t\t// T050: Execute command via commands.executeCommand\n\t\t\t\t\tawait commands.executeCommand(commandId, ...(args || []));\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[WelcomeScreenProvider] Command executed successfully: ${commandId}`\n\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// T051: Error handling for failed command execution\n\t\t\t\t\tconst message =\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\t`[WelcomeScreenProvider] Command execution failed: ${commandId} - ${message}`\n\t\t\t\t\t);\n\n\t\t\t\t\t// Send user-facing error message\n\t\t\t\t\tawait getPanel().postMessage({\n\t\t\t\t\t\ttype: \"welcome/error\",\n\t\t\t\t\t\tcode: WelcomeErrorCode.COMMAND_EXECUTION_FAILED,\n\t\t\t\t\t\tmessage: `Failed to execute command: ${commandId}`,\n\t\t\t\t\t\tcontext: message,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Show notification to user\n\t\t\t\t\twindow.showErrorMessage(\n\t\t\t\t\t\t`Failed to execute command \"${commandId}\": ${message}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonUpdateConfig: async (key: string, value: string | boolean) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Update config: ${key} = ${value}`\n\t\t\t\t);\n\t\t\t\tawait this.updateConfiguration(key, value, getPanel());\n\t\t\t},\n\t\t\t// T030: Handle welcome/install-dependency message\n\t\t\tonInstallDependency: async (\n\t\t\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\"\n\t\t\t) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Install dependency: ${dependency}`\n\t\t\t\t);\n\t\t\t\tawait this.installDependency(dependency, getPanel());\n\t\t\t},\n\t\t\t// T031: Handle welcome/refresh-dependencies message\n\t\t\tonRefreshDependencies: async () => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[WelcomeScreenProvider] Refresh dependencies (T028)\"\n\t\t\t\t);\n\t\t\t\tawait this.refreshDependencies(getPanel());\n\t\t\t},\n\t\t\tonOpenExternal: async (url: string) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Open external: ${url}`\n\t\t\t\t);\n\t\t\t\tawait this.openExternal(url);\n\t\t\t},\n\t\t\t// T121: Handle welcome/update-preference message\n\t\t\tonUpdatePreference: async (\n\t\t\t\tpreference: \"dontShowOnStartup\",\n\t\t\t\tvalue: boolean\n\t\t\t) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Update preference: ${preference} = ${value}`\n\t\t\t\t);\n\t\t\t\t// Store preference in workspace state\n\t\t\t\tawait this.context.workspaceState.update(\n\t\t\t\t\t\"gatomia.welcomeScreen.dontShowOnStartup\",\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t},\n\t\t\t// T129: Handle welcome/navigate-section message for telemetry\n\t\t\tonNavigateSection: (section: string) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Navigate to section: ${section}`\n\t\t\t\t);\n\t\t\t\t// T128: Telemetry logging if enabled\n\t\t\t\t// Placeholder for future telemetry implementation\n\t\t\t},\n\t\t\t// Handle welcome/search-resources message\n\t\t\tonSearchResources: (query: string) => {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[WelcomeScreenProvider] Search resources: ${query}`\n\t\t\t\t);\n\t\t\t\t// Placeholder for future search implementation\n\t\t\t},\n\t\t\t// Setter for panel reference (called by extension.ts after panel creation)\n\t\t\tsetPanel: (panel: WelcomeScreenPanel) => {\n\t\t\t\tpanelRef = panel;\n\t\t\t},\n\t\t};\n\n\t\treturn callbacks;\n\t}",
    "start_line": 527,
    "end_line": 672,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getCallbacks",
    "component_id": "src.providers.welcome-screen-provider.getCallbacks"
  },
  "src.providers.welcome-screen-provider.isEditableConfigKey": {
    "id": "src.providers.welcome-screen-provider.isEditableConfigKey",
    "name": "isEditableConfigKey",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "private isEditableConfigKey(key: string): boolean {\n\t\treturn EDITABLE_CONFIG_KEYS.includes(key as any);\n\t}",
    "start_line": 677,
    "end_line": 679,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "key"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isEditableConfigKey",
    "component_id": "src.providers.welcome-screen-provider.isEditableConfigKey"
  },
  "src.providers.welcome-screen-provider.sendError": {
    "id": "src.providers.welcome-screen-provider.sendError",
    "name": "sendError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/providers/welcome-screen-provider.ts",
    "relative_path": "src/providers/welcome-screen-provider.ts",
    "depends_on": [],
    "source_code": "private async sendError(\n\t\tpanel: WelcomeScreenPanel,\n\t\tcode: WelcomeErrorCodeType,\n\t\tmessage: string,\n\t\tcontext?: string\n\t): Promise<void> {\n\t\tawait panel.postMessage({\n\t\t\ttype: \"welcome/error\",\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\tcontext,\n\t\t});\n\t}",
    "start_line": 684,
    "end_line": 696,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "panel",
      "code",
      "message",
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method sendError",
    "component_id": "src.providers.welcome-screen-provider.sendError"
  },
  "src.services.agent-service.AgentService": {
    "id": "src.services.agent-service.AgentService",
    "name": "AgentService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [
      "src.features.agents.types.ResourceCache",
      "src.features.agents.types.AgentDefinition",
      "src.features.agents.chat-participant-registry.setToolRegistry",
      "src.features.agents.tool-registry.ToolRegistry",
      "src.services.agent-service.handleConfigurationChange",
      "src.features.agents.chat-participant-registry.ChatParticipantRegistry",
      "src.features.agents.chat-participant-registry.registerAgent",
      "src.features.agents.chat-participant-registry.getRegisteredAgents",
      "src.services.configuration-service.ConfigurationService",
      "src.features.agents.chat-participant-registry.setResourceCache",
      "src.features.agents.file-watcher.FileWatcher",
      "src.services.agent-service.dispose",
      "src.features.agents.agent-loader.AgentLoader",
      "src.features.agents.tool-registry.isRegistered",
      "src.features.agents.resource-cache.load",
      "src.services.agent-service.sendTelemetry",
      "src.features.agents.tool-registry.register",
      "src.services.agent-service.reload",
      "src.services.configuration-service.getConfiguration",
      "src.services.configuration-service.reloadConfiguration",
      "src.features.agents.agent-loader.loadAgents"
    ],
    "source_code": "class AgentService {\n\tprivate readonly loader: AgentLoader;\n\tprivate readonly registry: ChatParticipantRegistry;\n\tprivate readonly resourceCache: ResourceCache;\n\tprivate readonly toolRegistry: ToolRegistry;\n\tprivate readonly configService: ConfigurationService;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate disposables: Disposable[] = [];\n\tprivate agents: AgentDefinition[] = [];\n\tprivate fileWatcher: FileWatcher | null = null;\n\tprivate extensionPath = \"\";\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.loader = new AgentLoader(outputChannel);\n\t\tthis.registry = new ChatParticipantRegistry(outputChannel);\n\t\tthis.resourceCache = new ResourceCache(outputChannel);\n\t\tthis.toolRegistry = new ToolRegistry(outputChannel);\n\t\tthis.configService = new ConfigurationService();\n\t}\n\n\t/**\n\t * Initialize the agent service\n\t * Discovers and registers all agents, loads resources, and sets up file watching\n\t */\n\tasync initialize(extensionPath: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.extensionPath = extensionPath;\n\t\t\tthis.outputChannel.appendLine(\"[AgentService] Initializing...\");\n\n\t\t\t// Log configuration\n\t\t\tconst config = this.configService.getConfiguration();\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Configuration: resourcesPath=${config.resourcesPath}, enableHotReload=${config.enableHotReload}, logLevel=${config.logLevel}`\n\t\t\t);\n\n\t\t\t// Check if GitHub Copilot Chat is available\n\t\t\tif (!chat) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] GitHub Copilot Chat API not available. Agent registration skipped.\"\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] Please ensure GitHub Copilot extension is installed and enabled.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Discover agents from resources/agents directory using configured resources path\n\t\t\tconst agentsDir = Uri.joinPath(\n\t\t\t\tUri.file(extensionPath),\n\t\t\t\tconfig.resourcesPath,\n\t\t\t\t\"agents\"\n\t\t\t).fsPath;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loading agents from: ${agentsDir}`\n\t\t\t);\n\n\t\t\tconst startTime = Date.now();\n\t\t\tthis.agents = await this.loader.loadAgents(agentsDir);\n\t\t\tconst loadDuration = Date.now() - startTime;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loaded ${this.agents.length} agents in ${loadDuration}ms`\n\t\t\t);\n\n\t\t\t// Register each agent as a chat participant\n\t\t\tlet successCount = 0;\n\t\t\tlet failCount = 0;\n\n\t\t\tfor (const agent of this.agents) {\n\t\t\t\tconst disposable = this.registry.registerAgent(agent);\n\n\t\t\t\tif (disposable) {\n\t\t\t\t\tthis.disposables.push(disposable);\n\t\t\t\t\tsuccessCount += 1;\n\t\t\t\t} else {\n\t\t\t\t\tfailCount += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Registration complete: ${successCount} succeeded, ${failCount} failed`\n\t\t\t);\n\n\t\t\t// Wire up tool registry and resource cache to chat registry\n\t\t\tthis.registry.setToolRegistry(this.toolRegistry);\n\t\t\tthis.registry.setResourceCache(this.resourceCache);\n\n\t\t\t// T067 - Register built-in help handler\n\t\t\tthis.toolRegistry.register(\"agent.help\", helpHandler);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[AgentService] Registered built-in help handler\"\n\t\t\t);\n\n\t\t\t// Load resources (prompts, skills, instructions)\n\t\t\tconst resourcesDir = Uri.joinPath(\n\t\t\t\tUri.file(extensionPath),\n\t\t\t\tconfig.resourcesPath\n\t\t\t).fsPath;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loading resources from: ${resourcesDir}`\n\t\t\t);\n\n\t\t\tconst resourceLoadStart = Date.now();\n\t\t\tawait this.resourceCache.load(resourcesDir);\n\t\t\tconst resourceLoadDuration = Date.now() - resourceLoadStart;\n\n\t\t\tconst totalResources =\n\t\t\t\tthis.resourceCache.prompts.size +\n\t\t\t\tthis.resourceCache.skills.size +\n\t\t\t\tthis.resourceCache.instructions.size;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loaded ${totalResources} resources in ${resourceLoadDuration}ms`\n\t\t\t);\n\n\t\t\t// Set up file watcher for hot-reload (only if enabled)\n\t\t\tif (config.enableHotReload) {\n\t\t\t\tconst watchPattern = `${resourcesDir}/**/*.{md,prompt.md,skill.md,instructions.md}`;\n\t\t\t\tconst fsWatcher = workspace.createFileSystemWatcher(watchPattern);\n\n\t\t\t\tthis.fileWatcher = new FileWatcher(\n\t\t\t\t\tthis.outputChannel,\n\t\t\t\t\tfsWatcher,\n\t\t\t\t\tasync (changedFiles: string[]) => {\n\t\t\t\t\t\tawait this.resourceCache.reload(changedFiles);\n\t\t\t\t\t\tthis.sendTelemetry(\"agent.resources.reloaded\", {\n\t\t\t\t\t\t\tfileCount: changedFiles.length,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.disposables.push(this.fileWatcher);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] File watcher initialized\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] Hot-reload disabled via configuration\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Wire up configuration change listener\n\t\t\tconst configChangeDisposable = workspace.onDidChangeConfiguration(\n\t\t\t\t(event) => this.handleConfigurationChange(event)\n\t\t\t);\n\t\t\tthis.disposables.push(configChangeDisposable);\n\n\t\t\t// Send telemetry\n\t\t\tthis.sendTelemetry(\"agent.service.initialized\", {\n\t\t\t\tagentCount: this.agents.length,\n\t\t\t\tsuccessCount,\n\t\t\t\tfailCount,\n\t\t\t\tloadDuration,\n\t\t\t\tresourceCount: totalResources,\n\t\t\t\tresourceLoadDuration,\n\t\t\t});\n\n\t\t\tthis.outputChannel.appendLine(\"[AgentService] Initialization complete\");\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Initialization failed: ${error}`\n\t\t\t);\n\n\t\t\t// Send error telemetry\n\t\t\tthis.sendTelemetry(\"agent.service.initialization.failed\", {\n\t\t\t\terror: String(error),\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Handle configuration changes\n\t */\n\tprivate handleConfigurationChange(event: any): void {\n\t\tif (event.affectsConfiguration(\"gatomia.agents\")) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[AgentService] Agent settings changed, reloading configuration...\"\n\t\t\t);\n\n\t\t\tconst oldConfig = this.configService.getConfiguration();\n\t\t\tconst newConfig = this.configService.reloadConfiguration();\n\n\t\t\t// Check if resources path changed\n\t\t\tif (oldConfig.resourcesPath !== newConfig.resourcesPath) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentService] Resources path changed: ${oldConfig.resourcesPath} -> ${newConfig.resourcesPath}`\n\t\t\t\t);\n\t\t\t\tthis.sendTelemetry(\"agent.config.resourcesPath.changed\", {\n\t\t\t\t\toldPath: oldConfig.resourcesPath,\n\t\t\t\t\tnewPath: newConfig.resourcesPath,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check if hot-reload setting changed\n\t\t\tif (oldConfig.enableHotReload !== newConfig.enableHotReload) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentService] Hot-reload setting changed: ${oldConfig.enableHotReload} -> ${newConfig.enableHotReload}`\n\t\t\t\t);\n\t\t\t\tthis.sendTelemetry(\"agent.config.hotReload.changed\", {\n\t\t\t\t\tenabled: newConfig.enableHotReload,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check if log level changed\n\t\t\tif (oldConfig.logLevel !== newConfig.logLevel) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentService] Log level changed: ${oldConfig.logLevel} -> ${newConfig.logLevel}`\n\t\t\t\t);\n\t\t\t\tthis.sendTelemetry(\"agent.config.logLevel.changed\", {\n\t\t\t\t\toldLevel: oldConfig.logLevel,\n\t\t\t\t\tnewLevel: newConfig.logLevel,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Send general configuration change telemetry\n\t\t\tthis.sendTelemetry(\"agent.configuration.changed\", {\n\t\t\t\tresourcesPath: newConfig.resourcesPath,\n\t\t\t\tenableHotReload: newConfig.enableHotReload,\n\t\t\t\tlogLevel: newConfig.logLevel,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Reload agent configuration and resources\n\t * Called when configuration changes\n\t */\n\tasync reload(): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\"[AgentService] Reloading agents...\");\n\n\t\t\t// Reload configuration\n\t\t\tconst config = this.configService.reloadConfiguration();\n\n\t\t\t// Reload resources if path exists\n\t\t\tconst resourcesDir = Uri.joinPath(\n\t\t\t\tUri.file(this.extensionPath),\n\t\t\t\tconfig.resourcesPath\n\t\t\t).fsPath;\n\n\t\t\tconst resourceLoadStart = Date.now();\n\t\t\tawait this.resourceCache.load(resourcesDir);\n\t\t\tconst resourceLoadDuration = Date.now() - resourceLoadStart;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Resources reloaded in ${resourceLoadDuration}ms`\n\t\t\t);\n\n\t\t\tthis.sendTelemetry(\"agent.service.reloaded\", {\n\t\t\t\tresourceLoadDuration,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(`[AgentService] Reload failed: ${error}`);\n\t\t\tthis.sendTelemetry(\"agent.service.reload.failed\", {\n\t\t\t\terror: String(error),\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get the resource cache instance\n\t */\n\tgetResourceCache(): ResourceCache {\n\t\treturn this.resourceCache;\n\t}\n\n\t/**\n\t * Get the tool registry instance\n\t */\n\tgetToolRegistry(): ToolRegistry {\n\t\treturn this.toolRegistry;\n\t}\n\n\t/**\n\t * Get all loaded agents\n\t */\n\tgetAgents(): AgentDefinition[] {\n\t\treturn [...this.agents];\n\t}\n\n\t/**\n\t * Get registered agent IDs\n\t */\n\tgetRegisteredAgentIds(): string[] {\n\t\treturn this.registry.getRegisteredAgents();\n\t}\n\n\t/**\n\t * Check if an agent is registered\n\t */\n\tisAgentRegistered(agentId: string): boolean {\n\t\treturn this.registry.isRegistered(agentId);\n\t}\n\n\t/**\n\t * Send telemetry event\n\t */\n\tprivate sendTelemetry(\n\t\teventName: string,\n\t\tproperties?: Record<string, any>\n\t): void {\n\t\ttry {\n\t\t\t// In production, this would send to a telemetry service\n\t\t\t// For now, just log to output channel\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Telemetry: ${eventName} ${JSON.stringify(properties || {})}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\t// Silently fail telemetry\n\t\t}\n\t}\n\n\t/**\n\t * Dispose the service and cleanup resources\n\t */\n\tdispose(): void {\n\t\tthis.outputChannel.appendLine(\"[AgentService] Disposing...\");\n\n\t\t// Dispose all registered participants and watchers\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.disposables = [];\n\n\t\t// Dispose registry\n\t\tthis.registry.dispose();\n\n\t\t// Dispose resource cache\n\t\tthis.resourceCache.dispose();\n\n\t\t// Clear agents\n\t\tthis.agents = [];\n\n\t\tthis.outputChannel.appendLine(\"[AgentService] Disposed\");\n\t}\n}",
    "start_line": 22,
    "end_line": 362,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AgentService",
    "component_id": "src.services.agent-service.AgentService"
  },
  "src.services.agent-service.initialize": {
    "id": "src.services.agent-service.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "async initialize(extensionPath: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.extensionPath = extensionPath;\n\t\t\tthis.outputChannel.appendLine(\"[AgentService] Initializing...\");\n\n\t\t\t// Log configuration\n\t\t\tconst config = this.configService.getConfiguration();\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Configuration: resourcesPath=${config.resourcesPath}, enableHotReload=${config.enableHotReload}, logLevel=${config.logLevel}`\n\t\t\t);\n\n\t\t\t// Check if GitHub Copilot Chat is available\n\t\t\tif (!chat) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] GitHub Copilot Chat API not available. Agent registration skipped.\"\n\t\t\t\t);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] Please ensure GitHub Copilot extension is installed and enabled.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Discover agents from resources/agents directory using configured resources path\n\t\t\tconst agentsDir = Uri.joinPath(\n\t\t\t\tUri.file(extensionPath),\n\t\t\t\tconfig.resourcesPath,\n\t\t\t\t\"agents\"\n\t\t\t).fsPath;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loading agents from: ${agentsDir}`\n\t\t\t);\n\n\t\t\tconst startTime = Date.now();\n\t\t\tthis.agents = await this.loader.loadAgents(agentsDir);\n\t\t\tconst loadDuration = Date.now() - startTime;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loaded ${this.agents.length} agents in ${loadDuration}ms`\n\t\t\t);\n\n\t\t\t// Register each agent as a chat participant\n\t\t\tlet successCount = 0;\n\t\t\tlet failCount = 0;\n\n\t\t\tfor (const agent of this.agents) {\n\t\t\t\tconst disposable = this.registry.registerAgent(agent);\n\n\t\t\t\tif (disposable) {\n\t\t\t\t\tthis.disposables.push(disposable);\n\t\t\t\t\tsuccessCount += 1;\n\t\t\t\t} else {\n\t\t\t\t\tfailCount += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Registration complete: ${successCount} succeeded, ${failCount} failed`\n\t\t\t);\n\n\t\t\t// Wire up tool registry and resource cache to chat registry\n\t\t\tthis.registry.setToolRegistry(this.toolRegistry);\n\t\t\tthis.registry.setResourceCache(this.resourceCache);\n\n\t\t\t// T067 - Register built-in help handler\n\t\t\tthis.toolRegistry.register(\"agent.help\", helpHandler);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[AgentService] Registered built-in help handler\"\n\t\t\t);\n\n\t\t\t// Load resources (prompts, skills, instructions)\n\t\t\tconst resourcesDir = Uri.joinPath(\n\t\t\t\tUri.file(extensionPath),\n\t\t\t\tconfig.resourcesPath\n\t\t\t).fsPath;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loading resources from: ${resourcesDir}`\n\t\t\t);\n\n\t\t\tconst resourceLoadStart = Date.now();\n\t\t\tawait this.resourceCache.load(resourcesDir);\n\t\t\tconst resourceLoadDuration = Date.now() - resourceLoadStart;\n\n\t\t\tconst totalResources =\n\t\t\t\tthis.resourceCache.prompts.size +\n\t\t\t\tthis.resourceCache.skills.size +\n\t\t\t\tthis.resourceCache.instructions.size;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Loaded ${totalResources} resources in ${resourceLoadDuration}ms`\n\t\t\t);\n\n\t\t\t// Set up file watcher for hot-reload (only if enabled)\n\t\t\tif (config.enableHotReload) {\n\t\t\t\tconst watchPattern = `${resourcesDir}/**/*.{md,prompt.md,skill.md,instructions.md}`;\n\t\t\t\tconst fsWatcher = workspace.createFileSystemWatcher(watchPattern);\n\n\t\t\t\tthis.fileWatcher = new FileWatcher(\n\t\t\t\t\tthis.outputChannel,\n\t\t\t\t\tfsWatcher,\n\t\t\t\t\tasync (changedFiles: string[]) => {\n\t\t\t\t\t\tawait this.resourceCache.reload(changedFiles);\n\t\t\t\t\t\tthis.sendTelemetry(\"agent.resources.reloaded\", {\n\t\t\t\t\t\t\tfileCount: changedFiles.length,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.disposables.push(this.fileWatcher);\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] File watcher initialized\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[AgentService] Hot-reload disabled via configuration\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Wire up configuration change listener\n\t\t\tconst configChangeDisposable = workspace.onDidChangeConfiguration(\n\t\t\t\t(event) => this.handleConfigurationChange(event)\n\t\t\t);\n\t\t\tthis.disposables.push(configChangeDisposable);\n\n\t\t\t// Send telemetry\n\t\t\tthis.sendTelemetry(\"agent.service.initialized\", {\n\t\t\t\tagentCount: this.agents.length,\n\t\t\t\tsuccessCount,\n\t\t\t\tfailCount,\n\t\t\t\tloadDuration,\n\t\t\t\tresourceCount: totalResources,\n\t\t\t\tresourceLoadDuration,\n\t\t\t});\n\n\t\t\tthis.outputChannel.appendLine(\"[AgentService] Initialization complete\");\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Initialization failed: ${error}`\n\t\t\t);\n\n\t\t\t// Send error telemetry\n\t\t\tthis.sendTelemetry(\"agent.service.initialization.failed\", {\n\t\t\t\terror: String(error),\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t}\n\t}",
    "start_line": 47,
    "end_line": 195,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extensionPath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method initialize",
    "component_id": "src.services.agent-service.initialize"
  },
  "src.services.agent-service.handleConfigurationChange": {
    "id": "src.services.agent-service.handleConfigurationChange",
    "name": "handleConfigurationChange",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "private handleConfigurationChange(event: any): void {\n\t\tif (event.affectsConfiguration(\"gatomia.agents\")) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[AgentService] Agent settings changed, reloading configuration...\"\n\t\t\t);\n\n\t\t\tconst oldConfig = this.configService.getConfiguration();\n\t\t\tconst newConfig = this.configService.reloadConfiguration();\n\n\t\t\t// Check if resources path changed\n\t\t\tif (oldConfig.resourcesPath !== newConfig.resourcesPath) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentService] Resources path changed: ${oldConfig.resourcesPath} -> ${newConfig.resourcesPath}`\n\t\t\t\t);\n\t\t\t\tthis.sendTelemetry(\"agent.config.resourcesPath.changed\", {\n\t\t\t\t\toldPath: oldConfig.resourcesPath,\n\t\t\t\t\tnewPath: newConfig.resourcesPath,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check if hot-reload setting changed\n\t\t\tif (oldConfig.enableHotReload !== newConfig.enableHotReload) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentService] Hot-reload setting changed: ${oldConfig.enableHotReload} -> ${newConfig.enableHotReload}`\n\t\t\t\t);\n\t\t\t\tthis.sendTelemetry(\"agent.config.hotReload.changed\", {\n\t\t\t\t\tenabled: newConfig.enableHotReload,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check if log level changed\n\t\t\tif (oldConfig.logLevel !== newConfig.logLevel) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t`[AgentService] Log level changed: ${oldConfig.logLevel} -> ${newConfig.logLevel}`\n\t\t\t\t);\n\t\t\t\tthis.sendTelemetry(\"agent.config.logLevel.changed\", {\n\t\t\t\t\toldLevel: oldConfig.logLevel,\n\t\t\t\t\tnewLevel: newConfig.logLevel,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Send general configuration change telemetry\n\t\t\tthis.sendTelemetry(\"agent.configuration.changed\", {\n\t\t\t\tresourcesPath: newConfig.resourcesPath,\n\t\t\t\tenableHotReload: newConfig.enableHotReload,\n\t\t\t\tlogLevel: newConfig.logLevel,\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 200,
    "end_line": 248,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleConfigurationChange",
    "component_id": "src.services.agent-service.handleConfigurationChange"
  },
  "src.services.agent-service.reload": {
    "id": "src.services.agent-service.reload",
    "name": "reload",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "async reload(): Promise<void> {\n\t\ttry {\n\t\t\tthis.outputChannel.appendLine(\"[AgentService] Reloading agents...\");\n\n\t\t\t// Reload configuration\n\t\t\tconst config = this.configService.reloadConfiguration();\n\n\t\t\t// Reload resources if path exists\n\t\t\tconst resourcesDir = Uri.joinPath(\n\t\t\t\tUri.file(this.extensionPath),\n\t\t\t\tconfig.resourcesPath\n\t\t\t).fsPath;\n\n\t\t\tconst resourceLoadStart = Date.now();\n\t\t\tawait this.resourceCache.load(resourcesDir);\n\t\t\tconst resourceLoadDuration = Date.now() - resourceLoadStart;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Resources reloaded in ${resourceLoadDuration}ms`\n\t\t\t);\n\n\t\t\tthis.sendTelemetry(\"agent.service.reloaded\", {\n\t\t\t\tresourceLoadDuration,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(`[AgentService] Reload failed: ${error}`);\n\t\t\tthis.sendTelemetry(\"agent.service.reload.failed\", {\n\t\t\t\terror: String(error),\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 254,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method reload",
    "component_id": "src.services.agent-service.reload"
  },
  "src.services.agent-service.getResourceCache": {
    "id": "src.services.agent-service.getResourceCache",
    "name": "getResourceCache",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "getResourceCache(): ResourceCache {\n\t\treturn this.resourceCache;\n\t}",
    "start_line": 289,
    "end_line": 291,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getResourceCache",
    "component_id": "src.services.agent-service.getResourceCache"
  },
  "src.services.agent-service.getToolRegistry": {
    "id": "src.services.agent-service.getToolRegistry",
    "name": "getToolRegistry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "getToolRegistry(): ToolRegistry {\n\t\treturn this.toolRegistry;\n\t}",
    "start_line": 296,
    "end_line": 298,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getToolRegistry",
    "component_id": "src.services.agent-service.getToolRegistry"
  },
  "src.services.agent-service.getAgents": {
    "id": "src.services.agent-service.getAgents",
    "name": "getAgents",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "getAgents(): AgentDefinition[] {\n\t\treturn [...this.agents];\n\t}",
    "start_line": 303,
    "end_line": 305,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAgents",
    "component_id": "src.services.agent-service.getAgents"
  },
  "src.services.agent-service.getRegisteredAgentIds": {
    "id": "src.services.agent-service.getRegisteredAgentIds",
    "name": "getRegisteredAgentIds",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "getRegisteredAgentIds(): string[] {\n\t\treturn this.registry.getRegisteredAgents();\n\t}",
    "start_line": 310,
    "end_line": 312,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRegisteredAgentIds",
    "component_id": "src.services.agent-service.getRegisteredAgentIds"
  },
  "src.services.agent-service.isAgentRegistered": {
    "id": "src.services.agent-service.isAgentRegistered",
    "name": "isAgentRegistered",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "isAgentRegistered(agentId: string): boolean {\n\t\treturn this.registry.isRegistered(agentId);\n\t}",
    "start_line": 317,
    "end_line": 319,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "agentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isAgentRegistered",
    "component_id": "src.services.agent-service.isAgentRegistered"
  },
  "src.services.agent-service.sendTelemetry": {
    "id": "src.services.agent-service.sendTelemetry",
    "name": "sendTelemetry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "private sendTelemetry(\n\t\teventName: string,\n\t\tproperties?: Record<string, any>\n\t): void {\n\t\ttry {\n\t\t\t// In production, this would send to a telemetry service\n\t\t\t// For now, just log to output channel\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[AgentService] Telemetry: ${eventName} ${JSON.stringify(properties || {})}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\t// Silently fail telemetry\n\t\t}\n\t}",
    "start_line": 324,
    "end_line": 337,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "eventName",
      "properties"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method sendTelemetry",
    "component_id": "src.services.agent-service.sendTelemetry"
  },
  "src.services.agent-service.dispose": {
    "id": "src.services.agent-service.dispose",
    "name": "dispose",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/agent-service.ts",
    "relative_path": "src/services/agent-service.ts",
    "depends_on": [],
    "source_code": "dispose(): void {\n\t\tthis.outputChannel.appendLine(\"[AgentService] Disposing...\");\n\n\t\t// Dispose all registered participants and watchers\n\t\tfor (const disposable of this.disposables) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t\tthis.disposables = [];\n\n\t\t// Dispose registry\n\t\tthis.registry.dispose();\n\n\t\t// Dispose resource cache\n\t\tthis.resourceCache.dispose();\n\n\t\t// Clear agents\n\t\tthis.agents = [];\n\n\t\tthis.outputChannel.appendLine(\"[AgentService] Disposed\");\n\t}",
    "start_line": 342,
    "end_line": 361,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method dispose",
    "component_id": "src.services.agent-service.dispose"
  },
  "src.services.configuration-service.AgentConfiguration": {
    "id": "src.services.configuration-service.AgentConfiguration",
    "name": "AgentConfiguration",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "interface AgentConfiguration {\n\treadonly resourcesPath: string;\n\treadonly enableHotReload: boolean;\n\treadonly logLevel: \"debug\" | \"info\" | \"warn\" | \"error\";\n}",
    "start_line": 8,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentConfiguration",
    "component_id": "src.services.configuration-service.AgentConfiguration"
  },
  "src.services.configuration-service.ConfigurationService": {
    "id": "src.services.configuration-service.ConfigurationService",
    "name": "ConfigurationService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [
      "src.services.configuration-service.AgentConfiguration",
      "src.services.configuration-service.loadConfiguration",
      "src.services.configuration-service.getConfiguration",
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "class ConfigurationService {\n\tprivate config: AgentConfiguration;\n\n\tconstructor() {\n\t\tthis.config = Object.freeze(this.loadConfiguration());\n\t}\n\n\t/**\n\t * Load configuration from workspace settings\n\t */\n\tloadConfiguration(): AgentConfiguration {\n\t\tconst agentConfig = workspace.getConfiguration(\"gatomia.agents\");\n\n\t\tconst resourcesPath =\n\t\t\tagentConfig.get<string>(\"resourcesPath\", \"\") || \"resources\";\n\t\tconst enableHotReload = agentConfig.get<boolean>(\"enableHotReload\", true);\n\t\tconst logLevel = agentConfig.get<\"debug\" | \"info\" | \"warn\" | \"error\">(\n\t\t\t\"logLevel\",\n\t\t\t\"info\"\n\t\t);\n\n\t\treturn Object.freeze({\n\t\t\tresourcesPath,\n\t\t\tenableHotReload,\n\t\t\tlogLevel,\n\t\t});\n\t}\n\n\t/**\n\t * Reload configuration (for use when settings change)\n\t */\n\treloadConfiguration(): AgentConfiguration {\n\t\tthis.config = Object.freeze(this.loadConfiguration());\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * Get current configuration\n\t */\n\tgetConfiguration(): AgentConfiguration {\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * Get resources path setting\n\t */\n\tgetResourcesPath(): string {\n\t\treturn this.config.resourcesPath;\n\t}\n\n\t/**\n\t * Check if hot-reload is enabled\n\t */\n\tisHotReloadEnabled(): boolean {\n\t\treturn this.config.enableHotReload;\n\t}\n\n\t/**\n\t * Get log level setting\n\t */\n\tgetLogLevel(): \"debug\" | \"info\" | \"warn\" | \"error\" {\n\t\treturn this.config.logLevel;\n\t}\n}",
    "start_line": 18,
    "end_line": 81,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ConfigurationService",
    "component_id": "src.services.configuration-service.ConfigurationService"
  },
  "src.services.configuration-service.loadConfiguration": {
    "id": "src.services.configuration-service.loadConfiguration",
    "name": "loadConfiguration",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "loadConfiguration(): AgentConfiguration {\n\t\tconst agentConfig = workspace.getConfiguration(\"gatomia.agents\");\n\n\t\tconst resourcesPath =\n\t\t\tagentConfig.get<string>(\"resourcesPath\", \"\") || \"resources\";\n\t\tconst enableHotReload = agentConfig.get<boolean>(\"enableHotReload\", true);\n\t\tconst logLevel = agentConfig.get<\"debug\" | \"info\" | \"warn\" | \"error\">(\n\t\t\t\"logLevel\",\n\t\t\t\"info\"\n\t\t);\n\n\t\treturn Object.freeze({\n\t\t\tresourcesPath,\n\t\t\tenableHotReload,\n\t\t\tlogLevel,\n\t\t});\n\t}",
    "start_line": 28,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadConfiguration",
    "component_id": "src.services.configuration-service.loadConfiguration"
  },
  "src.services.configuration-service.reloadConfiguration": {
    "id": "src.services.configuration-service.reloadConfiguration",
    "name": "reloadConfiguration",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "reloadConfiguration(): AgentConfiguration {\n\t\tthis.config = Object.freeze(this.loadConfiguration());\n\t\treturn this.config;\n\t}",
    "start_line": 49,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method reloadConfiguration",
    "component_id": "src.services.configuration-service.reloadConfiguration"
  },
  "src.services.configuration-service.getConfiguration": {
    "id": "src.services.configuration-service.getConfiguration",
    "name": "getConfiguration",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "getConfiguration(): AgentConfiguration {\n\t\treturn this.config;\n\t}",
    "start_line": 57,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getConfiguration",
    "component_id": "src.services.configuration-service.getConfiguration"
  },
  "src.services.configuration-service.getResourcesPath": {
    "id": "src.services.configuration-service.getResourcesPath",
    "name": "getResourcesPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "getResourcesPath(): string {\n\t\treturn this.config.resourcesPath;\n\t}",
    "start_line": 64,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getResourcesPath",
    "component_id": "src.services.configuration-service.getResourcesPath"
  },
  "src.services.configuration-service.isHotReloadEnabled": {
    "id": "src.services.configuration-service.isHotReloadEnabled",
    "name": "isHotReloadEnabled",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "isHotReloadEnabled(): boolean {\n\t\treturn this.config.enableHotReload;\n\t}",
    "start_line": 71,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isHotReloadEnabled",
    "component_id": "src.services.configuration-service.isHotReloadEnabled"
  },
  "src.services.configuration-service.getLogLevel": {
    "id": "src.services.configuration-service.getLogLevel",
    "name": "getLogLevel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/configuration-service.ts",
    "relative_path": "src/services/configuration-service.ts",
    "depends_on": [],
    "source_code": "getLogLevel(): \"debug\" | \"info\" | \"warn\" | \"error\" {\n\t\treturn this.config.logLevel;\n\t}",
    "start_line": 78,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getLogLevel",
    "component_id": "src.services.configuration-service.getLogLevel"
  },
  "src.services.dependency-checker.CLIDetectionResult": {
    "id": "src.services.dependency-checker.CLIDetectionResult",
    "name": "CLIDetectionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "interface CLIDetectionResult {\n\tinstalled: boolean;\n\tversion: string | null;\n}",
    "start_line": 11,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CLIDetectionResult",
    "component_id": "src.services.dependency-checker.CLIDetectionResult"
  },
  "src.services.dependency-checker.CacheEntry": {
    "id": "src.services.dependency-checker.CacheEntry",
    "name": "CacheEntry",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus"
    ],
    "source_code": "interface CacheEntry {\n\ttimestamp: number;\n\tresult: DependencyStatus;\n}",
    "start_line": 16,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CacheEntry",
    "component_id": "src.services.dependency-checker.CacheEntry"
  },
  "src.services.dependency-checker.DependencyChecker": {
    "id": "src.services.dependency-checker.DependencyChecker",
    "name": "DependencyChecker",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [
      "src.services.dependency-checker.CacheEntry",
      "src.services.dependency-checker.checkCopilotChat",
      "src.services.dependency-checker.isCacheValid",
      "src.utils.cli-detector.checkCLI",
      "src.services.dependency-checker.checkSpecKitCLI",
      "src.services.dependency-checker.checkOpenSpecCLI",
      "ui.src.features.welcome.types.DependencyStatus"
    ],
    "source_code": "class DependencyChecker {\n\tprivate static readonly CACHE_TTL_MS = 60_000; // 60 seconds\n\t/**\n\t * CLI invocation timeout.\n\t * Shorten automatically under Vitest to keep unit tests below the default 5s test timeout.\n\t * Can also be overridden via GATOMIA_CLI_TIMEOUT_MS for debugging.\n\t */\n\tprivate static readonly CLI_TIMEOUT_MS: number = Number.parseInt(\n\t\tprocess.env.GATOMIA_CLI_TIMEOUT_MS ??\n\t\t\t(process.env.VITEST_WORKER_ID ? \"1000\" : \"5000\"),\n\t\t10\n\t);\n\n\tprivate cache: CacheEntry | null = null;\n\tprivate readonly outputChannel: OutputChannel;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Check all dependencies with caching\n\t * @param forceRefresh - Bypass cache and re-check\n\t */\n\tasync checkAll(forceRefresh = false): Promise<DependencyStatus> {\n\t\t// Return cached result if valid and not forcing refresh\n\t\tif (!forceRefresh && this.cache && this.isCacheValid()) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[DependencyChecker] Returning cached dependency status\"\n\t\t\t);\n\t\t\treturn this.cache.result;\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[DependencyChecker] Checking all dependencies...\"\n\t\t);\n\n\t\tconst copilotChat = this.checkCopilotChat();\n\t\tconst [speckit, openspec] = await Promise.all([\n\t\t\tthis.checkSpecKitCLI(),\n\t\t\tthis.checkOpenSpecCLI(),\n\t\t]);\n\n\t\tconst result: DependencyStatus = {\n\t\t\tcopilotChat,\n\t\t\tspeckit,\n\t\t\topenspec,\n\t\t\tlastChecked: Date.now(),\n\t\t};\n\n\t\t// Update cache\n\t\tthis.cache = {\n\t\t\ttimestamp: Date.now(),\n\t\t\tresult,\n\t\t};\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependencyChecker] Check complete: Copilot=${copilotChat.installed}, SpecKit=${speckit.installed}, OpenSpec=${openspec.installed}`\n\t\t);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Invalidate cache to force re-check on next call\n\t */\n\tinvalidateCache(): void {\n\t\tthis.outputChannel.appendLine(\"[DependencyChecker] Cache invalidated\");\n\t\tthis.cache = null;\n\t}\n\n\t/**\n\t * Check GitHub Copilot Chat extension\n\t * Uses VS Code extension API (synchronous, no timeout needed)\n\t */\n\tprivate checkCopilotChat(): DependencyStatus[\"copilotChat\"] {\n\t\ttry {\n\t\t\tconst extension = extensions.getExtension(\"github.copilot-chat\");\n\n\t\t\tif (!extension) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[DependencyChecker] GitHub Copilot Chat: NOT installed\"\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tinstalled: false,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tversion: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst version = extension.packageJSON?.version || null;\n\t\t\tconst active = extension.isActive;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependencyChecker] GitHub Copilot Chat: installed (v${version || \"unknown\"}), ${active ? \"active\" : \"inactive\"}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tinstalled: true,\n\t\t\t\tactive,\n\t\t\t\tversion,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependencyChecker] Error checking Copilot Chat: ${error}`\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tinstalled: false,\n\t\t\t\tactive: false,\n\t\t\t\tversion: null,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Check SpecKit CLI installation\n\t * Command: specify version (same as DependenciesViewProvider)\n\t * Uses extended PATH to find UV-installed tools\n\t */\n\tprivate async checkSpecKitCLI(): Promise<DependencyStatus[\"speckit\"]> {\n\t\tconst result = await checkCLI(\n\t\t\t\"specify version\",\n\t\t\tDependencyChecker.CLI_TIMEOUT_MS\n\t\t);\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependencyChecker] SpecKit CLI: ${result.installed ? `installed (v${result.version || \"unknown\"})` : \"NOT installed\"}${result.error ? ` - ${result.error}` : \"\"}`\n\t\t);\n\n\t\treturn {\n\t\t\tinstalled: result.installed,\n\t\t\tversion: result.version,\n\t\t};\n\t}\n\n\t/**\n\t * Check OpenSpec CLI installation\n\t * Command: openspec --version\n\t * Uses extended PATH to find installed tools\n\t */\n\tprivate async checkOpenSpecCLI(): Promise<DependencyStatus[\"openspec\"]> {\n\t\tconst result = await checkCLI(\n\t\t\t\"openspec --version\",\n\t\t\tDependencyChecker.CLI_TIMEOUT_MS\n\t\t);\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependencyChecker] OpenSpec CLI: ${result.installed ? `installed (v${result.version || \"unknown\"})` : \"NOT installed\"}${result.error ? ` - ${result.error}` : \"\"}`\n\t\t);\n\n\t\treturn {\n\t\t\tinstalled: result.installed,\n\t\t\tversion: result.version,\n\t\t};\n\t}\n\n\t/**\n\t * Check if cache is still valid based on TTL\n\t */\n\tprivate isCacheValid(): boolean {\n\t\tif (!this.cache) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst age = Date.now() - this.cache.timestamp;\n\t\treturn age < DependencyChecker.CACHE_TTL_MS;\n\t}\n\n\t/**\n\t * Get cache age in milliseconds (for testing/debugging)\n\t */\n\tgetCacheAge(): number | null {\n\t\tif (!this.cache) {\n\t\t\treturn null;\n\t\t}\n\t\treturn Date.now() - this.cache.timestamp;\n\t}\n}",
    "start_line": 21,
    "end_line": 198,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DependencyChecker",
    "component_id": "src.services.dependency-checker.DependencyChecker"
  },
  "src.services.dependency-checker.checkAll": {
    "id": "src.services.dependency-checker.checkAll",
    "name": "checkAll",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "async checkAll(forceRefresh = false): Promise<DependencyStatus> {\n\t\t// Return cached result if valid and not forcing refresh\n\t\tif (!forceRefresh && this.cache && this.isCacheValid()) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\"[DependencyChecker] Returning cached dependency status\"\n\t\t\t);\n\t\t\treturn this.cache.result;\n\t\t}\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t\"[DependencyChecker] Checking all dependencies...\"\n\t\t);\n\n\t\tconst copilotChat = this.checkCopilotChat();\n\t\tconst [speckit, openspec] = await Promise.all([\n\t\t\tthis.checkSpecKitCLI(),\n\t\t\tthis.checkOpenSpecCLI(),\n\t\t]);\n\n\t\tconst result: DependencyStatus = {\n\t\t\tcopilotChat,\n\t\t\tspeckit,\n\t\t\topenspec,\n\t\t\tlastChecked: Date.now(),\n\t\t};\n\n\t\t// Update cache\n\t\tthis.cache = {\n\t\t\ttimestamp: Date.now(),\n\t\t\tresult,\n\t\t};\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependencyChecker] Check complete: Copilot=${copilotChat.installed}, SpecKit=${speckit.installed}, OpenSpec=${openspec.installed}`\n\t\t);\n\n\t\treturn result;\n\t}",
    "start_line": 45,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "forceRefresh"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkAll",
    "component_id": "src.services.dependency-checker.checkAll"
  },
  "src.services.dependency-checker.invalidateCache": {
    "id": "src.services.dependency-checker.invalidateCache",
    "name": "invalidateCache",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "invalidateCache(): void {\n\t\tthis.outputChannel.appendLine(\"[DependencyChecker] Cache invalidated\");\n\t\tthis.cache = null;\n\t}",
    "start_line": 87,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method invalidateCache",
    "component_id": "src.services.dependency-checker.invalidateCache"
  },
  "src.services.dependency-checker.checkCopilotChat": {
    "id": "src.services.dependency-checker.checkCopilotChat",
    "name": "checkCopilotChat",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "private checkCopilotChat(): DependencyStatus[\"copilotChat\"] {\n\t\ttry {\n\t\t\tconst extension = extensions.getExtension(\"github.copilot-chat\");\n\n\t\t\tif (!extension) {\n\t\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t\t\"[DependencyChecker] GitHub Copilot Chat: NOT installed\"\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tinstalled: false,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tversion: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst version = extension.packageJSON?.version || null;\n\t\t\tconst active = extension.isActive;\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependencyChecker] GitHub Copilot Chat: installed (v${version || \"unknown\"}), ${active ? \"active\" : \"inactive\"}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tinstalled: true,\n\t\t\t\tactive,\n\t\t\t\tversion,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[DependencyChecker] Error checking Copilot Chat: ${error}`\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tinstalled: false,\n\t\t\t\tactive: false,\n\t\t\t\tversion: null,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 96,
    "end_line": 133,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method checkCopilotChat",
    "component_id": "src.services.dependency-checker.checkCopilotChat"
  },
  "src.services.dependency-checker.checkSpecKitCLI": {
    "id": "src.services.dependency-checker.checkSpecKitCLI",
    "name": "checkSpecKitCLI",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "private async checkSpecKitCLI(): Promise<DependencyStatus[\"speckit\"]> {\n\t\tconst result = await checkCLI(\n\t\t\t\"specify version\",\n\t\t\tDependencyChecker.CLI_TIMEOUT_MS\n\t\t);\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependencyChecker] SpecKit CLI: ${result.installed ? `installed (v${result.version || \"unknown\"})` : \"NOT installed\"}${result.error ? ` - ${result.error}` : \"\"}`\n\t\t);\n\n\t\treturn {\n\t\t\tinstalled: result.installed,\n\t\t\tversion: result.version,\n\t\t};\n\t}",
    "start_line": 140,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkSpecKitCLI",
    "component_id": "src.services.dependency-checker.checkSpecKitCLI"
  },
  "src.services.dependency-checker.checkOpenSpecCLI": {
    "id": "src.services.dependency-checker.checkOpenSpecCLI",
    "name": "checkOpenSpecCLI",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "private async checkOpenSpecCLI(): Promise<DependencyStatus[\"openspec\"]> {\n\t\tconst result = await checkCLI(\n\t\t\t\"openspec --version\",\n\t\t\tDependencyChecker.CLI_TIMEOUT_MS\n\t\t);\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DependencyChecker] OpenSpec CLI: ${result.installed ? `installed (v${result.version || \"unknown\"})` : \"NOT installed\"}${result.error ? ` - ${result.error}` : \"\"}`\n\t\t);\n\n\t\treturn {\n\t\t\tinstalled: result.installed,\n\t\t\tversion: result.version,\n\t\t};\n\t}",
    "start_line": 161,
    "end_line": 175,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkOpenSpecCLI",
    "component_id": "src.services.dependency-checker.checkOpenSpecCLI"
  },
  "src.services.dependency-checker.isCacheValid": {
    "id": "src.services.dependency-checker.isCacheValid",
    "name": "isCacheValid",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "private isCacheValid(): boolean {\n\t\tif (!this.cache) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst age = Date.now() - this.cache.timestamp;\n\t\treturn age < DependencyChecker.CACHE_TTL_MS;\n\t}",
    "start_line": 180,
    "end_line": 187,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isCacheValid",
    "component_id": "src.services.dependency-checker.isCacheValid"
  },
  "src.services.dependency-checker.getCacheAge": {
    "id": "src.services.dependency-checker.getCacheAge",
    "name": "getCacheAge",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/dependency-checker.ts",
    "relative_path": "src/services/dependency-checker.ts",
    "depends_on": [],
    "source_code": "getCacheAge(): number | null {\n\t\tif (!this.cache) {\n\t\t\treturn null;\n\t\t}\n\t\treturn Date.now() - this.cache.timestamp;\n\t}",
    "start_line": 192,
    "end_line": 197,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCacheAge",
    "component_id": "src.services.dependency-checker.getCacheAge"
  },
  "src.services.document-dependency-tracker.DocumentVersion": {
    "id": "src.services.document-dependency-tracker.DocumentVersion",
    "name": "DocumentVersion",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [
      "src.types.preview.PreviewDocumentType"
    ],
    "source_code": "interface DocumentVersion {\n\tdocumentId: string;\n\tdocumentType: PreviewDocumentType;\n\tcontentHash: string;\n\tlastModified: number;\n\tstructuralHash?: string; // For tasks/checklists - ignores checkbox changes\n}",
    "start_line": 7,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentVersion",
    "component_id": "src.services.document-dependency-tracker.DocumentVersion"
  },
  "src.services.document-dependency-tracker.DocumentDependency": {
    "id": "src.services.document-dependency-tracker.DocumentDependency",
    "name": "DocumentDependency",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [
      "src.types.preview.PreviewDocumentType"
    ],
    "source_code": "interface DocumentDependency {\n\tdocumentId: string;\n\tdocumentType: PreviewDocumentType;\n\tdependsOn: string[]; // Array of document IDs this depends on\n}",
    "start_line": 15,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentDependency",
    "component_id": "src.services.document-dependency-tracker.DocumentDependency"
  },
  "src.services.document-dependency-tracker.OutdatedDocumentInfo": {
    "id": "src.services.document-dependency-tracker.OutdatedDocumentInfo",
    "name": "OutdatedDocumentInfo",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [
      "src.types.preview.PreviewDocumentType"
    ],
    "source_code": "interface OutdatedDocumentInfo {\n\tdocumentId: string;\n\tdocumentType: PreviewDocumentType;\n\toutdatedSince: number;\n\tchangedDependencies: Array<{\n\t\tdocumentId: string;\n\t\tdocumentType: PreviewDocumentType;\n\t\tlastChanged: number;\n\t}>;\n}",
    "start_line": 21,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface OutdatedDocumentInfo",
    "component_id": "src.services.document-dependency-tracker.OutdatedDocumentInfo"
  },
  "src.services.document-dependency-tracker.DocumentDependencyTracker": {
    "id": "src.services.document-dependency-tracker.DocumentDependencyTracker",
    "name": "DocumentDependencyTracker",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [
      "src.services.document-dependency-tracker.getStoredVersions",
      "src.services.document-dependency-tracker.extractSpecName",
      "src.services.document-dependency-tracker.DocumentVersion",
      "src.services.document-dependency-tracker.computeContentHash",
      "src.services.document-dependency-tracker.registerDependency",
      "src.types.preview.PreviewDocumentType",
      "src.services.document-dependency-tracker.computeStructuralHash",
      "src.features.agents.resource-cache.get",
      "src.services.document-dependency-tracker.DocumentDependencyTracker",
      "src.services.document-dependency-tracker.OutdatedDocumentInfo",
      "src.services.document-dependency-tracker.DocumentDependency",
      "src.services.document-dependency-tracker.getStoredDependencies"
    ],
    "source_code": "class DocumentDependencyTracker {\n\tprivate static instance: DocumentDependencyTracker;\n\tprivate readonly context: ExtensionContext;\n\tprivate readonly VERSIONS_KEY = \"gatomia.document.versions\";\n\tprivate readonly DEPENDENCIES_KEY = \"gatomia.document.dependencies\";\n\n\t/**\n\t * Document dependency hierarchy in SpecKit/OpenSpec\n\t */\n\tprivate readonly dependencyRules: Record<\n\t\tPreviewDocumentType,\n\t\tPreviewDocumentType[]\n\t> = {\n\t\tspec: [], // Base document - no dependencies\n\t\tresearch: [], // Supports spec but doesn't depend on it\n\t\tdataModel: [\"spec\"], // Data model depends on spec\n\t\tapi: [\"spec\", \"dataModel\"], // API depends on spec and data model\n\t\tplan: [\"spec\"], // Plan depends on spec\n\t\ttask: [\"spec\", \"plan\"], // Tasks depend on spec and plan\n\t\tchecklist: [\"task\"], // Checklist depends on tasks\n\t\tquickstart: [\"spec\", \"plan\"], // Quickstart depends on spec and plan\n\t};\n\n\tprivate constructor(context: ExtensionContext) {\n\t\tthis.context = context;\n\t}\n\n\tstatic getInstance(context?: ExtensionContext): DocumentDependencyTracker {\n\t\tif (!DocumentDependencyTracker.instance) {\n\t\t\tif (!context) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"DocumentDependencyTracker must be initialized with context first\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tDocumentDependencyTracker.instance = new DocumentDependencyTracker(\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\treturn DocumentDependencyTracker.instance;\n\t}\n\n\t/**\n\t * Computes content hash for a document\n\t */\n\tprivate computeContentHash(content: string): string {\n\t\treturn createHash(\"sha256\").update(content).digest(\"hex\");\n\t}\n\n\t/**\n\t * Computes structural hash for tasks/checklists (ignores checkbox states)\n\t */\n\tprivate computeStructuralHash(\n\t\tcontent: string,\n\t\tdocType: PreviewDocumentType\n\t): string {\n\t\tif (docType === \"task\" || docType === \"checklist\") {\n\t\t\t// Remove checkbox markers to detect only structural changes\n\t\t\tconst normalized = content\n\t\t\t\t.replace(/- \\[[ xX]\\]/g, \"- [ ]\") // Normalize checkboxes\n\t\t\t\t.replace(/\\b\\d{4}-\\d{2}-\\d{2}\\b/g, \"DATE\") // Normalize dates\n\t\t\t\t.replace(\n\t\t\t\t\t/\\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\b/gi,\n\t\t\t\t\t\"UUID\"\n\t\t\t\t); // Normalize UUIDs\n\t\t\treturn this.computeContentHash(normalized);\n\t\t}\n\t\treturn this.computeContentHash(content);\n\t}\n\n\t/**\n\t * Records the current version of a document\n\t */\n\tasync recordDocumentVersion(\n\t\tdocumentId: string,\n\t\tdocumentType: PreviewDocumentType,\n\t\tcontent: string\n\t): Promise<void> {\n\t\tconst versions = this.getStoredVersions();\n\t\tconst contentHash = this.computeContentHash(content);\n\t\tconst structuralHash = this.computeStructuralHash(content, documentType);\n\n\t\tversions[documentId] = {\n\t\t\tdocumentId,\n\t\t\tdocumentType,\n\t\t\tcontentHash,\n\t\t\tstructuralHash,\n\t\t\tlastModified: Date.now(),\n\t\t};\n\n\t\tawait this.context.workspaceState.update(this.VERSIONS_KEY, versions);\n\n\t\t// Auto-register dependencies based on document type\n\t\tawait this.registerDependency(documentId, documentType);\n\t}\n\n\t/**\n\t * Registers a document's dependencies based on its type\n\t */\n\tprivate async registerDependency(\n\t\tdocumentId: string,\n\t\tdocumentType: PreviewDocumentType\n\t): Promise<void> {\n\t\tconst dependencies = this.getStoredDependencies();\n\t\tconst dependsOnTypes = this.dependencyRules[documentType] || [];\n\n\t\t// Extract spec name from document ID (e.g., \"001-feature\" from \"001-feature/spec.md\")\n\t\tconst specName = this.extractSpecName(documentId);\n\t\tif (!specName) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Build list of dependency document IDs based on the same spec\n\t\tconst dependsOn = dependsOnTypes.map((type) => `${specName}/${type}.md`);\n\n\t\tdependencies[documentId] = {\n\t\t\tdocumentId,\n\t\t\tdocumentType,\n\t\t\tdependsOn,\n\t\t};\n\n\t\tawait this.context.workspaceState.update(\n\t\t\tthis.DEPENDENCIES_KEY,\n\t\t\tdependencies\n\t\t);\n\t}\n\n\t/**\n\t * Extracts spec name from document ID\n\t */\n\tprivate extractSpecName(documentId: string): string | null {\n\t\t// Handle formats like \"001-feature/spec.md\" or \"001-feature\"\n\t\tconst match = documentId.match(SPEC_NAME_PATTERN);\n\t\treturn match ? match[1] : null;\n\t}\n\n\t/**\n\t * Checks if a document is outdated based on its dependencies\n\t */\n\tisDocumentOutdated(\n\t\tdocumentId: string,\n\t\tdocumentType: PreviewDocumentType\n\t): OutdatedDocumentInfo | null {\n\t\tconst versions = this.getStoredVersions();\n\t\tconst dependencies = this.getStoredDependencies();\n\n\t\tconst currentDoc = versions[documentId];\n\t\tif (!currentDoc) {\n\t\t\t// Document not tracked yet - not outdated\n\t\t\treturn null;\n\t\t}\n\n\t\tconst dependency = dependencies[documentId];\n\t\tif (!dependency || dependency.dependsOn.length === 0) {\n\t\t\t// No dependencies - never outdated\n\t\t\treturn null;\n\t\t}\n\n\t\tconst changedDependencies: OutdatedDocumentInfo[\"changedDependencies\"] = [];\n\n\t\tfor (const depId of dependency.dependsOn) {\n\t\t\tconst depVersion = versions[depId];\n\t\t\tif (!depVersion) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if dependency was modified after this document\n\t\t\tif (depVersion.lastModified > currentDoc.lastModified) {\n\t\t\t\t// Dependency changed after this document was last updated\n\t\t\t\tchangedDependencies.push({\n\t\t\t\t\tdocumentId: depId,\n\t\t\t\t\tdocumentType: depVersion.documentType,\n\t\t\t\t\tlastChanged: depVersion.lastModified,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (changedDependencies.length > 0) {\n\t\t\treturn {\n\t\t\t\tdocumentId,\n\t\t\t\tdocumentType,\n\t\t\t\toutdatedSince: Math.min(\n\t\t\t\t\t...changedDependencies.map((d) => d.lastChanged)\n\t\t\t\t),\n\t\t\t\tchangedDependencies,\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Marks a document as updated (resets its timestamp)\n\t */\n\tasync markDocumentUpdated(documentId: string): Promise<void> {\n\t\tconst versions = this.getStoredVersions();\n\t\tconst version = versions[documentId];\n\t\tif (!version) {\n\t\t\treturn;\n\t\t}\n\n\t\tversion.lastModified = Date.now();\n\t\tawait this.context.workspaceState.update(this.VERSIONS_KEY, versions);\n\t}\n\n\t/**\n\t * Gets the dependency chain for a document (what depends on what)\n\t */\n\tgetDependencyChain(documentId: string): string[] {\n\t\tconst dependencies = this.getStoredDependencies();\n\t\tconst dep = dependencies[documentId];\n\t\treturn dep ? dep.dependsOn : [];\n\t}\n\n\t/**\n\t * Gets all documents that depend on a given document\n\t */\n\tgetDependentDocuments(documentId: string): string[] {\n\t\tconst dependencies = this.getStoredDependencies();\n\t\treturn Object.values(dependencies)\n\t\t\t.filter((dep) => dep.dependsOn.includes(documentId))\n\t\t\t.map((dep) => dep.documentId);\n\t}\n\n\t/**\n\t * Clears all tracking data (for testing/debugging)\n\t */\n\tasync clearAllTracking(): Promise<void> {\n\t\tawait this.context.workspaceState.update(this.VERSIONS_KEY, undefined);\n\t\tawait this.context.workspaceState.update(this.DEPENDENCIES_KEY, undefined);\n\t}\n\n\tprivate getStoredVersions(): Record<string, DocumentVersion> {\n\t\treturn this.context.workspaceState.get(this.VERSIONS_KEY, {});\n\t}\n\n\tprivate getStoredDependencies(): Record<string, DocumentDependency> {\n\t\treturn this.context.workspaceState.get(this.DEPENDENCIES_KEY, {});\n\t}\n}",
    "start_line": 36,
    "end_line": 274,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DocumentDependencyTracker",
    "component_id": "src.services.document-dependency-tracker.DocumentDependencyTracker"
  },
  "src.services.document-dependency-tracker.getInstance": {
    "id": "src.services.document-dependency-tracker.getInstance",
    "name": "getInstance",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "static getInstance(context?: ExtensionContext): DocumentDependencyTracker {\n\t\tif (!DocumentDependencyTracker.instance) {\n\t\t\tif (!context) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"DocumentDependencyTracker must be initialized with context first\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tDocumentDependencyTracker.instance = new DocumentDependencyTracker(\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\treturn DocumentDependencyTracker.instance;\n\t}",
    "start_line": 63,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method getInstance",
    "component_id": "src.services.document-dependency-tracker.getInstance"
  },
  "src.services.document-dependency-tracker.computeContentHash": {
    "id": "src.services.document-dependency-tracker.computeContentHash",
    "name": "computeContentHash",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "private computeContentHash(content: string): string {\n\t\treturn createHash(\"sha256\").update(content).digest(\"hex\");\n\t}",
    "start_line": 80,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method computeContentHash",
    "component_id": "src.services.document-dependency-tracker.computeContentHash"
  },
  "src.services.document-dependency-tracker.computeStructuralHash": {
    "id": "src.services.document-dependency-tracker.computeStructuralHash",
    "name": "computeStructuralHash",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "private computeStructuralHash(\n\t\tcontent: string,\n\t\tdocType: PreviewDocumentType\n\t): string {\n\t\tif (docType === \"task\" || docType === \"checklist\") {\n\t\t\t// Remove checkbox markers to detect only structural changes\n\t\t\tconst normalized = content\n\t\t\t\t.replace(/- \\[[ xX]\\]/g, \"- [ ]\") // Normalize checkboxes\n\t\t\t\t.replace(/\\b\\d{4}-\\d{2}-\\d{2}\\b/g, \"DATE\") // Normalize dates\n\t\t\t\t.replace(\n\t\t\t\t\t/\\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\b/gi,\n\t\t\t\t\t\"UUID\"\n\t\t\t\t); // Normalize UUIDs\n\t\t\treturn this.computeContentHash(normalized);\n\t\t}\n\t\treturn this.computeContentHash(content);\n\t}",
    "start_line": 87,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content",
      "docType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method computeStructuralHash",
    "component_id": "src.services.document-dependency-tracker.computeStructuralHash"
  },
  "src.services.document-dependency-tracker.recordDocumentVersion": {
    "id": "src.services.document-dependency-tracker.recordDocumentVersion",
    "name": "recordDocumentVersion",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "async recordDocumentVersion(\n\t\tdocumentId: string,\n\t\tdocumentType: PreviewDocumentType,\n\t\tcontent: string\n\t): Promise<void> {\n\t\tconst versions = this.getStoredVersions();\n\t\tconst contentHash = this.computeContentHash(content);\n\t\tconst structuralHash = this.computeStructuralHash(content, documentType);\n\n\t\tversions[documentId] = {\n\t\t\tdocumentId,\n\t\t\tdocumentType,\n\t\t\tcontentHash,\n\t\t\tstructuralHash,\n\t\t\tlastModified: Date.now(),\n\t\t};\n\n\t\tawait this.context.workspaceState.update(this.VERSIONS_KEY, versions);\n\n\t\t// Auto-register dependencies based on document type\n\t\tawait this.registerDependency(documentId, documentType);\n\t}",
    "start_line": 108,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId",
      "documentType",
      "content"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method recordDocumentVersion",
    "component_id": "src.services.document-dependency-tracker.recordDocumentVersion"
  },
  "src.services.document-dependency-tracker.registerDependency": {
    "id": "src.services.document-dependency-tracker.registerDependency",
    "name": "registerDependency",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "private async registerDependency(\n\t\tdocumentId: string,\n\t\tdocumentType: PreviewDocumentType\n\t): Promise<void> {\n\t\tconst dependencies = this.getStoredDependencies();\n\t\tconst dependsOnTypes = this.dependencyRules[documentType] || [];\n\n\t\t// Extract spec name from document ID (e.g., \"001-feature\" from \"001-feature/spec.md\")\n\t\tconst specName = this.extractSpecName(documentId);\n\t\tif (!specName) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Build list of dependency document IDs based on the same spec\n\t\tconst dependsOn = dependsOnTypes.map((type) => `${specName}/${type}.md`);\n\n\t\tdependencies[documentId] = {\n\t\t\tdocumentId,\n\t\t\tdocumentType,\n\t\t\tdependsOn,\n\t\t};\n\n\t\tawait this.context.workspaceState.update(\n\t\t\tthis.DEPENDENCIES_KEY,\n\t\t\tdependencies\n\t\t);\n\t}",
    "start_line": 134,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId",
      "documentType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method registerDependency",
    "component_id": "src.services.document-dependency-tracker.registerDependency"
  },
  "src.services.document-dependency-tracker.extractSpecName": {
    "id": "src.services.document-dependency-tracker.extractSpecName",
    "name": "extractSpecName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "private extractSpecName(documentId: string): string | null {\n\t\t// Handle formats like \"001-feature/spec.md\" or \"001-feature\"\n\t\tconst match = documentId.match(SPEC_NAME_PATTERN);\n\t\treturn match ? match[1] : null;\n\t}",
    "start_line": 165,
    "end_line": 169,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractSpecName",
    "component_id": "src.services.document-dependency-tracker.extractSpecName"
  },
  "src.services.document-dependency-tracker.isDocumentOutdated": {
    "id": "src.services.document-dependency-tracker.isDocumentOutdated",
    "name": "isDocumentOutdated",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "isDocumentOutdated(\n\t\tdocumentId: string,\n\t\tdocumentType: PreviewDocumentType\n\t): OutdatedDocumentInfo | null {\n\t\tconst versions = this.getStoredVersions();\n\t\tconst dependencies = this.getStoredDependencies();\n\n\t\tconst currentDoc = versions[documentId];\n\t\tif (!currentDoc) {\n\t\t\t// Document not tracked yet - not outdated\n\t\t\treturn null;\n\t\t}\n\n\t\tconst dependency = dependencies[documentId];\n\t\tif (!dependency || dependency.dependsOn.length === 0) {\n\t\t\t// No dependencies - never outdated\n\t\t\treturn null;\n\t\t}\n\n\t\tconst changedDependencies: OutdatedDocumentInfo[\"changedDependencies\"] = [];\n\n\t\tfor (const depId of dependency.dependsOn) {\n\t\t\tconst depVersion = versions[depId];\n\t\t\tif (!depVersion) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if dependency was modified after this document\n\t\t\tif (depVersion.lastModified > currentDoc.lastModified) {\n\t\t\t\t// Dependency changed after this document was last updated\n\t\t\t\tchangedDependencies.push({\n\t\t\t\t\tdocumentId: depId,\n\t\t\t\t\tdocumentType: depVersion.documentType,\n\t\t\t\t\tlastChanged: depVersion.lastModified,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (changedDependencies.length > 0) {\n\t\t\treturn {\n\t\t\t\tdocumentId,\n\t\t\t\tdocumentType,\n\t\t\t\toutdatedSince: Math.min(\n\t\t\t\t\t...changedDependencies.map((d) => d.lastChanged)\n\t\t\t\t),\n\t\t\t\tchangedDependencies,\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}",
    "start_line": 174,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId",
      "documentType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isDocumentOutdated",
    "component_id": "src.services.document-dependency-tracker.isDocumentOutdated"
  },
  "src.services.document-dependency-tracker.markDocumentUpdated": {
    "id": "src.services.document-dependency-tracker.markDocumentUpdated",
    "name": "markDocumentUpdated",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "async markDocumentUpdated(documentId: string): Promise<void> {\n\t\tconst versions = this.getStoredVersions();\n\t\tconst version = versions[documentId];\n\t\tif (!version) {\n\t\t\treturn;\n\t\t}\n\n\t\tversion.lastModified = Date.now();\n\t\tawait this.context.workspaceState.update(this.VERSIONS_KEY, versions);\n\t}",
    "start_line": 229,
    "end_line": 238,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method markDocumentUpdated",
    "component_id": "src.services.document-dependency-tracker.markDocumentUpdated"
  },
  "src.services.document-dependency-tracker.getDependencyChain": {
    "id": "src.services.document-dependency-tracker.getDependencyChain",
    "name": "getDependencyChain",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "getDependencyChain(documentId: string): string[] {\n\t\tconst dependencies = this.getStoredDependencies();\n\t\tconst dep = dependencies[documentId];\n\t\treturn dep ? dep.dependsOn : [];\n\t}",
    "start_line": 243,
    "end_line": 247,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getDependencyChain",
    "component_id": "src.services.document-dependency-tracker.getDependencyChain"
  },
  "src.services.document-dependency-tracker.getDependentDocuments": {
    "id": "src.services.document-dependency-tracker.getDependentDocuments",
    "name": "getDependentDocuments",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "getDependentDocuments(documentId: string): string[] {\n\t\tconst dependencies = this.getStoredDependencies();\n\t\treturn Object.values(dependencies)\n\t\t\t.filter((dep) => dep.dependsOn.includes(documentId))\n\t\t\t.map((dep) => dep.documentId);\n\t}",
    "start_line": 252,
    "end_line": 257,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getDependentDocuments",
    "component_id": "src.services.document-dependency-tracker.getDependentDocuments"
  },
  "src.services.document-dependency-tracker.clearAllTracking": {
    "id": "src.services.document-dependency-tracker.clearAllTracking",
    "name": "clearAllTracking",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "async clearAllTracking(): Promise<void> {\n\t\tawait this.context.workspaceState.update(this.VERSIONS_KEY, undefined);\n\t\tawait this.context.workspaceState.update(this.DEPENDENCIES_KEY, undefined);\n\t}",
    "start_line": 262,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method clearAllTracking",
    "component_id": "src.services.document-dependency-tracker.clearAllTracking"
  },
  "src.services.document-dependency-tracker.getStoredVersions": {
    "id": "src.services.document-dependency-tracker.getStoredVersions",
    "name": "getStoredVersions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "private getStoredVersions(): Record<string, DocumentVersion> {\n\t\treturn this.context.workspaceState.get(this.VERSIONS_KEY, {});\n\t}",
    "start_line": 267,
    "end_line": 269,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getStoredVersions",
    "component_id": "src.services.document-dependency-tracker.getStoredVersions"
  },
  "src.services.document-dependency-tracker.getStoredDependencies": {
    "id": "src.services.document-dependency-tracker.getStoredDependencies",
    "name": "getStoredDependencies",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-dependency-tracker.ts",
    "relative_path": "src/services/document-dependency-tracker.ts",
    "depends_on": [],
    "source_code": "private getStoredDependencies(): Record<string, DocumentDependency> {\n\t\treturn this.context.workspaceState.get(this.DEPENDENCIES_KEY, {});\n\t}",
    "start_line": 271,
    "end_line": 273,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getStoredDependencies",
    "component_id": "src.services.document-dependency-tracker.getStoredDependencies"
  },
  "src.services.document-preview-service.LoadDocumentOptions": {
    "id": "src.services.document-preview-service.LoadDocumentOptions",
    "name": "LoadDocumentOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [
      "src.types.preview.PreviewDocumentType"
    ],
    "source_code": "interface LoadDocumentOptions {\n\tdocumentType?: PreviewDocumentType;\n\ttitleOverride?: string;\n}",
    "start_line": 23,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LoadDocumentOptions",
    "component_id": "src.services.document-preview-service.LoadDocumentOptions"
  },
  "src.services.document-preview-service.DocumentPreviewService": {
    "id": "src.services.document-preview-service.DocumentPreviewService",
    "name": "DocumentPreviewService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [
      "src.types.preview.PreviewSection",
      "src.types.preview.PreviewDocumentType",
      "src.services.document-preview-service.LoadDocumentOptions",
      "src.services.document-preview-service.normalizeFormField",
      "src.types.preview.DocumentPermissions",
      "src.services.document-preview-service.slugify",
      "ui.src.features.preview.api.form-bridge.FormSubmissionPayload",
      "ui.src.features.preview.types.DocumentArtifact",
      "src.utils.document-title-utils.getRelativePath",
      "src.services.document-dependency-tracker.isDocumentOutdated",
      "src.services.document-preview-service.uniqueSlug",
      "src.features.agents.resource-cache.get",
      "src.services.document-preview-service.extractSections",
      "src.services.document-preview-service.parseForms",
      "src.services.document-preview-service.inferTypeFromUri",
      "src.services.document-dependency-tracker.recordDocumentVersion",
      "ui.src.features.preview.stores.form-store.FormField",
      "src.utils.spec-kit-adapter.getInstance",
      "src.services.document-preview-service.parsePermissions",
      "src.services.document-dependency-tracker.DocumentDependencyTracker"
    ],
    "source_code": "class DocumentPreviewService {\n\tprivate readonly changeEmitter = new EventEmitter<Uri>();\n\treadonly onDidChangeDocument: Event<Uri>;\n\tprivate readonly outputChannel: OutputChannel;\n\tprivate readonly dependencyTracker: DocumentDependencyTracker | null = null;\n\n\tconstructor(outputChannel: OutputChannel, context?: ExtensionContext) {\n\t\tthis.outputChannel = outputChannel;\n\t\tthis.onDidChangeDocument = this.changeEmitter.event;\n\t\tif (context) {\n\t\t\tthis.dependencyTracker = DocumentDependencyTracker.getInstance(context);\n\t\t}\n\t}\n\n\tasync loadDocument(\n\t\turi: Uri,\n\t\toptions: LoadDocumentOptions = {}\n\t): Promise<DocumentArtifact> {\n\t\tconst bytes = await workspace.fs.readFile(uri);\n\t\tconst content = Buffer.from(bytes).toString(\"utf8\");\n\t\tconst parsed = matter(content);\n\n\t\tconst documentType =\n\t\t\toptions.documentType ?? this.inferTypeFromUri(uri.fsPath);\n\n\t\tconst sections = this.extractSections(parsed.content);\n\t\tconst forms = this.parseForms(parsed.data?.forms);\n\t\tconst permissions = this.parsePermissions(parsed.data?.permissions);\n\n\t\t// Get workspace root for relative path calculation\n\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\tconst filePath = getRelativePath(uri.fsPath, workspaceRoot);\n\n\t\t// Check if document is outdated due to dependency changes\n\t\tlet isOutdated = false;\n\t\tlet outdatedInfo: DocumentArtifact[\"outdatedInfo\"];\n\n\t\tif (this.dependencyTracker) {\n\t\t\tconst documentId = filePath || uri.toString();\n\n\t\t\t// Record current version\n\t\t\tawait this.dependencyTracker.recordDocumentVersion(\n\t\t\t\tdocumentId,\n\t\t\t\tdocumentType,\n\t\t\t\tcontent\n\t\t\t);\n\n\t\t\t// Check if outdated\n\t\t\tconst outdatedResult = this.dependencyTracker.isDocumentOutdated(\n\t\t\t\tdocumentId,\n\t\t\t\tdocumentType\n\t\t\t);\n\n\t\t\tif (outdatedResult) {\n\t\t\t\tisOutdated = true;\n\t\t\t\toutdatedInfo = {\n\t\t\t\t\toutdatedSince: outdatedResult.outdatedSince,\n\t\t\t\t\tchangedDependencies: outdatedResult.changedDependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst artifact: DocumentArtifact = {\n\t\t\tdocumentId: uri.toString(),\n\t\t\tdocumentType,\n\t\t\ttitle:\n\t\t\t\toptions.titleOverride ||\n\t\t\t\t(parsed.data?.title as string | undefined) ||\n\t\t\t\tbasename(uri.fsPath),\n\t\t\tfilePath,\n\t\t\tversion: parsed.data?.version as string | undefined,\n\t\t\towner: parsed.data?.owner as string | undefined,\n\t\t\tupdatedAt:\n\t\t\t\t(parsed.data?.updatedAt as string | undefined) ||\n\t\t\t\tnew Date().toISOString(),\n\t\t\trenderStandard:\n\t\t\t\t(parsed.data?.renderStandard as string | undefined) || \"markdown\",\n\t\t\tsessionId: randomUUID(),\n\t\t\tisOutdated,\n\t\t\toutdatedInfo,\n\t\t\tsections,\n\t\t\tdiagrams: [],\n\t\t\tforms,\n\t\t\trawContent: parsed.content,\n\t\t\tmetadata: parsed.data ?? {},\n\t\t\tpermissions,\n\t\t};\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewService] Loaded ${artifact.documentType} from ${uri.fsPath}`\n\t\t);\n\n\t\treturn artifact;\n\t}\n\n\tpersistFormSubmission(payload: FormSubmissionPayload): void {\n\t\tconst changedFieldIds = payload.fields\n\t\t\t.map((field) => field.fieldId)\n\t\t\t.join(\", \");\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewService] Received form submission for ${payload.documentId} (session ${payload.sessionId}) with fields: ${changedFieldIds}`\n\t\t);\n\t}\n\n\tmarkDocumentChanged(uri: Uri): void {\n\t\tthis.changeEmitter.fire(uri);\n\t}\n\n\tprivate parseForms(rawForms: unknown): FormField[] {\n\t\tif (!Array.isArray(rawForms)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn rawForms\n\t\t\t.map((rawField, index) => this.normalizeFormField(rawField, index))\n\t\t\t.filter((field): field is FormField => Boolean(field));\n\t}\n\n\t// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Normalizing heterogeneous form definitions requires consolidated branching.\n\tprivate normalizeFormField(\n\t\trawField: unknown,\n\t\tindex: number\n\t): FormField | undefined {\n\t\tif (!rawField || typeof rawField !== \"object\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst candidate = rawField as Record<string, unknown>;\n\t\tconst supportedTypes = new Set<FormField[\"type\"]>([\n\t\t\t\"checkbox\",\n\t\t\t\"dropdown\",\n\t\t\t\"text\",\n\t\t\t\"textarea\",\n\t\t\t\"multiselect\",\n\t\t]);\n\n\t\tconst rawType =\n\t\t\ttypeof candidate.type === \"string\" ? candidate.type : \"text\";\n\t\tconst type = supportedTypes.has(rawType as FormField[\"type\"])\n\t\t\t? (rawType as FormField[\"type\"])\n\t\t\t: \"text\";\n\n\t\tconst fieldId =\n\t\t\ttypeof candidate.fieldId === \"string\" && candidate.fieldId.trim()\n\t\t\t\t? candidate.fieldId.trim()\n\t\t\t\t: `form-field-${index + 1}`;\n\n\t\tlet value: string | string[] | undefined;\n\t\tif (type === \"multiselect\") {\n\t\t\tif (Array.isArray(candidate.value)) {\n\t\t\t\tvalue = candidate.value.filter(\n\t\t\t\t\t(item): item is string => typeof item === \"string\"\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\ttypeof candidate.value === \"string\" &&\n\t\t\t\tcandidate.value.length > 0\n\t\t\t) {\n\t\t\t\tvalue = candidate.value.split(\",\").map((item) => item.trim());\n\t\t\t} else {\n\t\t\t\tvalue = [];\n\t\t\t}\n\t\t} else if (typeof candidate.value === \"string\") {\n\t\t\tvalue = candidate.value;\n\t\t}\n\n\t\tconst options = Array.isArray(candidate.options)\n\t\t\t? candidate.options\n\t\t\t\t\t.map((option) => (typeof option === \"string\" ? option : undefined))\n\t\t\t\t\t.filter((option): option is string => Boolean(option))\n\t\t\t: undefined;\n\n\t\treturn {\n\t\t\tfieldId,\n\t\t\tlabel:\n\t\t\t\t(typeof candidate.label === \"string\" && candidate.label.trim()) ||\n\t\t\t\tfieldId,\n\t\t\ttype,\n\t\t\toptions,\n\t\t\trequired: Boolean(candidate.required),\n\t\t\tvalue,\n\t\t\tvalidationRules:\n\t\t\t\tcandidate.validationRules &&\n\t\t\t\ttypeof candidate.validationRules === \"object\"\n\t\t\t\t\t? (candidate.validationRules as Record<string, unknown>)\n\t\t\t\t\t: undefined,\n\t\t\treadOnly: Boolean(candidate.readOnly),\n\t\t};\n\t}\n\n\tprivate parsePermissions(\n\t\trawPermissions: unknown\n\t): DocumentPermissions | undefined {\n\t\tif (!rawPermissions || typeof rawPermissions !== \"object\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst candidate = rawPermissions as Record<string, unknown>;\n\t\tlet canEditForms = true;\n\t\tif (typeof candidate.canEditForms === \"boolean\") {\n\t\t\tcanEditForms = candidate.canEditForms;\n\t\t} else if (typeof candidate.canEdit === \"boolean\") {\n\t\t\tcanEditForms = candidate.canEdit;\n\t\t} else if (candidate.readOnly === true) {\n\t\t\tcanEditForms = false;\n\t\t}\n\n\t\tconst reason =\n\t\t\ttypeof candidate.reason === \"string\" && candidate.reason.trim().length > 0\n\t\t\t\t? candidate.reason.trim()\n\t\t\t\t: undefined;\n\n\t\treturn {\n\t\t\tcanEditForms,\n\t\t\treason,\n\t\t};\n\t}\n\n\tprivate inferTypeFromUri(path: string): PreviewDocumentType {\n\t\tconst normalized = path.toLowerCase();\n\t\tif (normalized.includes(\"/plan\") || normalized.includes(\"-plan\")) {\n\t\t\treturn \"plan\";\n\t\t}\n\t\tif (normalized.includes(\"research\")) {\n\t\t\treturn \"research\";\n\t\t}\n\t\tif (normalized.includes(\"task\")) {\n\t\t\treturn \"task\";\n\t\t}\n\t\tif (\n\t\t\tnormalized.includes(\"data-model\") ||\n\t\t\tnormalized.includes(\"data_model\")\n\t\t) {\n\t\t\treturn \"dataModel\";\n\t\t}\n\t\tif (normalized.includes(\"quickstart\")) {\n\t\t\treturn \"quickstart\";\n\t\t}\n\t\tif (normalized.includes(\"api\")) {\n\t\t\treturn \"api\";\n\t\t}\n\t\tif (\n\t\t\tnormalized.includes(\"/checklists/\") ||\n\t\t\tnormalized.includes(\"checklist\")\n\t\t) {\n\t\t\treturn \"checklist\";\n\t\t}\n\t\treturn \"spec\";\n\t}\n\n\tprivate extractSections(content: string): PreviewSection[] {\n\t\tconst lines = content.split(LINE_SPLIT_PATTERN);\n\t\tconst sections: PreviewSection[] = [];\n\t\tlet currentTitle = \"Overview\";\n\t\tlet currentId = \"overview\";\n\t\tlet currentBody: string[] = [];\n\t\tconst slugCounts = new Map<string, number>();\n\n\t\tconst commit = () => {\n\t\t\tconst body = currentBody.join(\"\\n\").trim();\n\t\t\tsections.push({\n\t\t\t\tid: this.uniqueSlug(currentId, slugCounts),\n\t\t\t\ttitle: currentTitle,\n\t\t\t\tbody,\n\t\t\t});\n\t\t};\n\n\t\tfor (const line of lines) {\n\t\t\tconst match = line.match(HEADING_PATTERN);\n\t\t\tif (match) {\n\t\t\t\tif (currentBody.length > 0 || sections.length === 0) {\n\t\t\t\t\tcommit();\n\t\t\t\t}\n\t\t\t\tcurrentTitle = match[1].trim();\n\t\t\t\tcurrentId = this.slugify(currentTitle);\n\t\t\t\tcurrentBody = [];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentBody.push(line);\n\t\t}\n\n\t\tif (currentBody.length > 0 || sections.length === 0) {\n\t\t\tcommit();\n\t\t}\n\n\t\treturn sections;\n\t}\n\n\tprivate slugify(value: string): string {\n\t\treturn (\n\t\t\tvalue\n\t\t\t\t.toLowerCase()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-+|-+$/g, \"\") || \"section\"\n\t\t);\n\t}\n\n\tprivate uniqueSlug(value: string, counts: Map<string, number>): string {\n\t\tconst count = counts.get(value) ?? 0;\n\t\tcounts.set(value, count + 1);\n\t\tif (count === 0) {\n\t\t\treturn value;\n\t\t}\n\t\treturn `${value}-${count}`;\n\t}\n}",
    "start_line": 31,
    "end_line": 335,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DocumentPreviewService",
    "component_id": "src.services.document-preview-service.DocumentPreviewService"
  },
  "src.services.document-preview-service.loadDocument": {
    "id": "src.services.document-preview-service.loadDocument",
    "name": "loadDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "async loadDocument(\n\t\turi: Uri,\n\t\toptions: LoadDocumentOptions = {}\n\t): Promise<DocumentArtifact> {\n\t\tconst bytes = await workspace.fs.readFile(uri);\n\t\tconst content = Buffer.from(bytes).toString(\"utf8\");\n\t\tconst parsed = matter(content);\n\n\t\tconst documentType =\n\t\t\toptions.documentType ?? this.inferTypeFromUri(uri.fsPath);\n\n\t\tconst sections = this.extractSections(parsed.content);\n\t\tconst forms = this.parseForms(parsed.data?.forms);\n\t\tconst permissions = this.parsePermissions(parsed.data?.permissions);\n\n\t\t// Get workspace root for relative path calculation\n\t\tconst workspaceRoot = workspace.workspaceFolders?.[0].uri.fsPath;\n\t\tconst filePath = getRelativePath(uri.fsPath, workspaceRoot);\n\n\t\t// Check if document is outdated due to dependency changes\n\t\tlet isOutdated = false;\n\t\tlet outdatedInfo: DocumentArtifact[\"outdatedInfo\"];\n\n\t\tif (this.dependencyTracker) {\n\t\t\tconst documentId = filePath || uri.toString();\n\n\t\t\t// Record current version\n\t\t\tawait this.dependencyTracker.recordDocumentVersion(\n\t\t\t\tdocumentId,\n\t\t\t\tdocumentType,\n\t\t\t\tcontent\n\t\t\t);\n\n\t\t\t// Check if outdated\n\t\t\tconst outdatedResult = this.dependencyTracker.isDocumentOutdated(\n\t\t\t\tdocumentId,\n\t\t\t\tdocumentType\n\t\t\t);\n\n\t\t\tif (outdatedResult) {\n\t\t\t\tisOutdated = true;\n\t\t\t\toutdatedInfo = {\n\t\t\t\t\toutdatedSince: outdatedResult.outdatedSince,\n\t\t\t\t\tchangedDependencies: outdatedResult.changedDependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tconst artifact: DocumentArtifact = {\n\t\t\tdocumentId: uri.toString(),\n\t\t\tdocumentType,\n\t\t\ttitle:\n\t\t\t\toptions.titleOverride ||\n\t\t\t\t(parsed.data?.title as string | undefined) ||\n\t\t\t\tbasename(uri.fsPath),\n\t\t\tfilePath,\n\t\t\tversion: parsed.data?.version as string | undefined,\n\t\t\towner: parsed.data?.owner as string | undefined,\n\t\t\tupdatedAt:\n\t\t\t\t(parsed.data?.updatedAt as string | undefined) ||\n\t\t\t\tnew Date().toISOString(),\n\t\t\trenderStandard:\n\t\t\t\t(parsed.data?.renderStandard as string | undefined) || \"markdown\",\n\t\t\tsessionId: randomUUID(),\n\t\t\tisOutdated,\n\t\t\toutdatedInfo,\n\t\t\tsections,\n\t\t\tdiagrams: [],\n\t\t\tforms,\n\t\t\trawContent: parsed.content,\n\t\t\tmetadata: parsed.data ?? {},\n\t\t\tpermissions,\n\t\t};\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewService] Loaded ${artifact.documentType} from ${uri.fsPath}`\n\t\t);\n\n\t\treturn artifact;\n\t}",
    "start_line": 45,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri",
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadDocument",
    "component_id": "src.services.document-preview-service.loadDocument"
  },
  "src.services.document-preview-service.persistFormSubmission": {
    "id": "src.services.document-preview-service.persistFormSubmission",
    "name": "persistFormSubmission",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "persistFormSubmission(payload: FormSubmissionPayload): void {\n\t\tconst changedFieldIds = payload.fields\n\t\t\t.map((field) => field.fieldId)\n\t\t\t.join(\", \");\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[DocumentPreviewService] Received form submission for ${payload.documentId} (session ${payload.sessionId}) with fields: ${changedFieldIds}`\n\t\t);\n\t}",
    "start_line": 126,
    "end_line": 133,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method persistFormSubmission",
    "component_id": "src.services.document-preview-service.persistFormSubmission"
  },
  "src.services.document-preview-service.markDocumentChanged": {
    "id": "src.services.document-preview-service.markDocumentChanged",
    "name": "markDocumentChanged",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "markDocumentChanged(uri: Uri): void {\n\t\tthis.changeEmitter.fire(uri);\n\t}",
    "start_line": 135,
    "end_line": 137,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "uri"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method markDocumentChanged",
    "component_id": "src.services.document-preview-service.markDocumentChanged"
  },
  "src.services.document-preview-service.parseForms": {
    "id": "src.services.document-preview-service.parseForms",
    "name": "parseForms",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private parseForms(rawForms: unknown): FormField[] {\n\t\tif (!Array.isArray(rawForms)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn rawForms\n\t\t\t.map((rawField, index) => this.normalizeFormField(rawField, index))\n\t\t\t.filter((field): field is FormField => Boolean(field));\n\t}",
    "start_line": 139,
    "end_line": 147,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawForms"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method parseForms",
    "component_id": "src.services.document-preview-service.parseForms"
  },
  "src.services.document-preview-service.normalizeFormField": {
    "id": "src.services.document-preview-service.normalizeFormField",
    "name": "normalizeFormField",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private normalizeFormField(\n\t\trawField: unknown,\n\t\tindex: number\n\t): FormField | undefined {\n\t\tif (!rawField || typeof rawField !== \"object\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst candidate = rawField as Record<string, unknown>;\n\t\tconst supportedTypes = new Set<FormField[\"type\"]>([\n\t\t\t\"checkbox\",\n\t\t\t\"dropdown\",\n\t\t\t\"text\",\n\t\t\t\"textarea\",\n\t\t\t\"multiselect\",\n\t\t]);\n\n\t\tconst rawType =\n\t\t\ttypeof candidate.type === \"string\" ? candidate.type : \"text\";\n\t\tconst type = supportedTypes.has(rawType as FormField[\"type\"])\n\t\t\t? (rawType as FormField[\"type\"])\n\t\t\t: \"text\";\n\n\t\tconst fieldId =\n\t\t\ttypeof candidate.fieldId === \"string\" && candidate.fieldId.trim()\n\t\t\t\t? candidate.fieldId.trim()\n\t\t\t\t: `form-field-${index + 1}`;\n\n\t\tlet value: string | string[] | undefined;\n\t\tif (type === \"multiselect\") {\n\t\t\tif (Array.isArray(candidate.value)) {\n\t\t\t\tvalue = candidate.value.filter(\n\t\t\t\t\t(item): item is string => typeof item === \"string\"\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\ttypeof candidate.value === \"string\" &&\n\t\t\t\tcandidate.value.length > 0\n\t\t\t) {\n\t\t\t\tvalue = candidate.value.split(\",\").map((item) => item.trim());\n\t\t\t} else {\n\t\t\t\tvalue = [];\n\t\t\t}\n\t\t} else if (typeof candidate.value === \"string\") {\n\t\t\tvalue = candidate.value;\n\t\t}\n\n\t\tconst options = Array.isArray(candidate.options)\n\t\t\t? candidate.options\n\t\t\t\t\t.map((option) => (typeof option === \"string\" ? option : undefined))\n\t\t\t\t\t.filter((option): option is string => Boolean(option))\n\t\t\t: undefined;\n\n\t\treturn {\n\t\t\tfieldId,\n\t\t\tlabel:\n\t\t\t\t(typeof candidate.label === \"string\" && candidate.label.trim()) ||\n\t\t\t\tfieldId,\n\t\t\ttype,\n\t\t\toptions,\n\t\t\trequired: Boolean(candidate.required),\n\t\t\tvalue,\n\t\t\tvalidationRules:\n\t\t\t\tcandidate.validationRules &&\n\t\t\t\ttypeof candidate.validationRules === \"object\"\n\t\t\t\t\t? (candidate.validationRules as Record<string, unknown>)\n\t\t\t\t\t: undefined,\n\t\t\treadOnly: Boolean(candidate.readOnly),\n\t\t};\n\t}",
    "start_line": 150,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawField",
      "index"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method normalizeFormField",
    "component_id": "src.services.document-preview-service.normalizeFormField"
  },
  "src.services.document-preview-service.parsePermissions": {
    "id": "src.services.document-preview-service.parsePermissions",
    "name": "parsePermissions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private parsePermissions(\n\t\trawPermissions: unknown\n\t): DocumentPermissions | undefined {\n\t\tif (!rawPermissions || typeof rawPermissions !== \"object\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst candidate = rawPermissions as Record<string, unknown>;\n\t\tlet canEditForms = true;\n\t\tif (typeof candidate.canEditForms === \"boolean\") {\n\t\t\tcanEditForms = candidate.canEditForms;\n\t\t} else if (typeof candidate.canEdit === \"boolean\") {\n\t\t\tcanEditForms = candidate.canEdit;\n\t\t} else if (candidate.readOnly === true) {\n\t\t\tcanEditForms = false;\n\t\t}\n\n\t\tconst reason =\n\t\t\ttypeof candidate.reason === \"string\" && candidate.reason.trim().length > 0\n\t\t\t\t? candidate.reason.trim()\n\t\t\t\t: undefined;\n\n\t\treturn {\n\t\t\tcanEditForms,\n\t\t\treason,\n\t\t};\n\t}",
    "start_line": 220,
    "end_line": 246,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawPermissions"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method parsePermissions",
    "component_id": "src.services.document-preview-service.parsePermissions"
  },
  "src.services.document-preview-service.inferTypeFromUri": {
    "id": "src.services.document-preview-service.inferTypeFromUri",
    "name": "inferTypeFromUri",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private inferTypeFromUri(path: string): PreviewDocumentType {\n\t\tconst normalized = path.toLowerCase();\n\t\tif (normalized.includes(\"/plan\") || normalized.includes(\"-plan\")) {\n\t\t\treturn \"plan\";\n\t\t}\n\t\tif (normalized.includes(\"research\")) {\n\t\t\treturn \"research\";\n\t\t}\n\t\tif (normalized.includes(\"task\")) {\n\t\t\treturn \"task\";\n\t\t}\n\t\tif (\n\t\t\tnormalized.includes(\"data-model\") ||\n\t\t\tnormalized.includes(\"data_model\")\n\t\t) {\n\t\t\treturn \"dataModel\";\n\t\t}\n\t\tif (normalized.includes(\"quickstart\")) {\n\t\t\treturn \"quickstart\";\n\t\t}\n\t\tif (normalized.includes(\"api\")) {\n\t\t\treturn \"api\";\n\t\t}\n\t\tif (\n\t\t\tnormalized.includes(\"/checklists/\") ||\n\t\t\tnormalized.includes(\"checklist\")\n\t\t) {\n\t\t\treturn \"checklist\";\n\t\t}\n\t\treturn \"spec\";\n\t}",
    "start_line": 248,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method inferTypeFromUri",
    "component_id": "src.services.document-preview-service.inferTypeFromUri"
  },
  "src.services.document-preview-service.extractSections": {
    "id": "src.services.document-preview-service.extractSections",
    "name": "extractSections",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private extractSections(content: string): PreviewSection[] {\n\t\tconst lines = content.split(LINE_SPLIT_PATTERN);\n\t\tconst sections: PreviewSection[] = [];\n\t\tlet currentTitle = \"Overview\";\n\t\tlet currentId = \"overview\";\n\t\tlet currentBody: string[] = [];\n\t\tconst slugCounts = new Map<string, number>();\n\n\t\tconst commit = () => {\n\t\t\tconst body = currentBody.join(\"\\n\").trim();\n\t\t\tsections.push({\n\t\t\t\tid: this.uniqueSlug(currentId, slugCounts),\n\t\t\t\ttitle: currentTitle,\n\t\t\t\tbody,\n\t\t\t});\n\t\t};\n\n\t\tfor (const line of lines) {\n\t\t\tconst match = line.match(HEADING_PATTERN);\n\t\t\tif (match) {\n\t\t\t\tif (currentBody.length > 0 || sections.length === 0) {\n\t\t\t\t\tcommit();\n\t\t\t\t}\n\t\t\t\tcurrentTitle = match[1].trim();\n\t\t\t\tcurrentId = this.slugify(currentTitle);\n\t\t\t\tcurrentBody = [];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrentBody.push(line);\n\t\t}\n\n\t\tif (currentBody.length > 0 || sections.length === 0) {\n\t\t\tcommit();\n\t\t}\n\n\t\treturn sections;\n\t}",
    "start_line": 280,
    "end_line": 316,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractSections",
    "component_id": "src.services.document-preview-service.extractSections"
  },
  "src.services.document-preview-service.slugify": {
    "id": "src.services.document-preview-service.slugify",
    "name": "slugify",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private slugify(value: string): string {\n\t\treturn (\n\t\t\tvalue\n\t\t\t\t.toLowerCase()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-+|-+$/g, \"\") || \"section\"\n\t\t);\n\t}",
    "start_line": 318,
    "end_line": 325,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method slugify",
    "component_id": "src.services.document-preview-service.slugify"
  },
  "src.services.document-preview-service.uniqueSlug": {
    "id": "src.services.document-preview-service.uniqueSlug",
    "name": "uniqueSlug",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/document-preview-service.ts",
    "relative_path": "src/services/document-preview-service.ts",
    "depends_on": [],
    "source_code": "private uniqueSlug(value: string, counts: Map<string, number>): string {\n\t\tconst count = counts.get(value) ?? 0;\n\t\tcounts.set(value, count + 1);\n\t\tif (count === 0) {\n\t\t\treturn value;\n\t\t}\n\t\treturn `${value}-${count}`;\n\t}",
    "start_line": 327,
    "end_line": 334,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value",
      "counts"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method uniqueSlug",
    "component_id": "src.services.document-preview-service.uniqueSlug"
  },
  "src.services.learning-resources.ResourceCategory": {
    "id": "src.services.learning-resources.ResourceCategory",
    "name": "ResourceCategory",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "type ResourceCategory =\n\t| \"Getting Started\"\n\t| \"Advanced Features\"\n\t| \"Troubleshooting\";",
    "start_line": 11,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ResourceCategory",
    "component_id": "src.services.learning-resources.ResourceCategory"
  },
  "src.services.learning-resources.LearningResources": {
    "id": "src.services.learning-resources.LearningResources",
    "name": "LearningResources",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [
      "src.services.learning-resources.sortResources",
      "ui.src.features.welcome.types.LearningResource",
      "src.services.learning-resources.getAll",
      "src.services.learning-resources.ResourceCategory",
      "src.services.learning-resources.calculateResourceScore"
    ],
    "source_code": "class LearningResources {\n\tprivate resources: LearningResource[] = [];\n\tprivate loaded = false;\n\n\t/**\n\t * Load resources from resources.json\n\t * @param extensionPath - Path to extension root directory\n\t */\n\tloadResources(extensionPath: string): LearningResource[] {\n\t\tif (this.loaded) {\n\t\t\treturn this.resources;\n\t\t}\n\n\t\ttry {\n\t\t\tconst resourcesPath = join(\n\t\t\t\textensionPath,\n\t\t\t\t\"specs\",\n\t\t\t\t\"006-welcome-screen\",\n\t\t\t\t\"resources.json\"\n\t\t\t);\n\n\t\t\tconst fileContent = readFileSync(resourcesPath, \"utf8\");\n\t\t\tconst rawResources = JSON.parse(fileContent) as LearningResource[];\n\n\t\t\t// Sort resources according to FR-015:\n\t\t\t// 1. Category (Getting Started  Advanced Features  Troubleshooting)\n\t\t\t// 2. Within category: alphabetical by title\n\t\t\tthis.resources = this.sortResources(rawResources);\n\t\t\tthis.loaded = true;\n\n\t\t\treturn this.resources;\n\t\t} catch (error) {\n\t\t\t// Only log in non-test environment\n\t\t\tif (process.env.NODE_ENV !== \"test\" && typeof process !== \"undefined\") {\n\t\t\t\tconsole.error(\"[LearningResources] Failed to load resources:\", error);\n\t\t\t}\n\t\t\t// Return empty array on error\n\t\t\tthis.resources = [];\n\t\t\tthis.loaded = true;\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Get all resources sorted by category and title\n\t */\n\tgetAll(): LearningResource[] {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\t\treturn [...this.resources];\n\t}\n\n\t/**\n\t * Filter resources by category\n\t */\n\tgetByCategory(category: ResourceCategory): LearningResource[] {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\t\treturn this.resources.filter((r) => r.category === category);\n\t}\n\n\t/**\n\t * Search resources by keyword matching title, description, or keywords array\n\t * Results sorted by relevance (keyword match count) then alphabetically\n\t */\n\tsearchByKeyword(query: string): LearningResource[] {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\n\t\tif (!query || query.trim() === \"\") {\n\t\t\treturn this.getAll();\n\t\t}\n\n\t\tconst normalizedQuery = query.toLowerCase().trim();\n\t\tconst queryWords = normalizedQuery.split(WHITESPACE_REGEX);\n\n\t\t// Score each resource by keyword matches\n\t\tconst scored = this.resources\n\t\t\t.map((resource) => ({\n\t\t\t\tresource,\n\t\t\t\tscore: this.calculateResourceScore(resource, queryWords),\n\t\t\t}))\n\t\t\t.filter((item) => item.score > 0);\n\n\t\t// Sort by score (descending) then alphabetically\n\t\tscored.sort((a, b) => {\n\t\t\tif (b.score !== a.score) {\n\t\t\t\treturn b.score - a.score;\n\t\t\t}\n\t\t\treturn a.resource.title.localeCompare(b.resource.title);\n\t\t});\n\n\t\treturn scored.map((item) => item.resource);\n\t}\n\n\t/**\n\t * Get resources count by category\n\t */\n\tgetCategoryCounts(): Record<ResourceCategory, number> {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\n\t\treturn {\n\t\t\t\"Getting Started\": this.resources.filter(\n\t\t\t\t(r) => r.category === \"Getting Started\"\n\t\t\t).length,\n\t\t\t\"Advanced Features\": this.resources.filter(\n\t\t\t\t(r) => r.category === \"Advanced Features\"\n\t\t\t).length,\n\t\t\tTroubleshooting: this.resources.filter(\n\t\t\t\t(r) => r.category === \"Troubleshooting\"\n\t\t\t).length,\n\t\t};\n\t}\n\n\t/**\n\t * Get resource by ID\n\t */\n\tgetById(id: string): LearningResource | undefined {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\t\treturn this.resources.find((r) => r.id === id);\n\t}\n\n\t/**\n\t * Sort resources by category order then alphabetically\n\t * Per FR-015 specification\n\t */\n\tprivate sortResources(resources: LearningResource[]): LearningResource[] {\n\t\tconst categoryOrder: Record<ResourceCategory, number> = {\n\t\t\t\"Getting Started\": 1,\n\t\t\t\"Advanced Features\": 2,\n\t\t\tTroubleshooting: 3,\n\t\t};\n\n\t\treturn resources.sort((a, b) => {\n\t\t\t// First by category\n\t\t\tconst catA = categoryOrder[a.category];\n\t\t\tconst catB = categoryOrder[b.category];\n\n\t\t\tif (catA !== catB) {\n\t\t\t\treturn catA - catB;\n\t\t\t}\n\n\t\t\t// Then alphabetically by title\n\t\t\treturn a.title.localeCompare(b.title);\n\t\t});\n\t}\n\n\t/**\n\t * Check if resources are loaded\n\t */\n\tisLoaded(): boolean {\n\t\treturn this.loaded;\n\t}\n\n\t/**\n\t * Calculate relevance score for a resource based on query words\n\t * @private\n\t */\n\tprivate calculateResourceScore(\n\t\tresource: LearningResource,\n\t\tqueryWords: string[]\n\t): number {\n\t\tlet score = 0;\n\n\t\t// Search in title (highest weight)\n\t\tconst titleLower = resource.title.toLowerCase();\n\t\tfor (const word of queryWords) {\n\t\t\tif (titleLower.includes(word)) {\n\t\t\t\tscore += 3;\n\t\t\t}\n\t\t}\n\n\t\t// Search in description (medium weight)\n\t\tconst descLower = resource.description.toLowerCase();\n\t\tfor (const word of queryWords) {\n\t\t\tif (descLower.includes(word)) {\n\t\t\t\tscore += 2;\n\t\t\t}\n\t\t}\n\n\t\t// Search in keywords (exact match weight)\n\t\tfor (const keyword of resource.keywords) {\n\t\t\tfor (const word of queryWords) {\n\t\t\t\tif (keyword === word) {\n\t\t\t\t\tscore += 5; // Exact keyword match highest priority\n\t\t\t\t} else if (keyword.includes(word)) {\n\t\t\t\t\tscore += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn score;\n\t}\n\n\t/**\n\t * Reset service (for testing)\n\t */\n\treset(): void {\n\t\tthis.resources = [];\n\t\tthis.loaded = false;\n\t}\n}",
    "start_line": 19,
    "end_line": 227,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class LearningResources",
    "component_id": "src.services.learning-resources.LearningResources"
  },
  "src.services.learning-resources.loadResources": {
    "id": "src.services.learning-resources.loadResources",
    "name": "loadResources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "loadResources(extensionPath: string): LearningResource[] {\n\t\tif (this.loaded) {\n\t\t\treturn this.resources;\n\t\t}\n\n\t\ttry {\n\t\t\tconst resourcesPath = join(\n\t\t\t\textensionPath,\n\t\t\t\t\"specs\",\n\t\t\t\t\"006-welcome-screen\",\n\t\t\t\t\"resources.json\"\n\t\t\t);\n\n\t\t\tconst fileContent = readFileSync(resourcesPath, \"utf8\");\n\t\t\tconst rawResources = JSON.parse(fileContent) as LearningResource[];\n\n\t\t\t// Sort resources according to FR-015:\n\t\t\t// 1. Category (Getting Started  Advanced Features  Troubleshooting)\n\t\t\t// 2. Within category: alphabetical by title\n\t\t\tthis.resources = this.sortResources(rawResources);\n\t\t\tthis.loaded = true;\n\n\t\t\treturn this.resources;\n\t\t} catch (error) {\n\t\t\t// Only log in non-test environment\n\t\t\tif (process.env.NODE_ENV !== \"test\" && typeof process !== \"undefined\") {\n\t\t\t\tconsole.error(\"[LearningResources] Failed to load resources:\", error);\n\t\t\t}\n\t\t\t// Return empty array on error\n\t\t\tthis.resources = [];\n\t\t\tthis.loaded = true;\n\t\t\treturn [];\n\t\t}\n\t}",
    "start_line": 27,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "extensionPath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadResources",
    "component_id": "src.services.learning-resources.loadResources"
  },
  "src.services.learning-resources.getAll": {
    "id": "src.services.learning-resources.getAll",
    "name": "getAll",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "getAll(): LearningResource[] {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\t\treturn [...this.resources];\n\t}",
    "start_line": 65,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAll",
    "component_id": "src.services.learning-resources.getAll"
  },
  "src.services.learning-resources.getByCategory": {
    "id": "src.services.learning-resources.getByCategory",
    "name": "getByCategory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "getByCategory(category: ResourceCategory): LearningResource[] {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\t\treturn this.resources.filter((r) => r.category === category);\n\t}",
    "start_line": 75,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "category"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getByCategory",
    "component_id": "src.services.learning-resources.getByCategory"
  },
  "src.services.learning-resources.searchByKeyword": {
    "id": "src.services.learning-resources.searchByKeyword",
    "name": "searchByKeyword",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "searchByKeyword(query: string): LearningResource[] {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\n\t\tif (!query || query.trim() === \"\") {\n\t\t\treturn this.getAll();\n\t\t}\n\n\t\tconst normalizedQuery = query.toLowerCase().trim();\n\t\tconst queryWords = normalizedQuery.split(WHITESPACE_REGEX);\n\n\t\t// Score each resource by keyword matches\n\t\tconst scored = this.resources\n\t\t\t.map((resource) => ({\n\t\t\t\tresource,\n\t\t\t\tscore: this.calculateResourceScore(resource, queryWords),\n\t\t\t}))\n\t\t\t.filter((item) => item.score > 0);\n\n\t\t// Sort by score (descending) then alphabetically\n\t\tscored.sort((a, b) => {\n\t\t\tif (b.score !== a.score) {\n\t\t\t\treturn b.score - a.score;\n\t\t\t}\n\t\t\treturn a.resource.title.localeCompare(b.resource.title);\n\t\t});\n\n\t\treturn scored.map((item) => item.resource);\n\t}",
    "start_line": 86,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "query"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method searchByKeyword",
    "component_id": "src.services.learning-resources.searchByKeyword"
  },
  "src.services.learning-resources.getCategoryCounts": {
    "id": "src.services.learning-resources.getCategoryCounts",
    "name": "getCategoryCounts",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "getCategoryCounts(): Record<ResourceCategory, number> {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\n\t\treturn {\n\t\t\t\"Getting Started\": this.resources.filter(\n\t\t\t\t(r) => r.category === \"Getting Started\"\n\t\t\t).length,\n\t\t\t\"Advanced Features\": this.resources.filter(\n\t\t\t\t(r) => r.category === \"Advanced Features\"\n\t\t\t).length,\n\t\t\tTroubleshooting: this.resources.filter(\n\t\t\t\t(r) => r.category === \"Troubleshooting\"\n\t\t\t).length,\n\t\t};\n\t}",
    "start_line": 120,
    "end_line": 136,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCategoryCounts",
    "component_id": "src.services.learning-resources.getCategoryCounts"
  },
  "src.services.learning-resources.getById": {
    "id": "src.services.learning-resources.getById",
    "name": "getById",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "getById(id: string): LearningResource | undefined {\n\t\tif (!this.loaded) {\n\t\t\tthrow new Error(\"Resources not loaded. Call loadResources() first.\");\n\t\t}\n\t\treturn this.resources.find((r) => r.id === id);\n\t}",
    "start_line": 141,
    "end_line": 146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getById",
    "component_id": "src.services.learning-resources.getById"
  },
  "src.services.learning-resources.sortResources": {
    "id": "src.services.learning-resources.sortResources",
    "name": "sortResources",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "private sortResources(resources: LearningResource[]): LearningResource[] {\n\t\tconst categoryOrder: Record<ResourceCategory, number> = {\n\t\t\t\"Getting Started\": 1,\n\t\t\t\"Advanced Features\": 2,\n\t\t\tTroubleshooting: 3,\n\t\t};\n\n\t\treturn resources.sort((a, b) => {\n\t\t\t// First by category\n\t\t\tconst catA = categoryOrder[a.category];\n\t\t\tconst catB = categoryOrder[b.category];\n\n\t\t\tif (catA !== catB) {\n\t\t\t\treturn catA - catB;\n\t\t\t}\n\n\t\t\t// Then alphabetically by title\n\t\t\treturn a.title.localeCompare(b.title);\n\t\t});\n\t}",
    "start_line": 152,
    "end_line": 171,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "resources"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method sortResources",
    "component_id": "src.services.learning-resources.sortResources"
  },
  "src.services.learning-resources.isLoaded": {
    "id": "src.services.learning-resources.isLoaded",
    "name": "isLoaded",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "isLoaded(): boolean {\n\t\treturn this.loaded;\n\t}",
    "start_line": 176,
    "end_line": 178,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isLoaded",
    "component_id": "src.services.learning-resources.isLoaded"
  },
  "src.services.learning-resources.calculateResourceScore": {
    "id": "src.services.learning-resources.calculateResourceScore",
    "name": "calculateResourceScore",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "private calculateResourceScore(\n\t\tresource: LearningResource,\n\t\tqueryWords: string[]\n\t): number {\n\t\tlet score = 0;\n\n\t\t// Search in title (highest weight)\n\t\tconst titleLower = resource.title.toLowerCase();\n\t\tfor (const word of queryWords) {\n\t\t\tif (titleLower.includes(word)) {\n\t\t\t\tscore += 3;\n\t\t\t}\n\t\t}\n\n\t\t// Search in description (medium weight)\n\t\tconst descLower = resource.description.toLowerCase();\n\t\tfor (const word of queryWords) {\n\t\t\tif (descLower.includes(word)) {\n\t\t\t\tscore += 2;\n\t\t\t}\n\t\t}\n\n\t\t// Search in keywords (exact match weight)\n\t\tfor (const keyword of resource.keywords) {\n\t\t\tfor (const word of queryWords) {\n\t\t\t\tif (keyword === word) {\n\t\t\t\t\tscore += 5; // Exact keyword match highest priority\n\t\t\t\t} else if (keyword.includes(word)) {\n\t\t\t\t\tscore += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn score;\n\t}",
    "start_line": 184,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "resource",
      "queryWords"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method calculateResourceScore",
    "component_id": "src.services.learning-resources.calculateResourceScore"
  },
  "src.services.learning-resources.reset": {
    "id": "src.services.learning-resources.reset",
    "name": "reset",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/learning-resources.ts",
    "relative_path": "src/services/learning-resources.ts",
    "depends_on": [],
    "source_code": "reset(): void {\n\t\tthis.resources = [];\n\t\tthis.loaded = false;\n\t}",
    "start_line": 223,
    "end_line": 226,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method reset",
    "component_id": "src.services.learning-resources.reset"
  },
  "src.services.prompt-loader.PromptLoader": {
    "id": "src.services.prompt-loader.PromptLoader",
    "name": "PromptLoader",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [
      "src.utils.telemetry.clear",
      "src.services.prompt-loader.loadPromptFromFile",
      "src.types.prompt.types.ValidationResult",
      "src.types.prompt.types.PromptFrontmatter",
      "src.types.prompt.types.PromptTemplate",
      "src.services.prompt-loader.validateVariables",
      "src.features.agents.resource-cache.get",
      "src.services.prompt-loader.PromptLoader",
      "src.services.prompt-loader.loadPrompt",
      "src.types.prompt.types.PromptMetadata",
      "src.services.prompt-loader.registerPrompt"
    ],
    "source_code": "class PromptLoader {\n\tprivate static instance: PromptLoader;\n\tprivate readonly prompts: Map<string, PromptTemplate> = new Map();\n\tprivate readonly compiledTemplates: Map<string, HandlebarsTemplateDelegate> =\n\t\tnew Map();\n\n\tprivate constructor() {\n\t\t// Private constructor for singleton\n\t}\n\n\t/**\n\t * Get singleton instance\n\t */\n\tstatic getInstance(): PromptLoader {\n\t\tif (!PromptLoader.instance) {\n\t\t\tPromptLoader.instance = new PromptLoader();\n\t\t}\n\t\treturn PromptLoader.instance;\n\t}\n\n\t/**\n\t * Initialize the loader by loading all prompts\n\t */\n\tinitialize(): void {\n\t\t// Clear existing data\n\t\tthis.prompts.clear();\n\t\tthis.compiledTemplates.clear();\n\n\t\t// Load all built-in prompts\n\t\tconst promptModules = Object.values(prompts);\n\n\t\t// Register each prompt\n\t\tfor (const module of promptModules) {\n\t\t\tif (module.frontmatter && module.content) {\n\t\t\t\tthis.registerPrompt(module as PromptTemplate);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load prompts from a directory\n\t * @param directoryPath Absolute path to the directory containing .md prompt files\n\t */\n\tloadPromptsFromDirectory(directoryPath: string): void {\n\t\ttry {\n\t\t\tconst files = readdirSync(directoryPath);\n\n\t\t\tfor (const file of files) {\n\t\t\t\tif (file.endsWith(\".md\") || file.endsWith(\".prompt.md\")) {\n\t\t\t\t\tconst fullPath = join(directoryPath, file);\n\t\t\t\t\tconst stat = statSync(fullPath);\n\n\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\tthis.loadPromptFromFile(fullPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Directory might not exist, which is fine\n\t\t\tconsole.warn(\n\t\t\t\t`[PromptLoader] Failed to load prompts from ${directoryPath}: ${error}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single prompt from a file\n\t */\n\tprivate loadPromptFromFile(filePath: string): void {\n\t\ttry {\n\t\t\tconst content = readFileSync(filePath, \"utf8\");\n\t\t\tconst { data, content: body } = matter(content);\n\n\t\t\t// Generate ID from filename if not provided in frontmatter\n\t\t\t// Remove extension\n\t\t\tconst fileName = basename(filePath).replace(\n\t\t\t\tPROMPT_FILE_EXTENSION_REGEX,\n\t\t\t\t\"\"\n\t\t\t);\n\t\t\tconst id = (data.id as string) || fileName;\n\n\t\t\tconst template: PromptTemplate = {\n\t\t\t\tfrontmatter: {\n\t\t\t\t\tid,\n\t\t\t\t\tname: (data.name as string) || id,\n\t\t\t\t\tdescription: (data.description as string) || \"\",\n\t\t\t\t\tversion: (data.version as string) || \"1.0.0\",\n\t\t\t\t\tvariables: (data.variables as Record<string, any>) || {},\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\tcontent: body,\n\t\t\t};\n\n\t\t\tthis.registerPrompt(template);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[PromptLoader] Failed to load prompt from ${filePath}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Register a prompt template\n\t */\n\tprivate registerPrompt(template: PromptTemplate): void {\n\t\tconst { id } = template.frontmatter;\n\n\t\t// Store the template\n\t\tthis.prompts.set(id, template);\n\n\t\t// Compile the template\n\t\ttry {\n\t\t\tconst compiled = compile(template.content);\n\t\t\tthis.compiledTemplates.set(id, compiled);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to compile template ${id}:`, error);\n\t\t}\n\t}\n\n\t/**\n\t * Load a prompt template by ID\n\t */\n\tloadPrompt(promptId: string): PromptTemplate {\n\t\tconst template = this.prompts.get(promptId);\n\t\tif (!template) {\n\t\t\tthrow new Error(\n\t\t\t\t`Prompt not found: ${promptId}. Available prompts: ${Array.from(this.prompts.keys()).join(\", \")}`\n\t\t\t);\n\t\t}\n\t\treturn template;\n\t}\n\n\t/**\n\t * Render a prompt with variables\n\t */\n\trenderPrompt(promptId: string, variables: Record<string, any> = {}): string {\n\t\tconst template = this.loadPrompt(promptId);\n\t\tconst compiled = this.compiledTemplates.get(promptId);\n\n\t\tif (!compiled) {\n\t\t\tthrow new Error(`Compiled template not found: ${promptId}`);\n\t\t}\n\n\t\t// Validate required variables\n\t\tconst validation = this.validateVariables(template.frontmatter, variables);\n\t\tif (!validation.valid) {\n\t\t\tthrow new Error(\n\t\t\t\t`Variable validation failed: ${validation.errors?.join(\", \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Render the template\n\t\ttry {\n\t\t\treturn compiled(variables);\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Failed to render template ${promptId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Validate variables against template requirements\n\t */\n\tprivate validateVariables(\n\t\tfrontmatter: PromptFrontmatter,\n\t\tvariables: Record<string, any>\n\t): ValidationResult {\n\t\tconst errors: string[] = [];\n\n\t\tif (frontmatter.variables) {\n\t\t\tfor (const [name, definition] of Object.entries(frontmatter.variables)) {\n\t\t\t\tif (definition.required && !(name in variables)) {\n\t\t\t\t\terrors.push(`Missing required variable: ${name}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t};\n\t}\n\n\t/**\n\t * List all available prompts\n\t */\n\tlistPrompts(): PromptMetadata[] {\n\t\tconst metadata: PromptMetadata[] = [];\n\n\t\tfor (const [id, template] of this.prompts) {\n\t\t\tconst category = id.split(\"-\")[0]; // Extract category from ID\n\t\t\tmetadata.push({\n\t\t\t\tid,\n\t\t\t\tname: template.frontmatter.name,\n\t\t\t\tversion: template.frontmatter.version,\n\t\t\t\tdescription: template.frontmatter.description,\n\t\t\t\tcategory,\n\t\t\t});\n\t\t}\n\n\t\treturn metadata;\n\t}\n}",
    "start_line": 21,
    "end_line": 223,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class PromptLoader",
    "component_id": "src.services.prompt-loader.PromptLoader"
  },
  "src.services.prompt-loader.getInstance": {
    "id": "src.services.prompt-loader.getInstance",
    "name": "getInstance",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "static getInstance(): PromptLoader {\n\t\tif (!PromptLoader.instance) {\n\t\t\tPromptLoader.instance = new PromptLoader();\n\t\t}\n\t\treturn PromptLoader.instance;\n\t}",
    "start_line": 34,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method getInstance",
    "component_id": "src.services.prompt-loader.getInstance"
  },
  "src.services.prompt-loader.initialize": {
    "id": "src.services.prompt-loader.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "initialize(): void {\n\t\t// Clear existing data\n\t\tthis.prompts.clear();\n\t\tthis.compiledTemplates.clear();\n\n\t\t// Load all built-in prompts\n\t\tconst promptModules = Object.values(prompts);\n\n\t\t// Register each prompt\n\t\tfor (const module of promptModules) {\n\t\t\tif (module.frontmatter && module.content) {\n\t\t\t\tthis.registerPrompt(module as PromptTemplate);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 44,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initialize",
    "component_id": "src.services.prompt-loader.initialize"
  },
  "src.services.prompt-loader.loadPromptsFromDirectory": {
    "id": "src.services.prompt-loader.loadPromptsFromDirectory",
    "name": "loadPromptsFromDirectory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "loadPromptsFromDirectory(directoryPath: string): void {\n\t\ttry {\n\t\t\tconst files = readdirSync(directoryPath);\n\n\t\t\tfor (const file of files) {\n\t\t\t\tif (file.endsWith(\".md\") || file.endsWith(\".prompt.md\")) {\n\t\t\t\t\tconst fullPath = join(directoryPath, file);\n\t\t\t\t\tconst stat = statSync(fullPath);\n\n\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\tthis.loadPromptFromFile(fullPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Directory might not exist, which is fine\n\t\t\tconsole.warn(\n\t\t\t\t`[PromptLoader] Failed to load prompts from ${directoryPath}: ${error}`\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 64,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "directoryPath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadPromptsFromDirectory",
    "component_id": "src.services.prompt-loader.loadPromptsFromDirectory"
  },
  "src.services.prompt-loader.loadPromptFromFile": {
    "id": "src.services.prompt-loader.loadPromptFromFile",
    "name": "loadPromptFromFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "private loadPromptFromFile(filePath: string): void {\n\t\ttry {\n\t\t\tconst content = readFileSync(filePath, \"utf8\");\n\t\t\tconst { data, content: body } = matter(content);\n\n\t\t\t// Generate ID from filename if not provided in frontmatter\n\t\t\t// Remove extension\n\t\t\tconst fileName = basename(filePath).replace(\n\t\t\t\tPROMPT_FILE_EXTENSION_REGEX,\n\t\t\t\t\"\"\n\t\t\t);\n\t\t\tconst id = (data.id as string) || fileName;\n\n\t\t\tconst template: PromptTemplate = {\n\t\t\t\tfrontmatter: {\n\t\t\t\t\tid,\n\t\t\t\t\tname: (data.name as string) || id,\n\t\t\t\t\tdescription: (data.description as string) || \"\",\n\t\t\t\t\tversion: (data.version as string) || \"1.0.0\",\n\t\t\t\t\tvariables: (data.variables as Record<string, any>) || {},\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\tcontent: body,\n\t\t\t};\n\n\t\t\tthis.registerPrompt(template);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[PromptLoader] Failed to load prompt from ${filePath}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 89,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadPromptFromFile",
    "component_id": "src.services.prompt-loader.loadPromptFromFile"
  },
  "src.services.prompt-loader.registerPrompt": {
    "id": "src.services.prompt-loader.registerPrompt",
    "name": "registerPrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "private registerPrompt(template: PromptTemplate): void {\n\t\tconst { id } = template.frontmatter;\n\n\t\t// Store the template\n\t\tthis.prompts.set(id, template);\n\n\t\t// Compile the template\n\t\ttry {\n\t\t\tconst compiled = compile(template.content);\n\t\t\tthis.compiledTemplates.set(id, compiled);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to compile template ${id}:`, error);\n\t\t}\n\t}",
    "start_line": 126,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "template"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method registerPrompt",
    "component_id": "src.services.prompt-loader.registerPrompt"
  },
  "src.services.prompt-loader.loadPrompt": {
    "id": "src.services.prompt-loader.loadPrompt",
    "name": "loadPrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "loadPrompt(promptId: string): PromptTemplate {\n\t\tconst template = this.prompts.get(promptId);\n\t\tif (!template) {\n\t\t\tthrow new Error(\n\t\t\t\t`Prompt not found: ${promptId}. Available prompts: ${Array.from(this.prompts.keys()).join(\", \")}`\n\t\t\t);\n\t\t}\n\t\treturn template;\n\t}",
    "start_line": 144,
    "end_line": 152,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "promptId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadPrompt",
    "component_id": "src.services.prompt-loader.loadPrompt"
  },
  "src.services.prompt-loader.renderPrompt": {
    "id": "src.services.prompt-loader.renderPrompt",
    "name": "renderPrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "renderPrompt(promptId: string, variables: Record<string, any> = {}): string {\n\t\tconst template = this.loadPrompt(promptId);\n\t\tconst compiled = this.compiledTemplates.get(promptId);\n\n\t\tif (!compiled) {\n\t\t\tthrow new Error(`Compiled template not found: ${promptId}`);\n\t\t}\n\n\t\t// Validate required variables\n\t\tconst validation = this.validateVariables(template.frontmatter, variables);\n\t\tif (!validation.valid) {\n\t\t\tthrow new Error(\n\t\t\t\t`Variable validation failed: ${validation.errors?.join(\", \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Render the template\n\t\ttry {\n\t\t\treturn compiled(variables);\n\t\t} catch (error) {\n\t\t\tthrow new Error(`Failed to render template ${promptId}: ${error}`);\n\t\t}\n\t}",
    "start_line": 157,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "promptId",
      "variables"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method renderPrompt",
    "component_id": "src.services.prompt-loader.renderPrompt"
  },
  "src.services.prompt-loader.validateVariables": {
    "id": "src.services.prompt-loader.validateVariables",
    "name": "validateVariables",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "private validateVariables(\n\t\tfrontmatter: PromptFrontmatter,\n\t\tvariables: Record<string, any>\n\t): ValidationResult {\n\t\tconst errors: string[] = [];\n\n\t\tif (frontmatter.variables) {\n\t\t\tfor (const [name, definition] of Object.entries(frontmatter.variables)) {\n\t\t\t\tif (definition.required && !(name in variables)) {\n\t\t\t\t\terrors.push(`Missing required variable: ${name}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvalid: errors.length === 0,\n\t\t\terrors,\n\t\t};\n\t}",
    "start_line": 184,
    "end_line": 202,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "frontmatter",
      "variables"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateVariables",
    "component_id": "src.services.prompt-loader.validateVariables"
  },
  "src.services.prompt-loader.listPrompts": {
    "id": "src.services.prompt-loader.listPrompts",
    "name": "listPrompts",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/prompt-loader.ts",
    "relative_path": "src/services/prompt-loader.ts",
    "depends_on": [],
    "source_code": "listPrompts(): PromptMetadata[] {\n\t\tconst metadata: PromptMetadata[] = [];\n\n\t\tfor (const [id, template] of this.prompts) {\n\t\t\tconst category = id.split(\"-\")[0]; // Extract category from ID\n\t\t\tmetadata.push({\n\t\t\t\tid,\n\t\t\t\tname: template.frontmatter.name,\n\t\t\t\tversion: template.frontmatter.version,\n\t\t\t\tdescription: template.frontmatter.description,\n\t\t\t\tcategory,\n\t\t\t});\n\t\t}\n\n\t\treturn metadata;\n\t}",
    "start_line": 207,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method listPrompts",
    "component_id": "src.services.prompt-loader.listPrompts"
  },
  "src.services.refinement-gateway.RefinementResult": {
    "id": "src.services.refinement-gateway.RefinementResult",
    "name": "RefinementResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/refinement-gateway.ts",
    "relative_path": "src/services/refinement-gateway.ts",
    "depends_on": [],
    "source_code": "interface RefinementResult {\n\trequestId: string;\n\tstatus: \"success\" | \"error\";\n\tmessage?: string;\n}",
    "start_line": 10,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefinementResult",
    "component_id": "src.services.refinement-gateway.RefinementResult"
  },
  "src.services.refinement-gateway.RefinementGateway": {
    "id": "src.services.refinement-gateway.RefinementGateway",
    "name": "RefinementGateway",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/refinement-gateway.ts",
    "relative_path": "src/services/refinement-gateway.ts",
    "depends_on": [
      "src.types.preview.PreviewDocumentType",
      "src.services.refinement-gateway.RefinementResult",
      "src.services.refinement-gateway.getAgentCommandForDocumentType",
      "src.types.preview.RefinementRequestPayload",
      "src.services.refinement-gateway.getIssueTypeLabel",
      "src.services.refinement-gateway.formatRefinementPrompt",
      "src.utils.chat-prompt-runner.sendPromptToChat"
    ],
    "source_code": "class RefinementGateway {\n\tprivate readonly outputChannel: OutputChannel;\n\n\tconstructor(outputChannel: OutputChannel) {\n\t\tthis.outputChannel = outputChannel;\n\t}\n\n\t/**\n\t * Maps document types to their appropriate SpecKit/OpenSpec commands\n\t */\n\tprivate getAgentCommandForDocumentType(docType: PreviewDocumentType): string {\n\t\tconst commandMap: Record<PreviewDocumentType, string> = {\n\t\t\tspec: \"/speckit.specify\",\n\t\t\tplan: \"/speckit.plan\",\n\t\t\ttask: \"/speckit.tasks\",\n\t\t\tresearch: \"/speckit.research\",\n\t\t\tdataModel: \"/speckit.specify\",\n\t\t\tapi: \"/speckit.specify\",\n\t\t\tquickstart: \"/speckit.specify\",\n\t\t\tchecklist: \"/speckit.checklist\",\n\t\t};\n\n\t\treturn commandMap[docType] || \"/speckit.clarify\";\n\t}\n\n\t/**\n\t * Formats the refinement request into a proper prompt for the agent\n\t */\n\tprivate formatRefinementPrompt(payload: RefinementRequestPayload): string {\n\t\tconst {\n\t\t\tdocumentId,\n\t\t\tdocumentType,\n\t\t\tsectionRef,\n\t\t\tissueType,\n\t\t\tdescription,\n\t\t\tactionType,\n\t\t\tchangedDependencies,\n\t\t} = payload;\n\n\t\tconst command = this.getAgentCommandForDocumentType(documentType);\n\t\tconst section = sectionRef ? ` (Section: ${sectionRef})` : \"\";\n\n\t\t// Handle \"update\" action type differently\n\t\tif (\n\t\t\tactionType === \"update\" &&\n\t\t\tchangedDependencies &&\n\t\t\tchangedDependencies.length > 0\n\t\t) {\n\t\t\tconst depList = changedDependencies\n\t\t\t\t.map((dep) => `- ${dep.documentId} (${dep.documentType})`)\n\t\t\t\t.join(\"\\n\");\n\n\t\t\treturn `${command}\n\nUpdate the current document \"${documentId}\"${section} according to the updates in the following dependent documents:\n\n${depList}\n\n${description ? `**Additional Context**:\\n${description}\\n\\n` : \"\"}Please ensure that all necessary changes have been made, maintaining consistency and adherence to the specifications. The document should be complete and properly synchronized with its dependencies.`;\n\t\t}\n\n\t\t// Handle standard \"refine\" action\n\t\tconst issueTypeLabel = this.getIssueTypeLabel(issueType);\n\n\t\treturn `${command}\n\nAccording to our review, the document \"${documentId}\"${section} must be refined with the following information:\n\n**Issue Type**: ${issueTypeLabel}\n\n**Refinement Request**:\n${description}\n\nPlease update the document accordingly.`;\n\t}\n\n\t/**\n\t * Converts issue type to human-readable label\n\t */\n\tprivate getIssueTypeLabel(issueType: string): string {\n\t\tconst labels: Record<string, string> = {\n\t\t\tmissingDetail: \"Missing Detail\",\n\t\t\tincorrectInfo: \"Incorrect Information\",\n\t\t\tmissingAsset: \"Missing Asset\",\n\t\t\tother: \"Other\",\n\t\t};\n\t\treturn labels[issueType] || issueType;\n\t}\n\n\tasync submitRequest(\n\t\tpayload: RefinementRequestPayload\n\t): Promise<RefinementResult> {\n\t\tconst requestId = payload.requestId || randomUUID();\n\t\tconst reporterId = env.machineId;\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[RefinementGateway] Processing ${payload.issueType} request ${requestId} for ${payload.documentId} (reporter: ${reporterId})`\n\t\t);\n\n\t\ttry {\n\t\t\t// Format and send refinement request to appropriate agent\n\t\t\tconst prompt = this.formatRefinementPrompt(payload);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Sending refinement to ${payload.documentType} agent`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Prompt: ${prompt.substring(0, 200)}...`\n\t\t\t);\n\n\t\t\tawait sendPromptToChat(prompt);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Successfully sent refinement request ${requestId} to chat`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\trequestId,\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: \"Refinement request sent to agent\",\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Failed to send refinement request ${requestId}: ${message}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\trequestId,\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: `Failed to send refinement: ${message}`,\n\t\t\t};\n\t\t}\n\t}\n}",
    "start_line": 16,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class RefinementGateway",
    "component_id": "src.services.refinement-gateway.RefinementGateway"
  },
  "src.services.refinement-gateway.getAgentCommandForDocumentType": {
    "id": "src.services.refinement-gateway.getAgentCommandForDocumentType",
    "name": "getAgentCommandForDocumentType",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/refinement-gateway.ts",
    "relative_path": "src/services/refinement-gateway.ts",
    "depends_on": [],
    "source_code": "private getAgentCommandForDocumentType(docType: PreviewDocumentType): string {\n\t\tconst commandMap: Record<PreviewDocumentType, string> = {\n\t\t\tspec: \"/speckit.specify\",\n\t\t\tplan: \"/speckit.plan\",\n\t\t\ttask: \"/speckit.tasks\",\n\t\t\tresearch: \"/speckit.research\",\n\t\t\tdataModel: \"/speckit.specify\",\n\t\t\tapi: \"/speckit.specify\",\n\t\t\tquickstart: \"/speckit.specify\",\n\t\t\tchecklist: \"/speckit.checklist\",\n\t\t};\n\n\t\treturn commandMap[docType] || \"/speckit.clarify\";\n\t}",
    "start_line": 26,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "docType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAgentCommandForDocumentType",
    "component_id": "src.services.refinement-gateway.getAgentCommandForDocumentType"
  },
  "src.services.refinement-gateway.formatRefinementPrompt": {
    "id": "src.services.refinement-gateway.formatRefinementPrompt",
    "name": "formatRefinementPrompt",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/refinement-gateway.ts",
    "relative_path": "src/services/refinement-gateway.ts",
    "depends_on": [],
    "source_code": "private formatRefinementPrompt(payload: RefinementRequestPayload): string {\n\t\tconst {\n\t\t\tdocumentId,\n\t\t\tdocumentType,\n\t\t\tsectionRef,\n\t\t\tissueType,\n\t\t\tdescription,\n\t\t\tactionType,\n\t\t\tchangedDependencies,\n\t\t} = payload;\n\n\t\tconst command = this.getAgentCommandForDocumentType(documentType);\n\t\tconst section = sectionRef ? ` (Section: ${sectionRef})` : \"\";\n\n\t\t// Handle \"update\" action type differently\n\t\tif (\n\t\t\tactionType === \"update\" &&\n\t\t\tchangedDependencies &&\n\t\t\tchangedDependencies.length > 0\n\t\t) {\n\t\t\tconst depList = changedDependencies\n\t\t\t\t.map((dep) => `- ${dep.documentId} (${dep.documentType})`)\n\t\t\t\t.join(\"\\n\");\n\n\t\t\treturn `${command}\n\nUpdate the current document \"${documentId}\"${section} according to the updates in the following dependent documents:\n\n${depList}\n\n${description ? `**Additional Context**:\\n${description}\\n\\n` : \"\"}Please ensure that all necessary changes have been made, maintaining consistency and adherence to the specifications. The document should be complete and properly synchronized with its dependencies.`;\n\t\t}\n\n\t\t// Handle standard \"refine\" action\n\t\tconst issueTypeLabel = this.getIssueTypeLabel(issueType);\n\n\t\treturn `${command}\n\nAccording to our review, the document \"${documentId}\"${section} must be refined with the following information:\n\n**Issue Type**: ${issueTypeLabel}\n\n**Refinement Request**:\n${description}\n\nPlease update the document accordingly.`;\n\t}",
    "start_line": 44,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method formatRefinementPrompt",
    "component_id": "src.services.refinement-gateway.formatRefinementPrompt"
  },
  "src.services.refinement-gateway.getIssueTypeLabel": {
    "id": "src.services.refinement-gateway.getIssueTypeLabel",
    "name": "getIssueTypeLabel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/refinement-gateway.ts",
    "relative_path": "src/services/refinement-gateway.ts",
    "depends_on": [],
    "source_code": "private getIssueTypeLabel(issueType: string): string {\n\t\tconst labels: Record<string, string> = {\n\t\t\tmissingDetail: \"Missing Detail\",\n\t\t\tincorrectInfo: \"Incorrect Information\",\n\t\t\tmissingAsset: \"Missing Asset\",\n\t\t\tother: \"Other\",\n\t\t};\n\t\treturn labels[issueType] || issueType;\n\t}",
    "start_line": 95,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "issueType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getIssueTypeLabel",
    "component_id": "src.services.refinement-gateway.getIssueTypeLabel"
  },
  "src.services.refinement-gateway.submitRequest": {
    "id": "src.services.refinement-gateway.submitRequest",
    "name": "submitRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/refinement-gateway.ts",
    "relative_path": "src/services/refinement-gateway.ts",
    "depends_on": [],
    "source_code": "async submitRequest(\n\t\tpayload: RefinementRequestPayload\n\t): Promise<RefinementResult> {\n\t\tconst requestId = payload.requestId || randomUUID();\n\t\tconst reporterId = env.machineId;\n\n\t\tthis.outputChannel.appendLine(\n\t\t\t`[RefinementGateway] Processing ${payload.issueType} request ${requestId} for ${payload.documentId} (reporter: ${reporterId})`\n\t\t);\n\n\t\ttry {\n\t\t\t// Format and send refinement request to appropriate agent\n\t\t\tconst prompt = this.formatRefinementPrompt(payload);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Sending refinement to ${payload.documentType} agent`\n\t\t\t);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Prompt: ${prompt.substring(0, 200)}...`\n\t\t\t);\n\n\t\t\tawait sendPromptToChat(prompt);\n\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Successfully sent refinement request ${requestId} to chat`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\trequestId,\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: \"Refinement request sent to agent\",\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\t\tthis.outputChannel.appendLine(\n\t\t\t\t`[RefinementGateway] Failed to send refinement request ${requestId}: ${message}`\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\trequestId,\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: `Failed to send refinement: ${message}`,\n\t\t\t};\n\t\t}\n\t}",
    "start_line": 105,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method submitRequest",
    "component_id": "src.services.refinement-gateway.submitRequest"
  },
  "src.services.system-diagnostics.SystemDiagnostics": {
    "id": "src.services.system-diagnostics.SystemDiagnostics",
    "name": "SystemDiagnostics",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [
      "src.services.system-diagnostics.cleanup",
      "ui.src.features.welcome.types.SystemDiagnostic",
      "src.services.system-diagnostics.generateId"
    ],
    "source_code": "class SystemDiagnostics {\n\tprivate static readonly MAX_DIAGNOSTICS = 5;\n\tprivate static readonly RETENTION_PERIOD_MS = 24 * 60 * 60 * 1000; // 24 hours\n\n\tprivate diagnostics: SystemDiagnostic[] = [];\n\tprivate lastCleanup: number = Date.now();\n\n\t/**\n\t * Record a new error or warning\n\t * Automatically cleans up old entries and enforces 5-entry limit\n\t * @param severity - 'error' or 'warning'\n\t * @param message - Human-readable error description\n\t * @param source - Which component generated the error\n\t * @param suggestedAction - Optional actionable fix description\n\t */\n\trecordError(\n\t\tseverity: \"error\" | \"warning\",\n\t\tmessage: string,\n\t\tsource: string,\n\t\tsuggestedAction?: string\n\t): SystemDiagnostic {\n\t\t// Cleanup old diagnostics periodically\n\t\tthis.cleanup();\n\n\t\tconst diagnostic: SystemDiagnostic = {\n\t\t\tid: this.generateId(),\n\t\t\ttimestamp: Date.now(),\n\t\t\tseverity,\n\t\t\tmessage,\n\t\t\tsource,\n\t\t\tsuggestedAction: suggestedAction || null,\n\t\t};\n\n\t\t// Add to beginning of array (most recent first)\n\t\tthis.diagnostics.unshift(diagnostic);\n\n\t\t// Enforce 5-entry limit\n\t\tif (this.diagnostics.length > SystemDiagnostics.MAX_DIAGNOSTICS) {\n\t\t\tthis.diagnostics = this.diagnostics.slice(\n\t\t\t\t0,\n\t\t\t\tSystemDiagnostics.MAX_DIAGNOSTICS\n\t\t\t);\n\t\t}\n\n\t\treturn diagnostic;\n\t}\n\n\t/**\n\t * Get recent diagnostics from the past 24 hours, limited to 5 entries\n\t * Returns most recent diagnostics first\n\t */\n\tgetRecentDiagnostics(): SystemDiagnostic[] {\n\t\t// Cleanup before returning\n\t\tthis.cleanup();\n\n\t\t// Already limited to 5 and filtered by age during cleanup\n\t\treturn [...this.diagnostics];\n\t}\n\n\t/**\n\t * Remove diagnostics older than 24 hours\n\t * Runs automatically on recordError and getRecentDiagnostics\n\t */\n\tcleanup(): void {\n\t\tconst cutoffTime = Date.now() - SystemDiagnostics.RETENTION_PERIOD_MS;\n\n\t\t// Only cleanup once per minute to avoid excessive filtering\n\t\tconst timeSinceLastCleanup = Date.now() - this.lastCleanup;\n\t\tif (timeSinceLastCleanup < 60_000 && this.diagnostics.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst beforeCount = this.diagnostics.length;\n\t\tthis.diagnostics = this.diagnostics.filter(\n\t\t\t(d) => d.timestamp >= cutoffTime\n\t\t);\n\n\t\tconst removed = beforeCount - this.diagnostics.length;\n\t\tif (removed > 0) {\n\t\t\tthis.lastCleanup = Date.now();\n\t\t}\n\t}\n\n\t/**\n\t * Clear all diagnostics (for testing or manual reset)\n\t */\n\tclear(): void {\n\t\tthis.diagnostics = [];\n\t\tthis.lastCleanup = Date.now();\n\t}\n\n\t/**\n\t * Get count of diagnostics by severity\n\t */\n\tgetCounts(): { errors: number; warnings: number; total: number } {\n\t\tthis.cleanup();\n\n\t\tconst errors = this.diagnostics.filter(\n\t\t\t(d) => d.severity === \"error\"\n\t\t).length;\n\t\tconst warnings = this.diagnostics.filter(\n\t\t\t(d) => d.severity === \"warning\"\n\t\t).length;\n\n\t\treturn {\n\t\t\terrors,\n\t\t\twarnings,\n\t\t\ttotal: this.diagnostics.length,\n\t\t};\n\t}\n\n\t/**\n\t * Check if there are any recent errors\n\t */\n\thasErrors(): boolean {\n\t\tthis.cleanup();\n\t\treturn this.diagnostics.some((d) => d.severity === \"error\");\n\t}\n\n\t/**\n\t * Generate unique diagnostic ID\n\t */\n\tprivate generateId(): string {\n\t\treturn `diag-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\t}\n\n\t/**\n\t * Get diagnostic by ID (for testing)\n\t */\n\tgetById(id: string): SystemDiagnostic | undefined {\n\t\treturn this.diagnostics.find((d) => d.id === id);\n\t}\n\n\t/**\n\t * Get diagnostics from specific source\n\t */\n\tgetBySource(source: string): SystemDiagnostic[] {\n\t\tthis.cleanup();\n\t\treturn this.diagnostics.filter((d) => d.source === source);\n\t}\n\n\t/**\n\t * Get all diagnostics without cleanup (for testing)\n\t */\n\tgetAllRaw(): SystemDiagnostic[] {\n\t\treturn [...this.diagnostics];\n\t}\n}",
    "start_line": 9,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SystemDiagnostics",
    "component_id": "src.services.system-diagnostics.SystemDiagnostics"
  },
  "src.services.system-diagnostics.recordError": {
    "id": "src.services.system-diagnostics.recordError",
    "name": "recordError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "recordError(\n\t\tseverity: \"error\" | \"warning\",\n\t\tmessage: string,\n\t\tsource: string,\n\t\tsuggestedAction?: string\n\t): SystemDiagnostic {\n\t\t// Cleanup old diagnostics periodically\n\t\tthis.cleanup();\n\n\t\tconst diagnostic: SystemDiagnostic = {\n\t\t\tid: this.generateId(),\n\t\t\ttimestamp: Date.now(),\n\t\t\tseverity,\n\t\t\tmessage,\n\t\t\tsource,\n\t\t\tsuggestedAction: suggestedAction || null,\n\t\t};\n\n\t\t// Add to beginning of array (most recent first)\n\t\tthis.diagnostics.unshift(diagnostic);\n\n\t\t// Enforce 5-entry limit\n\t\tif (this.diagnostics.length > SystemDiagnostics.MAX_DIAGNOSTICS) {\n\t\t\tthis.diagnostics = this.diagnostics.slice(\n\t\t\t\t0,\n\t\t\t\tSystemDiagnostics.MAX_DIAGNOSTICS\n\t\t\t);\n\t\t}\n\n\t\treturn diagnostic;\n\t}",
    "start_line": 24,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "severity",
      "message",
      "source",
      "suggestedAction"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method recordError",
    "component_id": "src.services.system-diagnostics.recordError"
  },
  "src.services.system-diagnostics.getRecentDiagnostics": {
    "id": "src.services.system-diagnostics.getRecentDiagnostics",
    "name": "getRecentDiagnostics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "getRecentDiagnostics(): SystemDiagnostic[] {\n\t\t// Cleanup before returning\n\t\tthis.cleanup();\n\n\t\t// Already limited to 5 and filtered by age during cleanup\n\t\treturn [...this.diagnostics];\n\t}",
    "start_line": 60,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRecentDiagnostics",
    "component_id": "src.services.system-diagnostics.getRecentDiagnostics"
  },
  "src.services.system-diagnostics.cleanup": {
    "id": "src.services.system-diagnostics.cleanup",
    "name": "cleanup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "cleanup(): void {\n\t\tconst cutoffTime = Date.now() - SystemDiagnostics.RETENTION_PERIOD_MS;\n\n\t\t// Only cleanup once per minute to avoid excessive filtering\n\t\tconst timeSinceLastCleanup = Date.now() - this.lastCleanup;\n\t\tif (timeSinceLastCleanup < 60_000 && this.diagnostics.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst beforeCount = this.diagnostics.length;\n\t\tthis.diagnostics = this.diagnostics.filter(\n\t\t\t(d) => d.timestamp >= cutoffTime\n\t\t);\n\n\t\tconst removed = beforeCount - this.diagnostics.length;\n\t\tif (removed > 0) {\n\t\t\tthis.lastCleanup = Date.now();\n\t\t}\n\t}",
    "start_line": 72,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method cleanup",
    "component_id": "src.services.system-diagnostics.cleanup"
  },
  "src.services.system-diagnostics.clear": {
    "id": "src.services.system-diagnostics.clear",
    "name": "clear",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "clear(): void {\n\t\tthis.diagnostics = [];\n\t\tthis.lastCleanup = Date.now();\n\t}",
    "start_line": 95,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clear",
    "component_id": "src.services.system-diagnostics.clear"
  },
  "src.services.system-diagnostics.getCounts": {
    "id": "src.services.system-diagnostics.getCounts",
    "name": "getCounts",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "getCounts(): { errors: number; warnings: number; total: number } {\n\t\tthis.cleanup();\n\n\t\tconst errors = this.diagnostics.filter(\n\t\t\t(d) => d.severity === \"error\"\n\t\t).length;\n\t\tconst warnings = this.diagnostics.filter(\n\t\t\t(d) => d.severity === \"warning\"\n\t\t).length;\n\n\t\treturn {\n\t\t\terrors,\n\t\t\twarnings,\n\t\t\ttotal: this.diagnostics.length,\n\t\t};\n\t}",
    "start_line": 103,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCounts",
    "component_id": "src.services.system-diagnostics.getCounts"
  },
  "src.services.system-diagnostics.hasErrors": {
    "id": "src.services.system-diagnostics.hasErrors",
    "name": "hasErrors",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "hasErrors(): boolean {\n\t\tthis.cleanup();\n\t\treturn this.diagnostics.some((d) => d.severity === \"error\");\n\t}",
    "start_line": 123,
    "end_line": 126,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method hasErrors",
    "component_id": "src.services.system-diagnostics.hasErrors"
  },
  "src.services.system-diagnostics.generateId": {
    "id": "src.services.system-diagnostics.generateId",
    "name": "generateId",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "private generateId(): string {\n\t\treturn `diag-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\t}",
    "start_line": 131,
    "end_line": 133,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method generateId",
    "component_id": "src.services.system-diagnostics.generateId"
  },
  "src.services.system-diagnostics.getById": {
    "id": "src.services.system-diagnostics.getById",
    "name": "getById",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "getById(id: string): SystemDiagnostic | undefined {\n\t\treturn this.diagnostics.find((d) => d.id === id);\n\t}",
    "start_line": 138,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getById",
    "component_id": "src.services.system-diagnostics.getById"
  },
  "src.services.system-diagnostics.getBySource": {
    "id": "src.services.system-diagnostics.getBySource",
    "name": "getBySource",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "getBySource(source: string): SystemDiagnostic[] {\n\t\tthis.cleanup();\n\t\treturn this.diagnostics.filter((d) => d.source === source);\n\t}",
    "start_line": 145,
    "end_line": 148,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "source"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getBySource",
    "component_id": "src.services.system-diagnostics.getBySource"
  },
  "src.services.system-diagnostics.getAllRaw": {
    "id": "src.services.system-diagnostics.getAllRaw",
    "name": "getAllRaw",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/services/system-diagnostics.ts",
    "relative_path": "src/services/system-diagnostics.ts",
    "depends_on": [],
    "source_code": "getAllRaw(): SystemDiagnostic[] {\n\t\treturn [...this.diagnostics];\n\t}",
    "start_line": 153,
    "end_line": 155,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAllRaw",
    "component_id": "src.services.system-diagnostics.getAllRaw"
  },
  "src.types.preview.PreviewDocumentType": {
    "id": "src.types.preview.PreviewDocumentType",
    "name": "PreviewDocumentType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "type PreviewDocumentType =\n\t| \"task\"\n\t| \"spec\"\n\t| \"plan\"\n\t| \"research\"\n\t| \"dataModel\"\n\t| \"api\"\n\t| \"quickstart\"\n\t| \"checklist\";",
    "start_line": 1,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewDocumentType",
    "component_id": "src.types.preview.PreviewDocumentType"
  },
  "src.types.preview.PreviewSection": {
    "id": "src.types.preview.PreviewSection",
    "name": "PreviewSection",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "interface PreviewSection {\n\tid: string;\n\ttitle: string;\n\tbody?: string;\n}",
    "start_line": 11,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewSection",
    "component_id": "src.types.preview.PreviewSection"
  },
  "src.types.preview.DiagramBlock": {
    "id": "src.types.preview.DiagramBlock",
    "name": "DiagramBlock",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "interface DiagramBlock {\n\tdiagramId: string;\n\tlanguage: string;\n\trawSource: string;\n\trenderStandard?: string;\n}",
    "start_line": 17,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DiagramBlock",
    "component_id": "src.types.preview.DiagramBlock"
  },
  "src.types.preview.FormField": {
    "id": "src.types.preview.FormField",
    "name": "FormField",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "interface FormField {\n\tfieldId: string;\n\tlabel: string;\n\ttype: \"checkbox\" | \"dropdown\" | \"text\" | \"textarea\" | \"multiselect\";\n\toptions?: string[];\n\trequired?: boolean;\n\tvalue?: string | string[];\n\tvalidationRules?: Record<string, unknown>;\n\treadOnly?: boolean;\n}",
    "start_line": 24,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormField",
    "component_id": "src.types.preview.FormField"
  },
  "src.types.preview.FormSubmissionPayload": {
    "id": "src.types.preview.FormSubmissionPayload",
    "name": "FormSubmissionPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "interface FormSubmissionPayload {\n\trequestId: string;\n\tdocumentId: string;\n\tsessionId: string;\n\tfields: Array<{ fieldId: string; value: string | string[]; dirty: boolean }>;\n\tsubmittedAt: string;\n}",
    "start_line": 35,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormSubmissionPayload",
    "component_id": "src.types.preview.FormSubmissionPayload"
  },
  "src.types.preview.RefinementIssueType": {
    "id": "src.types.preview.RefinementIssueType",
    "name": "RefinementIssueType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "type RefinementIssueType =\n\t| \"missingDetail\"\n\t| \"incorrectInfo\"\n\t| \"missingAsset\"\n\t| \"other\";",
    "start_line": 43,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RefinementIssueType",
    "component_id": "src.types.preview.RefinementIssueType"
  },
  "src.types.preview.RefinementActionType": {
    "id": "src.types.preview.RefinementActionType",
    "name": "RefinementActionType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "type RefinementActionType = \"refine\" | \"update\";",
    "start_line": 49,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RefinementActionType",
    "component_id": "src.types.preview.RefinementActionType"
  },
  "src.types.preview.RefinementRequestPayload": {
    "id": "src.types.preview.RefinementRequestPayload",
    "name": "RefinementRequestPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [
      "src.types.preview.PreviewDocumentType",
      "src.types.preview.RefinementIssueType",
      "src.types.preview.RefinementActionType"
    ],
    "source_code": "interface RefinementRequestPayload {\n\trequestId: string;\n\tdocumentId: string;\n\tdocumentType: PreviewDocumentType;\n\tdocumentVersion?: string;\n\tsectionRef?: string;\n\tissueType: RefinementIssueType;\n\tdescription: string;\n\tsubmittedAt: string;\n\tactionType?: RefinementActionType; // \"refine\" for manual refinement, \"update\" for dependency sync\n\tchangedDependencies?: Array<{\n\t\tdocumentId: string;\n\t\tdocumentType: PreviewDocumentType;\n\t}>; // Documents that changed and triggered this update\n}",
    "start_line": 51,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefinementRequestPayload",
    "component_id": "src.types.preview.RefinementRequestPayload"
  },
  "src.types.preview.RefinementResultPayload": {
    "id": "src.types.preview.RefinementResultPayload",
    "name": "RefinementResultPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "interface RefinementResultPayload {\n\trequestId: string;\n\tstatus: \"success\" | \"error\";\n\tmessage?: string;\n}",
    "start_line": 67,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefinementResultPayload",
    "component_id": "src.types.preview.RefinementResultPayload"
  },
  "src.types.preview.DocumentPermissions": {
    "id": "src.types.preview.DocumentPermissions",
    "name": "DocumentPermissions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [],
    "source_code": "interface DocumentPermissions {\n\tcanEditForms: boolean;\n\treason?: string;\n}",
    "start_line": 73,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentPermissions",
    "component_id": "src.types.preview.DocumentPermissions"
  },
  "src.types.preview.DocumentArtifact": {
    "id": "src.types.preview.DocumentArtifact",
    "name": "DocumentArtifact",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [
      "src.types.preview.PreviewSection",
      "src.types.preview.PreviewDocumentType",
      "src.types.preview.DocumentPermissions",
      "src.types.preview.FormField",
      "src.types.preview.DiagramBlock"
    ],
    "source_code": "interface DocumentArtifact {\n\tdocumentId: string;\n\tdocumentType: PreviewDocumentType;\n\ttitle: string;\n\tfilePath?: string;\n\tversion?: string;\n\towner?: string;\n\tupdatedAt?: string;\n\trenderStandard: string;\n\tsessionId: string;\n\tisOutdated?: boolean; // True if dependencies have changed\n\toutdatedInfo?: {\n\t\toutdatedSince: number;\n\t\tchangedDependencies: Array<{\n\t\t\tdocumentId: string;\n\t\t\tdocumentType: PreviewDocumentType;\n\t\t}>;\n\t};\n\tsections: PreviewSection[];\n\tdiagrams: DiagramBlock[];\n\tforms: FormField[];\n\trawContent: string;\n\tmetadata: Record<string, unknown>;\n\tpermissions?: DocumentPermissions;\n}",
    "start_line": 78,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentArtifact",
    "component_id": "src.types.preview.DocumentArtifact"
  },
  "src.types.preview.PreviewPanelMessage": {
    "id": "src.types.preview.PreviewPanelMessage",
    "name": "PreviewPanelMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [
      "src.types.preview.DocumentArtifact",
      "src.types.preview.RefinementResultPayload"
    ],
    "source_code": "type PreviewPanelMessage =\n\t| { type: \"preview/load-document\"; payload: DocumentArtifact }\n\t| { type: \"preview/show-placeholder\"; payload?: { reason?: string } }\n\t| {\n\t\t\ttype: \"preview/forms/result\";\n\t\t\tpayload: {\n\t\t\t\trequestId: string;\n\t\t\t\tstatus: \"success\" | \"error\";\n\t\t\t\tmessage?: string;\n\t\t\t};\n\t  }\n\t| { type: \"preview/refine/result\"; payload: RefinementResultPayload }\n\t| { type: \"preview/refresh-request\" };",
    "start_line": 104,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewPanelMessage",
    "component_id": "src.types.preview.PreviewPanelMessage"
  },
  "src.types.preview.PreviewWebviewMessage": {
    "id": "src.types.preview.PreviewWebviewMessage",
    "name": "PreviewWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/preview.ts",
    "relative_path": "src/types/preview.ts",
    "depends_on": [
      "src.types.preview.FormSubmissionPayload",
      "src.types.preview.RefinementRequestPayload"
    ],
    "source_code": "type PreviewWebviewMessage =\n\t| { type: \"preview/ready\" }\n\t| { type: \"preview/request-reload\" }\n\t| { type: \"preview/edit-attempt\"; payload?: { reason?: string } }\n\t| { type: \"preview/open-in-editor\" }\n\t| { type: \"preview/forms/submit\"; payload: FormSubmissionPayload }\n\t| { type: \"preview/refine/submit\"; payload: RefinementRequestPayload };",
    "start_line": 118,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewWebviewMessage",
    "component_id": "src.types.preview.PreviewWebviewMessage"
  },
  "src.types.prompt.types.PromptVariable": {
    "id": "src.types.prompt.types.PromptVariable",
    "name": "PromptVariable",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/prompt.types.ts",
    "relative_path": "src/types/prompt.types.ts",
    "depends_on": [],
    "source_code": "interface PromptVariable {\n\ttype: \"string\" | \"number\" | \"boolean\" | \"array\" | \"object\";\n\trequired?: boolean;\n\tdefault?: any;\n\tdescription?: string;\n}",
    "start_line": 5,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PromptVariable",
    "component_id": "src.types.prompt.types.PromptVariable"
  },
  "src.types.prompt.types.PromptFrontmatter": {
    "id": "src.types.prompt.types.PromptFrontmatter",
    "name": "PromptFrontmatter",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/prompt.types.ts",
    "relative_path": "src/types/prompt.types.ts",
    "depends_on": [
      "src.types.prompt.types.PromptVariable"
    ],
    "source_code": "interface PromptFrontmatter {\n\tid: string;\n\tname: string;\n\tversion: string;\n\tdescription?: string;\n\tauthor?: string;\n\ttags?: string[];\n\textends?: string;\n\tvariables?: Record<string, PromptVariable>;\n}",
    "start_line": 12,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PromptFrontmatter",
    "component_id": "src.types.prompt.types.PromptFrontmatter"
  },
  "src.types.prompt.types.PromptTemplate": {
    "id": "src.types.prompt.types.PromptTemplate",
    "name": "PromptTemplate",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/prompt.types.ts",
    "relative_path": "src/types/prompt.types.ts",
    "depends_on": [
      "src.types.prompt.types.PromptFrontmatter"
    ],
    "source_code": "interface PromptTemplate {\n\tfrontmatter: PromptFrontmatter;\n\tcontent: string;\n}",
    "start_line": 23,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PromptTemplate",
    "component_id": "src.types.prompt.types.PromptTemplate"
  },
  "src.types.prompt.types.PromptMetadata": {
    "id": "src.types.prompt.types.PromptMetadata",
    "name": "PromptMetadata",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/prompt.types.ts",
    "relative_path": "src/types/prompt.types.ts",
    "depends_on": [],
    "source_code": "interface PromptMetadata {\n\tid: string;\n\tname: string;\n\tversion: string;\n\tdescription?: string;\n\tcategory: string;\n}",
    "start_line": 28,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PromptMetadata",
    "component_id": "src.types.prompt.types.PromptMetadata"
  },
  "src.types.prompt.types.ValidationResult": {
    "id": "src.types.prompt.types.ValidationResult",
    "name": "ValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/prompt.types.ts",
    "relative_path": "src/types/prompt.types.ts",
    "depends_on": [],
    "source_code": "interface ValidationResult {\n\tvalid: boolean;\n\terrors?: string[];\n}",
    "start_line": 36,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ValidationResult",
    "component_id": "src.types.prompt.types.ValidationResult"
  },
  "src.types.welcome.WelcomeInitMessage": {
    "id": "src.types.welcome.WelcomeInitMessage",
    "name": "WelcomeInitMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeInitMessage {\n\ttype: \"welcome/init\";\n\textensionVersion: string;\n\tvscodeVersion: string;\n}",
    "start_line": 10,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeInitMessage",
    "component_id": "src.types.welcome.WelcomeInitMessage"
  },
  "src.types.welcome.WelcomeStateMessage": {
    "id": "src.types.welcome.WelcomeStateMessage",
    "name": "WelcomeStateMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [
      "src.types.welcome.DependencyStatus",
      "src.types.welcome.SystemDiagnostic",
      "src.types.welcome.FeatureAction",
      "src.types.welcome.ConfigurationState",
      "src.types.welcome.LearningResource"
    ],
    "source_code": "interface WelcomeStateMessage {\n\ttype: \"welcome/state\";\n\thasShownBefore: boolean;\n\tdontShowOnStartup: boolean;\n\tcurrentView: \"setup\" | \"features\" | \"configuration\" | \"status\" | \"learning\";\n\tdependencies: DependencyStatus;\n\tconfiguration: ConfigurationState;\n\tdiagnostics: SystemDiagnostic[];\n\tlearningResources: LearningResource[];\n\tfeatureActions: FeatureAction[];\n}",
    "start_line": 16,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeStateMessage",
    "component_id": "src.types.welcome.WelcomeStateMessage"
  },
  "src.types.welcome.WelcomeConfigUpdatedMessage": {
    "id": "src.types.welcome.WelcomeConfigUpdatedMessage",
    "name": "WelcomeConfigUpdatedMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeConfigUpdatedMessage {\n\ttype: \"welcome/config-updated\";\n\tkey: string;\n\tnewValue: string | boolean;\n}",
    "start_line": 28,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeConfigUpdatedMessage",
    "component_id": "src.types.welcome.WelcomeConfigUpdatedMessage"
  },
  "src.types.welcome.WelcomeDependencyStatusMessage": {
    "id": "src.types.welcome.WelcomeDependencyStatusMessage",
    "name": "WelcomeDependencyStatusMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeDependencyStatusMessage {\n\ttype: \"welcome/dependency-status\";\n\tcopilotChat: {\n\t\tinstalled: boolean;\n\t\tactive: boolean;\n\t\tversion: string | null;\n\t};\n\tspeckit: {\n\t\tinstalled: boolean;\n\t\tversion: string | null;\n\t};\n\topenspec: {\n\t\tinstalled: boolean;\n\t\tversion: string | null;\n\t};\n\tlastChecked: number;\n}",
    "start_line": 34,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeDependencyStatusMessage",
    "component_id": "src.types.welcome.WelcomeDependencyStatusMessage"
  },
  "src.types.welcome.WelcomeDiagnosticAddedMessage": {
    "id": "src.types.welcome.WelcomeDiagnosticAddedMessage",
    "name": "WelcomeDiagnosticAddedMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [
      "src.types.welcome.SystemDiagnostic"
    ],
    "source_code": "interface WelcomeDiagnosticAddedMessage {\n\ttype: \"welcome/diagnostic-added\";\n\tdiagnostic: SystemDiagnostic;\n}",
    "start_line": 52,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeDiagnosticAddedMessage",
    "component_id": "src.types.welcome.WelcomeDiagnosticAddedMessage"
  },
  "src.types.welcome.WelcomeErrorMessage": {
    "id": "src.types.welcome.WelcomeErrorMessage",
    "name": "WelcomeErrorMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeErrorMessage {\n\ttype: \"welcome/error\";\n\tcode: string;\n\tmessage: string;\n\tcontext?: string;\n}",
    "start_line": 57,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeErrorMessage",
    "component_id": "src.types.welcome.WelcomeErrorMessage"
  },
  "src.types.welcome.ExtensionToWebviewMessage": {
    "id": "src.types.welcome.ExtensionToWebviewMessage",
    "name": "ExtensionToWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "type ExtensionToWebviewMessage =\n\t| WelcomeInitMessage\n\t| WelcomeStateMessage\n\t| WelcomeConfigUpdatedMessage\n\t| WelcomeDependencyStatusMessage\n\t| WelcomeDiagnosticAddedMessage\n\t| WelcomeErrorMessage;",
    "start_line": 64,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExtensionToWebviewMessage",
    "component_id": "src.types.welcome.ExtensionToWebviewMessage"
  },
  "src.types.welcome.WelcomeReadyMessage": {
    "id": "src.types.welcome.WelcomeReadyMessage",
    "name": "WelcomeReadyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeReadyMessage {\n\ttype: \"welcome/ready\";\n}",
    "start_line": 76,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeReadyMessage",
    "component_id": "src.types.welcome.WelcomeReadyMessage"
  },
  "src.types.welcome.WelcomeExecuteCommandMessage": {
    "id": "src.types.welcome.WelcomeExecuteCommandMessage",
    "name": "WelcomeExecuteCommandMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeExecuteCommandMessage {\n\ttype: \"welcome/execute-command\";\n\tcommandId: string;\n\targs?: unknown[];\n}",
    "start_line": 80,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeExecuteCommandMessage",
    "component_id": "src.types.welcome.WelcomeExecuteCommandMessage"
  },
  "src.types.welcome.WelcomeUpdateConfigMessage": {
    "id": "src.types.welcome.WelcomeUpdateConfigMessage",
    "name": "WelcomeUpdateConfigMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeUpdateConfigMessage {\n\ttype: \"welcome/update-config\";\n\tkey: string;\n\tvalue: string | boolean;\n}",
    "start_line": 86,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeUpdateConfigMessage",
    "component_id": "src.types.welcome.WelcomeUpdateConfigMessage"
  },
  "src.types.welcome.WelcomeInstallDependencyMessage": {
    "id": "src.types.welcome.WelcomeInstallDependencyMessage",
    "name": "WelcomeInstallDependencyMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeInstallDependencyMessage {\n\ttype: \"welcome/install-dependency\";\n\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\";\n}",
    "start_line": 92,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeInstallDependencyMessage",
    "component_id": "src.types.welcome.WelcomeInstallDependencyMessage"
  },
  "src.types.welcome.WelcomeRefreshDependenciesMessage": {
    "id": "src.types.welcome.WelcomeRefreshDependenciesMessage",
    "name": "WelcomeRefreshDependenciesMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeRefreshDependenciesMessage {\n\ttype: \"welcome/refresh-dependencies\";\n}",
    "start_line": 97,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeRefreshDependenciesMessage",
    "component_id": "src.types.welcome.WelcomeRefreshDependenciesMessage"
  },
  "src.types.welcome.WelcomeUpdatePreferenceMessage": {
    "id": "src.types.welcome.WelcomeUpdatePreferenceMessage",
    "name": "WelcomeUpdatePreferenceMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeUpdatePreferenceMessage {\n\ttype: \"welcome/update-preference\";\n\tpreference: \"dontShowOnStartup\";\n\tvalue: boolean;\n}",
    "start_line": 101,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeUpdatePreferenceMessage",
    "component_id": "src.types.welcome.WelcomeUpdatePreferenceMessage"
  },
  "src.types.welcome.WelcomeOpenExternalMessage": {
    "id": "src.types.welcome.WelcomeOpenExternalMessage",
    "name": "WelcomeOpenExternalMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeOpenExternalMessage {\n\ttype: \"welcome/open-external\";\n\turl: string;\n}",
    "start_line": 107,
    "end_line": 110,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeOpenExternalMessage",
    "component_id": "src.types.welcome.WelcomeOpenExternalMessage"
  },
  "src.types.welcome.WelcomeNavigateSectionMessage": {
    "id": "src.types.welcome.WelcomeNavigateSectionMessage",
    "name": "WelcomeNavigateSectionMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeNavigateSectionMessage {\n\ttype: \"welcome/navigate-section\";\n\tsection: \"setup\" | \"features\" | \"configuration\" | \"status\" | \"learning\";\n}",
    "start_line": 112,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeNavigateSectionMessage",
    "component_id": "src.types.welcome.WelcomeNavigateSectionMessage"
  },
  "src.types.welcome.WelcomeSearchResourcesMessage": {
    "id": "src.types.welcome.WelcomeSearchResourcesMessage",
    "name": "WelcomeSearchResourcesMessage",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface WelcomeSearchResourcesMessage {\n\ttype: \"welcome/search-resources\";\n\tquery: string;\n}",
    "start_line": 117,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeSearchResourcesMessage",
    "component_id": "src.types.welcome.WelcomeSearchResourcesMessage"
  },
  "src.types.welcome.WebviewToExtensionMessage": {
    "id": "src.types.welcome.WebviewToExtensionMessage",
    "name": "WebviewToExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "type WebviewToExtensionMessage =\n\t| WelcomeReadyMessage\n\t| WelcomeExecuteCommandMessage\n\t| WelcomeUpdateConfigMessage\n\t| WelcomeInstallDependencyMessage\n\t| WelcomeRefreshDependenciesMessage\n\t| WelcomeUpdatePreferenceMessage\n\t| WelcomeOpenExternalMessage\n\t| WelcomeNavigateSectionMessage\n\t| WelcomeSearchResourcesMessage;",
    "start_line": 122,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type WebviewToExtensionMessage",
    "component_id": "src.types.welcome.WebviewToExtensionMessage"
  },
  "src.types.welcome.DependencyStatus": {
    "id": "src.types.welcome.DependencyStatus",
    "name": "DependencyStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface DependencyStatus {\n\tcopilotChat: {\n\t\tinstalled: boolean;\n\t\tactive: boolean;\n\t\tversion: string | null;\n\t};\n\tspeckit: {\n\t\tinstalled: boolean;\n\t\tversion: string | null;\n\t};\n\topenspec: {\n\t\tinstalled: boolean;\n\t\tversion: string | null;\n\t};\n\tlastChecked: number;\n}",
    "start_line": 137,
    "end_line": 152,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependencyStatus",
    "component_id": "src.types.welcome.DependencyStatus"
  },
  "src.types.welcome.ConfigurationItem": {
    "id": "src.types.welcome.ConfigurationItem",
    "name": "ConfigurationItem",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface ConfigurationItem {\n\tkey: string;\n\tlabel: string;\n\tcurrentValue: string | boolean;\n\teditable: boolean;\n\toptions?: string[];\n}",
    "start_line": 154,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConfigurationItem",
    "component_id": "src.types.welcome.ConfigurationItem"
  },
  "src.types.welcome.ConfigurationState": {
    "id": "src.types.welcome.ConfigurationState",
    "name": "ConfigurationState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [
      "src.types.welcome.ConfigurationItem"
    ],
    "source_code": "interface ConfigurationState {\n\tspecSystem: ConfigurationItem & {\n\t\tcurrentValue: \"auto\" | \"speckit\" | \"openspec\";\n\t\toptions: string[];\n\t};\n\tspeckitSpecsPath: ConfigurationItem & { currentValue: string };\n\tspeckitMemoryPath: ConfigurationItem & { currentValue: string };\n\tspeckitTemplatesPath: ConfigurationItem & { currentValue: string };\n\topenspecPath: ConfigurationItem & { currentValue: string };\n\tpromptsPath: ConfigurationItem & { currentValue: string };\n\totherSettings: Array<ConfigurationItem & { editable: false }>;\n}",
    "start_line": 162,
    "end_line": 173,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConfigurationState",
    "component_id": "src.types.welcome.ConfigurationState"
  },
  "src.types.welcome.SystemDiagnostic": {
    "id": "src.types.welcome.SystemDiagnostic",
    "name": "SystemDiagnostic",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface SystemDiagnostic {\n\tid: string;\n\ttimestamp: number;\n\tseverity: \"error\" | \"warning\";\n\tmessage: string;\n\tsource: string;\n\tsuggestedAction: string | null;\n}",
    "start_line": 175,
    "end_line": 182,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SystemDiagnostic",
    "component_id": "src.types.welcome.SystemDiagnostic"
  },
  "src.types.welcome.LearningResource": {
    "id": "src.types.welcome.LearningResource",
    "name": "LearningResource",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface LearningResource {\n\tid: string;\n\ttitle: string;\n\tdescription: string;\n\turl: string;\n\tcategory: \"Getting Started\" | \"Advanced Features\" | \"Troubleshooting\";\n\tkeywords: string[];\n\testimatedMinutes: number | null;\n}",
    "start_line": 184,
    "end_line": 192,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LearningResource",
    "component_id": "src.types.welcome.LearningResource"
  },
  "src.types.welcome.FeatureAction": {
    "id": "src.types.welcome.FeatureAction",
    "name": "FeatureAction",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "interface FeatureAction {\n\tid: string;\n\tfeatureArea: \"Specs\" | \"Actions\" | \"Hooks\" | \"Steering\";\n\tlabel: string;\n\tdescription: string;\n\tcommandId: string;\n\tenabled: boolean;\n\ticon?: string;\n}",
    "start_line": 194,
    "end_line": 202,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FeatureAction",
    "component_id": "src.types.welcome.FeatureAction"
  },
  "src.types.welcome.WelcomeScreenState": {
    "id": "src.types.welcome.WelcomeScreenState",
    "name": "WelcomeScreenState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [
      "src.types.welcome.DependencyStatus",
      "src.types.welcome.SystemDiagnostic",
      "src.types.welcome.FeatureAction",
      "src.types.welcome.ConfigurationState",
      "src.types.welcome.LearningResource"
    ],
    "source_code": "interface WelcomeScreenState {\n\textensionVersion: string;\n\tvscodeVersion: string;\n\thasShownBefore: boolean;\n\tdontShowOnStartup: boolean;\n\tcurrentView: \"setup\" | \"features\" | \"configuration\" | \"status\" | \"learning\";\n\tdependencies: DependencyStatus;\n\tconfiguration: ConfigurationState;\n\tdiagnostics: SystemDiagnostic[];\n\tlearningResources: LearningResource[];\n\tfeatureActions: FeatureAction[];\n}",
    "start_line": 208,
    "end_line": 219,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeScreenState",
    "component_id": "src.types.welcome.WelcomeScreenState"
  },
  "src.types.welcome.WelcomeErrorCodeType": {
    "id": "src.types.welcome.WelcomeErrorCodeType",
    "name": "WelcomeErrorCodeType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/types/welcome.ts",
    "relative_path": "src/types/welcome.ts",
    "depends_on": [],
    "source_code": "type WelcomeErrorCodeType =\n\t(typeof WelcomeErrorCode)[keyof typeof WelcomeErrorCode];",
    "start_line": 233,
    "end_line": 234,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type WelcomeErrorCodeType",
    "component_id": "src.types.welcome.WelcomeErrorCodeType"
  },
  "src.utils.chat-prompt-runner.ChatContext": {
    "id": "src.utils.chat-prompt-runner.ChatContext",
    "name": "ChatContext",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/chat-prompt-runner.ts",
    "relative_path": "src/utils/chat-prompt-runner.ts",
    "depends_on": [],
    "source_code": "interface ChatContext {\n\tinstructionType?: \"createSpec\" | \"startAllTask\" | \"runPrompt\";\n}",
    "start_line": 4,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChatContext",
    "component_id": "src.utils.chat-prompt-runner.ChatContext"
  },
  "src.utils.chat-prompt-runner.sendPromptToChat": {
    "id": "src.utils.chat-prompt-runner.sendPromptToChat",
    "name": "sendPromptToChat",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/chat-prompt-runner.ts",
    "relative_path": "src/utils/chat-prompt-runner.ts",
    "depends_on": [
      "src.providers.welcome-screen-provider.executeCommand",
      "src.utils.spec-kit-adapter.getInstance",
      "src.utils.config-manager.getSettings",
      "src.utils.chat-prompt-runner.ChatContext"
    ],
    "source_code": "sendPromptToChat = async (\n\tprompt: string,\n\tcontext?: ChatContext\n): Promise<void> => {\n\tconst configManager = ConfigManager.getInstance();\n\tconst settings = configManager.getSettings();\n\tconst language = settings.chatLanguage;\n\tconst customInstructions = settings.customInstructions;\n\n\tlet finalPrompt = prompt;\n\n\t// Append global custom instruction\n\tif (customInstructions.global) {\n\t\tfinalPrompt += `\\n\\n${customInstructions.global}`;\n\t}\n\n\t// Append specific custom instruction\n\tif (context?.instructionType) {\n\t\tconst specificInstruction = customInstructions[context.instructionType];\n\t\tif (specificInstruction) {\n\t\t\tfinalPrompt += `\\n\\n${specificInstruction}`;\n\t\t}\n\t}\n\n\t// Append language instruction\n\tif (language !== \"English\") {\n\t\tfinalPrompt += `\\n\\n(Please respond in ${language}.)`;\n\t}\n\n\tawait commands.executeCommand(\"workbench.action.chat.open\", {\n\t\tquery: finalPrompt,\n\t});\n}",
    "start_line": 8,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "prompt",
      "context"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function sendPromptToChat",
    "component_id": "src.utils.chat-prompt-runner.sendPromptToChat"
  },
  "src.utils.checklist-parser.ChecklistItem": {
    "id": "src.utils.checklist-parser.ChecklistItem",
    "name": "ChecklistItem",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/checklist-parser.ts",
    "relative_path": "src/utils/checklist-parser.ts",
    "depends_on": [],
    "source_code": "interface ChecklistItem {\n\ttext: string;\n\tchecked: boolean;\n\tline: number;\n}",
    "start_line": 7,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChecklistItem",
    "component_id": "src.utils.checklist-parser.ChecklistItem"
  },
  "src.utils.checklist-parser.ChecklistStatus": {
    "id": "src.utils.checklist-parser.ChecklistStatus",
    "name": "ChecklistStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/checklist-parser.ts",
    "relative_path": "src/utils/checklist-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskStatus"
    ],
    "source_code": "interface ChecklistStatus {\n\tstatus: TaskStatus;\n\ttotal: number;\n\tcompleted: number;\n}",
    "start_line": 16,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChecklistStatus",
    "component_id": "src.utils.checklist-parser.ChecklistStatus"
  },
  "src.utils.checklist-parser.parseChecklistFromFile": {
    "id": "src.utils.checklist-parser.parseChecklistFromFile",
    "name": "parseChecklistFromFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/checklist-parser.ts",
    "relative_path": "src/utils/checklist-parser.ts",
    "depends_on": [
      "src.utils.checklist-parser.parseChecklistContent",
      "src.utils.checklist-parser.ChecklistItem"
    ],
    "source_code": "function parseChecklistFromFile(filePath: string): ChecklistItem[] {\n\tif (!existsSync(filePath)) {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\tconst content = readFileSync(filePath, \"utf-8\");\n\t\treturn parseChecklistContent(content);\n\t} catch {\n\t\treturn [];\n\t}\n}",
    "start_line": 30,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseChecklistFromFile",
    "component_id": "src.utils.checklist-parser.parseChecklistFromFile"
  },
  "src.utils.checklist-parser.parseChecklistContent": {
    "id": "src.utils.checklist-parser.parseChecklistContent",
    "name": "parseChecklistContent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/checklist-parser.ts",
    "relative_path": "src/utils/checklist-parser.ts",
    "depends_on": [
      "src.utils.checklist-parser.ChecklistItem"
    ],
    "source_code": "function parseChecklistContent(content: string): ChecklistItem[] {\n\tconst lines = content.split(\"\\n\");\n\tconst items: ChecklistItem[] = [];\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i];\n\t\tconst match = line.match(CHECKBOX_PATTERN);\n\n\t\tif (match) {\n\t\t\titems.push({\n\t\t\t\ttext: match[2].trim(),\n\t\t\t\tchecked: match[1].toLowerCase() === \"x\",\n\t\t\t\tline: i + 1,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn items;\n}",
    "start_line": 46,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseChecklistContent",
    "component_id": "src.utils.checklist-parser.parseChecklistContent"
  },
  "src.utils.checklist-parser.calculateChecklistStatus": {
    "id": "src.utils.checklist-parser.calculateChecklistStatus",
    "name": "calculateChecklistStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/checklist-parser.ts",
    "relative_path": "src/utils/checklist-parser.ts",
    "depends_on": [
      "src.utils.checklist-parser.ChecklistStatus",
      "src.utils.task-parser.TaskStatus",
      "src.utils.checklist-parser.ChecklistItem"
    ],
    "source_code": "function calculateChecklistStatus(\n\titems: ChecklistItem[]\n): ChecklistStatus {\n\tif (items.length === 0) {\n\t\treturn {\n\t\t\tstatus: \"not-started\",\n\t\t\ttotal: 0,\n\t\t\tcompleted: 0,\n\t\t};\n\t}\n\n\tconst completed = items.filter((item) => item.checked).length;\n\tconst total = items.length;\n\n\tlet status: TaskStatus;\n\tif (completed === total) {\n\t\tstatus = \"completed\";\n\t} else if (completed > 0) {\n\t\tstatus = \"in-progress\";\n\t} else {\n\t\tstatus = \"not-started\";\n\t}\n\n\treturn {\n\t\tstatus,\n\t\ttotal,\n\t\tcompleted,\n\t};\n}",
    "start_line": 69,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "items"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculateChecklistStatus",
    "component_id": "src.utils.checklist-parser.calculateChecklistStatus"
  },
  "src.utils.checklist-parser.getChecklistStatusFromFile": {
    "id": "src.utils.checklist-parser.getChecklistStatusFromFile",
    "name": "getChecklistStatusFromFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/checklist-parser.ts",
    "relative_path": "src/utils/checklist-parser.ts",
    "depends_on": [
      "src.utils.checklist-parser.calculateChecklistStatus",
      "src.utils.checklist-parser.ChecklistStatus",
      "src.utils.checklist-parser.parseChecklistFromFile"
    ],
    "source_code": "function getChecklistStatusFromFile(filePath: string): ChecklistStatus {\n\tconst items = parseChecklistFromFile(filePath);\n\treturn calculateChecklistStatus(items);\n}",
    "start_line": 102,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getChecklistStatusFromFile",
    "component_id": "src.utils.checklist-parser.getChecklistStatusFromFile"
  },
  "src.utils.cli-detector.getExtendedPath": {
    "id": "src.utils.cli-detector.getExtendedPath",
    "name": "getExtendedPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/cli-detector.ts",
    "relative_path": "src/utils/cli-detector.ts",
    "depends_on": [],
    "source_code": "getExtendedPath = (): string => {\n\tconst home = homedir();\n\tconst additionalPaths = [\n\t\t`${home}/.local/bin`, // UV tools (specify)\n\t\t`${home}/.cargo/bin`, // Rust tools\n\t\t`${home}/.bun/bin`, // Bun\n\t\t`${home}/.deno/bin`, // Deno\n\t\t`${home}/.langflow/uv`, // UV via Langflow installation\n\t\t`${home}/.astral/uv/bin`, // UV via Astral installation\n\t\t`${home}/.uv/bin`, // Alternative UV location\n\t\t\"/opt/homebrew/bin\", // Homebrew on Apple Silicon\n\t\t\"/usr/local/bin\", // Homebrew on Intel Mac\n\t];\n\tconst currentPath = process.env.PATH || \"\";\n\treturn [...additionalPaths, currentPath].join(\":\");\n}",
    "start_line": 17,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getExtendedPath",
    "component_id": "src.utils.cli-detector.getExtendedPath"
  },
  "src.utils.cli-detector.extractVersion": {
    "id": "src.utils.cli-detector.extractVersion",
    "name": "extractVersion",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/cli-detector.ts",
    "relative_path": "src/utils/cli-detector.ts",
    "depends_on": [],
    "source_code": "extractVersion = (output: string): string | undefined => {\n\tfor (const pattern of VERSION_PATTERNS) {\n\t\tconst match = output.match(pattern);\n\t\tif (match) {\n\t\t\treturn match[1];\n\t\t}\n\t}\n\treturn;\n}",
    "start_line": 46,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "output"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function extractVersion",
    "component_id": "src.utils.cli-detector.extractVersion"
  },
  "src.utils.cli-detector.CLICheckResult": {
    "id": "src.utils.cli-detector.CLICheckResult",
    "name": "CLICheckResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/cli-detector.ts",
    "relative_path": "src/utils/cli-detector.ts",
    "depends_on": [],
    "source_code": "interface CLICheckResult {\n\tinstalled: boolean;\n\tversion: string | null;\n\toutput?: string;\n\terror?: string;\n}",
    "start_line": 56,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CLICheckResult",
    "component_id": "src.utils.cli-detector.CLICheckResult"
  },
  "src.utils.cli-detector.checkCLI": {
    "id": "src.utils.cli-detector.checkCLI",
    "name": "checkCLI",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/cli-detector.ts",
    "relative_path": "src/utils/cli-detector.ts",
    "depends_on": [
      "src.utils.cli-detector.extractVersion",
      "src.utils.cli-detector.getExtendedPath",
      "src.utils.cli-detector.CLICheckResult"
    ],
    "source_code": "checkCLI = async (\n\tcommand: string,\n\ttimeoutMs = 5000\n): Promise<CLICheckResult> => {\n\ttry {\n\t\tconst { stdout, stderr } = await execAsync(command, {\n\t\t\ttimeout: timeoutMs,\n\t\t\tencoding: \"utf8\",\n\t\t\tenv: {\n\t\t\t\t...process.env,\n\t\t\t\tPATH: getExtendedPath(),\n\t\t\t},\n\t\t});\n\n\t\tconst output = stdout.trim() || stderr.trim();\n\n\t\t// Try JSON parse first (some CLIs output JSON)\n\t\ttry {\n\t\t\tconst json = JSON.parse(output);\n\t\t\tif (json.version) {\n\t\t\t\treturn {\n\t\t\t\t\tinstalled: true,\n\t\t\t\t\tversion: json.version,\n\t\t\t\t\toutput,\n\t\t\t\t};\n\t\t\t}\n\t\t} catch {\n\t\t\t// Not JSON, continue to regex parsing\n\t\t}\n\n\t\t// Extract version from text output\n\t\tconst version = extractVersion(output);\n\n\t\treturn {\n\t\t\tinstalled: true,\n\t\t\tversion: version || output || \"unknown\",\n\t\t\toutput,\n\t\t};\n\t} catch (error: any) {\n\t\t// Command not found (not in PATH)\n\t\tif (error.code === \"ENOENT\") {\n\t\t\treturn {\n\t\t\t\tinstalled: false,\n\t\t\t\tversion: null,\n\t\t\t\terror: \"Command not found\",\n\t\t\t};\n\t\t}\n\n\t\t// Timeout\n\t\tif (error.killed || error.signal === \"SIGTERM\") {\n\t\t\treturn {\n\t\t\t\tinstalled: false,\n\t\t\t\tversion: null,\n\t\t\t\terror: `Command timed out after ${timeoutMs}ms`,\n\t\t\t};\n\t\t}\n\n\t\t// Other errors\n\t\treturn {\n\t\t\tinstalled: false,\n\t\t\tversion: null,\n\t\t\terror: error.message || String(error),\n\t\t};\n\t}\n}",
    "start_line": 71,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command",
      "timeoutMs"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function checkCLI",
    "component_id": "src.utils.cli-detector.checkCLI"
  },
  "src.utils.config-manager.OpenSpecSettings": {
    "id": "src.utils.config-manager.OpenSpecSettings",
    "name": "OpenSpecSettings",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "interface OpenSpecSettings {\n\tpaths: {\n\t\tspecs: string;\n\t\tprompts: string;\n\t};\n\tspeckit: {\n\t\tpaths: {\n\t\t\tspecs: string;\n\t\t\tmemory: string;\n\t\t\ttemplates: string;\n\t\t\tscripts: string;\n\t\t\tagents: string;\n\t\t\tskills: string;\n\t\t};\n\t};\n\tviews: {\n\t\tspecs: { visible: boolean };\n\t\tsteering: { visible: boolean };\n\t\tprompts: { visible: boolean };\n\t\tquickAccess: { visible: boolean };\n\t};\n\tchatLanguage: string;\n\tcustomInstructions: {\n\t\tglobal: string;\n\t\tcreateSpec: string;\n\t\tstartAllTask: string;\n\t\trunPrompt: string;\n\t};\n\tspecSystem: string;\n}",
    "start_line": 10,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface OpenSpecSettings",
    "component_id": "src.utils.config-manager.OpenSpecSettings"
  },
  "src.utils.config-manager.ConfigManager": {
    "id": "src.utils.config-manager.ConfigManager",
    "name": "ConfigManager",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [
      "src.utils.config-manager.OpenSpecSettings",
      "src.utils.config-manager.getSpecKitPaths",
      "src.utils.config-manager.getCustomInstructions",
      "src.utils.config-manager.getChatLanguage",
      "src.utils.config-manager.getSettings",
      "src.utils.config-manager.getPath",
      "src.services.configuration-service.getConfiguration",
      "src.utils.config-manager.getSpecSystem",
      "src.features.agents.resource-cache.get",
      "src.utils.config-manager.mergeSettings",
      "src.utils.config-manager.getConfiguredPaths",
      "src.utils.config-manager.ConfigManager",
      "src.utils.config-manager.getDefaultSettings",
      "src.utils.spec-kit-adapter.createSpec"
    ],
    "source_code": "class ConfigManager {\n\tprivate static instance: ConfigManager;\n\tprivate settings: OpenSpecSettings | null = null;\n\tprivate readonly workspaceFolder: WorkspaceFolder | undefined;\n\n\t// Internal constants\n\tprivate static readonly TERMINAL_VENV_ACTIVATION_DELAY = 800; // ms\n\n\tprivate constructor() {\n\t\tthis.workspaceFolder = workspace.workspaceFolders?.[0];\n\t}\n\n\tstatic getInstance(): ConfigManager {\n\t\tif (!ConfigManager.instance) {\n\t\t\tConfigManager.instance = new ConfigManager();\n\t\t}\n\t\treturn ConfigManager.instance;\n\t}\n\n\t// biome-ignore lint/suspicious/useAwait: ignore\n\tasync loadSettings(): Promise<OpenSpecSettings> {\n\t\tconst settings = this.getDefaultSettings();\n\t\tthis.settings = settings;\n\t\treturn settings;\n\t}\n\n\tgetSettings(): OpenSpecSettings {\n\t\tif (!this.settings) {\n\t\t\tthis.settings = this.getDefaultSettings();\n\t\t}\n\t\treturn this.settings;\n\t}\n\n\tgetPath(type: keyof typeof DEFAULT_PATHS): string {\n\t\tconst settings = this.getSettings();\n\t\treturn settings.paths[type] ?? DEFAULT_PATHS[type];\n\t}\n\n\tgetAbsolutePath(type: keyof typeof DEFAULT_PATHS): string {\n\t\tif (!this.workspaceFolder) {\n\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t}\n\t\treturn join(this.workspaceFolder.uri.fsPath, this.getPath(type));\n\t}\n\n\tgetTerminalDelay(): number {\n\t\treturn ConfigManager.TERMINAL_VENV_ACTIVATION_DELAY;\n\t}\n\n\tprivate getConfiguredPaths(): Partial<\n\t\tRecord<keyof typeof DEFAULT_PATHS, string>\n\t> {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\tconst promptsPath = config.get<string>(\"copilot.promptsPath\")?.trim();\n\t\tconst specsPath = config.get<string>(\"copilot.specsPath\")?.trim();\n\n\t\tconst configuredPaths: Partial<Record<keyof typeof DEFAULT_PATHS, string>> =\n\t\t\t{};\n\n\t\tif (promptsPath) {\n\t\t\tconfiguredPaths.prompts = promptsPath;\n\t\t}\n\n\t\tif (specsPath) {\n\t\t\tconfiguredPaths.specs = specsPath;\n\t\t}\n\n\t\treturn configuredPaths;\n\t}\n\n\tprivate getSpecKitPaths(): OpenSpecSettings[\"speckit\"][\"paths\"] {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn {\n\t\t\tspecs:\n\t\t\t\tconfig.get<string>(\"speckit.specsPath\") ?? SPECKIT_CONFIG.paths.specs,\n\t\t\tmemory:\n\t\t\t\tconfig.get<string>(\"speckit.memoryPath\") ?? SPECKIT_CONFIG.paths.memory,\n\t\t\ttemplates:\n\t\t\t\tconfig.get<string>(\"speckit.templatesPath\") ??\n\t\t\t\tSPECKIT_CONFIG.paths.templates,\n\t\t\tscripts:\n\t\t\t\tconfig.get<string>(\"speckit.scriptsPath\") ??\n\t\t\t\tSPECKIT_CONFIG.paths.scripts,\n\t\t\tagents:\n\t\t\t\tconfig.get<string>(\"speckit.agentsPath\") ?? SPECKIT_CONFIG.paths.agents,\n\t\t\tskills:\n\t\t\t\tconfig.get<string>(\"speckit.skillsPath\") ?? SPECKIT_CONFIG.paths.skills,\n\t\t};\n\t}\n\n\tprivate getChatLanguage(): string {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn config.get<string>(\"chatLanguage\") ?? DEFAULT_CONFIG.chatLanguage;\n\t}\n\n\tprivate getSpecSystem(): string {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn config.get<string>(\"specSystem\") ?? \"auto\";\n\t}\n\n\tprivate getCustomInstructions(): OpenSpecSettings[\"customInstructions\"] {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn {\n\t\t\tglobal: config.get<string>(\"customInstructions.global\") ?? \"\",\n\t\t\tcreateSpec: config.get<string>(\"customInstructions.createSpec\") ?? \"\",\n\t\t\tstartAllTask: config.get<string>(\"customInstructions.startAllTask\") ?? \"\",\n\t\t\trunPrompt: config.get<string>(\"customInstructions.runPrompt\") ?? \"\",\n\t\t};\n\t}\n\n\tprivate mergeSettings(\n\t\tdefaults: OpenSpecSettings,\n\t\toverrides: Partial<OpenSpecSettings> = {}\n\t): OpenSpecSettings {\n\t\tconst mergedPaths = {\n\t\t\t...defaults.paths,\n\t\t\t...(overrides.paths ?? {}),\n\t\t};\n\n\t\tconst mergedSpecKitPaths = {\n\t\t\t...defaults.speckit.paths,\n\t\t\t...(overrides.speckit?.paths ?? {}),\n\t\t};\n\n\t\tconst mergedViews = {\n\t\t\tspecs: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.specs?.visible ?? defaults.views.specs.visible,\n\t\t\t},\n\t\t\tsteering: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.steering?.visible ?? defaults.views.steering.visible,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.prompts?.visible ?? defaults.views.prompts.visible,\n\t\t\t},\n\t\t\tquickAccess: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.quickAccess?.visible ??\n\t\t\t\t\tdefaults.views.quickAccess.visible,\n\t\t\t},\n\t\t};\n\n\t\tconst mergedCustomInstructions = {\n\t\t\tglobal:\n\t\t\t\toverrides.customInstructions?.global ??\n\t\t\t\tdefaults.customInstructions.global,\n\t\t\tcreateSpec:\n\t\t\t\toverrides.customInstructions?.createSpec ??\n\t\t\t\tdefaults.customInstructions.createSpec,\n\t\t\tstartAllTask:\n\t\t\t\toverrides.customInstructions?.startAllTask ??\n\t\t\t\tdefaults.customInstructions.startAllTask,\n\t\t\trunPrompt:\n\t\t\t\toverrides.customInstructions?.runPrompt ??\n\t\t\t\tdefaults.customInstructions.runPrompt,\n\t\t};\n\n\t\treturn {\n\t\t\tpaths: mergedPaths,\n\t\t\tspeckit: {\n\t\t\t\tpaths: mergedSpecKitPaths,\n\t\t\t},\n\t\t\tviews: mergedViews,\n\t\t\tchatLanguage: overrides.chatLanguage ?? defaults.chatLanguage,\n\t\t\tcustomInstructions: mergedCustomInstructions,\n\t\t\tspecSystem: overrides.specSystem ?? defaults.specSystem,\n\t\t};\n\t}\n\n\tprivate getDefaultSettings(): OpenSpecSettings {\n\t\tconst configuredPaths = this.getConfiguredPaths();\n\t\tconst specKitPaths = this.getSpecKitPaths();\n\t\tconst chatLanguage = this.getChatLanguage();\n\t\tconst customInstructions = this.getCustomInstructions();\n\t\tconst specSystem = this.getSpecSystem();\n\n\t\treturn {\n\t\t\tpaths: { ...DEFAULT_PATHS, ...configuredPaths },\n\t\t\tspeckit: {\n\t\t\t\tpaths: specKitPaths,\n\t\t\t},\n\t\t\tviews: {\n\t\t\t\tspecs: { visible: DEFAULT_VIEW_VISIBILITY.specs },\n\t\t\t\tsteering: { visible: DEFAULT_VIEW_VISIBILITY.steering },\n\t\t\t\tprompts: { visible: DEFAULT_VIEW_VISIBILITY.prompts },\n\t\t\t\tquickAccess: { visible: DEFAULT_VIEW_VISIBILITY.quickAccess },\n\t\t\t},\n\t\t\tchatLanguage,\n\t\t\tcustomInstructions,\n\t\t\tspecSystem,\n\t\t};\n\t}\n\t// biome-ignore lint/suspicious/useAwait: ignore\n\tasync saveSettings(settings: OpenSpecSettings): Promise<void> {\n\t\tthis.settings = this.mergeSettings(this.getDefaultSettings(), settings);\n\t}\n}",
    "start_line": 41,
    "end_line": 239,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ConfigManager",
    "component_id": "src.utils.config-manager.ConfigManager"
  },
  "src.utils.config-manager.getInstance": {
    "id": "src.utils.config-manager.getInstance",
    "name": "getInstance",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "static getInstance(): ConfigManager {\n\t\tif (!ConfigManager.instance) {\n\t\t\tConfigManager.instance = new ConfigManager();\n\t\t}\n\t\treturn ConfigManager.instance;\n\t}",
    "start_line": 53,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method getInstance",
    "component_id": "src.utils.config-manager.getInstance"
  },
  "src.utils.config-manager.loadSettings": {
    "id": "src.utils.config-manager.loadSettings",
    "name": "loadSettings",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "async loadSettings(): Promise<OpenSpecSettings> {\n\t\tconst settings = this.getDefaultSettings();\n\t\tthis.settings = settings;\n\t\treturn settings;\n\t}",
    "start_line": 61,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadSettings",
    "component_id": "src.utils.config-manager.loadSettings"
  },
  "src.utils.config-manager.getSettings": {
    "id": "src.utils.config-manager.getSettings",
    "name": "getSettings",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "getSettings(): OpenSpecSettings {\n\t\tif (!this.settings) {\n\t\t\tthis.settings = this.getDefaultSettings();\n\t\t}\n\t\treturn this.settings;\n\t}",
    "start_line": 67,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSettings",
    "component_id": "src.utils.config-manager.getSettings"
  },
  "src.utils.config-manager.getPath": {
    "id": "src.utils.config-manager.getPath",
    "name": "getPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "getPath(type: keyof typeof DEFAULT_PATHS): string {\n\t\tconst settings = this.getSettings();\n\t\treturn settings.paths[type] ?? DEFAULT_PATHS[type];\n\t}",
    "start_line": 74,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getPath",
    "component_id": "src.utils.config-manager.getPath"
  },
  "src.utils.config-manager.getAbsolutePath": {
    "id": "src.utils.config-manager.getAbsolutePath",
    "name": "getAbsolutePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "getAbsolutePath(type: keyof typeof DEFAULT_PATHS): string {\n\t\tif (!this.workspaceFolder) {\n\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t}\n\t\treturn join(this.workspaceFolder.uri.fsPath, this.getPath(type));\n\t}",
    "start_line": 79,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAbsolutePath",
    "component_id": "src.utils.config-manager.getAbsolutePath"
  },
  "src.utils.config-manager.getTerminalDelay": {
    "id": "src.utils.config-manager.getTerminalDelay",
    "name": "getTerminalDelay",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "getTerminalDelay(): number {\n\t\treturn ConfigManager.TERMINAL_VENV_ACTIVATION_DELAY;\n\t}",
    "start_line": 86,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getTerminalDelay",
    "component_id": "src.utils.config-manager.getTerminalDelay"
  },
  "src.utils.config-manager.getConfiguredPaths": {
    "id": "src.utils.config-manager.getConfiguredPaths",
    "name": "getConfiguredPaths",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private getConfiguredPaths(): Partial<\n\t\tRecord<keyof typeof DEFAULT_PATHS, string>\n\t> {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\tconst promptsPath = config.get<string>(\"copilot.promptsPath\")?.trim();\n\t\tconst specsPath = config.get<string>(\"copilot.specsPath\")?.trim();\n\n\t\tconst configuredPaths: Partial<Record<keyof typeof DEFAULT_PATHS, string>> =\n\t\t\t{};\n\n\t\tif (promptsPath) {\n\t\t\tconfiguredPaths.prompts = promptsPath;\n\t\t}\n\n\t\tif (specsPath) {\n\t\t\tconfiguredPaths.specs = specsPath;\n\t\t}\n\n\t\treturn configuredPaths;\n\t}",
    "start_line": 90,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getConfiguredPaths",
    "component_id": "src.utils.config-manager.getConfiguredPaths"
  },
  "src.utils.config-manager.getSpecKitPaths": {
    "id": "src.utils.config-manager.getSpecKitPaths",
    "name": "getSpecKitPaths",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private getSpecKitPaths(): OpenSpecSettings[\"speckit\"][\"paths\"] {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn {\n\t\t\tspecs:\n\t\t\t\tconfig.get<string>(\"speckit.specsPath\") ?? SPECKIT_CONFIG.paths.specs,\n\t\t\tmemory:\n\t\t\t\tconfig.get<string>(\"speckit.memoryPath\") ?? SPECKIT_CONFIG.paths.memory,\n\t\t\ttemplates:\n\t\t\t\tconfig.get<string>(\"speckit.templatesPath\") ??\n\t\t\t\tSPECKIT_CONFIG.paths.templates,\n\t\t\tscripts:\n\t\t\t\tconfig.get<string>(\"speckit.scriptsPath\") ??\n\t\t\t\tSPECKIT_CONFIG.paths.scripts,\n\t\t\tagents:\n\t\t\t\tconfig.get<string>(\"speckit.agentsPath\") ?? SPECKIT_CONFIG.paths.agents,\n\t\t\tskills:\n\t\t\t\tconfig.get<string>(\"speckit.skillsPath\") ?? SPECKIT_CONFIG.paths.skills,\n\t\t};\n\t}",
    "start_line": 111,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecKitPaths",
    "component_id": "src.utils.config-manager.getSpecKitPaths"
  },
  "src.utils.config-manager.getChatLanguage": {
    "id": "src.utils.config-manager.getChatLanguage",
    "name": "getChatLanguage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private getChatLanguage(): string {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn config.get<string>(\"chatLanguage\") ?? DEFAULT_CONFIG.chatLanguage;\n\t}",
    "start_line": 131,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getChatLanguage",
    "component_id": "src.utils.config-manager.getChatLanguage"
  },
  "src.utils.config-manager.getSpecSystem": {
    "id": "src.utils.config-manager.getSpecSystem",
    "name": "getSpecSystem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private getSpecSystem(): string {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn config.get<string>(\"specSystem\") ?? \"auto\";\n\t}",
    "start_line": 136,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecSystem",
    "component_id": "src.utils.config-manager.getSpecSystem"
  },
  "src.utils.config-manager.getCustomInstructions": {
    "id": "src.utils.config-manager.getCustomInstructions",
    "name": "getCustomInstructions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private getCustomInstructions(): OpenSpecSettings[\"customInstructions\"] {\n\t\tconst config = workspace.getConfiguration(VSC_CONFIG_NAMESPACE);\n\t\treturn {\n\t\t\tglobal: config.get<string>(\"customInstructions.global\") ?? \"\",\n\t\t\tcreateSpec: config.get<string>(\"customInstructions.createSpec\") ?? \"\",\n\t\t\tstartAllTask: config.get<string>(\"customInstructions.startAllTask\") ?? \"\",\n\t\t\trunPrompt: config.get<string>(\"customInstructions.runPrompt\") ?? \"\",\n\t\t};\n\t}",
    "start_line": 141,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCustomInstructions",
    "component_id": "src.utils.config-manager.getCustomInstructions"
  },
  "src.utils.config-manager.mergeSettings": {
    "id": "src.utils.config-manager.mergeSettings",
    "name": "mergeSettings",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private mergeSettings(\n\t\tdefaults: OpenSpecSettings,\n\t\toverrides: Partial<OpenSpecSettings> = {}\n\t): OpenSpecSettings {\n\t\tconst mergedPaths = {\n\t\t\t...defaults.paths,\n\t\t\t...(overrides.paths ?? {}),\n\t\t};\n\n\t\tconst mergedSpecKitPaths = {\n\t\t\t...defaults.speckit.paths,\n\t\t\t...(overrides.speckit?.paths ?? {}),\n\t\t};\n\n\t\tconst mergedViews = {\n\t\t\tspecs: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.specs?.visible ?? defaults.views.specs.visible,\n\t\t\t},\n\t\t\tsteering: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.steering?.visible ?? defaults.views.steering.visible,\n\t\t\t},\n\t\t\tprompts: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.prompts?.visible ?? defaults.views.prompts.visible,\n\t\t\t},\n\t\t\tquickAccess: {\n\t\t\t\tvisible:\n\t\t\t\t\toverrides.views?.quickAccess?.visible ??\n\t\t\t\t\tdefaults.views.quickAccess.visible,\n\t\t\t},\n\t\t};\n\n\t\tconst mergedCustomInstructions = {\n\t\t\tglobal:\n\t\t\t\toverrides.customInstructions?.global ??\n\t\t\t\tdefaults.customInstructions.global,\n\t\t\tcreateSpec:\n\t\t\t\toverrides.customInstructions?.createSpec ??\n\t\t\t\tdefaults.customInstructions.createSpec,\n\t\t\tstartAllTask:\n\t\t\t\toverrides.customInstructions?.startAllTask ??\n\t\t\t\tdefaults.customInstructions.startAllTask,\n\t\t\trunPrompt:\n\t\t\t\toverrides.customInstructions?.runPrompt ??\n\t\t\t\tdefaults.customInstructions.runPrompt,\n\t\t};\n\n\t\treturn {\n\t\t\tpaths: mergedPaths,\n\t\t\tspeckit: {\n\t\t\t\tpaths: mergedSpecKitPaths,\n\t\t\t},\n\t\t\tviews: mergedViews,\n\t\t\tchatLanguage: overrides.chatLanguage ?? defaults.chatLanguage,\n\t\t\tcustomInstructions: mergedCustomInstructions,\n\t\t\tspecSystem: overrides.specSystem ?? defaults.specSystem,\n\t\t};\n\t}",
    "start_line": 151,
    "end_line": 210,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "defaults",
      "overrides"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method mergeSettings",
    "component_id": "src.utils.config-manager.mergeSettings"
  },
  "src.utils.config-manager.getDefaultSettings": {
    "id": "src.utils.config-manager.getDefaultSettings",
    "name": "getDefaultSettings",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "private getDefaultSettings(): OpenSpecSettings {\n\t\tconst configuredPaths = this.getConfiguredPaths();\n\t\tconst specKitPaths = this.getSpecKitPaths();\n\t\tconst chatLanguage = this.getChatLanguage();\n\t\tconst customInstructions = this.getCustomInstructions();\n\t\tconst specSystem = this.getSpecSystem();\n\n\t\treturn {\n\t\t\tpaths: { ...DEFAULT_PATHS, ...configuredPaths },\n\t\t\tspeckit: {\n\t\t\t\tpaths: specKitPaths,\n\t\t\t},\n\t\t\tviews: {\n\t\t\t\tspecs: { visible: DEFAULT_VIEW_VISIBILITY.specs },\n\t\t\t\tsteering: { visible: DEFAULT_VIEW_VISIBILITY.steering },\n\t\t\t\tprompts: { visible: DEFAULT_VIEW_VISIBILITY.prompts },\n\t\t\t\tquickAccess: { visible: DEFAULT_VIEW_VISIBILITY.quickAccess },\n\t\t\t},\n\t\t\tchatLanguage,\n\t\t\tcustomInstructions,\n\t\t\tspecSystem,\n\t\t};\n\t}",
    "start_line": 212,
    "end_line": 234,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getDefaultSettings",
    "component_id": "src.utils.config-manager.getDefaultSettings"
  },
  "src.utils.config-manager.saveSettings": {
    "id": "src.utils.config-manager.saveSettings",
    "name": "saveSettings",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/config-manager.ts",
    "relative_path": "src/utils/config-manager.ts",
    "depends_on": [],
    "source_code": "async saveSettings(settings: OpenSpecSettings): Promise<void> {\n\t\tthis.settings = this.mergeSettings(this.getDefaultSettings(), settings);\n\t}",
    "start_line": 236,
    "end_line": 238,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "settings"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method saveSettings",
    "component_id": "src.utils.config-manager.saveSettings"
  },
  "src.utils.copilot-chat-utils.selectEntireDocument": {
    "id": "src.utils.copilot-chat-utils.selectEntireDocument",
    "name": "selectEntireDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-chat-utils.ts",
    "relative_path": "src/utils/copilot-chat-utils.ts",
    "depends_on": [],
    "source_code": "selectEntireDocument = async (\n\tdocumentUri: Uri,\n\tshowOptions: TextDocumentShowOptions = { preview: false }\n) => {\n\tconst targetUriString = documentUri.toString();\n\tlet editor = window.activeTextEditor;\n\tconst matchesTarget = (candidate?: typeof editor) =>\n\t\tcandidate?.document.uri.toString() === targetUriString;\n\n\tif (!matchesTarget(editor)) {\n\t\teditor = window.visibleTextEditors.find((item) => matchesTarget(item));\n\t}\n\n\tif (!editor) {\n\t\tconst document = await workspace.openTextDocument(documentUri);\n\t\teditor = await window.showTextDocument(document, showOptions);\n\t} else if (!matchesTarget(window.activeTextEditor)) {\n\t\tawait window.showTextDocument(editor.document, showOptions);\n\t}\n\n\tconst document = editor.document;\n\tconst lastLineIndex = Math.max(document.lineCount - 1, 0);\n\tconst endPosition = document.lineAt(lastLineIndex).range.end;\n\tconst fullRange = new Range(new Position(0, 0), endPosition);\n\n\teditor.selection = new Selection(fullRange.start, fullRange.end);\n\teditor.revealRange(fullRange, TextEditorRevealType.Default);\n}",
    "start_line": 15,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentUri",
      "showOptions"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function selectEntireDocument",
    "component_id": "src.utils.copilot-chat-utils.selectEntireDocument"
  },
  "src.utils.copilot-chat-utils.addDocumentToCopilotChat": {
    "id": "src.utils.copilot-chat-utils.addDocumentToCopilotChat",
    "name": "addDocumentToCopilotChat",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-chat-utils.ts",
    "relative_path": "src/utils/copilot-chat-utils.ts",
    "depends_on": [
      "src.utils.copilot-chat-utils.selectEntireDocument",
      "src.providers.welcome-screen-provider.executeCommand"
    ],
    "source_code": "addDocumentToCopilotChat = async (\n\tdocumentUri: Uri,\n\tshowOptions?: TextDocumentShowOptions\n): Promise<void> => {\n\tawait selectEntireDocument(documentUri, showOptions);\n\tawait commands.executeCommand(COPILOT_ADD_TO_CHAT_COMMAND_ID);\n}",
    "start_line": 44,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "documentUri",
      "showOptions"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addDocumentToCopilotChat",
    "component_id": "src.utils.copilot-chat-utils.addDocumentToCopilotChat"
  },
  "src.utils.copilot-mcp-utils.MCPConfig": {
    "id": "src.utils.copilot-mcp-utils.MCPConfig",
    "name": "MCPConfig",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.MCPServerConfig"
    ],
    "source_code": "interface MCPConfig {\n\tmcpServers: Record<string, MCPServerConfig>;\n}",
    "start_line": 27,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPConfig",
    "component_id": "src.utils.copilot-mcp-utils.MCPConfig"
  },
  "src.utils.copilot-mcp-utils.MCPServerConfig": {
    "id": "src.utils.copilot-mcp-utils.MCPServerConfig",
    "name": "MCPServerConfig",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "interface MCPServerConfig {\n\tcommand: string;\n\targs?: string[];\n\tenv?: Record<string, string>;\n}",
    "start_line": 31,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServerConfig",
    "component_id": "src.utils.copilot-mcp-utils.MCPServerConfig"
  },
  "src.utils.copilot-mcp-utils.loadMCPConfig": {
    "id": "src.utils.copilot-mcp-utils.loadMCPConfig",
    "name": "loadMCPConfig",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.MCPServerConfig",
      "src.utils.platform-utils.getMcpConfigPath"
    ],
    "source_code": "async function loadMCPConfig(): Promise<Map<string, MCPServerConfig>> {\n\ttry {\n\t\t// Get the MCP config path (automatically handles profiles)\n\t\tconst mcpConfigPath = await getMcpConfigPath();\n\n\t\tconsole.info(`[MCP] Looking for config at: ${mcpConfigPath}`);\n\n\t\tif (!existsSync(mcpConfigPath)) {\n\t\t\tconsole.warn(`[MCP] Config file not found at: ${mcpConfigPath}`);\n\t\t\treturn new Map();\n\t\t}\n\n\t\tconst content = readFileSync(mcpConfigPath, \"utf-8\");\n\t\tconst config = JSON.parse(content) as MCPConfig;\n\n\t\tif (!config.mcpServers || Object.keys(config.mcpServers).length === 0) {\n\t\t\tconsole.warn(\"[MCP] Config file exists but has no servers configured\");\n\t\t\treturn new Map();\n\t\t}\n\n\t\tconsole.info(`[MCP] Loaded config from: ${mcpConfigPath}`);\n\t\tconsole.info(\n\t\t\t`[MCP] Found ${Object.keys(config.mcpServers).length} configured servers: ${Object.keys(config.mcpServers).join(\", \")}`\n\t\t);\n\n\t\treturn new Map(Object.entries(config.mcpServers));\n\t} catch (error) {\n\t\tconsole.error(\"[MCP] Failed to load MCP config:\", error);\n\t\treturn new Map();\n\t}\n}",
    "start_line": 46,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function loadMCPConfig",
    "component_id": "src.utils.copilot-mcp-utils.loadMCPConfig"
  },
  "src.utils.copilot-mcp-utils.queryMCPServers": {
    "id": "src.utils.copilot-mcp-utils.queryMCPServers",
    "name": "queryMCPServers",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.formatServerName",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool",
      "src.utils.copilot-mcp-utils.loadMCPConfig",
      "src.features.agents.resource-cache.get",
      "src.utils.copilot-mcp-utils.formatDisplayName",
      "src.utils.copilot-mcp-utils.correlateToolWithServer"
    ],
    "source_code": "async function queryMCPServers(): Promise<MCPServer[]> {\n\ttry {\n\t\t// Access registered language model tools\n\t\tif (!lm?.tools) {\n\t\t\tconsole.warn(\"[MCP] Language Model API not available\");\n\t\t\treturn [];\n\t\t}\n\n\t\tconst allTools = lm.tools;\n\n\t\tif (allTools.length === 0) {\n\t\t\tconsole.info(\"[MCP] No MCP tools registered in Language Model API\");\n\t\t\treturn [];\n\t\t}\n\n\t\tconsole.info(\n\t\t\t`[MCP] Discovered ${allTools.length} registered tools from Language Model API`\n\t\t);\n\n\t\t// Log first few tool names for debugging\n\t\tif (allTools.length > 0) {\n\t\t\tconst sampleTools = allTools.slice(0, 5).map((t) => t.name);\n\t\t\tconsole.info(`[MCP] Sample tool names: ${sampleTools.join(\", \")}`);\n\t\t}\n\n\t\t// Load MCP configuration to know which servers are configured\n\t\tconst mcpConfig = await loadMCPConfig();\n\t\tconst configuredServerIds = Array.from(mcpConfig.keys());\n\n\t\tconsole.info(`[MCP] Configured servers: ${configuredServerIds.join(\", \")}`);\n\n\t\t// Group tools by server using correlation heuristics\n\t\tconst serverMap = new Map<string, MCPTool[]>();\n\n\t\tfor (const toolInfo of allTools) {\n\t\t\t// Correlate tool with configured server\n\t\t\tconst serverId = correlateToolWithServer(\n\t\t\t\ttoolInfo.name,\n\t\t\t\tconfiguredServerIds\n\t\t\t);\n\n\t\t\t// Convert LanguageModelToolInformation to MCPTool\n\t\t\tconst mcpTool: MCPTool = {\n\t\t\t\tname: toolInfo.name,\n\t\t\t\tdisplayName: formatDisplayName(toolInfo.name, serverId),\n\t\t\t\tdescription: toolInfo.description || \"No description available\",\n\t\t\t\tinputSchema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: (toolInfo.inputSchema as any)?.properties || {},\n\t\t\t\t\trequired: (toolInfo.inputSchema as any)?.required || [],\n\t\t\t\t},\n\t\t\t\tserverId,\n\t\t\t};\n\n\t\t\tif (!serverMap.has(serverId)) {\n\t\t\t\tserverMap.set(serverId, []);\n\t\t\t}\n\t\t\tserverMap.get(serverId)!.push(mcpTool);\n\t\t}\n\n\t\t// Convert map to MCPServer array\n\t\tconst servers: MCPServer[] = Array.from(serverMap.entries()).map(\n\t\t\t([serverId, tools]) => ({\n\t\t\t\tid: serverId,\n\t\t\t\tname: formatServerName(serverId),\n\t\t\t\tdescription: `MCP server with ${tools.length} available tools`,\n\t\t\t\tstatus: \"available\" as const,\n\t\t\t\ttools,\n\t\t\t\tlastDiscovered: Date.now(),\n\t\t\t})\n\t\t);\n\n\t\tconsole.info(\n\t\t\t`[MCP] Discovered ${servers.length} MCP servers: ${servers.map((s) => s.id).join(\", \")}`\n\t\t);\n\n\t\treturn servers;\n\t} catch (error) {\n\t\tconst message =\n\t\t\terror instanceof Error ? error.message : \"Unknown error occurred\";\n\t\tconsole.error(`[MCP] Failed to query MCP servers: ${message}`);\n\t\tthrow new Error(`Failed to query MCP servers: ${message}`);\n\t}\n}",
    "start_line": 87,
    "end_line": 170,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function queryMCPServers",
    "component_id": "src.utils.copilot-mcp-utils.queryMCPServers"
  },
  "src.utils.copilot-mcp-utils.queryMCPTools": {
    "id": "src.utils.copilot-mcp-utils.queryMCPTools",
    "name": "queryMCPTools",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.loadMCPConfig",
      "src.utils.copilot-mcp-utils.correlateToolWithServer",
      "src.utils.copilot-mcp-utils.formatDisplayName",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool"
    ],
    "source_code": "async function queryMCPTools(serverId: string): Promise<MCPTool[]> {\n\ttry {\n\t\tif (!lm?.tools) {\n\t\t\tconsole.warn(\"[MCP] Language Model API not available\");\n\t\t\treturn [];\n\t\t}\n\n\t\tconst allTools = lm.tools;\n\n\t\t// Load MCP configuration to get all configured servers\n\t\tconst mcpConfig = await loadMCPConfig();\n\t\tconst configuredServerIds = Array.from(mcpConfig.keys());\n\n\t\t// Filter tools that belong to this server\n\t\tconst serverTools: MCPTool[] = [];\n\n\t\tfor (const toolInfo of allTools) {\n\t\t\tconst toolServerId = correlateToolWithServer(\n\t\t\t\ttoolInfo.name,\n\t\t\t\tconfiguredServerIds\n\t\t\t);\n\n\t\t\tif (toolServerId === serverId) {\n\t\t\t\tconst mcpTool: MCPTool = {\n\t\t\t\t\tname: toolInfo.name,\n\t\t\t\t\tdisplayName: formatDisplayName(toolInfo.name, serverId),\n\t\t\t\t\tdescription: toolInfo.description || \"No description available\",\n\t\t\t\t\tinputSchema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: (toolInfo.inputSchema as any)?.properties || {},\n\t\t\t\t\t\trequired: (toolInfo.inputSchema as any)?.required || [],\n\t\t\t\t\t},\n\t\t\t\t\tserverId,\n\t\t\t\t};\n\t\t\t\tserverTools.push(mcpTool);\n\t\t\t}\n\t\t}\n\n\t\tconsole.info(\n\t\t\t`[MCP] Found ${serverTools.length} tools for server '${serverId}'`\n\t\t);\n\n\t\treturn serverTools;\n\t} catch (error) {\n\t\tconst message =\n\t\t\terror instanceof Error ? error.message : \"Unknown error occurred\";\n\t\tconsole.error(\n\t\t\t`[MCP] Failed to query tools for server '${serverId}': ${message}`\n\t\t);\n\t\tthrow new Error(\n\t\t\t`Failed to query MCP tools for server '${serverId}': ${message}`\n\t\t);\n\t}\n}",
    "start_line": 181,
    "end_line": 234,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function queryMCPTools",
    "component_id": "src.utils.copilot-mcp-utils.queryMCPTools"
  },
  "src.utils.copilot-mcp-utils.executeMCPTool": {
    "id": "src.utils.copilot-mcp-utils.executeMCPTool",
    "name": "executeMCPTool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "async function executeMCPTool(\n\tserverId: string,\n\ttoolName: string,\n\tparameters: Record<string, unknown>\n): Promise<unknown> {\n\ttry {\n\t\tif (!lm?.invokeTool) {\n\t\t\tthrow new Error(\"Language Model API not available\");\n\t\t}\n\n\t\tconsole.info(\n\t\t\t`[MCP] Executing tool '${toolName}' on server '${serverId}' with parameters:`,\n\t\t\tparameters\n\t\t);\n\n\t\t// Invoke the tool using VS Code's Language Model API\n\t\tconst result = await lm.invokeTool(\n\t\t\ttoolName,\n\t\t\t{ input: parameters },\n\t\t\tnew CancellationTokenSource().token\n\t\t);\n\n\t\tconsole.info(\n\t\t\t`[MCP] Tool '${toolName}' executed successfully. Result:`,\n\t\t\tresult\n\t\t);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconst message =\n\t\t\terror instanceof Error ? error.message : \"Unknown error occurred\";\n\t\tconsole.error(\n\t\t\t`[MCP] Failed to execute tool '${toolName}' on server '${serverId}': ${message}`\n\t\t);\n\t\tthrow new Error(\n\t\t\t`Failed to execute MCP tool '${toolName}' on server '${serverId}': ${message}`\n\t\t);\n\t}\n}",
    "start_line": 247,
    "end_line": 285,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId",
      "toolName",
      "parameters"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function executeMCPTool",
    "component_id": "src.utils.copilot-mcp-utils.executeMCPTool"
  },
  "src.utils.copilot-mcp-utils.isCopilotAvailable": {
    "id": "src.utils.copilot-mcp-utils.isCopilotAvailable",
    "name": "isCopilotAvailable",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function isCopilotAvailable(): boolean {\n\ttry {\n\t\t// Check if Language Model API is available\n\t\tif (!lm?.tools) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[MCP] Language Model API not available in this VS Code version\"\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there are any registered tools\n\t\tconst hasTools = lm.tools.length > 0;\n\n\t\tif (!hasTools) {\n\t\t\tconsole.info(\n\t\t\t\t\"[MCP] Language Model API available but no MCP tools registered yet\"\n\t\t\t);\n\t\t}\n\n\t\treturn true; // API is available even if no tools are registered yet\n\t} catch (error) {\n\t\tconsole.error(\n\t\t\t\"[MCP] Error checking Language Model API availability:\",\n\t\t\terror\n\t\t);\n\t\treturn false;\n\t}\n}",
    "start_line": 295,
    "end_line": 322,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isCopilotAvailable",
    "component_id": "src.utils.copilot-mcp-utils.isCopilotAvailable"
  },
  "src.utils.copilot-mcp-utils.getCopilotExtension": {
    "id": "src.utils.copilot-mcp-utils.getCopilotExtension",
    "name": "getCopilotExtension",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.extension.activate"
    ],
    "source_code": "async function getCopilotExtension(): Promise<\n\tExtension<unknown> | undefined\n> {\n\ttry {\n\t\tconst copilotExtension = extensions.getExtension(\"github.copilot\");\n\t\tif (!copilotExtension) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Activate if needed\n\t\tif (!copilotExtension.isActive) {\n\t\t\tawait copilotExtension.activate();\n\t\t}\n\n\t\treturn copilotExtension;\n\t} catch (error) {\n\t\treturn;\n\t}\n}",
    "start_line": 329,
    "end_line": 347,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getCopilotExtension",
    "component_id": "src.utils.copilot-mcp-utils.getCopilotExtension"
  },
  "src.utils.copilot-mcp-utils.correlateToolWithServer": {
    "id": "src.utils.copilot-mcp-utils.correlateToolWithServer",
    "name": "correlateToolWithServer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.isVSCodeBuiltInTool",
      "src.utils.copilot-mcp-utils.findMatchingServer",
      "src.utils.copilot-mcp-utils.extractFromMCPPattern"
    ],
    "source_code": "function correlateToolWithServer(\n\ttoolName: string,\n\tconfiguredServerIds: string[]\n): string {\n\tconst normalizedToolName = toolName.toLowerCase();\n\n\t// Check for VS Code built-in tools (not MCP)\n\tif (isVSCodeBuiltInTool(normalizedToolName)) {\n\t\treturn \"vscode-tools\";\n\t}\n\n\t// Try to match with configured servers\n\tconst matchedServer = findMatchingServer(\n\t\tnormalizedToolName,\n\t\tconfiguredServerIds\n\t);\n\tif (matchedServer) {\n\t\treturn matchedServer;\n\t}\n\n\t// Try to extract from mcp_ prefix pattern\n\tconst extractedServer = extractFromMCPPattern(\n\t\tnormalizedToolName,\n\t\tconfiguredServerIds\n\t);\n\tif (extractedServer) {\n\t\treturn extractedServer;\n\t}\n\n\t// Fallback: group under \"other-tools\"\n\treturn \"other-tools\";\n}",
    "start_line": 372,
    "end_line": 403,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "toolName",
      "configuredServerIds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function correlateToolWithServer",
    "component_id": "src.utils.copilot-mcp-utils.correlateToolWithServer"
  },
  "src.utils.copilot-mcp-utils.isVSCodeBuiltInTool": {
    "id": "src.utils.copilot-mcp-utils.isVSCodeBuiltInTool",
    "name": "isVSCodeBuiltInTool",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function isVSCodeBuiltInTool(normalizedToolName: string): boolean {\n\treturn (\n\t\tnormalizedToolName.startsWith(\"vscode_\") ||\n\t\tnormalizedToolName.startsWith(\"terminal_\") ||\n\t\tnormalizedToolName.includes(\"_confirmation\")\n\t);\n}",
    "start_line": 408,
    "end_line": 414,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "normalizedToolName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isVSCodeBuiltInTool",
    "component_id": "src.utils.copilot-mcp-utils.isVSCodeBuiltInTool"
  },
  "src.utils.copilot-mcp-utils.findMatchingServer": {
    "id": "src.utils.copilot-mcp-utils.findMatchingServer",
    "name": "findMatchingServer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.matchesServer"
    ],
    "source_code": "function findMatchingServer(\n\tnormalizedToolName: string,\n\tconfiguredServerIds: string[]\n): string | undefined {\n\tfor (const serverId of configuredServerIds) {\n\t\tif (matchesServer(normalizedToolName, serverId)) {\n\t\t\treturn serverId;\n\t\t}\n\t}\n\treturn;\n}",
    "start_line": 419,
    "end_line": 429,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "normalizedToolName",
      "configuredServerIds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findMatchingServer",
    "component_id": "src.utils.copilot-mcp-utils.findMatchingServer"
  },
  "src.utils.copilot-mcp-utils.matchesServer": {
    "id": "src.utils.copilot-mcp-utils.matchesServer",
    "name": "matchesServer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function matchesServer(normalizedToolName: string, serverId: string): boolean {\n\tconst normalizedServerId = serverId.toLowerCase();\n\n\t// Direct match\n\tif (normalizedToolName.includes(normalizedServerId)) {\n\t\treturn true;\n\t}\n\n\t// Path-based match (e.g., \"oraios/serena\")\n\tif (serverId.includes(\"/\")) {\n\t\tconst parts = serverId.split(\"/\");\n\t\treturn parts.some((part) =>\n\t\t\tnormalizedToolName.includes(part.toLowerCase())\n\t\t);\n\t}\n\n\t// Hyphenated match (e.g., \"firecrawl-mcp-server\")\n\tif (serverId.includes(\"-\")) {\n\t\tconst mainPart = serverId.split(\"-\")[0];\n\t\treturn normalizedToolName.includes(mainPart.toLowerCase());\n\t}\n\n\treturn false;\n}",
    "start_line": 434,
    "end_line": 457,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "normalizedToolName",
      "serverId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function matchesServer",
    "component_id": "src.utils.copilot-mcp-utils.matchesServer"
  },
  "src.utils.copilot-mcp-utils.extractFromMCPPattern": {
    "id": "src.utils.copilot-mcp-utils.extractFromMCPPattern",
    "name": "extractFromMCPPattern",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function extractFromMCPPattern(\n\tnormalizedToolName: string,\n\tconfiguredServerIds: string[]\n): string | undefined {\n\tif (!normalizedToolName.startsWith(\"mcp_\")) {\n\t\treturn;\n\t}\n\n\tconst withoutPrefix = normalizedToolName.substring(4);\n\tconst parts = withoutPrefix.split(\"_\");\n\n\t// Check if first part matches any configured server\n\tfor (const serverId of configuredServerIds) {\n\t\tif (parts[0] === serverId.toLowerCase()) {\n\t\t\treturn serverId;\n\t\t}\n\t}\n\n\treturn;\n}",
    "start_line": 462,
    "end_line": 481,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "normalizedToolName",
      "configuredServerIds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractFromMCPPattern",
    "component_id": "src.utils.copilot-mcp-utils.extractFromMCPPattern"
  },
  "src.utils.copilot-mcp-utils.formatServerName": {
    "id": "src.utils.copilot-mcp-utils.formatServerName",
    "name": "formatServerName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [
      "src.utils.copilot-mcp-utils.formatServerNameFromPath"
    ],
    "source_code": "function formatServerName(serverId: string): string {\n\t// Handle known server names with exact mappings\n\tconst knownServers: Record<string, string> = {\n\t\t// Special groups\n\t\t\"vscode-tools\": \"VS Code Tools\",\n\t\t\"other-tools\": \"Other Tools\",\n\t\t// Simple names\n\t\tsequentialthinking: \"Sequential Thinking\",\n\t\tmemory: \"Memory\",\n\t\talchemy: \"Alchemy\",\n\t\tflipside: \"Flipside\",\n\t\tetherscan: \"Etherscan\",\n\t\t// Path-based servers\n\t\t\"microsoft/playwright-mcp\": \"Microsoft Playwright\",\n\t\t\"firecrawl/firecrawl-mcp-server\": \"Firecrawl\",\n\t\t\"oraios/serena\": \"Oraios Serena\",\n\t\t// Reverse domain notation\n\t\t\"io.github.github/github-mcp-server\": \"GitHub MCP Server\",\n\t\t\"io.github.upstash/context7\": \"Upstash Context7\",\n\t\t// Other known servers\n\t\tgithub: \"GitHub\",\n\t\tgitlab: \"GitLab\",\n\t\tslack: \"Slack\",\n\t\tnotion: \"Notion\",\n\t\tjira: \"Jira\",\n\t\ttrello: \"Trello\",\n\t\tasana: \"Asana\",\n\t};\n\n\t// Check if we have a known mapping\n\tif (knownServers[serverId.toLowerCase()]) {\n\t\treturn knownServers[serverId.toLowerCase()];\n\t}\n\n\t// For unknown servers, try to format intelligently\n\t// Handle reverse domain notation (io.github.org/server-name  Server Name)\n\tif (serverId.includes(\"/\")) {\n\t\tconst parts = serverId.split(\"/\");\n\t\tconst lastPart = parts.at(-1);\n\t\tif (lastPart) {\n\t\t\treturn formatServerNameFromPath(lastPart);\n\t\t}\n\t}\n\n\t// Handle dot notation (io.github.org  Io Github Org)\n\tif (serverId.includes(\".\")) {\n\t\treturn serverId\n\t\t\t.split(\".\")\n\t\t\t.map((part) => part.charAt(0).toUpperCase() + part.slice(1))\n\t\t\t.join(\" \");\n\t}\n\n\t// Default: capitalize first letter\n\treturn serverId.charAt(0).toUpperCase() + serverId.slice(1);\n}",
    "start_line": 498,
    "end_line": 552,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatServerName",
    "component_id": "src.utils.copilot-mcp-utils.formatServerName"
  },
  "src.utils.copilot-mcp-utils.formatServerNameFromPath": {
    "id": "src.utils.copilot-mcp-utils.formatServerNameFromPath",
    "name": "formatServerNameFromPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function formatServerNameFromPath(pathPart: string): string {\n\treturn pathPart\n\t\t.split(SERVER_PATH_SEPARATOR_REGEX)\n\t\t.map((word) => {\n\t\t\t// Handle known acronyms\n\t\t\tif (word.toLowerCase() === \"mcp\") {\n\t\t\t\treturn \"MCP\";\n\t\t\t}\n\t\t\tif (word.toLowerCase() === \"github\") {\n\t\t\t\treturn \"GitHub\";\n\t\t\t}\n\t\t\tif (word.toLowerCase() === \"gitlab\") {\n\t\t\t\treturn \"GitLab\";\n\t\t\t}\n\t\t\treturn word.charAt(0).toUpperCase() + word.slice(1);\n\t\t})\n\t\t.join(\" \");\n}",
    "start_line": 565,
    "end_line": 582,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pathPart"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatServerNameFromPath",
    "component_id": "src.utils.copilot-mcp-utils.formatServerNameFromPath"
  },
  "src.utils.copilot-mcp-utils.formatDisplayName": {
    "id": "src.utils.copilot-mcp-utils.formatDisplayName",
    "name": "formatDisplayName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function formatDisplayName(toolName: string, serverId: string): string {\n\tlet actionPart = toolName.toLowerCase();\n\n\t// Remove common prefixes\n\tif (actionPart.startsWith(\"mcp_\")) {\n\t\tactionPart = actionPart.substring(4);\n\t}\n\n\t// Remove server ID from the tool name if present\n\tconst normalizedServerId = serverId.toLowerCase().replace(/[/-]/g, \"_\");\n\tif (actionPart.startsWith(`${normalizedServerId}_`)) {\n\t\tactionPart = actionPart.substring(normalizedServerId.length + 1);\n\t}\n\n\t// Handle path-based server IDs (e.g., \"oraios/serena\")\n\tif (serverId.includes(\"/\")) {\n\t\tfor (const part of serverId.split(\"/\")) {\n\t\t\tconst normalizedPart = part.toLowerCase();\n\t\t\tif (actionPart.startsWith(`${normalizedPart}_`)) {\n\t\t\t\tactionPart = actionPart.substring(normalizedPart.length + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to title case\n\treturn actionPart\n\t\t.split(TOOL_NAME_SEPARATOR_REGEX)\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n\t\t.join(\" \");\n}",
    "start_line": 600,
    "end_line": 629,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "toolName",
      "serverId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatDisplayName",
    "component_id": "src.utils.copilot-mcp-utils.formatDisplayName"
  },
  "src.utils.copilot-mcp-utils.getVSCodeVersionInfo": {
    "id": "src.utils.copilot-mcp-utils.getVSCodeVersionInfo",
    "name": "getVSCodeVersionInfo",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/copilot-mcp-utils.ts",
    "relative_path": "src/utils/copilot-mcp-utils.ts",
    "depends_on": [],
    "source_code": "function getVSCodeVersionInfo(): {\n\tversion: string;\n\tisInsiders: boolean;\n\tproductName: string;\n} {\n\tconst isInsiders =\n\t\tenv.appName.includes(\"Insiders\") || env.appName.includes(\"insider\");\n\n\treturn {\n\t\tversion,\n\t\tisInsiders,\n\t\tproductName: env.appName,\n\t};\n}",
    "start_line": 638,
    "end_line": 651,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getVSCodeVersionInfo",
    "component_id": "src.utils.copilot-mcp-utils.getVSCodeVersionInfo"
  },
  "src.utils.document-title-utils.toFriendlyName": {
    "id": "src.utils.document-title-utils.toFriendlyName",
    "name": "toFriendlyName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/document-title-utils.ts",
    "relative_path": "src/utils/document-title-utils.ts",
    "depends_on": [],
    "source_code": "function toFriendlyName(filename: string): string {\n\t// Remove extension\n\tlet name = basename(filename).replace(EXTENSION_PATTERN, \"\");\n\n\t// Remove leading numbers and dashes (e.g., \"001-\")\n\tname = name.replace(LEADING_NUMBERS_PATTERN, \"\");\n\n\t// Replace hyphens and underscores with spaces\n\tname = name.replace(WHITESPACE_PATTERN, \" \");\n\n\t// Capitalize first letter of each word\n\tname = name\n\t\t.split(\" \")\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n\t\t.join(\" \");\n\n\treturn name;\n}",
    "start_line": 14,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toFriendlyName",
    "component_id": "src.utils.document-title-utils.toFriendlyName"
  },
  "src.utils.document-title-utils.getRelativePath": {
    "id": "src.utils.document-title-utils.getRelativePath",
    "name": "getRelativePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/document-title-utils.ts",
    "relative_path": "src/utils/document-title-utils.ts",
    "depends_on": [],
    "source_code": "function getRelativePath(\n\tabsolutePath: string,\n\tworkspacePath?: string\n): string {\n\tif (!workspacePath) {\n\t\treturn basename(absolutePath);\n\t}\n\n\tif (absolutePath.startsWith(workspacePath)) {\n\t\treturn absolutePath.slice(workspacePath.length + 1);\n\t}\n\n\treturn absolutePath;\n}",
    "start_line": 37,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "absolutePath",
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getRelativePath",
    "component_id": "src.utils.document-title-utils.getRelativePath"
  },
  "src.utils.get-webview-content.getWebviewContent": {
    "id": "src.utils.get-webview-content.getWebviewContent",
    "name": "getWebviewContent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/get-webview-content.ts",
    "relative_path": "src/utils/get-webview-content.ts",
    "depends_on": [
      "src.utils.get-webview-content.getNonce"
    ],
    "source_code": "getWebviewContent = (\n\twebview: Webview,\n\textensionUri: Uri,\n\tpage: string\n): string => {\n\tconst scriptUri = webview.asWebviewUri(\n\t\tUri.joinPath(extensionUri, \"dist\", \"webview\", \"app\", \"index.js\")\n\t);\n\tconst styleUri = webview.asWebviewUri(\n\t\tUri.joinPath(extensionUri, \"dist\", \"webview\", \"app\", \"assets\", \"index.css\")\n\t);\n\n\tconst nonce = getNonce();\n\n\treturn `<!DOCTYPE html>\n        <html lang=\"en\" style=\"height: 100%;\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; img-src ${webview.cspSource} data: https:; style-src ${webview.cspSource} 'unsafe-inline'; font-src ${webview.cspSource} data:; script-src 'nonce-${nonce}';\">\n            <link href=\"${styleUri}\" rel=\"stylesheet\" />\n            <title>GatomIA</title>\n        </head>\n        <body style=\"height: 100%; margin: 0;\">\n            <div id=\"root\" data-page=\"${page}\" style=\"height: 100%;\"></div>\n            <script type=\"module\" nonce=\"${nonce}\" src=\"${scriptUri}\"></script>\n        </body>\n        </html>`;\n}",
    "start_line": 3,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "webview",
      "extensionUri",
      "page"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getWebviewContent",
    "component_id": "src.utils.get-webview-content.getWebviewContent"
  },
  "src.utils.get-webview-content.getNonce": {
    "id": "src.utils.get-webview-content.getNonce",
    "name": "getNonce",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/get-webview-content.ts",
    "relative_path": "src/utils/get-webview-content.ts",
    "depends_on": [],
    "source_code": "function getNonce() {\n\tlet text = \"\";\n\tconst possible =\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\tconst NonceLength = 32;\n\tfor (let i = 0; i < NonceLength; i++) {\n\t\ttext += possible.charAt(Math.floor(Math.random() * possible.length));\n\t}\n\treturn text;\n}",
    "start_line": 33,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getNonce",
    "component_id": "src.utils.get-webview-content.getNonce"
  },
  "src.utils.notification-utils.NotificationUtils": {
    "id": "src.utils.notification-utils.NotificationUtils",
    "name": "NotificationUtils",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/notification-utils.ts",
    "relative_path": "src/utils/notification-utils.ts",
    "depends_on": [],
    "source_code": "class NotificationUtils {\n\t/**\n\t * Show a notification that automatically dismisses after a specified duration\n\t * @param message - The message to display\n\t * @param durationMs - Duration in milliseconds (default: 3000ms)\n\t */\n\tstatic async showAutoDismissNotification(\n\t\tmessage: string,\n\t\tdurationMs = 3000\n\t): Promise<void> {\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: message,\n\t\t\t\tcancellable: false,\n\t\t\t},\n\t\t\tasync () => {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, durationMs));\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Show an error notification\n\t * @param message - The error message to display\n\t */\n\tstatic showError(message: string): void {\n\t\twindow.showErrorMessage(message);\n\t}\n\n\t/**\n\t * Show a warning notification\n\t * @param message - The warning message to display\n\t */\n\tstatic showWarning(message: string): void {\n\t\twindow.showWarningMessage(message);\n\t}\n\n\t/**\n\t * Show an information notification (standard, doesn't auto-dismiss)\n\t * @param message - The information message to display\n\t */\n\tstatic showInfo(message: string): void {\n\t\twindow.showInformationMessage(message);\n\t}\n\n\t/**\n\t * Show a review-alert notification (shared by manual + automatic review flows)\n\t * @param message - The review alert message to display\n\t */\n\tstatic showReviewAlert(message: string): void {\n\t\twindow.showInformationMessage(message);\n\t}\n}",
    "start_line": 6,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class NotificationUtils",
    "component_id": "src.utils.notification-utils.NotificationUtils"
  },
  "src.utils.notification-utils.showAutoDismissNotification": {
    "id": "src.utils.notification-utils.showAutoDismissNotification",
    "name": "showAutoDismissNotification",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/notification-utils.ts",
    "relative_path": "src/utils/notification-utils.ts",
    "depends_on": [],
    "source_code": "static async showAutoDismissNotification(\n\t\tmessage: string,\n\t\tdurationMs = 3000\n\t): Promise<void> {\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: message,\n\t\t\t\tcancellable: false,\n\t\t\t},\n\t\t\tasync () => {\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, durationMs));\n\t\t\t}\n\t\t);\n\t}",
    "start_line": 12,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message",
      "durationMs"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method showAutoDismissNotification",
    "component_id": "src.utils.notification-utils.showAutoDismissNotification"
  },
  "src.utils.notification-utils.showError": {
    "id": "src.utils.notification-utils.showError",
    "name": "showError",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/notification-utils.ts",
    "relative_path": "src/utils/notification-utils.ts",
    "depends_on": [],
    "source_code": "static showError(message: string): void {\n\t\twindow.showErrorMessage(message);\n\t}",
    "start_line": 32,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method showError",
    "component_id": "src.utils.notification-utils.showError"
  },
  "src.utils.notification-utils.showWarning": {
    "id": "src.utils.notification-utils.showWarning",
    "name": "showWarning",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/notification-utils.ts",
    "relative_path": "src/utils/notification-utils.ts",
    "depends_on": [],
    "source_code": "static showWarning(message: string): void {\n\t\twindow.showWarningMessage(message);\n\t}",
    "start_line": 40,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method showWarning",
    "component_id": "src.utils.notification-utils.showWarning"
  },
  "src.utils.notification-utils.showInfo": {
    "id": "src.utils.notification-utils.showInfo",
    "name": "showInfo",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/notification-utils.ts",
    "relative_path": "src/utils/notification-utils.ts",
    "depends_on": [],
    "source_code": "static showInfo(message: string): void {\n\t\twindow.showInformationMessage(message);\n\t}",
    "start_line": 48,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method showInfo",
    "component_id": "src.utils.notification-utils.showInfo"
  },
  "src.utils.notification-utils.showReviewAlert": {
    "id": "src.utils.notification-utils.showReviewAlert",
    "name": "showReviewAlert",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/notification-utils.ts",
    "relative_path": "src/utils/notification-utils.ts",
    "depends_on": [],
    "source_code": "static showReviewAlert(message: string): void {\n\t\twindow.showInformationMessage(message);\n\t}",
    "start_line": 56,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method showReviewAlert",
    "component_id": "src.utils.notification-utils.showReviewAlert"
  },
  "src.utils.platform-utils.isWindowsOrWsl": {
    "id": "src.utils.platform-utils.isWindowsOrWsl",
    "name": "isWindowsOrWsl",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/platform-utils.ts",
    "relative_path": "src/utils/platform-utils.ts",
    "depends_on": [],
    "source_code": "function isWindowsOrWsl(): boolean {\n\treturn (\n\t\tprocess.platform === \"win32\" ||\n\t\t(process.platform === \"linux\" &&\n\t\t\t(WSL_REGEX.test(release()) || !!process.env.WSL_DISTRO_NAME))\n\t);\n}",
    "start_line": 11,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isWindowsOrWsl",
    "component_id": "src.utils.platform-utils.isWindowsOrWsl"
  },
  "src.utils.platform-utils.getIDEDirectoryName": {
    "id": "src.utils.platform-utils.getIDEDirectoryName",
    "name": "getIDEDirectoryName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/platform-utils.ts",
    "relative_path": "src/utils/platform-utils.ts",
    "depends_on": [],
    "source_code": "function getIDEDirectoryName(): string {\n\tconst appName = vscode.env.appName;\n\n\t// Map common IDE names to their directory names\n\t// VS Code Insiders\n\tif (appName.toLowerCase().includes(\"insiders\")) {\n\t\treturn \"Code - Insiders\";\n\t}\n\n\t// Cursor IDE\n\tif (appName.toLowerCase().includes(\"cursor\")) {\n\t\treturn \"Cursor\";\n\t}\n\n\t// Windsurf IDE\n\tif (appName.toLowerCase().includes(\"windsurf\")) {\n\t\treturn \"windsurf\";\n\t}\n\n\t// Positron IDE\n\tif (appName.toLowerCase().includes(\"positron\")) {\n\t\treturn \"Positron\";\n\t}\n\n\t// VSCodium\n\tif (appName.toLowerCase().includes(\"vscodium\")) {\n\t\treturn \"VSCodium\";\n\t}\n\n\t// Default to \"Code\" for standard VS Code and unknown forks\n\treturn \"Code\";\n}",
    "start_line": 23,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getIDEDirectoryName",
    "component_id": "src.utils.platform-utils.getIDEDirectoryName"
  },
  "src.utils.platform-utils.getVSCodeUserDataPath": {
    "id": "src.utils.platform-utils.getVSCodeUserDataPath",
    "name": "getVSCodeUserDataPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/platform-utils.ts",
    "relative_path": "src/utils/platform-utils.ts",
    "depends_on": [
      "src.utils.platform-utils.getIDEDirectoryName"
    ],
    "source_code": "async function getVSCodeUserDataPath(): Promise<string> {\n\tconst ideDir = getIDEDirectoryName();\n\n\tconst isWsl =\n\t\tprocess.platform === \"linux\" &&\n\t\t(WSL_REGEX.test(release()) || !!process.env.WSL_DISTRO_NAME);\n\n\tif (process.platform === \"win32\") {\n\t\treturn join(process.env.APPDATA || \"\", ideDir, \"User\");\n\t}\n\n\tif (isWsl) {\n\t\ttry {\n\t\t\tconst execAsync = promisify(exec);\n\t\t\tconst { stdout: winAppData } = await execAsync(\n\t\t\t\t'cmd.exe /C \"echo %APPDATA%\"'\n\t\t\t);\n\t\t\tconst trimmedWinAppData = winAppData.trim();\n\t\t\tconst { stdout: wslPath } = await execAsync(\n\t\t\t\t`wslpath -u \"${trimmedWinAppData}\"`\n\t\t\t);\n\t\t\tconst appDataPath = wslPath.trim();\n\t\t\treturn join(appDataPath, ideDir, \"User\");\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to resolve Windows path in WSL: ${error}`);\n\t\t\t// Fallback to Linux path if resolution fails\n\t\t}\n\t}\n\n\tif (process.platform === \"darwin\") {\n\t\treturn join(homedir(), \"Library\", \"Application Support\", ideDir, \"User\");\n\t}\n\n\treturn join(homedir(), \".config\", ideDir, \"User\");\n}",
    "start_line": 56,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getVSCodeUserDataPath",
    "component_id": "src.utils.platform-utils.getVSCodeUserDataPath"
  },
  "src.utils.platform-utils.getMcpConfigPath": {
    "id": "src.utils.platform-utils.getMcpConfigPath",
    "name": "getMcpConfigPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/platform-utils.ts",
    "relative_path": "src/utils/platform-utils.ts",
    "depends_on": [
      "src.utils.platform-utils.getVSCodeUserDataPath"
    ],
    "source_code": "async function getMcpConfigPath(): Promise<string> {\n\tconst userDataPath = await getVSCodeUserDataPath();\n\tconst profilesDir = join(userDataPath, \"profiles\");\n\n\ttry {\n\t\t// Check if profiles directory exists\n\t\tconst profilesStat = await stat(profilesDir);\n\t\tif (profilesStat.isDirectory()) {\n\t\t\t// List all profiles\n\t\t\tconst profiles = await readdir(profilesDir);\n\n\t\t\t// Find mcp.json in each profile and get modification time\n\t\t\tconst mcpConfigFiles: Array<{ path: string; mtime: Date }> = [];\n\n\t\t\tfor (const profile of profiles) {\n\t\t\t\tconst mcpPath = join(profilesDir, profile, \"mcp.json\");\n\t\t\t\ttry {\n\t\t\t\t\tconst mcpStat = await stat(mcpPath);\n\t\t\t\t\tif (mcpStat.isFile()) {\n\t\t\t\t\t\tmcpConfigFiles.push({ path: mcpPath, mtime: mcpStat.mtime });\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Profile doesn't have mcp.json, skip\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If profiles with mcp.json were found, return the most recent\n\t\t\tif (mcpConfigFiles.length > 0) {\n\t\t\t\t// Sort by modification time (newest first)\n\t\t\t\tmcpConfigFiles.sort((a, b) => b.mtime.getTime() - a.mtime.getTime());\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[MCP] Found ${mcpConfigFiles.length} profile(s) with mcp.json, using most recent: ${mcpConfigFiles[0].path}`\n\t\t\t\t);\n\t\t\t\treturn mcpConfigFiles[0].path;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// Profiles directory doesn't exist or error reading it\n\t\tconsole.log(\"[MCP] No profiles directory found, checking User directory\");\n\t}\n\n\t// Fallback to User/mcp.json (check if it exists)\n\tconst defaultMcpPath = join(userDataPath, \"mcp.json\");\n\ttry {\n\t\tconst defaultStat = await stat(defaultMcpPath);\n\t\tif (defaultStat.isFile()) {\n\t\t\tconsole.log(\n\t\t\t\t`[MCP] Using mcp.json from User directory: ${defaultMcpPath}`\n\t\t\t);\n\t\t\treturn defaultMcpPath;\n\t\t}\n\t} catch {\n\t\t// File doesn't exist yet, but return the path anyway for future creation\n\t\tconsole.log(\n\t\t\t`[MCP] No mcp.json found, will use default location: ${defaultMcpPath}`\n\t\t);\n\t}\n\n\treturn defaultMcpPath;\n}",
    "start_line": 103,
    "end_line": 162,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getMcpConfigPath",
    "component_id": "src.utils.platform-utils.getMcpConfigPath"
  },
  "src.utils.spec-kit-adapter.SpecAdapterConfig": {
    "id": "src.utils.spec-kit-adapter.SpecAdapterConfig",
    "name": "SpecAdapterConfig",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [
      "src.constants.SpecSystemMode"
    ],
    "source_code": "interface SpecAdapterConfig {\n\tsystem: SpecSystemMode;\n\tworkspacePath: string;\n\tspecsPath: string;\n\tpromptsPath: string;\n}",
    "start_line": 25,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecAdapterConfig",
    "component_id": "src.utils.spec-kit-adapter.SpecAdapterConfig"
  },
  "src.utils.spec-kit-adapter.UnifiedSpec": {
    "id": "src.utils.spec-kit-adapter.UnifiedSpec",
    "name": "UnifiedSpec",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [
      "src.constants.SpecSystemMode"
    ],
    "source_code": "interface UnifiedSpec {\n\tid: string;\n\tname: string;\n\tpath: string;\n\tsystem: SpecSystemMode;\n\tfiles: Record<string, string>;\n\tisNumbered?: boolean;\n\tnumber?: number;\n}",
    "start_line": 35,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UnifiedSpec",
    "component_id": "src.utils.spec-kit-adapter.UnifiedSpec"
  },
  "src.utils.spec-kit-adapter.SpecSystemAdapter": {
    "id": "src.utils.spec-kit-adapter.SpecSystemAdapter",
    "name": "SpecSystemAdapter",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      "src.utils.spec-kit-adapter.listOpenSpecSpecs",
      "src.utils.config-manager.getSettings",
      "src.utils.spec-kit-adapter.getConfig",
      "src.utils.spec-kit-adapter.initialize",
      "src.utils.spec-kit-adapter.listSpecs",
      "src.utils.spec-kit-utilities.generateNextFeatureNumber",
      "src.utils.spec-kit-adapter.createSpecKitFeature",
      "src.utils.spec-kit-utilities.detectAvailableSpecSystems",
      "src.utils.spec-kit-utilities.getSpecKitFeatureFiles",
      "src.constants.SpecSystemMode",
      "src.utils.config-manager.saveSettings",
      "src.utils.spec-kit-adapter.SpecAdapterConfig",
      "src.utils.spec-kit-utilities.detectActiveSpecSystem",
      "src.utils.spec-kit-adapter.listSpecKitSpecs",
      "src.utils.spec-kit-adapter.getOpenSpecFiles",
      "src.utils.spec-kit-adapter.createOpenSpecSpec",
      "src.utils.spec-kit-utilities.createFeatureDirectoryName",
      "src.utils.spec-kit-utilities.discoverSpecKitFeatures",
      "src.utils.spec-kit-adapter.UnifiedSpec",
      "src.utils.spec-kit-adapter.getInstance",
      "src.utils.spec-kit-adapter.SpecSystemAdapter",
      "src.utils.config-manager.loadSettings",
      "src.utils.spec-kit-adapter.getSpecKitFeatureFiles"
    ],
    "source_code": "class SpecSystemAdapter {\n\tprivate config: SpecAdapterConfig | null = null;\n\tprivate static instance: SpecSystemAdapter;\n\n\tprivate constructor() {}\n\n\tstatic getInstance(): SpecSystemAdapter {\n\t\tif (!SpecSystemAdapter.instance) {\n\t\t\tSpecSystemAdapter.instance = new SpecSystemAdapter();\n\t\t}\n\t\treturn SpecSystemAdapter.instance;\n\t}\n\n\t/**\n\t * Initializes the adapter with workspace configuration\n\t */\n\tasync initialize(): Promise<void> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t}\n\n\t\tconst workspacePath = workspaceFolder.uri.fsPath;\n\t\tconst configManager = ConfigManager.getInstance();\n\t\tconst settings = await configManager.loadSettings();\n\n\t\tlet system: SpecSystemMode;\n\n\t\t// 1. Check user preference\n\t\tif (\n\t\t\tsettings.specSystem &&\n\t\t\tsettings.specSystem !== \"auto\" &&\n\t\t\tObject.values(SPEC_SYSTEM_MODE).includes(\n\t\t\t\tsettings.specSystem as SpecSystemMode\n\t\t\t)\n\t\t) {\n\t\t\tsystem = settings.specSystem as SpecSystemMode;\n\t\t} else {\n\t\t\t// 2. Auto-detect\n\t\t\tconst available = detectAvailableSpecSystems(workspacePath);\n\n\t\t\tif (available.length > 1) {\n\t\t\t\t// Multiple systems detected and no preference set\n\t\t\t\tconst choice = await window.showQuickPick(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlabel: \"SpecKit\",\n\t\t\t\t\t\t\tdescription: \"Use SpecKit system\",\n\t\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlabel: \"OpenSpec\",\n\t\t\t\t\t\t\tdescription: \"Use OpenSpec system\",\n\t\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t{\n\t\t\t\t\t\tplaceHolder:\n\t\t\t\t\t\t\t\"Multiple Spec Systems detected. Which one do you want to use?\",\n\t\t\t\t\t\tignoreFocusOut: true,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (choice) {\n\t\t\t\t\tsystem = choice.value;\n\t\t\t\t\t// Save preference\n\t\t\t\t\tawait configManager.saveSettings({\n\t\t\t\t\t\t...settings,\n\t\t\t\t\t\tspecSystem: system,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Default to SpecKit if user cancels, but don't save\n\t\t\t\t\tsystem = SPEC_SYSTEM_MODE.SPECKIT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsystem = detectActiveSpecSystem(workspacePath);\n\t\t\t}\n\t\t}\n\n\t\t// Determine paths based on active system\n\t\tlet specsPath: string;\n\t\tlet promptsPath: string;\n\n\t\tif (system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\tspecsPath = join(workspacePath, SPECKIT_CONFIG.paths.specs);\n\t\t\tpromptsPath = join(workspacePath, SPECKIT_CONFIG.paths.templates);\n\t\t} else {\n\t\t\tspecsPath = join(workspacePath, DEFAULT_CONFIG.paths.specs);\n\t\t\tpromptsPath = join(workspacePath, DEFAULT_CONFIG.paths.prompts);\n\t\t}\n\n\t\tthis.config = {\n\t\t\tsystem,\n\t\t\tworkspacePath,\n\t\t\tspecsPath,\n\t\t\tpromptsPath,\n\t\t};\n\t}\n\n\t/**\n\t * Allows user to manually select the spec system\n\t */\n\tasync selectSpecSystem(): Promise<void> {\n\t\tconst choice = await window.showQuickPick(\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Auto\",\n\t\t\t\t\tdescription: \"Automatically detect based on files\",\n\t\t\t\t\tvalue: \"auto\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"SpecKit\",\n\t\t\t\t\tdescription: \"Use SpecKit system\",\n\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"OpenSpec\",\n\t\t\t\t\tdescription: \"Use OpenSpec system\",\n\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t},\n\t\t\t],\n\t\t\t{\n\t\t\t\tplaceHolder: \"Select Spec System\",\n\t\t\t}\n\t\t);\n\n\t\tif (choice) {\n\t\t\tconst configManager = ConfigManager.getInstance();\n\t\t\tconst settings = configManager.getSettings();\n\t\t\tawait configManager.saveSettings({\n\t\t\t\t...settings,\n\t\t\t\tspecSystem: choice.value,\n\t\t\t});\n\n\t\t\t// Re-initialize to apply changes\n\t\t\tawait this.initialize();\n\t\t\twindow.showInformationMessage(`Spec System set to: ${choice.label}`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets the current configuration\n\t */\n\tgetConfig(): SpecAdapterConfig {\n\t\tif (!this.config) {\n\t\t\tthrow new Error(\"Adapter not initialized. Call initialize() first.\");\n\t\t}\n\t\treturn this.config;\n\t}\n\n\t/**\n\t * Gets the active spec system\n\t */\n\tgetActiveSystem(): SpecSystemMode {\n\t\treturn this.getConfig().system;\n\t}\n\n\t/**\n\t * Gets the workspace path\n\t */\n\tgetWorkspacePath(): string {\n\t\treturn this.getConfig().workspacePath;\n\t}\n\n\t/**\n\t * Gets the specs base path\n\t */\n\tgetSpecsBasePath(): string {\n\t\treturn this.getConfig().specsPath;\n\t}\n\n\t/**\n\t * Gets the prompts base path\n\t */\n\tgetPromptsBasePath(): string {\n\t\treturn this.getConfig().promptsPath;\n\t}\n\n\t/**\n\t * Lists all available specs in the workspace\n\t */\n\tlistSpecs(): Promise<UnifiedSpec[]> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn this.listSpecKitSpecs();\n\t\t}\n\t\treturn this.listOpenSpecSpecs();\n\t}\n\n\t/**\n\t * Lists SpecKit features (numbered directories)\n\t */\n\tprivate listSpecKitSpecs(): Promise<UnifiedSpec[]> {\n\t\tconst config = this.getConfig();\n\t\tconst features = discoverSpecKitFeatures(config.specsPath);\n\n\t\treturn Promise.resolve(\n\t\t\tfeatures.map((feature) => ({\n\t\t\t\tid: feature.slug,\n\t\t\t\tname: feature.name,\n\t\t\t\tpath: feature.path,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\tfiles: this.getSpecKitFeatureFiles(feature.path),\n\t\t\t\tisNumbered: true,\n\t\t\t\tnumber: feature.number,\n\t\t\t}))\n\t\t);\n\t}\n\n\t/**\n\t * Lists OpenSpec specs\n\t */\n\tprivate listOpenSpecSpecs(): Promise<UnifiedSpec[]> {\n\t\tconst config = this.getConfig();\n\t\tconst specsPath = join(config.specsPath, \"specs\");\n\n\t\tif (!existsSync(specsPath)) {\n\t\t\treturn Promise.resolve([]);\n\t\t}\n\n\t\tconst specs: UnifiedSpec[] = [];\n\n\t\ttry {\n\t\t\tconst entries = readdirSync(specsPath);\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = join(specsPath, entry);\n\t\t\t\tconst stat = statSync(fullPath);\n\n\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\tspecs.push({\n\t\t\t\t\t\tid: entry,\n\t\t\t\t\t\tname: entry,\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t\t\tfiles: this.getOpenSpecFiles(fullPath),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error listing OpenSpec specs: ${error}`);\n\t\t}\n\n\t\treturn Promise.resolve(specs);\n\t}\n\n\t/**\n\t * Gets file paths for a SpecKit feature\n\t */\n\tprivate getSpecKitFeatureFiles(featurePath: string): Record<string, string> {\n\t\tconst files: Record<string, string> = {};\n\n\t\tconst documentTypes = [\n\t\t\t\"spec\",\n\t\t\t\"plan\",\n\t\t\t\"tasks\",\n\t\t\t\"research\",\n\t\t\t\"data-model\",\n\t\t\t\"quickstart\",\n\t\t];\n\n\t\tfor (const docType of documentTypes) {\n\t\t\tconst filePath = join(featurePath, `${docType}.md`);\n\t\t\tif (existsSync(filePath)) {\n\t\t\t\tfiles[docType] = filePath;\n\t\t\t}\n\t\t}\n\n\t\t// Check for checklists folder\n\t\tconst checklistsPath = join(featurePath, \"checklists\");\n\t\tif (existsSync(checklistsPath) && statSync(checklistsPath).isDirectory()) {\n\t\t\tfiles.checklists = checklistsPath;\n\t\t}\n\n\t\treturn files;\n\t}\n\n\t/**\n\t * Gets file paths for an OpenSpec spec\n\t */\n\tprivate getOpenSpecFiles(specPath: string): Record<string, string> {\n\t\tconst files: Record<string, string> = {};\n\n\t\tconst documentTypes = [\"spec\", \"requirements\", \"design\", \"tasks\"];\n\n\t\tfor (const docType of documentTypes) {\n\t\t\tconst filePath = join(specPath, `${docType}.md`);\n\t\t\tif (existsSync(filePath)) {\n\t\t\t\tfiles[docType] = filePath;\n\t\t\t}\n\t\t}\n\n\t\treturn files;\n\t}\n\n\t/**\n\t * Creates a new spec in the appropriate system\n\t */\n\tcreateSpec(name: string): Promise<UnifiedSpec> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn this.createSpecKitFeature(name);\n\t\t}\n\t\treturn this.createOpenSpecSpec(name);\n\t}\n\n\t/**\n\t * Creates a new SpecKit feature\n\t */\n\tprivate createSpecKitFeature(name: string): Promise<UnifiedSpec> {\n\t\tconst config = this.getConfig();\n\n\t\ttry {\n\t\t\tmkdirSync(config.specsPath, { recursive: true });\n\n\t\t\tconst nextNumber = generateNextFeatureNumber(config.specsPath);\n\t\t\tconst dirName = createFeatureDirectoryName(nextNumber, name);\n\t\t\tconst featurePath = join(config.specsPath, dirName);\n\n\t\t\tmkdirSync(featurePath, { recursive: true });\n\n\t\t\treturn Promise.resolve({\n\t\t\t\tid: dirName,\n\t\t\t\tname,\n\t\t\t\tpath: featurePath,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\tfiles: {},\n\t\t\t\tisNumbered: true,\n\t\t\t\tnumber: nextNumber,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`Failed to create SpecKit feature: ${error}`)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new OpenSpec spec\n\t */\n\tprivate createOpenSpecSpec(name: string): Promise<UnifiedSpec> {\n\t\tconst config = this.getConfig();\n\t\tconst specsPath = join(config.specsPath, \"specs\");\n\n\t\ttry {\n\t\t\tmkdirSync(specsPath, { recursive: true });\n\n\t\t\tconst specPath = join(specsPath, name);\n\t\t\tmkdirSync(specPath, { recursive: true });\n\n\t\t\treturn Promise.resolve({\n\t\t\t\tid: name,\n\t\t\t\tname,\n\t\t\t\tpath: specPath,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\tfiles: {},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`Failed to create OpenSpec spec: ${error}`)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Opens a spec document in the editor\n\t */\n\tasync openSpecDocument(spec: UnifiedSpec, docType: string): Promise<void> {\n\t\tconst filePath = spec.files[docType];\n\n\t\tif (!filePath) {\n\t\t\tthrow new Error(\n\t\t\t\t`Document type \"${docType}\" not found for spec \"${spec.name}\"`\n\t\t\t);\n\t\t}\n\n\t\tconst textDocument = await workspace.openTextDocument(filePath);\n\t\tawait require(\"vscode\").window.showTextDocument(textDocument);\n\t}\n\n\t/**\n\t * Gets a spec by ID\n\t */\n\tasync getSpec(specId: string): Promise<UnifiedSpec | undefined> {\n\t\tconst specs = await this.listSpecs();\n\t\treturn specs.find((s) => s.id === specId);\n\t}\n\n\t/**\n\t * Gets file paths for a specific spec by name\n\t */\n\tgetSpecFiles(specName: string): Record<string, string> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t// Find the feature directory that matches the spec name\n\t\t\tconst features = discoverSpecKitFeatures(config.specsPath);\n\t\t\tconst feature = features.find(\n\t\t\t\t(f) => f.slug === specName || f.name === specName\n\t\t\t);\n\n\t\t\tif (!feature) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\treturn this.getSpecKitFeatureFiles(feature.path);\n\t\t}\n\n\t\t// OpenSpec format\n\t\tconst specsPath = join(config.specsPath, \"specs\", specName);\n\t\tif (!existsSync(specsPath)) {\n\t\t\treturn {};\n\t\t}\n\n\t\treturn this.getOpenSpecFiles(specsPath);\n\t}\n\n\t/**\n\t * Gets the system-appropriate prompt path\n\t */\n\tgetPromptPath(promptName: string): string {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn join(config.promptsPath, `${promptName}.md`);\n\t\t}\n\t\treturn join(config.promptsPath, `${promptName}.prompt.md`);\n\t}\n\n\t/**\n\t * Converts OpenSpec spec to SpecKit format (future migration support)\n\t */\n\tmigrateSpecToSpecKit(openSpecId: string): Promise<UnifiedSpec | null> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system !== SPEC_SYSTEM_MODE.OPENSPEC) {\n\t\t\tconsole.warn(\"Migration only works from OpenSpec to SpecKit\");\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\t// This is a placeholder for migration logic\n\t\t// In a full implementation, this would:\n\t\t// 1. Read files from OpenSpec directory\n\t\t// 2. Convert format/metadata if needed\n\t\t// 3. Create SpecKit feature directory\n\t\t// 4. Write converted files\n\t\t// 5. Return the new unified spec\n\n\t\treturn Promise.resolve(null);\n\t}\n\n\t/**\n\t * Resets the adapter (useful for testing or reinitialization)\n\t */\n\treset(): void {\n\t\tthis.config = null;\n\t}\n}",
    "start_line": 48,
    "end_line": 507,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecSystemAdapter",
    "component_id": "src.utils.spec-kit-adapter.SpecSystemAdapter"
  },
  "src.utils.spec-kit-adapter.getInstance": {
    "id": "src.utils.spec-kit-adapter.getInstance",
    "name": "getInstance",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "static getInstance(): SpecSystemAdapter {\n\t\tif (!SpecSystemAdapter.instance) {\n\t\t\tSpecSystemAdapter.instance = new SpecSystemAdapter();\n\t\t}\n\t\treturn SpecSystemAdapter.instance;\n\t}",
    "start_line": 54,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method getInstance",
    "component_id": "src.utils.spec-kit-adapter.getInstance"
  },
  "src.utils.spec-kit-adapter.initialize": {
    "id": "src.utils.spec-kit-adapter.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "async initialize(): Promise<void> {\n\t\tconst workspaceFolder = workspace.workspaceFolders?.[0];\n\t\tif (!workspaceFolder) {\n\t\t\tthrow new Error(\"No workspace folder found\");\n\t\t}\n\n\t\tconst workspacePath = workspaceFolder.uri.fsPath;\n\t\tconst configManager = ConfigManager.getInstance();\n\t\tconst settings = await configManager.loadSettings();\n\n\t\tlet system: SpecSystemMode;\n\n\t\t// 1. Check user preference\n\t\tif (\n\t\t\tsettings.specSystem &&\n\t\t\tsettings.specSystem !== \"auto\" &&\n\t\t\tObject.values(SPEC_SYSTEM_MODE).includes(\n\t\t\t\tsettings.specSystem as SpecSystemMode\n\t\t\t)\n\t\t) {\n\t\t\tsystem = settings.specSystem as SpecSystemMode;\n\t\t} else {\n\t\t\t// 2. Auto-detect\n\t\t\tconst available = detectAvailableSpecSystems(workspacePath);\n\n\t\t\tif (available.length > 1) {\n\t\t\t\t// Multiple systems detected and no preference set\n\t\t\t\tconst choice = await window.showQuickPick(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlabel: \"SpecKit\",\n\t\t\t\t\t\t\tdescription: \"Use SpecKit system\",\n\t\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlabel: \"OpenSpec\",\n\t\t\t\t\t\t\tdescription: \"Use OpenSpec system\",\n\t\t\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t{\n\t\t\t\t\t\tplaceHolder:\n\t\t\t\t\t\t\t\"Multiple Spec Systems detected. Which one do you want to use?\",\n\t\t\t\t\t\tignoreFocusOut: true,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tif (choice) {\n\t\t\t\t\tsystem = choice.value;\n\t\t\t\t\t// Save preference\n\t\t\t\t\tawait configManager.saveSettings({\n\t\t\t\t\t\t...settings,\n\t\t\t\t\t\tspecSystem: system,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Default to SpecKit if user cancels, but don't save\n\t\t\t\t\tsystem = SPEC_SYSTEM_MODE.SPECKIT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsystem = detectActiveSpecSystem(workspacePath);\n\t\t\t}\n\t\t}\n\n\t\t// Determine paths based on active system\n\t\tlet specsPath: string;\n\t\tlet promptsPath: string;\n\n\t\tif (system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\tspecsPath = join(workspacePath, SPECKIT_CONFIG.paths.specs);\n\t\t\tpromptsPath = join(workspacePath, SPECKIT_CONFIG.paths.templates);\n\t\t} else {\n\t\t\tspecsPath = join(workspacePath, DEFAULT_CONFIG.paths.specs);\n\t\t\tpromptsPath = join(workspacePath, DEFAULT_CONFIG.paths.prompts);\n\t\t}\n\n\t\tthis.config = {\n\t\t\tsystem,\n\t\t\tworkspacePath,\n\t\t\tspecsPath,\n\t\t\tpromptsPath,\n\t\t};\n\t}",
    "start_line": 64,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method initialize",
    "component_id": "src.utils.spec-kit-adapter.initialize"
  },
  "src.utils.spec-kit-adapter.selectSpecSystem": {
    "id": "src.utils.spec-kit-adapter.selectSpecSystem",
    "name": "selectSpecSystem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "async selectSpecSystem(): Promise<void> {\n\t\tconst choice = await window.showQuickPick(\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Auto\",\n\t\t\t\t\tdescription: \"Automatically detect based on files\",\n\t\t\t\t\tvalue: \"auto\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"SpecKit\",\n\t\t\t\t\tdescription: \"Use SpecKit system\",\n\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"OpenSpec\",\n\t\t\t\t\tdescription: \"Use OpenSpec system\",\n\t\t\t\t\tvalue: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t},\n\t\t\t],\n\t\t\t{\n\t\t\t\tplaceHolder: \"Select Spec System\",\n\t\t\t}\n\t\t);\n\n\t\tif (choice) {\n\t\t\tconst configManager = ConfigManager.getInstance();\n\t\t\tconst settings = configManager.getSettings();\n\t\t\tawait configManager.saveSettings({\n\t\t\t\t...settings,\n\t\t\t\tspecSystem: choice.value,\n\t\t\t});\n\n\t\t\t// Re-initialize to apply changes\n\t\t\tawait this.initialize();\n\t\t\twindow.showInformationMessage(`Spec System set to: ${choice.label}`);\n\t\t}\n\t}",
    "start_line": 150,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method selectSpecSystem",
    "component_id": "src.utils.spec-kit-adapter.selectSpecSystem"
  },
  "src.utils.spec-kit-adapter.getConfig": {
    "id": "src.utils.spec-kit-adapter.getConfig",
    "name": "getConfig",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getConfig(): SpecAdapterConfig {\n\t\tif (!this.config) {\n\t\t\tthrow new Error(\"Adapter not initialized. Call initialize() first.\");\n\t\t}\n\t\treturn this.config;\n\t}",
    "start_line": 191,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getConfig",
    "component_id": "src.utils.spec-kit-adapter.getConfig"
  },
  "src.utils.spec-kit-adapter.getActiveSystem": {
    "id": "src.utils.spec-kit-adapter.getActiveSystem",
    "name": "getActiveSystem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getActiveSystem(): SpecSystemMode {\n\t\treturn this.getConfig().system;\n\t}",
    "start_line": 201,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getActiveSystem",
    "component_id": "src.utils.spec-kit-adapter.getActiveSystem"
  },
  "src.utils.spec-kit-adapter.getWorkspacePath": {
    "id": "src.utils.spec-kit-adapter.getWorkspacePath",
    "name": "getWorkspacePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getWorkspacePath(): string {\n\t\treturn this.getConfig().workspacePath;\n\t}",
    "start_line": 208,
    "end_line": 210,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getWorkspacePath",
    "component_id": "src.utils.spec-kit-adapter.getWorkspacePath"
  },
  "src.utils.spec-kit-adapter.getSpecsBasePath": {
    "id": "src.utils.spec-kit-adapter.getSpecsBasePath",
    "name": "getSpecsBasePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getSpecsBasePath(): string {\n\t\treturn this.getConfig().specsPath;\n\t}",
    "start_line": 215,
    "end_line": 217,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecsBasePath",
    "component_id": "src.utils.spec-kit-adapter.getSpecsBasePath"
  },
  "src.utils.spec-kit-adapter.getPromptsBasePath": {
    "id": "src.utils.spec-kit-adapter.getPromptsBasePath",
    "name": "getPromptsBasePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getPromptsBasePath(): string {\n\t\treturn this.getConfig().promptsPath;\n\t}",
    "start_line": 222,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getPromptsBasePath",
    "component_id": "src.utils.spec-kit-adapter.getPromptsBasePath"
  },
  "src.utils.spec-kit-adapter.listSpecs": {
    "id": "src.utils.spec-kit-adapter.listSpecs",
    "name": "listSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "listSpecs(): Promise<UnifiedSpec[]> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn this.listSpecKitSpecs();\n\t\t}\n\t\treturn this.listOpenSpecSpecs();\n\t}",
    "start_line": 229,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method listSpecs",
    "component_id": "src.utils.spec-kit-adapter.listSpecs"
  },
  "src.utils.spec-kit-adapter.listSpecKitSpecs": {
    "id": "src.utils.spec-kit-adapter.listSpecKitSpecs",
    "name": "listSpecKitSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "private listSpecKitSpecs(): Promise<UnifiedSpec[]> {\n\t\tconst config = this.getConfig();\n\t\tconst features = discoverSpecKitFeatures(config.specsPath);\n\n\t\treturn Promise.resolve(\n\t\t\tfeatures.map((feature) => ({\n\t\t\t\tid: feature.slug,\n\t\t\t\tname: feature.name,\n\t\t\t\tpath: feature.path,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\tfiles: this.getSpecKitFeatureFiles(feature.path),\n\t\t\t\tisNumbered: true,\n\t\t\t\tnumber: feature.number,\n\t\t\t}))\n\t\t);\n\t}",
    "start_line": 241,
    "end_line": 256,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method listSpecKitSpecs",
    "component_id": "src.utils.spec-kit-adapter.listSpecKitSpecs"
  },
  "src.utils.spec-kit-adapter.listOpenSpecSpecs": {
    "id": "src.utils.spec-kit-adapter.listOpenSpecSpecs",
    "name": "listOpenSpecSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "private listOpenSpecSpecs(): Promise<UnifiedSpec[]> {\n\t\tconst config = this.getConfig();\n\t\tconst specsPath = join(config.specsPath, \"specs\");\n\n\t\tif (!existsSync(specsPath)) {\n\t\t\treturn Promise.resolve([]);\n\t\t}\n\n\t\tconst specs: UnifiedSpec[] = [];\n\n\t\ttry {\n\t\t\tconst entries = readdirSync(specsPath);\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = join(specsPath, entry);\n\t\t\t\tconst stat = statSync(fullPath);\n\n\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\tspecs.push({\n\t\t\t\t\t\tid: entry,\n\t\t\t\t\t\tname: entry,\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\t\t\tfiles: this.getOpenSpecFiles(fullPath),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error listing OpenSpec specs: ${error}`);\n\t\t}\n\n\t\treturn Promise.resolve(specs);\n\t}",
    "start_line": 261,
    "end_line": 293,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method listOpenSpecSpecs",
    "component_id": "src.utils.spec-kit-adapter.listOpenSpecSpecs"
  },
  "src.utils.spec-kit-adapter.getSpecKitFeatureFiles": {
    "id": "src.utils.spec-kit-adapter.getSpecKitFeatureFiles",
    "name": "getSpecKitFeatureFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "private getSpecKitFeatureFiles(featurePath: string): Record<string, string> {\n\t\tconst files: Record<string, string> = {};\n\n\t\tconst documentTypes = [\n\t\t\t\"spec\",\n\t\t\t\"plan\",\n\t\t\t\"tasks\",\n\t\t\t\"research\",\n\t\t\t\"data-model\",\n\t\t\t\"quickstart\",\n\t\t];\n\n\t\tfor (const docType of documentTypes) {\n\t\t\tconst filePath = join(featurePath, `${docType}.md`);\n\t\t\tif (existsSync(filePath)) {\n\t\t\t\tfiles[docType] = filePath;\n\t\t\t}\n\t\t}\n\n\t\t// Check for checklists folder\n\t\tconst checklistsPath = join(featurePath, \"checklists\");\n\t\tif (existsSync(checklistsPath) && statSync(checklistsPath).isDirectory()) {\n\t\t\tfiles.checklists = checklistsPath;\n\t\t}\n\n\t\treturn files;\n\t}",
    "start_line": 298,
    "end_line": 324,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "featurePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecKitFeatureFiles",
    "component_id": "src.utils.spec-kit-adapter.getSpecKitFeatureFiles"
  },
  "src.utils.spec-kit-adapter.getOpenSpecFiles": {
    "id": "src.utils.spec-kit-adapter.getOpenSpecFiles",
    "name": "getOpenSpecFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "private getOpenSpecFiles(specPath: string): Record<string, string> {\n\t\tconst files: Record<string, string> = {};\n\n\t\tconst documentTypes = [\"spec\", \"requirements\", \"design\", \"tasks\"];\n\n\t\tfor (const docType of documentTypes) {\n\t\t\tconst filePath = join(specPath, `${docType}.md`);\n\t\t\tif (existsSync(filePath)) {\n\t\t\t\tfiles[docType] = filePath;\n\t\t\t}\n\t\t}\n\n\t\treturn files;\n\t}",
    "start_line": 329,
    "end_line": 342,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specPath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getOpenSpecFiles",
    "component_id": "src.utils.spec-kit-adapter.getOpenSpecFiles"
  },
  "src.utils.spec-kit-adapter.createSpec": {
    "id": "src.utils.spec-kit-adapter.createSpec",
    "name": "createSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "createSpec(name: string): Promise<UnifiedSpec> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn this.createSpecKitFeature(name);\n\t\t}\n\t\treturn this.createOpenSpecSpec(name);\n\t}",
    "start_line": 347,
    "end_line": 354,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createSpec",
    "component_id": "src.utils.spec-kit-adapter.createSpec"
  },
  "src.utils.spec-kit-adapter.createSpecKitFeature": {
    "id": "src.utils.spec-kit-adapter.createSpecKitFeature",
    "name": "createSpecKitFeature",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "private createSpecKitFeature(name: string): Promise<UnifiedSpec> {\n\t\tconst config = this.getConfig();\n\n\t\ttry {\n\t\t\tmkdirSync(config.specsPath, { recursive: true });\n\n\t\t\tconst nextNumber = generateNextFeatureNumber(config.specsPath);\n\t\t\tconst dirName = createFeatureDirectoryName(nextNumber, name);\n\t\t\tconst featurePath = join(config.specsPath, dirName);\n\n\t\t\tmkdirSync(featurePath, { recursive: true });\n\n\t\t\treturn Promise.resolve({\n\t\t\t\tid: dirName,\n\t\t\t\tname,\n\t\t\t\tpath: featurePath,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.SPECKIT,\n\t\t\t\tfiles: {},\n\t\t\t\tisNumbered: true,\n\t\t\t\tnumber: nextNumber,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`Failed to create SpecKit feature: ${error}`)\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 359,
    "end_line": 385,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createSpecKitFeature",
    "component_id": "src.utils.spec-kit-adapter.createSpecKitFeature"
  },
  "src.utils.spec-kit-adapter.createOpenSpecSpec": {
    "id": "src.utils.spec-kit-adapter.createOpenSpecSpec",
    "name": "createOpenSpecSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "private createOpenSpecSpec(name: string): Promise<UnifiedSpec> {\n\t\tconst config = this.getConfig();\n\t\tconst specsPath = join(config.specsPath, \"specs\");\n\n\t\ttry {\n\t\t\tmkdirSync(specsPath, { recursive: true });\n\n\t\t\tconst specPath = join(specsPath, name);\n\t\t\tmkdirSync(specPath, { recursive: true });\n\n\t\t\treturn Promise.resolve({\n\t\t\t\tid: name,\n\t\t\t\tname,\n\t\t\t\tpath: specPath,\n\t\t\t\tsystem: SPEC_SYSTEM_MODE.OPENSPEC,\n\t\t\t\tfiles: {},\n\t\t\t});\n\t\t} catch (error) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`Failed to create OpenSpec spec: ${error}`)\n\t\t\t);\n\t\t}\n\t}",
    "start_line": 390,
    "end_line": 412,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createOpenSpecSpec",
    "component_id": "src.utils.spec-kit-adapter.createOpenSpecSpec"
  },
  "src.utils.spec-kit-adapter.openSpecDocument": {
    "id": "src.utils.spec-kit-adapter.openSpecDocument",
    "name": "openSpecDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "async openSpecDocument(spec: UnifiedSpec, docType: string): Promise<void> {\n\t\tconst filePath = spec.files[docType];\n\n\t\tif (!filePath) {\n\t\t\tthrow new Error(\n\t\t\t\t`Document type \"${docType}\" not found for spec \"${spec.name}\"`\n\t\t\t);\n\t\t}\n\n\t\tconst textDocument = await workspace.openTextDocument(filePath);\n\t\tawait require(\"vscode\").window.showTextDocument(textDocument);\n\t}",
    "start_line": 417,
    "end_line": 428,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spec",
      "docType"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method openSpecDocument",
    "component_id": "src.utils.spec-kit-adapter.openSpecDocument"
  },
  "src.utils.spec-kit-adapter.getSpec": {
    "id": "src.utils.spec-kit-adapter.getSpec",
    "name": "getSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "async getSpec(specId: string): Promise<UnifiedSpec | undefined> {\n\t\tconst specs = await this.listSpecs();\n\t\treturn specs.find((s) => s.id === specId);\n\t}",
    "start_line": 433,
    "end_line": 436,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getSpec",
    "component_id": "src.utils.spec-kit-adapter.getSpec"
  },
  "src.utils.spec-kit-adapter.getSpecFiles": {
    "id": "src.utils.spec-kit-adapter.getSpecFiles",
    "name": "getSpecFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getSpecFiles(specName: string): Record<string, string> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\t// Find the feature directory that matches the spec name\n\t\t\tconst features = discoverSpecKitFeatures(config.specsPath);\n\t\t\tconst feature = features.find(\n\t\t\t\t(f) => f.slug === specName || f.name === specName\n\t\t\t);\n\n\t\t\tif (!feature) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\treturn this.getSpecKitFeatureFiles(feature.path);\n\t\t}\n\n\t\t// OpenSpec format\n\t\tconst specsPath = join(config.specsPath, \"specs\", specName);\n\t\tif (!existsSync(specsPath)) {\n\t\t\treturn {};\n\t\t}\n\n\t\treturn this.getOpenSpecFiles(specsPath);\n\t}",
    "start_line": 441,
    "end_line": 465,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSpecFiles",
    "component_id": "src.utils.spec-kit-adapter.getSpecFiles"
  },
  "src.utils.spec-kit-adapter.getPromptPath": {
    "id": "src.utils.spec-kit-adapter.getPromptPath",
    "name": "getPromptPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "getPromptPath(promptName: string): string {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system === SPEC_SYSTEM_MODE.SPECKIT) {\n\t\t\treturn join(config.promptsPath, `${promptName}.md`);\n\t\t}\n\t\treturn join(config.promptsPath, `${promptName}.prompt.md`);\n\t}",
    "start_line": 470,
    "end_line": 477,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "promptName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getPromptPath",
    "component_id": "src.utils.spec-kit-adapter.getPromptPath"
  },
  "src.utils.spec-kit-adapter.migrateSpecToSpecKit": {
    "id": "src.utils.spec-kit-adapter.migrateSpecToSpecKit",
    "name": "migrateSpecToSpecKit",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "migrateSpecToSpecKit(openSpecId: string): Promise<UnifiedSpec | null> {\n\t\tconst config = this.getConfig();\n\n\t\tif (config.system !== SPEC_SYSTEM_MODE.OPENSPEC) {\n\t\t\tconsole.warn(\"Migration only works from OpenSpec to SpecKit\");\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\t// This is a placeholder for migration logic\n\t\t// In a full implementation, this would:\n\t\t// 1. Read files from OpenSpec directory\n\t\t// 2. Convert format/metadata if needed\n\t\t// 3. Create SpecKit feature directory\n\t\t// 4. Write converted files\n\t\t// 5. Return the new unified spec\n\n\t\treturn Promise.resolve(null);\n\t}",
    "start_line": 482,
    "end_line": 499,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "openSpecId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method migrateSpecToSpecKit",
    "component_id": "src.utils.spec-kit-adapter.migrateSpecToSpecKit"
  },
  "src.utils.spec-kit-adapter.reset": {
    "id": "src.utils.spec-kit-adapter.reset",
    "name": "reset",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [],
    "source_code": "reset(): void {\n\t\tthis.config = null;\n\t}",
    "start_line": 504,
    "end_line": 506,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method reset",
    "component_id": "src.utils.spec-kit-adapter.reset"
  },
  "src.utils.spec-kit-adapter.getSpecSystemAdapter": {
    "id": "src.utils.spec-kit-adapter.getSpecSystemAdapter",
    "name": "getSpecSystemAdapter",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [
      "src.utils.spec-kit-adapter.SpecSystemAdapter",
      "src.utils.spec-kit-adapter.getInstance"
    ],
    "source_code": "function getSpecSystemAdapter(): SpecSystemAdapter {\n\treturn SpecSystemAdapter.getInstance();\n}",
    "start_line": 512,
    "end_line": 514,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getSpecSystemAdapter",
    "component_id": "src.utils.spec-kit-adapter.getSpecSystemAdapter"
  },
  "src.utils.spec-kit-adapter.initializeSpecSystemAdapter": {
    "id": "src.utils.spec-kit-adapter.initializeSpecSystemAdapter",
    "name": "initializeSpecSystemAdapter",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-adapter.ts",
    "relative_path": "src/utils/spec-kit-adapter.ts",
    "depends_on": [
      "src.utils.spec-kit-adapter.initialize",
      "src.utils.spec-kit-adapter.SpecSystemAdapter",
      "src.utils.spec-kit-adapter.getSpecSystemAdapter"
    ],
    "source_code": "async function initializeSpecSystemAdapter(): Promise<SpecSystemAdapter> {\n\tconst adapter = getSpecSystemAdapter();\n\tawait adapter.initialize();\n\treturn adapter;\n}",
    "start_line": 519,
    "end_line": 523,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function initializeSpecSystemAdapter",
    "component_id": "src.utils.spec-kit-adapter.initializeSpecSystemAdapter"
  },
  "src.utils.spec-kit-migration.MigrationResult": {
    "id": "src.utils.spec-kit-migration.MigrationResult",
    "name": "MigrationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "interface MigrationResult {\n\tsuccess: boolean;\n\tmigratedSpecs: number;\n\tbackupPath: string | null;\n\terrors: string[];\n}",
    "start_line": 21,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MigrationResult",
    "component_id": "src.utils.spec-kit-migration.MigrationResult"
  },
  "src.utils.spec-kit-migration.SpecKitMigration": {
    "id": "src.utils.spec-kit-migration.SpecKitMigration",
    "name": "SpecKitMigration",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [
      "src.features.steering.constitution-manager.ensureConstitutionExists",
      "src.utils.spec-kit-migration.generateConstitution",
      "src.utils.spec-kit-migration.migrateSingleSpec",
      "src.utils.spec-kit-migration.MigrationResult",
      "src.utils.spec-kit-utilities.getSpecsPath",
      "src.utils.spec-kit-utilities.createFeatureDirectoryName",
      "src.utils.spec-kit-utilities.getMemoryPath",
      "src.utils.spec-kit-migration.copyDirectoryRecursive",
      "src.utils.spec-kit-migration.createBackup",
      "src.utils.spec-kit-utilities.generateNextFeatureNumber",
      "src.features.steering.constitution-manager.ConstitutionManager",
      "src.utils.spec-kit-utilities.getConstitutionPath"
    ],
    "source_code": "class SpecKitMigration {\n\tprivate readonly workspaceRoot: string;\n\n\tconstructor(workspaceRoot: string) {\n\t\tthis.workspaceRoot = workspaceRoot;\n\t}\n\n\t/**\n\t * Creates a backup of the OpenSpec structure before migration\n\t */\n\tcreateBackup(): string | null {\n\t\tconst openSpecPath = join(this.workspaceRoot, \"openspec\");\n\t\tif (!existsSync(openSpecPath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\t\tconst backupPath = join(\n\t\t\tthis.workspaceRoot,\n\t\t\t`.openspec-backup-${timestamp}`\n\t\t);\n\n\t\ttry {\n\t\t\tthis.copyDirectoryRecursive(openSpecPath, backupPath);\n\t\t\treturn backupPath;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Failed to create backup:\", error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Recursively copies a directory\n\t */\n\tprivate copyDirectoryRecursive(source: string, target: string): void {\n\t\tif (!existsSync(target)) {\n\t\t\tmkdirSync(target, { recursive: true });\n\t\t}\n\n\t\tconst entries = readdirSync(source);\n\n\t\tfor (const entry of entries) {\n\t\t\tconst sourcePath = join(source, entry);\n\t\t\tconst targetPath = join(target, entry);\n\t\t\tconst stat = statSync(sourcePath);\n\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tthis.copyDirectoryRecursive(sourcePath, targetPath);\n\t\t\t} else {\n\t\t\t\tcopyFileSync(sourcePath, targetPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generates a constitution.md from existing project files\n\t * Looks for AGENTS.md, README.md, and other guideline files\n\t */\n\tasync generateConstitution(): Promise<boolean> {\n\t\tconst constitutionManager = new ConstitutionManager(this.workspaceRoot);\n\n\t\tif (constitutionManager.ensureConstitutionExists()) {\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Constitution already exists. Overwrite?\",\n\t\t\t\t\"Yes\",\n\t\t\t\t\"No\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Yes\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Collect content from various sources\n\t\tconst sources: { name: string; content: string }[] = [];\n\n\t\t// 1. Check for AGENTS.md in openspec\n\t\tconst agentsPath = join(this.workspaceRoot, \"openspec\", \"AGENTS.md\");\n\t\tif (existsSync(agentsPath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"AGENTS.md\",\n\t\t\t\tcontent: readFileSync(agentsPath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// 2. Check for root AGENTS.md\n\t\tconst rootAgentsPath = join(this.workspaceRoot, \"AGENTS.md\");\n\t\tif (existsSync(rootAgentsPath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"Root AGENTS.md\",\n\t\t\t\tcontent: readFileSync(rootAgentsPath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// 3. Check for CLAUDE.md\n\t\tconst claudePath = join(this.workspaceRoot, \"CLAUDE.md\");\n\t\tif (existsSync(claudePath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"CLAUDE.md\",\n\t\t\t\tcontent: readFileSync(claudePath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// 4. Check for project.md in openspec\n\t\tconst projectPath = join(this.workspaceRoot, \"openspec\", \"project.md\");\n\t\tif (existsSync(projectPath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"project.md\",\n\t\t\t\tcontent: readFileSync(projectPath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// Build constitution content\n\t\tlet constitutionContent = \"# Project Constitution\\n\\n\";\n\n\t\tif (sources.length === 0) {\n\t\t\t// Create default constitution\n\t\t\tconstitutionContent += `## 1. Core Principles\n- **Quality First**: Code must be clean, tested, and maintainable.\n- **User Centric**: Features must provide value to the user.\n\n## 2. Technical Standards\n- Follow the project's linting rules.\n- Write tests for all new features.\n\n## 3. Workflow\n- All changes must be specified before implementation.\n- Use the SpecKit workflow: Specify -> Plan -> Implement.\n`;\n\t\t} else {\n\t\t\t// Merge content from sources\n\t\t\tconstitutionContent +=\n\t\t\t\t\"> This constitution was generated from existing project guidelines.\\n\\n\";\n\n\t\t\tfor (const source of sources) {\n\t\t\t\tconstitutionContent += `---\\n\\n## From ${source.name}\\n\\n${source.content}\\n\\n`;\n\t\t\t}\n\t\t}\n\n\t\t// Ensure memory directory exists\n\t\tconst memoryPath = getMemoryPath(this.workspaceRoot);\n\t\tif (!existsSync(memoryPath)) {\n\t\t\tmkdirSync(memoryPath, { recursive: true });\n\t\t}\n\n\t\t// Write constitution\n\t\tconst constitutionPath = getConstitutionPath(this.workspaceRoot);\n\t\twriteFileSync(constitutionPath, constitutionContent, \"utf-8\");\n\n\t\twindow.showInformationMessage(\n\t\t\t`Constitution generated from ${sources.length} source(s).`\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Migrates all OpenSpec specs to SpecKit format\n\t */\n\tasync migrateAllSpecs(): Promise<MigrationResult> {\n\t\tconst result: MigrationResult = {\n\t\t\tsuccess: false,\n\t\t\tmigratedSpecs: 0,\n\t\t\tbackupPath: null,\n\t\t\terrors: [],\n\t\t};\n\n\t\tconst openSpecPath = join(this.workspaceRoot, \"openspec\", \"specs\");\n\t\tif (!existsSync(openSpecPath)) {\n\t\t\twindow.showInformationMessage(\"No OpenSpec specs found to migrate.\");\n\t\t\tresult.success = true;\n\t\t\treturn result;\n\t\t}\n\n\t\tconst specs = readdirSync(openSpecPath).filter((entry) => {\n\t\t\tconst fullPath = join(openSpecPath, entry);\n\t\t\treturn statSync(fullPath).isDirectory();\n\t\t});\n\n\t\tif (specs.length === 0) {\n\t\t\twindow.showInformationMessage(\"No OpenSpec specs found to migrate.\");\n\t\t\tresult.success = true;\n\t\t\treturn result;\n\t\t}\n\n\t\tconst confirm = await window.showWarningMessage(\n\t\t\t`Found ${specs.length} specs to migrate. This will create new numbered directories in 'specs/'. A backup will be created. Continue?`,\n\t\t\t\"Yes\",\n\t\t\t\"No\"\n\t\t);\n\n\t\tif (confirm !== \"Yes\") {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Create backup first\n\t\tresult.backupPath = this.createBackup();\n\t\tif (result.backupPath) {\n\t\t\twindow.showInformationMessage(`Backup created at: ${result.backupPath}`);\n\t\t}\n\n\t\tconst specsPath = getSpecsPath(this.workspaceRoot);\n\t\tif (!existsSync(specsPath)) {\n\t\t\tmkdirSync(specsPath, { recursive: true });\n\t\t}\n\n\t\tfor (const specName of specs) {\n\t\t\ttry {\n\t\t\t\tthis.migrateSingleSpec(specName, openSpecPath, specsPath);\n\t\t\t\tresult.migratedSpecs += 1;\n\t\t\t} catch (error) {\n\t\t\t\tconst errorMsg = `Failed to migrate spec ${specName}: ${error}`;\n\t\t\t\tconsole.error(errorMsg);\n\t\t\t\tresult.errors.push(errorMsg);\n\t\t\t\twindow.showErrorMessage(errorMsg);\n\t\t\t}\n\t\t}\n\n\t\t// Generate constitution from existing guidelines\n\t\tawait this.generateConstitution();\n\n\t\tresult.success = result.errors.length === 0;\n\t\twindow.showInformationMessage(\n\t\t\t`Migration complete. Migrated ${result.migratedSpecs} specs.`\n\t\t);\n\n\t\treturn result;\n\t}\n\n\tprivate migrateSingleSpec(\n\t\tspecName: string,\n\t\tsourceBasePath: string,\n\t\ttargetBasePath: string\n\t): void {\n\t\tconst sourcePath = join(sourceBasePath, specName);\n\n\t\t// Generate next number\n\t\tconst nextNumber = generateNextFeatureNumber(targetBasePath);\n\t\tconst dirName = createFeatureDirectoryName(nextNumber, specName);\n\t\tconst targetPath = join(targetBasePath, dirName);\n\n\t\tmkdirSync(targetPath, { recursive: true });\n\n\t\t// Map files\n\t\t// OpenSpec: spec.md, requirements.md, design.md, tasks.md\n\t\t// SpecKit: spec.md, plan.md, tasks.md\n\n\t\t// 1. spec.md -> spec.md\n\t\tif (existsSync(join(sourcePath, \"spec.md\"))) {\n\t\t\tcopyFileSync(join(sourcePath, \"spec.md\"), join(targetPath, \"spec.md\"));\n\t\t}\n\n\t\t// 2. requirements.md -> appended to spec.md or separate?\n\t\t// SpecKit usually puts requirements in spec.md. For now, let's copy it as requirements.md (extra file)\n\t\tif (existsSync(join(sourcePath, \"requirements.md\"))) {\n\t\t\tcopyFileSync(\n\t\t\t\tjoin(sourcePath, \"requirements.md\"),\n\t\t\t\tjoin(targetPath, \"requirements.md\")\n\t\t\t);\n\t\t}\n\n\t\t// 3. design.md -> plan.md\n\t\tif (existsSync(join(sourcePath, \"design.md\"))) {\n\t\t\tcopyFileSync(join(sourcePath, \"design.md\"), join(targetPath, \"plan.md\"));\n\t\t}\n\n\t\t// 4. tasks.md -> tasks.md\n\t\tif (existsSync(join(sourcePath, \"tasks.md\"))) {\n\t\t\tcopyFileSync(join(sourcePath, \"tasks.md\"), join(targetPath, \"tasks.md\"));\n\t\t}\n\n\t\t// 5. Copy any additional markdown files\n\t\tconst additionalFiles = readdirSync(sourcePath).filter(\n\t\t\t(f) =>\n\t\t\t\tf.endsWith(\".md\") &&\n\t\t\t\t![\"spec.md\", \"requirements.md\", \"design.md\", \"tasks.md\"].includes(f)\n\t\t);\n\n\t\tfor (const file of additionalFiles) {\n\t\t\tcopyFileSync(join(sourcePath, file), join(targetPath, file));\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated Use generateConstitution() instead\n\t */\n\tprivate async migrateAgentsToConstitution(): Promise<void> {\n\t\tawait this.generateConstitution();\n\t}\n}",
    "start_line": 28,
    "end_line": 315,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecKitMigration",
    "component_id": "src.utils.spec-kit-migration.SpecKitMigration"
  },
  "src.utils.spec-kit-migration.createBackup": {
    "id": "src.utils.spec-kit-migration.createBackup",
    "name": "createBackup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "createBackup(): string | null {\n\t\tconst openSpecPath = join(this.workspaceRoot, \"openspec\");\n\t\tif (!existsSync(openSpecPath)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\t\tconst backupPath = join(\n\t\t\tthis.workspaceRoot,\n\t\t\t`.openspec-backup-${timestamp}`\n\t\t);\n\n\t\ttry {\n\t\t\tthis.copyDirectoryRecursive(openSpecPath, backupPath);\n\t\t\treturn backupPath;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Failed to create backup:\", error);\n\t\t\treturn null;\n\t\t}\n\t}",
    "start_line": 38,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createBackup",
    "component_id": "src.utils.spec-kit-migration.createBackup"
  },
  "src.utils.spec-kit-migration.copyDirectoryRecursive": {
    "id": "src.utils.spec-kit-migration.copyDirectoryRecursive",
    "name": "copyDirectoryRecursive",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "private copyDirectoryRecursive(source: string, target: string): void {\n\t\tif (!existsSync(target)) {\n\t\t\tmkdirSync(target, { recursive: true });\n\t\t}\n\n\t\tconst entries = readdirSync(source);\n\n\t\tfor (const entry of entries) {\n\t\t\tconst sourcePath = join(source, entry);\n\t\t\tconst targetPath = join(target, entry);\n\t\t\tconst stat = statSync(sourcePath);\n\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tthis.copyDirectoryRecursive(sourcePath, targetPath);\n\t\t\t} else {\n\t\t\t\tcopyFileSync(sourcePath, targetPath);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 62,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "source",
      "target"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method copyDirectoryRecursive",
    "component_id": "src.utils.spec-kit-migration.copyDirectoryRecursive"
  },
  "src.utils.spec-kit-migration.generateConstitution": {
    "id": "src.utils.spec-kit-migration.generateConstitution",
    "name": "generateConstitution",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "async generateConstitution(): Promise<boolean> {\n\t\tconst constitutionManager = new ConstitutionManager(this.workspaceRoot);\n\n\t\tif (constitutionManager.ensureConstitutionExists()) {\n\t\t\tconst overwrite = await window.showWarningMessage(\n\t\t\t\t\"Constitution already exists. Overwrite?\",\n\t\t\t\t\"Yes\",\n\t\t\t\t\"No\"\n\t\t\t);\n\t\t\tif (overwrite !== \"Yes\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Collect content from various sources\n\t\tconst sources: { name: string; content: string }[] = [];\n\n\t\t// 1. Check for AGENTS.md in openspec\n\t\tconst agentsPath = join(this.workspaceRoot, \"openspec\", \"AGENTS.md\");\n\t\tif (existsSync(agentsPath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"AGENTS.md\",\n\t\t\t\tcontent: readFileSync(agentsPath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// 2. Check for root AGENTS.md\n\t\tconst rootAgentsPath = join(this.workspaceRoot, \"AGENTS.md\");\n\t\tif (existsSync(rootAgentsPath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"Root AGENTS.md\",\n\t\t\t\tcontent: readFileSync(rootAgentsPath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// 3. Check for CLAUDE.md\n\t\tconst claudePath = join(this.workspaceRoot, \"CLAUDE.md\");\n\t\tif (existsSync(claudePath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"CLAUDE.md\",\n\t\t\t\tcontent: readFileSync(claudePath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// 4. Check for project.md in openspec\n\t\tconst projectPath = join(this.workspaceRoot, \"openspec\", \"project.md\");\n\t\tif (existsSync(projectPath)) {\n\t\t\tsources.push({\n\t\t\t\tname: \"project.md\",\n\t\t\t\tcontent: readFileSync(projectPath, \"utf-8\"),\n\t\t\t});\n\t\t}\n\n\t\t// Build constitution content\n\t\tlet constitutionContent = \"# Project Constitution\\n\\n\";\n\n\t\tif (sources.length === 0) {\n\t\t\t// Create default constitution\n\t\t\tconstitutionContent += `## 1. Core Principles\n- **Quality First**: Code must be clean, tested, and maintainable.\n- **User Centric**: Features must provide value to the user.\n\n## 2. Technical Standards\n- Follow the project's linting rules.\n- Write tests for all new features.\n\n## 3. Workflow\n- All changes must be specified before implementation.\n- Use the SpecKit workflow: Specify -> Plan -> Implement.\n`;\n\t\t} else {\n\t\t\t// Merge content from sources\n\t\t\tconstitutionContent +=\n\t\t\t\t\"> This constitution was generated from existing project guidelines.\\n\\n\";\n\n\t\t\tfor (const source of sources) {\n\t\t\t\tconstitutionContent += `---\\n\\n## From ${source.name}\\n\\n${source.content}\\n\\n`;\n\t\t\t}\n\t\t}\n\n\t\t// Ensure memory directory exists\n\t\tconst memoryPath = getMemoryPath(this.workspaceRoot);\n\t\tif (!existsSync(memoryPath)) {\n\t\t\tmkdirSync(memoryPath, { recursive: true });\n\t\t}\n\n\t\t// Write constitution\n\t\tconst constitutionPath = getConstitutionPath(this.workspaceRoot);\n\t\twriteFileSync(constitutionPath, constitutionContent, \"utf-8\");\n\n\t\twindow.showInformationMessage(\n\t\t\t`Constitution generated from ${sources.length} source(s).`\n\t\t);\n\t\treturn true;\n\t}",
    "start_line": 86,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method generateConstitution",
    "component_id": "src.utils.spec-kit-migration.generateConstitution"
  },
  "src.utils.spec-kit-migration.migrateAllSpecs": {
    "id": "src.utils.spec-kit-migration.migrateAllSpecs",
    "name": "migrateAllSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "async migrateAllSpecs(): Promise<MigrationResult> {\n\t\tconst result: MigrationResult = {\n\t\t\tsuccess: false,\n\t\t\tmigratedSpecs: 0,\n\t\t\tbackupPath: null,\n\t\t\terrors: [],\n\t\t};\n\n\t\tconst openSpecPath = join(this.workspaceRoot, \"openspec\", \"specs\");\n\t\tif (!existsSync(openSpecPath)) {\n\t\t\twindow.showInformationMessage(\"No OpenSpec specs found to migrate.\");\n\t\t\tresult.success = true;\n\t\t\treturn result;\n\t\t}\n\n\t\tconst specs = readdirSync(openSpecPath).filter((entry) => {\n\t\t\tconst fullPath = join(openSpecPath, entry);\n\t\t\treturn statSync(fullPath).isDirectory();\n\t\t});\n\n\t\tif (specs.length === 0) {\n\t\t\twindow.showInformationMessage(\"No OpenSpec specs found to migrate.\");\n\t\t\tresult.success = true;\n\t\t\treturn result;\n\t\t}\n\n\t\tconst confirm = await window.showWarningMessage(\n\t\t\t`Found ${specs.length} specs to migrate. This will create new numbered directories in 'specs/'. A backup will be created. Continue?`,\n\t\t\t\"Yes\",\n\t\t\t\"No\"\n\t\t);\n\n\t\tif (confirm !== \"Yes\") {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Create backup first\n\t\tresult.backupPath = this.createBackup();\n\t\tif (result.backupPath) {\n\t\t\twindow.showInformationMessage(`Backup created at: ${result.backupPath}`);\n\t\t}\n\n\t\tconst specsPath = getSpecsPath(this.workspaceRoot);\n\t\tif (!existsSync(specsPath)) {\n\t\t\tmkdirSync(specsPath, { recursive: true });\n\t\t}\n\n\t\tfor (const specName of specs) {\n\t\t\ttry {\n\t\t\t\tthis.migrateSingleSpec(specName, openSpecPath, specsPath);\n\t\t\t\tresult.migratedSpecs += 1;\n\t\t\t} catch (error) {\n\t\t\t\tconst errorMsg = `Failed to migrate spec ${specName}: ${error}`;\n\t\t\t\tconsole.error(errorMsg);\n\t\t\t\tresult.errors.push(errorMsg);\n\t\t\t\twindow.showErrorMessage(errorMsg);\n\t\t\t}\n\t\t}\n\n\t\t// Generate constitution from existing guidelines\n\t\tawait this.generateConstitution();\n\n\t\tresult.success = result.errors.length === 0;\n\t\twindow.showInformationMessage(\n\t\t\t`Migration complete. Migrated ${result.migratedSpecs} specs.`\n\t\t);\n\n\t\treturn result;\n\t}",
    "start_line": 185,
    "end_line": 253,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method migrateAllSpecs",
    "component_id": "src.utils.spec-kit-migration.migrateAllSpecs"
  },
  "src.utils.spec-kit-migration.migrateSingleSpec": {
    "id": "src.utils.spec-kit-migration.migrateSingleSpec",
    "name": "migrateSingleSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "private migrateSingleSpec(\n\t\tspecName: string,\n\t\tsourceBasePath: string,\n\t\ttargetBasePath: string\n\t): void {\n\t\tconst sourcePath = join(sourceBasePath, specName);\n\n\t\t// Generate next number\n\t\tconst nextNumber = generateNextFeatureNumber(targetBasePath);\n\t\tconst dirName = createFeatureDirectoryName(nextNumber, specName);\n\t\tconst targetPath = join(targetBasePath, dirName);\n\n\t\tmkdirSync(targetPath, { recursive: true });\n\n\t\t// Map files\n\t\t// OpenSpec: spec.md, requirements.md, design.md, tasks.md\n\t\t// SpecKit: spec.md, plan.md, tasks.md\n\n\t\t// 1. spec.md -> spec.md\n\t\tif (existsSync(join(sourcePath, \"spec.md\"))) {\n\t\t\tcopyFileSync(join(sourcePath, \"spec.md\"), join(targetPath, \"spec.md\"));\n\t\t}\n\n\t\t// 2. requirements.md -> appended to spec.md or separate?\n\t\t// SpecKit usually puts requirements in spec.md. For now, let's copy it as requirements.md (extra file)\n\t\tif (existsSync(join(sourcePath, \"requirements.md\"))) {\n\t\t\tcopyFileSync(\n\t\t\t\tjoin(sourcePath, \"requirements.md\"),\n\t\t\t\tjoin(targetPath, \"requirements.md\")\n\t\t\t);\n\t\t}\n\n\t\t// 3. design.md -> plan.md\n\t\tif (existsSync(join(sourcePath, \"design.md\"))) {\n\t\t\tcopyFileSync(join(sourcePath, \"design.md\"), join(targetPath, \"plan.md\"));\n\t\t}\n\n\t\t// 4. tasks.md -> tasks.md\n\t\tif (existsSync(join(sourcePath, \"tasks.md\"))) {\n\t\t\tcopyFileSync(join(sourcePath, \"tasks.md\"), join(targetPath, \"tasks.md\"));\n\t\t}\n\n\t\t// 5. Copy any additional markdown files\n\t\tconst additionalFiles = readdirSync(sourcePath).filter(\n\t\t\t(f) =>\n\t\t\t\tf.endsWith(\".md\") &&\n\t\t\t\t![\"spec.md\", \"requirements.md\", \"design.md\", \"tasks.md\"].includes(f)\n\t\t);\n\n\t\tfor (const file of additionalFiles) {\n\t\t\tcopyFileSync(join(sourcePath, file), join(targetPath, file));\n\t\t}\n\t}",
    "start_line": 255,
    "end_line": 307,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specName",
      "sourceBasePath",
      "targetBasePath"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method migrateSingleSpec",
    "component_id": "src.utils.spec-kit-migration.migrateSingleSpec"
  },
  "src.utils.spec-kit-migration.migrateAgentsToConstitution": {
    "id": "src.utils.spec-kit-migration.migrateAgentsToConstitution",
    "name": "migrateAgentsToConstitution",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-migration.ts",
    "relative_path": "src/utils/spec-kit-migration.ts",
    "depends_on": [],
    "source_code": "private async migrateAgentsToConstitution(): Promise<void> {\n\t\tawait this.generateConstitution();\n\t}",
    "start_line": 312,
    "end_line": 314,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method migrateAgentsToConstitution",
    "component_id": "src.utils.spec-kit-migration.migrateAgentsToConstitution"
  },
  "src.utils.spec-kit-utilities.SpecKitFeature": {
    "id": "src.utils.spec-kit-utilities.SpecKitFeature",
    "name": "SpecKitFeature",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "interface SpecKitFeature {\n\tnumber: number;\n\tname: string;\n\tslug: string;\n\tpath: string;\n}",
    "start_line": 25,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecKitFeature",
    "component_id": "src.utils.spec-kit-utilities.SpecKitFeature"
  },
  "src.utils.spec-kit-utilities.detectAvailableSpecSystems": {
    "id": "src.utils.spec-kit-utilities.detectAvailableSpecSystems",
    "name": "detectAvailableSpecSystems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.constants.SpecSystemMode"
    ],
    "source_code": "function detectAvailableSpecSystems(\n\tworkspacePath: string\n): SpecSystemMode[] {\n\tconst systems: SpecSystemMode[] = [];\n\tconst openspecPath = join(workspacePath, \"openspec\");\n\tconst specsPath = join(workspacePath, \"specs\");\n\tconst specifyPath = join(workspacePath, \".specify\");\n\n\t// Check for SpecKit indicators\n\tif (existsSync(specifyPath) && existsSync(specsPath)) {\n\t\tsystems.push(SPEC_SYSTEM_MODE.SPECKIT);\n\t}\n\n\t// Check for OpenSpec indicators\n\tif (existsSync(openspecPath)) {\n\t\tsystems.push(SPEC_SYSTEM_MODE.OPENSPEC);\n\t}\n\n\treturn systems;\n}",
    "start_line": 35,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function detectAvailableSpecSystems",
    "component_id": "src.utils.spec-kit-utilities.detectAvailableSpecSystems"
  },
  "src.utils.spec-kit-utilities.detectActiveSpecSystem": {
    "id": "src.utils.spec-kit-utilities.detectActiveSpecSystem",
    "name": "detectActiveSpecSystem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.constants.SpecSystemMode",
      "src.utils.spec-kit-utilities.detectAvailableSpecSystems"
    ],
    "source_code": "function detectActiveSpecSystem(workspacePath: string): SpecSystemMode {\n\tconst available = detectAvailableSpecSystems(workspacePath);\n\n\tif (available.length === 1) {\n\t\treturn available[0];\n\t}\n\n\tif (available.includes(SPEC_SYSTEM_MODE.SPECKIT)) {\n\t\treturn SPEC_SYSTEM_MODE.SPECKIT; // Default preference if both exist, but SpecManager should handle user choice\n\t}\n\n\t// Default to auto-detect (could be new project)\n\treturn SPEC_SYSTEM_MODE.AUTO;\n}",
    "start_line": 60,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function detectActiveSpecSystem",
    "component_id": "src.utils.spec-kit-utilities.detectActiveSpecSystem"
  },
  "src.utils.spec-kit-utilities.parseSpecKitDirectoryName": {
    "id": "src.utils.spec-kit-utilities.parseSpecKitDirectoryName",
    "name": "parseSpecKitDirectoryName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.convertSlugToName",
      "src.utils.spec-kit-utilities.SpecKitFeature"
    ],
    "source_code": "function parseSpecKitDirectoryName(\n\tdirName: string\n): SpecKitFeature | null {\n\tconst match = dirName.match(SPEC_KIT_DIR_REGEX);\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst number = Number.parseInt(match[1], 10);\n\tconst slug = match[2];\n\n\treturn {\n\t\tnumber,\n\t\tname: convertSlugToName(slug),\n\t\tslug: dirName,\n\t\tpath: dirName,\n\t};\n}",
    "start_line": 80,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dirName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseSpecKitDirectoryName",
    "component_id": "src.utils.spec-kit-utilities.parseSpecKitDirectoryName"
  },
  "src.utils.spec-kit-utilities.convertSlugToName": {
    "id": "src.utils.spec-kit-utilities.convertSlugToName",
    "name": "convertSlugToName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function convertSlugToName(slug: string): string {\n\treturn slug\n\t\t.split(\"-\")\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n\t\t.join(\" \");\n}",
    "start_line": 103,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "slug"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convertSlugToName",
    "component_id": "src.utils.spec-kit-utilities.convertSlugToName"
  },
  "src.utils.spec-kit-utilities.convertNameToSlug": {
    "id": "src.utils.spec-kit-utilities.convertNameToSlug",
    "name": "convertNameToSlug",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function convertNameToSlug(name: string): string {\n\treturn name\n\t\t.toLowerCase()\n\t\t.replace(SLUG_WHITESPACE_REGEX, \"-\")\n\t\t.replace(SLUG_INVALID_CHARS_REGEX, \"\");\n}",
    "start_line": 114,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convertNameToSlug",
    "component_id": "src.utils.spec-kit-utilities.convertNameToSlug"
  },
  "src.utils.spec-kit-utilities.discoverSpecKitFeatures": {
    "id": "src.utils.spec-kit-utilities.discoverSpecKitFeatures",
    "name": "discoverSpecKitFeatures",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.parseSpecKitDirectoryName",
      "src.utils.spec-kit-utilities.SpecKitFeature"
    ],
    "source_code": "function discoverSpecKitFeatures(specsPath: string): SpecKitFeature[] {\n\tif (!existsSync(specsPath)) {\n\t\treturn [];\n\t}\n\n\tconst features: SpecKitFeature[] = [];\n\n\ttry {\n\t\tconst entries = readdirSync(specsPath);\n\n\t\tfor (const entry of entries) {\n\t\t\tconst fullPath = join(specsPath, entry);\n\t\t\tconst stat = statSync(fullPath);\n\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tconst feature = parseSpecKitDirectoryName(entry);\n\t\t\t\tif (feature) {\n\t\t\t\t\tfeature.path = fullPath;\n\t\t\t\t\tfeatures.push(feature);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(`Error discovering SpecKit features in ${specsPath}:`, error);\n\t}\n\n\t// Sort by number\n\treturn features.sort((a, b) => a.number - b.number);\n}",
    "start_line": 124,
    "end_line": 152,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specsPath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function discoverSpecKitFeatures",
    "component_id": "src.utils.spec-kit-utilities.discoverSpecKitFeatures"
  },
  "src.utils.spec-kit-utilities.generateNextFeatureNumber": {
    "id": "src.utils.spec-kit-utilities.generateNextFeatureNumber",
    "name": "generateNextFeatureNumber",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.discoverSpecKitFeatures"
    ],
    "source_code": "function generateNextFeatureNumber(specsPath: string): number {\n\tconst features = discoverSpecKitFeatures(specsPath);\n\n\tif (features.length === 0) {\n\t\treturn 1;\n\t}\n\n\tconst maxNumber = Math.max(...features.map((f) => f.number));\n\treturn maxNumber + 1;\n}",
    "start_line": 158,
    "end_line": 167,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specsPath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateNextFeatureNumber",
    "component_id": "src.utils.spec-kit-utilities.generateNextFeatureNumber"
  },
  "src.utils.spec-kit-utilities.formatFeatureNumber": {
    "id": "src.utils.spec-kit-utilities.formatFeatureNumber",
    "name": "formatFeatureNumber",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function formatFeatureNumber(num: number, padding = 3): string {\n\treturn String(num).padStart(padding, \"0\");\n}",
    "start_line": 172,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "num",
      "padding"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatFeatureNumber",
    "component_id": "src.utils.spec-kit-utilities.formatFeatureNumber"
  },
  "src.utils.spec-kit-utilities.createFeatureDirectoryName": {
    "id": "src.utils.spec-kit-utilities.createFeatureDirectoryName",
    "name": "createFeatureDirectoryName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.formatFeatureNumber",
      "src.utils.spec-kit-utilities.convertNameToSlug"
    ],
    "source_code": "function createFeatureDirectoryName(\n\tnumber: number,\n\tname: string\n): string {\n\tconst slug = convertNameToSlug(name);\n\treturn `${formatFeatureNumber(number)}-${slug}`;\n}",
    "start_line": 180,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "number",
      "name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createFeatureDirectoryName",
    "component_id": "src.utils.spec-kit-utilities.createFeatureDirectoryName"
  },
  "src.utils.spec-kit-utilities.isSpecKitFeatureDirectory": {
    "id": "src.utils.spec-kit-utilities.isSpecKitFeatureDirectory",
    "name": "isSpecKitFeatureDirectory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function isSpecKitFeatureDirectory(dirName: string): boolean {\n\treturn SPEC_KIT_FEATURE_DIR_VALIDATION_REGEX.test(dirName);\n}",
    "start_line": 191,
    "end_line": 193,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dirName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isSpecKitFeatureDirectory",
    "component_id": "src.utils.spec-kit-utilities.isSpecKitFeatureDirectory"
  },
  "src.utils.spec-kit-utilities.getSpecKitFeatureFiles": {
    "id": "src.utils.spec-kit-utilities.getSpecKitFeatureFiles",
    "name": "getSpecKitFeatureFiles",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function getSpecKitFeatureFiles(\n\tfeaturePath: string\n): Record<string, string> {\n\tconst files: Record<string, string> = {};\n\tconst requiredFiles = [\"spec\", \"plan\", \"tasks\"];\n\n\tfor (const fileType of requiredFiles) {\n\t\tconst filePath = join(featurePath, `${fileType}.md`);\n\t\tfiles[fileType] = filePath;\n\t}\n\n\t// Add optional files\n\tconst optionalFiles = [\n\t\t\"research\",\n\t\t\"data-model\",\n\t\t\"quickstart\",\n\t\t\"constitution\",\n\t];\n\tfor (const fileType of optionalFiles) {\n\t\tconst filePath = join(featurePath, `${fileType}.md`);\n\t\tif (existsSync(filePath)) {\n\t\t\tfiles[fileType] = filePath;\n\t\t}\n\t}\n\n\treturn files;\n}",
    "start_line": 199,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "featurePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getSpecKitFeatureFiles",
    "component_id": "src.utils.spec-kit-utilities.getSpecKitFeatureFiles"
  },
  "src.utils.spec-kit-utilities.SpecKitValidationResult": {
    "id": "src.utils.spec-kit-utilities.SpecKitValidationResult",
    "name": "SpecKitValidationResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "interface SpecKitValidationResult {\n\tisValid: boolean;\n\tmissingDirectories: string[];\n\tmissingFiles: string[];\n\twarnings: string[];\n}",
    "start_line": 231,
    "end_line": 236,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecKitValidationResult",
    "component_id": "src.utils.spec-kit-utilities.SpecKitValidationResult"
  },
  "src.utils.spec-kit-utilities.validateSpecKitStructure": {
    "id": "src.utils.spec-kit-utilities.validateSpecKitStructure",
    "name": "validateSpecKitStructure",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.SpecKitValidationResult",
      "src.features.hooks.actions.custom-action.isValid"
    ],
    "source_code": "function validateSpecKitStructure(\n\tworkspacePath: string\n): SpecKitValidationResult {\n\tconst result: SpecKitValidationResult = {\n\t\tisValid: true,\n\t\tmissingDirectories: [],\n\t\tmissingFiles: [],\n\t\twarnings: [],\n\t};\n\n\t// Check required directories\n\tconst requiredDirs = [\n\t\t\"specs\",\n\t\t\".specify\",\n\t\t\".specify/memory\",\n\t\t\".specify/templates\",\n\t];\n\n\tfor (const dir of requiredDirs) {\n\t\tconst dirPath = join(workspacePath, dir);\n\t\tif (!existsSync(dirPath)) {\n\t\t\tresult.missingDirectories.push(dir);\n\t\t\tresult.isValid = false;\n\t\t}\n\t}\n\n\t// Check for constitution.md\n\tconst constitutionPath = join(\n\t\tworkspacePath,\n\t\t\".specify/memory/constitution.md\"\n\t);\n\tif (!existsSync(constitutionPath)) {\n\t\tresult.missingFiles.push(\".specify/memory/constitution.md\");\n\t\tresult.warnings.push(\n\t\t\t\"constitution.md not found - run /speckit.constitution\"\n\t\t);\n\t}\n\n\treturn result;\n}",
    "start_line": 238,
    "end_line": 277,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateSpecKitStructure",
    "component_id": "src.utils.spec-kit-utilities.validateSpecKitStructure"
  },
  "src.utils.spec-kit-utilities.getConstitutionPath": {
    "id": "src.utils.spec-kit-utilities.getConstitutionPath",
    "name": "getConstitutionPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function getConstitutionPath(workspacePath: string): string {\n\treturn join(workspacePath, SPECKIT_CONFIG.paths.memory, \"constitution.md\");\n}",
    "start_line": 282,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getConstitutionPath",
    "component_id": "src.utils.spec-kit-utilities.getConstitutionPath"
  },
  "src.utils.spec-kit-utilities.getMemoryPath": {
    "id": "src.utils.spec-kit-utilities.getMemoryPath",
    "name": "getMemoryPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function getMemoryPath(workspacePath: string): string {\n\treturn join(workspacePath, SPECKIT_CONFIG.paths.memory);\n}",
    "start_line": 289,
    "end_line": 291,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getMemoryPath",
    "component_id": "src.utils.spec-kit-utilities.getMemoryPath"
  },
  "src.utils.spec-kit-utilities.getTemplatesPath": {
    "id": "src.utils.spec-kit-utilities.getTemplatesPath",
    "name": "getTemplatesPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function getTemplatesPath(workspacePath: string): string {\n\treturn join(workspacePath, SPECKIT_CONFIG.paths.templates);\n}",
    "start_line": 296,
    "end_line": 298,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getTemplatesPath",
    "component_id": "src.utils.spec-kit-utilities.getTemplatesPath"
  },
  "src.utils.spec-kit-utilities.getScriptsPath": {
    "id": "src.utils.spec-kit-utilities.getScriptsPath",
    "name": "getScriptsPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function getScriptsPath(workspacePath: string): string {\n\treturn join(workspacePath, SPECKIT_CONFIG.paths.scripts);\n}",
    "start_line": 303,
    "end_line": 305,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getScriptsPath",
    "component_id": "src.utils.spec-kit-utilities.getScriptsPath"
  },
  "src.utils.spec-kit-utilities.getSpecsPath": {
    "id": "src.utils.spec-kit-utilities.getSpecsPath",
    "name": "getSpecsPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [],
    "source_code": "function getSpecsPath(workspacePath: string): string {\n\treturn join(workspacePath, SPECKIT_CONFIG.paths.specs);\n}",
    "start_line": 310,
    "end_line": 312,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "workspacePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getSpecsPath",
    "component_id": "src.utils.spec-kit-utilities.getSpecsPath"
  },
  "src.utils.spec-kit-utilities.extractFeatureNameFromPath": {
    "id": "src.utils.spec-kit-utilities.extractFeatureNameFromPath",
    "name": "extractFeatureNameFromPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.parseSpecKitDirectoryName"
    ],
    "source_code": "function extractFeatureNameFromPath(featurePath: string): string {\n\tconst dirName = featurePath.split(PATH_SEPARATOR_REGEX).pop() || \"\";\n\tconst feature = parseSpecKitDirectoryName(dirName);\n\treturn feature ? feature.name : dirName;\n}",
    "start_line": 318,
    "end_line": 322,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "featurePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractFeatureNameFromPath",
    "component_id": "src.utils.spec-kit-utilities.extractFeatureNameFromPath"
  },
  "src.utils.spec-kit-utilities.extractFeatureNumberFromPath": {
    "id": "src.utils.spec-kit-utilities.extractFeatureNumberFromPath",
    "name": "extractFeatureNumberFromPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.parseSpecKitDirectoryName"
    ],
    "source_code": "function extractFeatureNumberFromPath(\n\tfeaturePath: string\n): number | null {\n\tconst dirName = featurePath.split(PATH_SEPARATOR_REGEX).pop() || \"\";\n\tconst feature = parseSpecKitDirectoryName(dirName);\n\treturn feature ? feature.number : null;\n}",
    "start_line": 328,
    "end_line": 334,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "featurePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractFeatureNumberFromPath",
    "component_id": "src.utils.spec-kit-utilities.extractFeatureNumberFromPath"
  },
  "src.utils.spec-kit-utilities.isInSpecKitFeatureDirectory": {
    "id": "src.utils.spec-kit-utilities.isInSpecKitFeatureDirectory",
    "name": "isInSpecKitFeatureDirectory",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/spec-kit-utilities.ts",
    "relative_path": "src/utils/spec-kit-utilities.ts",
    "depends_on": [
      "src.utils.spec-kit-utilities.isSpecKitFeatureDirectory"
    ],
    "source_code": "function isInSpecKitFeatureDirectory(\n\tfilePath: string,\n\tspecsPath: string\n): boolean {\n\tconst normalized = filePath.replace(BACKSLASH_REGEX, \"/\");\n\tconst normalizedSpecs = specsPath.replace(BACKSLASH_REGEX, \"/\");\n\n\tif (!normalized.includes(normalizedSpecs)) {\n\t\treturn false;\n\t}\n\n\t// Check if path contains a feature directory\n\tconst relativePath = normalized\n\t\t.substring(normalizedSpecs.length)\n\t\t.replace(LEADING_SLASH_REGEX, \"\");\n\tconst parts = relativePath.split(\"/\");\n\n\treturn parts.length > 0 && isSpecKitFeatureDirectory(parts[0]);\n}",
    "start_line": 339,
    "end_line": 357,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath",
      "specsPath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isInSpecKitFeatureDirectory",
    "component_id": "src.utils.spec-kit-utilities.isInSpecKitFeatureDirectory"
  },
  "src.utils.task-parser.TaskStatus": {
    "id": "src.utils.task-parser.TaskStatus",
    "name": "TaskStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [],
    "source_code": "type TaskStatus = \"completed\" | \"in-progress\" | \"not-started\";",
    "start_line": 8,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TaskStatus",
    "component_id": "src.utils.task-parser.TaskStatus"
  },
  "src.utils.task-parser.ParsedTask": {
    "id": "src.utils.task-parser.ParsedTask",
    "name": "ParsedTask",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskStatus"
    ],
    "source_code": "interface ParsedTask {\n\tid: string;\n\ttitle: string;\n\tstatus: TaskStatus;\n\tphase?: string;\n\tpriority?: string;\n\tcomplexity?: string;\n\tline: number;\n}",
    "start_line": 13,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ParsedTask",
    "component_id": "src.utils.task-parser.ParsedTask"
  },
  "src.utils.task-parser.TaskGroup": {
    "id": "src.utils.task-parser.TaskGroup",
    "name": "TaskGroup",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.ParsedTask"
    ],
    "source_code": "interface TaskGroup {\n\tname: string;\n\ttasks: ParsedTask[];\n}",
    "start_line": 26,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TaskGroup",
    "component_id": "src.utils.task-parser.TaskGroup"
  },
  "src.utils.task-parser.parseTasksFromFile": {
    "id": "src.utils.task-parser.parseTasksFromFile",
    "name": "parseTasksFromFile",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskGroup",
      "src.utils.task-parser.parseTasksContent"
    ],
    "source_code": "function parseTasksFromFile(filePath: string): TaskGroup[] {\n\tif (!existsSync(filePath)) {\n\t\treturn [];\n\t}\n\n\ttry {\n\t\tconst content = readFileSync(filePath, \"utf-8\");\n\t\treturn parseTasksContent(content);\n\t} catch {\n\t\treturn [];\n\t}\n}",
    "start_line": 72,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filePath"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseTasksFromFile",
    "component_id": "src.utils.task-parser.parseTasksFromFile"
  },
  "src.utils.task-parser.parseTasksContent": {
    "id": "src.utils.task-parser.parseTasksContent",
    "name": "parseTasksContent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskGroup",
      "src.utils.task-parser.ParsedTask"
    ],
    "source_code": "function parseTasksContent(content: string): TaskGroup[] {\n\tconst lines = content.split(\"\\n\");\n\tconst groups: TaskGroup[] = [];\n\n\tlet currentGroup: TaskGroup | null = null;\n\tlet currentTask: ParsedTask | null = null;\n\tlet taskContentLines: string[] = [];\n\tlet inAcceptanceCriteria = false;\n\tlet acceptanceCriteriaItems: { checked: boolean; text: string }[] = [];\n\n\t// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Finalizer considers validation, status, and metadata extraction in one pass.\n\tconst finalizeTask = () => {\n\t\tif (currentTask && currentGroup) {\n\t\t\t// Determine task status based on acceptance criteria (only for header-style tasks)\n\t\t\tif (acceptanceCriteriaItems.length > 0) {\n\t\t\t\tconst completedCount = acceptanceCriteriaItems.filter(\n\t\t\t\t\t(item) => item.checked\n\t\t\t\t).length;\n\t\t\t\tconst totalCount = acceptanceCriteriaItems.length;\n\n\t\t\t\tif (completedCount === totalCount) {\n\t\t\t\t\tcurrentTask.status = \"completed\";\n\t\t\t\t} else if (completedCount > 0) {\n\t\t\t\t\tcurrentTask.status = \"in-progress\";\n\t\t\t\t} else {\n\t\t\t\t\tcurrentTask.status = \"not-started\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for explicit STATUS marker in task content\n\t\t\tconst taskContent = taskContentLines.join(\"\\n\");\n\t\t\tif (STATUS_COMPLETE_PATTERN.test(taskContent)) {\n\t\t\t\tcurrentTask.status = \"completed\";\n\t\t\t} else if (STATUS_IN_PROGRESS_PATTERN.test(taskContent)) {\n\t\t\t\tcurrentTask.status = \"in-progress\";\n\t\t\t}\n\n\t\t\t// Extract priority and complexity\n\t\t\tconst priorityMatch = taskContent.match(PRIORITY_PATTERN);\n\t\t\tif (priorityMatch) {\n\t\t\t\tcurrentTask.priority = priorityMatch[1];\n\t\t\t}\n\n\t\t\tconst complexityMatch = taskContent.match(COMPLEXITY_PATTERN);\n\t\t\tif (complexityMatch) {\n\t\t\t\tcurrentTask.complexity = complexityMatch[1];\n\t\t\t}\n\n\t\t\tcurrentGroup.tasks.push(currentTask);\n\t\t}\n\n\t\tcurrentTask = null;\n\t\ttaskContentLines = [];\n\t\tinAcceptanceCriteria = false;\n\t\tacceptanceCriteriaItems = [];\n\t};\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i];\n\t\tconst lineNumber = i + 1;\n\n\t\t// Check for phase header (## Phase N: Name or ## Section Name)\n\t\tconst phaseMatch = line.match(PHASE_HEADER_PATTERN);\n\t\tif (\n\t\t\tphaseMatch &&\n\t\t\t!line.includes(\"Task Count\") &&\n\t\t\t!line.includes(\"Summary\") &&\n\t\t\t!line.includes(\"Risk\") &&\n\t\t\t!line.includes(\"Next Steps\") &&\n\t\t\t!line.includes(\"Testing Coverage\") &&\n\t\t\t!line.includes(\"Recommended\") &&\n\t\t\t!line.includes(\"Dependencies\") &&\n\t\t\t!line.includes(\"Execution Order\") &&\n\t\t\t!line.includes(\"Parallel Example\") &&\n\t\t\t!line.includes(\"Implementation Strategy\") &&\n\t\t\t!line.includes(\"Format:\") &&\n\t\t\t!line.includes(\"Notes\") &&\n\t\t\tline.startsWith(\"##\") &&\n\t\t\t!line.startsWith(\"###\")\n\t\t) {\n\t\t\t// Finalize previous task before starting new group\n\t\t\tfinalizeTask();\n\n\t\t\tcurrentGroup = {\n\t\t\t\tname: phaseMatch[1].trim(),\n\t\t\t\ttasks: [],\n\t\t\t};\n\t\t\tgroups.push(currentGroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check for inline task format: - [X] T001 Description or - [ ] T038 [P] [US2] Description\n\t\tconst inlineTaskMatch = line.match(INLINE_TASK_PATTERN);\n\t\tif (inlineTaskMatch && currentGroup) {\n\t\t\t// Finalize any previous header-style task\n\t\t\tfinalizeTask();\n\n\t\t\tconst isChecked = inlineTaskMatch[1].toLowerCase() === \"x\";\n\t\t\tconst taskId = inlineTaskMatch[2];\n\t\t\tconst taskTitle = inlineTaskMatch[3].trim();\n\n\t\t\t// Add inline task directly to group (no multi-line content)\n\t\t\tcurrentGroup.tasks.push({\n\t\t\t\tid: taskId,\n\t\t\t\ttitle: taskTitle,\n\t\t\t\tstatus: isChecked ? \"completed\" : \"not-started\",\n\t\t\t\tphase: currentGroup.name,\n\t\t\t\tline: lineNumber,\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check for header-style task: ### T1.1: Create Type Definitions\n\t\tconst taskMatch = line.match(TASK_HEADER_PATTERN);\n\t\tif (taskMatch) {\n\t\t\t// Finalize previous task\n\t\t\tfinalizeTask();\n\n\t\t\tcurrentTask = {\n\t\t\t\tid: taskMatch[1],\n\t\t\t\ttitle: taskMatch[2].trim(),\n\t\t\t\tstatus: \"not-started\",\n\t\t\t\tphase: currentGroup?.name,\n\t\t\t\tline: lineNumber,\n\t\t\t};\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If we're in a header-style task, collect content\n\t\tif (currentTask) {\n\t\t\ttaskContentLines.push(line);\n\n\t\t\t// Check for acceptance criteria section\n\t\t\tif (\n\t\t\t\tline.includes(\"**Acceptance Criteria**\") ||\n\t\t\t\tline.includes(\"Acceptance Criteria:\")\n\t\t\t) {\n\t\t\t\tinAcceptanceCriteria = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if we're exiting acceptance criteria (new section or task)\n\t\t\tif (\n\t\t\t\tinAcceptanceCriteria &&\n\t\t\t\t(line.startsWith(\"---\") ||\n\t\t\t\t\tline.startsWith(\"##\") ||\n\t\t\t\t\t(line.startsWith(\"**\") && !line.match(CHECKBOX_PATTERN)))\n\t\t\t) {\n\t\t\t\tinAcceptanceCriteria = false;\n\t\t\t}\n\n\t\t\t// Parse checkbox items in acceptance criteria\n\t\t\tif (inAcceptanceCriteria) {\n\t\t\t\tconst checkboxMatch = line.match(CHECKBOX_PATTERN);\n\t\t\t\tif (checkboxMatch) {\n\t\t\t\t\tacceptanceCriteriaItems.push({\n\t\t\t\t\t\tchecked: checkboxMatch[1].toLowerCase() === \"x\",\n\t\t\t\t\t\ttext: checkboxMatch[2],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Finalize last task\n\tfinalizeTask();\n\n\t// Filter out empty groups\n\treturn groups.filter((group) => group.tasks.length > 0);\n}",
    "start_line": 89,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseTasksContent",
    "component_id": "src.utils.task-parser.parseTasksContent"
  },
  "src.utils.task-parser.getTasksFilePath": {
    "id": "src.utils.task-parser.getTasksFilePath",
    "name": "getTasksFilePath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [],
    "source_code": "function getTasksFilePath(\n\tspecName: string,\n\tisChange = false\n): string | null {\n\tconst workspaceFolders = workspace.workspaceFolders;\n\tif (!workspaceFolders) {\n\t\treturn null;\n\t}\n\n\tconst workspaceRoot = workspaceFolders[0].uri.fsPath;\n\n\t// Try different possible paths\n\tconst possiblePaths = isChange\n\t\t? [\n\t\t\t\tjoin(workspaceRoot, \"openspec\", \"changes\", specName, \"tasks.md\"),\n\t\t\t\tjoin(workspaceRoot, \".specify\", specName, \"tasks.md\"),\n\t\t\t\tjoin(workspaceRoot, \"specs\", specName, \"tasks.md\"),\n\t\t\t]\n\t\t: [\n\t\t\t\tjoin(workspaceRoot, \".specify\", specName, \"tasks.md\"),\n\t\t\t\tjoin(workspaceRoot, \"specs\", specName, \"tasks.md\"),\n\t\t\t\tjoin(workspaceRoot, \"openspec\", \"specs\", specName, \"tasks.md\"),\n\t\t\t];\n\n\tfor (const path of possiblePaths) {\n\t\tif (existsSync(path)) {\n\t\t\treturn path;\n\t\t}\n\t}\n\n\treturn null;\n}",
    "start_line": 263,
    "end_line": 294,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specName",
      "isChange"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getTasksFilePath",
    "component_id": "src.utils.task-parser.getTasksFilePath"
  },
  "src.utils.task-parser.getTaskStatusIcon": {
    "id": "src.utils.task-parser.getTaskStatusIcon",
    "name": "getTaskStatusIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskStatus"
    ],
    "source_code": "function getTaskStatusIcon(status: TaskStatus): string {\n\tswitch (status) {\n\t\tcase \"completed\":\n\t\t\treturn \"pass\"; // Green checkmark\n\t\tcase \"in-progress\":\n\t\t\treturn \"sync~spin\"; // Spinning/in-progress icon\n\t\tcase \"not-started\":\n\t\t\treturn \"record\"; // Circle/record icon\n\t\tdefault:\n\t\t\treturn \"record\";\n\t}\n}",
    "start_line": 300,
    "end_line": 311,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getTaskStatusIcon",
    "component_id": "src.utils.task-parser.getTaskStatusIcon"
  },
  "src.utils.task-parser.getGroupStatusIcon": {
    "id": "src.utils.task-parser.getGroupStatusIcon",
    "name": "getGroupStatusIcon",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskStatus"
    ],
    "source_code": "function getGroupStatusIcon(status: TaskStatus): string {\n\tswitch (status) {\n\t\tcase \"completed\":\n\t\t\treturn \"pass\"; // All tasks completed\n\t\tcase \"in-progress\":\n\t\t\treturn \"sync~spin\"; // Some tasks completed\n\t\tcase \"not-started\":\n\t\t\treturn \"record\"; // No tasks completed\n\t\tdefault:\n\t\t\treturn \"record\";\n\t}\n}",
    "start_line": 316,
    "end_line": 327,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGroupStatusIcon",
    "component_id": "src.utils.task-parser.getGroupStatusIcon"
  },
  "src.utils.task-parser.calculateGroupStatus": {
    "id": "src.utils.task-parser.calculateGroupStatus",
    "name": "calculateGroupStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskStatus",
      "src.utils.task-parser.ParsedTask"
    ],
    "source_code": "function calculateGroupStatus(tasks: ParsedTask[]): TaskStatus {\n\tif (tasks.length === 0) {\n\t\treturn \"not-started\";\n\t}\n\n\tconst completedCount = tasks.filter((t) => t.status === \"completed\").length;\n\n\tif (completedCount === tasks.length) {\n\t\treturn \"completed\";\n\t}\n\n\tif (completedCount > 0) {\n\t\treturn \"in-progress\";\n\t}\n\n\treturn \"not-started\";\n}",
    "start_line": 332,
    "end_line": 348,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "tasks"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculateGroupStatus",
    "component_id": "src.utils.task-parser.calculateGroupStatus"
  },
  "src.utils.task-parser.calculateOverallStatus": {
    "id": "src.utils.task-parser.calculateOverallStatus",
    "name": "calculateOverallStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.calculateGroupStatus",
      "src.utils.task-parser.TaskGroup",
      "src.utils.task-parser.TaskStatus"
    ],
    "source_code": "function calculateOverallStatus(groups: TaskGroup[]): TaskStatus {\n\tconst allTasks = groups.flatMap((g) => g.tasks);\n\treturn calculateGroupStatus(allTasks);\n}",
    "start_line": 353,
    "end_line": 356,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "groups"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculateOverallStatus",
    "component_id": "src.utils.task-parser.calculateOverallStatus"
  },
  "src.utils.task-parser.getTaskStatusTooltip": {
    "id": "src.utils.task-parser.getTaskStatusTooltip",
    "name": "getTaskStatusTooltip",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/task-parser.ts",
    "relative_path": "src/utils/task-parser.ts",
    "depends_on": [
      "src.utils.task-parser.TaskStatus"
    ],
    "source_code": "function getTaskStatusTooltip(status: TaskStatus): string {\n\tswitch (status) {\n\t\tcase \"completed\":\n\t\t\treturn \"Completed\";\n\t\tcase \"in-progress\":\n\t\t\treturn \"In Progress\";\n\t\tcase \"not-started\":\n\t\t\treturn \"Not Started\";\n\t\tdefault:\n\t\t\treturn \"Unknown\";\n\t}\n}",
    "start_line": 361,
    "end_line": 372,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getTaskStatusTooltip",
    "component_id": "src.utils.task-parser.getTaskStatusTooltip"
  },
  "src.utils.telemetry.PreviewLoadMetrics": {
    "id": "src.utils.telemetry.PreviewLoadMetrics",
    "name": "PreviewLoadMetrics",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "interface PreviewLoadMetrics {\n\tdocumentId: string;\n\tdocumentType: DocumentType;\n\tloadStartTime: number;\n\tloadEndTime?: number;\n\tduration?: number;\n\tsuccess: boolean;\n\terror?: string;\n\tdiagramCount: number;\n\tformFieldCount: number;\n\tsectionCount: number;\n}",
    "start_line": 15,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewLoadMetrics",
    "component_id": "src.utils.telemetry.PreviewLoadMetrics"
  },
  "src.utils.telemetry.DiagramRenderMetrics": {
    "id": "src.utils.telemetry.DiagramRenderMetrics",
    "name": "DiagramRenderMetrics",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "interface DiagramRenderMetrics {\n\tdocumentId: string;\n\tdiagramId: string;\n\tlanguage: \"mermaid\" | \"c4\" | \"plantuml\" | \"other\";\n\trenderStartTime: number;\n\trenderEndTime?: number;\n\tduration?: number;\n\tsuccess: boolean;\n\terror?: string;\n\tretryCount: number;\n}",
    "start_line": 28,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DiagramRenderMetrics",
    "component_id": "src.utils.telemetry.DiagramRenderMetrics"
  },
  "src.utils.telemetry.FormInteractionMetrics": {
    "id": "src.utils.telemetry.FormInteractionMetrics",
    "name": "FormInteractionMetrics",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "interface FormInteractionMetrics {\n\tdocumentId: string;\n\tsessionId: string;\n\tfieldId: string;\n\tfieldType: \"checkbox\" | \"dropdown\" | \"text\" | \"textarea\" | \"multiselect\";\n\tinteractionType: \"focus\" | \"change\" | \"blur\" | \"submit\";\n\ttimestamp: number;\n\tvalidationSuccess?: boolean;\n\tvalidationError?: string;\n}",
    "start_line": 40,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormInteractionMetrics",
    "component_id": "src.utils.telemetry.FormInteractionMetrics"
  },
  "src.utils.telemetry.RefinementRequestMetrics": {
    "id": "src.utils.telemetry.RefinementRequestMetrics",
    "name": "RefinementRequestMetrics",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "interface RefinementRequestMetrics {\n\tdocumentId: string;\n\tdocumentType: DocumentType;\n\tsessionId: string;\n\tissueType: \"missingDetail\" | \"incorrectInfo\" | \"missingAsset\" | \"other\";\n\ttimestamp: number;\n\tsuccess: boolean;\n\trequestId?: string;\n\terror?: string;\n}",
    "start_line": 51,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefinementRequestMetrics",
    "component_id": "src.utils.telemetry.RefinementRequestMetrics"
  },
  "src.utils.telemetry.PerformanceSummary": {
    "id": "src.utils.telemetry.PerformanceSummary",
    "name": "PerformanceSummary",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "interface PerformanceSummary {\n\ttotalPreviews: number;\n\tsuccessfulPreviews: number;\n\tfailedPreviews: number;\n\taverageLoadTime: number;\n\tmedianLoadTime: number;\n\tp95LoadTime: number;\n\tpreviewsUnder3Seconds: number;\n\tpreviewsUnder3SecondsPercentage: number;\n\ttotalDiagrams: number;\n\tsuccessfulDiagrams: number;\n\tfailedDiagrams: number;\n\tdiagramSuccessRate: number;\n\tbyDocumentType: Map<\n\t\tDocumentType,\n\t\t{\n\t\t\tcount: number;\n\t\t\taverageLoadTime: number;\n\t\t\tsuccessRate: number;\n\t\t}\n\t>;\n}",
    "start_line": 62,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PerformanceSummary",
    "component_id": "src.utils.telemetry.PerformanceSummary"
  },
  "src.utils.telemetry.TelemetryStore": {
    "id": "src.utils.telemetry.TelemetryStore",
    "name": "TelemetryStore",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.PreviewLoadMetrics",
      "src.utils.telemetry.DiagramRenderMetrics",
      "src.utils.telemetry.pruneIfNeeded",
      "src.utils.telemetry.FormInteractionMetrics",
      "src.utils.telemetry.RefinementRequestMetrics"
    ],
    "source_code": "class TelemetryStore {\n\tprivate previewMetrics: PreviewLoadMetrics[] = [];\n\tprivate diagramMetrics: DiagramRenderMetrics[] = [];\n\tprivate formMetrics: FormInteractionMetrics[] = [];\n\tprivate refinementMetrics: RefinementRequestMetrics[] = [];\n\tprivate readonly maxStoredMetrics = 1000; // Prevent unbounded growth\n\n\taddPreviewMetric(metric: PreviewLoadMetrics): void {\n\t\tthis.previewMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.previewMetrics);\n\t}\n\n\taddDiagramMetric(metric: DiagramRenderMetrics): void {\n\t\tthis.diagramMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.diagramMetrics);\n\t}\n\n\taddFormMetric(metric: FormInteractionMetrics): void {\n\t\tthis.formMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.formMetrics);\n\t}\n\n\taddRefinementMetric(metric: RefinementRequestMetrics): void {\n\t\tthis.refinementMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.refinementMetrics);\n\t}\n\n\tgetPreviewMetrics(): readonly PreviewLoadMetrics[] {\n\t\treturn this.previewMetrics;\n\t}\n\n\tgetDiagramMetrics(): readonly DiagramRenderMetrics[] {\n\t\treturn this.diagramMetrics;\n\t}\n\n\tgetFormMetrics(): readonly FormInteractionMetrics[] {\n\t\treturn this.formMetrics;\n\t}\n\n\tgetRefinementMetrics(): readonly RefinementRequestMetrics[] {\n\t\treturn this.refinementMetrics;\n\t}\n\n\tclear(): void {\n\t\tthis.previewMetrics = [];\n\t\tthis.diagramMetrics = [];\n\t\tthis.formMetrics = [];\n\t\tthis.refinementMetrics = [];\n\t}\n\n\tprivate pruneIfNeeded<T>(array: T[]): void {\n\t\tif (array.length > this.maxStoredMetrics) {\n\t\t\tarray.splice(0, array.length - this.maxStoredMetrics);\n\t\t}\n\t}\n}",
    "start_line": 87,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class TelemetryStore",
    "component_id": "src.utils.telemetry.TelemetryStore"
  },
  "src.utils.telemetry.addPreviewMetric": {
    "id": "src.utils.telemetry.addPreviewMetric",
    "name": "addPreviewMetric",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "addPreviewMetric(metric: PreviewLoadMetrics): void {\n\t\tthis.previewMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.previewMetrics);\n\t}",
    "start_line": 94,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "metric"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addPreviewMetric",
    "component_id": "src.utils.telemetry.addPreviewMetric"
  },
  "src.utils.telemetry.addDiagramMetric": {
    "id": "src.utils.telemetry.addDiagramMetric",
    "name": "addDiagramMetric",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "addDiagramMetric(metric: DiagramRenderMetrics): void {\n\t\tthis.diagramMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.diagramMetrics);\n\t}",
    "start_line": 99,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "metric"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addDiagramMetric",
    "component_id": "src.utils.telemetry.addDiagramMetric"
  },
  "src.utils.telemetry.addFormMetric": {
    "id": "src.utils.telemetry.addFormMetric",
    "name": "addFormMetric",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "addFormMetric(metric: FormInteractionMetrics): void {\n\t\tthis.formMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.formMetrics);\n\t}",
    "start_line": 104,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "metric"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addFormMetric",
    "component_id": "src.utils.telemetry.addFormMetric"
  },
  "src.utils.telemetry.addRefinementMetric": {
    "id": "src.utils.telemetry.addRefinementMetric",
    "name": "addRefinementMetric",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "addRefinementMetric(metric: RefinementRequestMetrics): void {\n\t\tthis.refinementMetrics.push(metric);\n\t\tthis.pruneIfNeeded(this.refinementMetrics);\n\t}",
    "start_line": 109,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "metric"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method addRefinementMetric",
    "component_id": "src.utils.telemetry.addRefinementMetric"
  },
  "src.utils.telemetry.getPreviewMetrics": {
    "id": "src.utils.telemetry.getPreviewMetrics",
    "name": "getPreviewMetrics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "getPreviewMetrics(): readonly PreviewLoadMetrics[] {\n\t\treturn this.previewMetrics;\n\t}",
    "start_line": 114,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getPreviewMetrics",
    "component_id": "src.utils.telemetry.getPreviewMetrics"
  },
  "src.utils.telemetry.getDiagramMetrics": {
    "id": "src.utils.telemetry.getDiagramMetrics",
    "name": "getDiagramMetrics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "getDiagramMetrics(): readonly DiagramRenderMetrics[] {\n\t\treturn this.diagramMetrics;\n\t}",
    "start_line": 118,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getDiagramMetrics",
    "component_id": "src.utils.telemetry.getDiagramMetrics"
  },
  "src.utils.telemetry.getFormMetrics": {
    "id": "src.utils.telemetry.getFormMetrics",
    "name": "getFormMetrics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "getFormMetrics(): readonly FormInteractionMetrics[] {\n\t\treturn this.formMetrics;\n\t}",
    "start_line": 122,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getFormMetrics",
    "component_id": "src.utils.telemetry.getFormMetrics"
  },
  "src.utils.telemetry.getRefinementMetrics": {
    "id": "src.utils.telemetry.getRefinementMetrics",
    "name": "getRefinementMetrics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "getRefinementMetrics(): readonly RefinementRequestMetrics[] {\n\t\treturn this.refinementMetrics;\n\t}",
    "start_line": 126,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRefinementMetrics",
    "component_id": "src.utils.telemetry.getRefinementMetrics"
  },
  "src.utils.telemetry.clear": {
    "id": "src.utils.telemetry.clear",
    "name": "clear",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "clear(): void {\n\t\tthis.previewMetrics = [];\n\t\tthis.diagramMetrics = [];\n\t\tthis.formMetrics = [];\n\t\tthis.refinementMetrics = [];\n\t}",
    "start_line": 130,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clear",
    "component_id": "src.utils.telemetry.clear"
  },
  "src.utils.telemetry.pruneIfNeeded": {
    "id": "src.utils.telemetry.pruneIfNeeded",
    "name": "pruneIfNeeded",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "private pruneIfNeeded<T>(array: T[]): void {\n\t\tif (array.length > this.maxStoredMetrics) {\n\t\t\tarray.splice(0, array.length - this.maxStoredMetrics);\n\t\t}\n\t}",
    "start_line": 137,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "array"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method pruneIfNeeded",
    "component_id": "src.utils.telemetry.pruneIfNeeded"
  },
  "src.utils.telemetry.PreviewLoadTracker": {
    "id": "src.utils.telemetry.PreviewLoadTracker",
    "name": "PreviewLoadTracker",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.PreviewLoadMetrics",
      "src.utils.telemetry.addPreviewMetric"
    ],
    "source_code": "class PreviewLoadTracker {\n\tprivate readonly documentId: string;\n\tprivate readonly documentType: DocumentType;\n\tprivate readonly startTime: number;\n\tprivate diagramCount = 0;\n\tprivate formFieldCount = 0;\n\tprivate sectionCount = 0;\n\n\tconstructor(documentId: string, documentType: DocumentType) {\n\t\tthis.documentId = documentId;\n\t\tthis.documentType = documentType;\n\t\tthis.startTime = Date.now();\n\t}\n\n\tsetMetadata(metadata: {\n\t\tdiagramCount?: number;\n\t\tformFieldCount?: number;\n\t\tsectionCount?: number;\n\t}): void {\n\t\tif (metadata.diagramCount !== undefined) {\n\t\t\tthis.diagramCount = metadata.diagramCount;\n\t\t}\n\t\tif (metadata.formFieldCount !== undefined) {\n\t\t\tthis.formFieldCount = metadata.formFieldCount;\n\t\t}\n\t\tif (metadata.sectionCount !== undefined) {\n\t\t\tthis.sectionCount = metadata.sectionCount;\n\t\t}\n\t}\n\n\tcomplete(success = true, error?: string): void {\n\t\tconst endTime = Date.now();\n\t\tconst duration = endTime - this.startTime;\n\n\t\tconst metric: PreviewLoadMetrics = {\n\t\t\tdocumentId: this.documentId,\n\t\t\tdocumentType: this.documentType,\n\t\t\tloadStartTime: this.startTime,\n\t\t\tloadEndTime: endTime,\n\t\t\tduration,\n\t\t\tsuccess,\n\t\t\terror,\n\t\t\tdiagramCount: this.diagramCount,\n\t\t\tformFieldCount: this.formFieldCount,\n\t\t\tsectionCount: this.sectionCount,\n\t\t};\n\n\t\ttelemetryStore.addPreviewMetric(metric);\n\n\t\t// Log for debugging in development\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconsole.log(\"[Telemetry] Preview Load:\", {\n\t\t\t\tdocumentId: this.documentId,\n\t\t\t\tduration: `${duration}ms`,\n\t\t\t\tsuccess,\n\t\t\t\tdiagrams: this.diagramCount,\n\t\t\t\tforms: this.formFieldCount,\n\t\t\t});\n\t\t}\n\t}\n}",
    "start_line": 149,
    "end_line": 209,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class PreviewLoadTracker",
    "component_id": "src.utils.telemetry.PreviewLoadTracker"
  },
  "src.utils.telemetry.setMetadata": {
    "id": "src.utils.telemetry.setMetadata",
    "name": "setMetadata",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "setMetadata(metadata: {\n\t\tdiagramCount?: number;\n\t\tformFieldCount?: number;\n\t\tsectionCount?: number;\n\t}): void {\n\t\tif (metadata.diagramCount !== undefined) {\n\t\t\tthis.diagramCount = metadata.diagramCount;\n\t\t}\n\t\tif (metadata.formFieldCount !== undefined) {\n\t\t\tthis.formFieldCount = metadata.formFieldCount;\n\t\t}\n\t\tif (metadata.sectionCount !== undefined) {\n\t\t\tthis.sectionCount = metadata.sectionCount;\n\t\t}\n\t}",
    "start_line": 163,
    "end_line": 177,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "metadata"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setMetadata",
    "component_id": "src.utils.telemetry.setMetadata"
  },
  "src.utils.telemetry.complete": {
    "id": "src.utils.telemetry.complete",
    "name": "complete",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "complete(success = true, error?: string): void {\n\t\tconst endTime = Date.now();\n\t\tconst duration = endTime - this.startTime;\n\n\t\tconst metric: DiagramRenderMetrics = {\n\t\t\tdocumentId: this.documentId,\n\t\t\tdiagramId: this.diagramId,\n\t\t\tlanguage: this.language,\n\t\t\trenderStartTime: this.startTime,\n\t\t\trenderEndTime: endTime,\n\t\t\tduration,\n\t\t\tsuccess,\n\t\t\terror,\n\t\t\tretryCount: this.retryCount,\n\t\t};\n\n\t\ttelemetryStore.addDiagramMetric(metric);\n\n\t\t// Log for debugging in development\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconsole.log(\"[Telemetry] Diagram Render:\", {\n\t\t\t\tdiagramId: this.diagramId,\n\t\t\t\tlanguage: this.language,\n\t\t\t\tduration: `${duration}ms`,\n\t\t\t\tsuccess,\n\t\t\t\tretries: this.retryCount,\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 236,
    "end_line": 264,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "success",
      "error"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method complete",
    "component_id": "src.utils.telemetry.complete"
  },
  "src.utils.telemetry.DiagramRenderTracker": {
    "id": "src.utils.telemetry.DiagramRenderTracker",
    "name": "DiagramRenderTracker",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.DiagramRenderMetrics",
      "src.utils.telemetry.addDiagramMetric"
    ],
    "source_code": "class DiagramRenderTracker {\n\tprivate readonly documentId: string;\n\tprivate readonly diagramId: string;\n\tprivate readonly language: DiagramRenderMetrics[\"language\"];\n\tprivate startTime: number;\n\tprivate retryCount = 0;\n\n\tconstructor(\n\t\tdocumentId: string,\n\t\tdiagramId: string,\n\t\tlanguage: DiagramRenderMetrics[\"language\"]\n\t) {\n\t\tthis.documentId = documentId;\n\t\tthis.diagramId = diagramId;\n\t\tthis.language = language;\n\t\tthis.startTime = Date.now();\n\t}\n\n\tretry(): void {\n\t\tthis.retryCount += 1;\n\t\tthis.startTime = Date.now();\n\t}\n\n\tcomplete(success = true, error?: string): void {\n\t\tconst endTime = Date.now();\n\t\tconst duration = endTime - this.startTime;\n\n\t\tconst metric: DiagramRenderMetrics = {\n\t\t\tdocumentId: this.documentId,\n\t\t\tdiagramId: this.diagramId,\n\t\t\tlanguage: this.language,\n\t\t\trenderStartTime: this.startTime,\n\t\t\trenderEndTime: endTime,\n\t\t\tduration,\n\t\t\tsuccess,\n\t\t\terror,\n\t\t\tretryCount: this.retryCount,\n\t\t};\n\n\t\ttelemetryStore.addDiagramMetric(metric);\n\n\t\t// Log for debugging in development\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconsole.log(\"[Telemetry] Diagram Render:\", {\n\t\t\t\tdiagramId: this.diagramId,\n\t\t\t\tlanguage: this.language,\n\t\t\t\tduration: `${duration}ms`,\n\t\t\t\tsuccess,\n\t\t\t\tretries: this.retryCount,\n\t\t\t});\n\t\t}\n\t}\n}",
    "start_line": 213,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class DiagramRenderTracker",
    "component_id": "src.utils.telemetry.DiagramRenderTracker"
  },
  "src.utils.telemetry.retry": {
    "id": "src.utils.telemetry.retry",
    "name": "retry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [],
    "source_code": "retry(): void {\n\t\tthis.retryCount += 1;\n\t\tthis.startTime = Date.now();\n\t}",
    "start_line": 231,
    "end_line": 234,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method retry",
    "component_id": "src.utils.telemetry.retry"
  },
  "src.utils.telemetry.TrackFormInteractionOptions": {
    "id": "src.utils.telemetry.TrackFormInteractionOptions",
    "name": "TrackFormInteractionOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.FormInteractionMetrics"
    ],
    "source_code": "interface TrackFormInteractionOptions {\n\tdocumentId: string;\n\tsessionId: string;\n\tfieldId: string;\n\tfieldType: FormInteractionMetrics[\"fieldType\"];\n\tinteractionType: FormInteractionMetrics[\"interactionType\"];\n\tvalidationSuccess?: boolean;\n\tvalidationError?: string;\n}",
    "start_line": 269,
    "end_line": 277,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TrackFormInteractionOptions",
    "component_id": "src.utils.telemetry.TrackFormInteractionOptions"
  },
  "src.utils.telemetry.trackFormInteraction": {
    "id": "src.utils.telemetry.trackFormInteraction",
    "name": "trackFormInteraction",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.FormInteractionMetrics",
      "src.utils.telemetry.TrackFormInteractionOptions",
      "src.utils.telemetry.addFormMetric"
    ],
    "source_code": "function trackFormInteraction(\n\toptions: TrackFormInteractionOptions\n): void {\n\tconst metric: FormInteractionMetrics = {\n\t\tdocumentId: options.documentId,\n\t\tsessionId: options.sessionId,\n\t\tfieldId: options.fieldId,\n\t\tfieldType: options.fieldType,\n\t\tinteractionType: options.interactionType,\n\t\ttimestamp: Date.now(),\n\t\tvalidationSuccess: options.validationSuccess,\n\t\tvalidationError: options.validationError,\n\t};\n\n\ttelemetryStore.addFormMetric(metric);\n}",
    "start_line": 279,
    "end_line": 294,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function trackFormInteraction",
    "component_id": "src.utils.telemetry.trackFormInteraction"
  },
  "src.utils.telemetry.TrackRefinementRequestOptions": {
    "id": "src.utils.telemetry.TrackRefinementRequestOptions",
    "name": "TrackRefinementRequestOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.RefinementRequestMetrics"
    ],
    "source_code": "interface TrackRefinementRequestOptions {\n\tdocumentId: string;\n\tdocumentType: DocumentType;\n\tsessionId: string;\n\tissueType: RefinementRequestMetrics[\"issueType\"];\n\tsuccess: boolean;\n\trequestId?: string;\n\terror?: string;\n}",
    "start_line": 298,
    "end_line": 306,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TrackRefinementRequestOptions",
    "component_id": "src.utils.telemetry.TrackRefinementRequestOptions"
  },
  "src.utils.telemetry.trackRefinementRequest": {
    "id": "src.utils.telemetry.trackRefinementRequest",
    "name": "trackRefinementRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.TrackRefinementRequestOptions",
      "src.utils.telemetry.RefinementRequestMetrics",
      "src.utils.telemetry.addRefinementMetric"
    ],
    "source_code": "function trackRefinementRequest(\n\toptions: TrackRefinementRequestOptions\n): void {\n\tconst metric: RefinementRequestMetrics = {\n\t\tdocumentId: options.documentId,\n\t\tdocumentType: options.documentType,\n\t\tsessionId: options.sessionId,\n\t\tissueType: options.issueType,\n\t\ttimestamp: Date.now(),\n\t\tsuccess: options.success,\n\t\trequestId: options.requestId,\n\t\terror: options.error,\n\t};\n\n\ttelemetryStore.addRefinementMetric(metric);\n\n\t// Log for debugging in development\n\tif (process.env.NODE_ENV === \"development\") {\n\t\tconsole.log(\"[Telemetry] Refinement Request:\", {\n\t\t\tdocumentId: options.documentId,\n\t\t\tissueType: options.issueType,\n\t\t\tsuccess: options.success,\n\t\t\trequestId: options.requestId,\n\t\t});\n\t}\n}",
    "start_line": 308,
    "end_line": 333,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function trackRefinementRequest",
    "component_id": "src.utils.telemetry.trackRefinementRequest"
  },
  "src.utils.telemetry.getPerformanceSummary": {
    "id": "src.utils.telemetry.getPerformanceSummary",
    "name": "getPerformanceSummary",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.PerformanceSummary",
      "src.utils.telemetry.getDiagramMetrics",
      "src.features.agents.resource-cache.get",
      "src.utils.telemetry.getPreviewMetrics"
    ],
    "source_code": "function getPerformanceSummary(): PerformanceSummary {\n\tconst previewMetrics = telemetryStore.getPreviewMetrics();\n\tconst diagramMetrics = telemetryStore.getDiagramMetrics();\n\n\t// Preview metrics\n\tconst successfulPreviews = previewMetrics.filter((m) => m.success);\n\tconst failedPreviews = previewMetrics.filter((m) => !m.success);\n\tconst durations = successfulPreviews\n\t\t.map((m) => m.duration!)\n\t\t.filter((d) => d !== undefined)\n\t\t.sort((a, b) => a - b);\n\n\tconst averageLoadTime =\n\t\tdurations.length > 0\n\t\t\t? durations.reduce((sum, d) => sum + d, 0) / durations.length\n\t\t\t: 0;\n\n\tconst medianLoadTime =\n\t\tdurations.length > 0 ? durations[Math.floor(durations.length / 2)] : 0;\n\n\tconst p95Index = Math.floor(durations.length * 0.95);\n\tconst p95LoadTime = durations.length > 0 ? durations[p95Index] : 0;\n\n\tconst previewsUnder3Seconds = durations.filter((d) => d <= 3000).length;\n\tconst previewsUnder3SecondsPercentage =\n\t\tdurations.length > 0 ? (previewsUnder3Seconds / durations.length) * 100 : 0;\n\n\t// Diagram metrics\n\tconst successfulDiagrams = diagramMetrics.filter((m) => m.success);\n\tconst failedDiagrams = diagramMetrics.filter((m) => !m.success);\n\tconst diagramSuccessRate =\n\t\tdiagramMetrics.length > 0\n\t\t\t? (successfulDiagrams.length / diagramMetrics.length) * 100\n\t\t\t: 0;\n\n\t// By document type\n\tconst byDocumentType = new Map<\n\t\tDocumentType,\n\t\t{\n\t\t\tcount: number;\n\t\t\taverageLoadTime: number;\n\t\t\tsuccessRate: number;\n\t\t}\n\t>();\n\n\tfor (const metric of previewMetrics) {\n\t\tconst existing = byDocumentType.get(metric.documentType) || {\n\t\t\tcount: 0,\n\t\t\taverageLoadTime: 0,\n\t\t\tsuccessRate: 0,\n\t\t};\n\n\t\tconst typeMetrics = previewMetrics.filter(\n\t\t\t(m) => m.documentType === metric.documentType\n\t\t);\n\t\tconst typeSuccessful = typeMetrics.filter((m) => m.success);\n\t\tconst typeDurations = typeSuccessful\n\t\t\t.map((m) => m.duration!)\n\t\t\t.filter((d) => d !== undefined);\n\n\t\tbyDocumentType.set(metric.documentType, {\n\t\t\tcount: typeMetrics.length,\n\t\t\taverageLoadTime:\n\t\t\t\ttypeDurations.length > 0\n\t\t\t\t\t? typeDurations.reduce((sum, d) => sum + d, 0) / typeDurations.length\n\t\t\t\t\t: 0,\n\t\t\tsuccessRate:\n\t\t\t\ttypeMetrics.length > 0\n\t\t\t\t\t? (typeSuccessful.length / typeMetrics.length) * 100\n\t\t\t\t\t: 0,\n\t\t});\n\t}\n\n\treturn {\n\t\ttotalPreviews: previewMetrics.length,\n\t\tsuccessfulPreviews: successfulPreviews.length,\n\t\tfailedPreviews: failedPreviews.length,\n\t\taverageLoadTime,\n\t\tmedianLoadTime,\n\t\tp95LoadTime,\n\t\tpreviewsUnder3Seconds,\n\t\tpreviewsUnder3SecondsPercentage,\n\t\ttotalDiagrams: diagramMetrics.length,\n\t\tsuccessfulDiagrams: successfulDiagrams.length,\n\t\tfailedDiagrams: failedDiagrams.length,\n\t\tdiagramSuccessRate,\n\t\tbyDocumentType,\n\t};\n}",
    "start_line": 337,
    "end_line": 425,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getPerformanceSummary",
    "component_id": "src.utils.telemetry.getPerformanceSummary"
  },
  "src.utils.telemetry.meetsPreviewPerformanceTarget": {
    "id": "src.utils.telemetry.meetsPreviewPerformanceTarget",
    "name": "meetsPreviewPerformanceTarget",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.getPerformanceSummary"
    ],
    "source_code": "function meetsPreviewPerformanceTarget(): boolean {\n\tconst summary = getPerformanceSummary();\n\treturn summary.previewsUnder3SecondsPercentage >= 95;\n}",
    "start_line": 432,
    "end_line": 435,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function meetsPreviewPerformanceTarget",
    "component_id": "src.utils.telemetry.meetsPreviewPerformanceTarget"
  },
  "src.utils.telemetry.meetsDiagramSuccessTarget": {
    "id": "src.utils.telemetry.meetsDiagramSuccessTarget",
    "name": "meetsDiagramSuccessTarget",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.getPerformanceSummary"
    ],
    "source_code": "function meetsDiagramSuccessTarget(): boolean {\n\tconst summary = getPerformanceSummary();\n\treturn summary.diagramSuccessRate >= 90;\n}",
    "start_line": 440,
    "end_line": 443,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function meetsDiagramSuccessTarget",
    "component_id": "src.utils.telemetry.meetsDiagramSuccessTarget"
  },
  "src.utils.telemetry.getPerformanceReport": {
    "id": "src.utils.telemetry.getPerformanceReport",
    "name": "getPerformanceReport",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.getPerformanceSummary",
      "src.utils.telemetry.meetsDiagramSuccessTarget",
      "src.utils.telemetry.meetsPreviewPerformanceTarget"
    ],
    "source_code": "function getPerformanceReport(): string {\n\tconst summary = getPerformanceSummary();\n\n\tconst lines = [\n\t\t\"=== Preview Performance Report ===\",\n\t\t\"\",\n\t\t\"Preview Load Times:\",\n\t\t`  Total Previews: ${summary.totalPreviews}`,\n\t\t`  Successful: ${summary.successfulPreviews}`,\n\t\t`  Failed: ${summary.failedPreviews}`,\n\t\t`  Average Load Time: ${summary.averageLoadTime.toFixed(0)}ms`,\n\t\t`  Median Load Time: ${summary.medianLoadTime.toFixed(0)}ms`,\n\t\t`  P95 Load Time: ${summary.p95LoadTime.toFixed(0)}ms`,\n\t\t`  Under 3 seconds: ${summary.previewsUnder3Seconds} (${summary.previewsUnder3SecondsPercentage.toFixed(1)}%)`,\n\t\t`  SC-001 Target (95% < 3s): ${meetsPreviewPerformanceTarget() ? \" PASS\" : \" FAIL\"}`,\n\t\t\"\",\n\t\t\"Diagram Rendering:\",\n\t\t`  Total Diagrams: ${summary.totalDiagrams}`,\n\t\t`  Successful: ${summary.successfulDiagrams}`,\n\t\t`  Failed: ${summary.failedDiagrams}`,\n\t\t`  Success Rate: ${summary.diagramSuccessRate.toFixed(1)}%`,\n\t\t`  SC-002 Target (90% success): ${meetsDiagramSuccessTarget() ? \" PASS\" : \" FAIL\"}`,\n\t\t\"\",\n\t\t\"By Document Type:\",\n\t];\n\n\tfor (const [docType, stats] of summary.byDocumentType.entries()) {\n\t\tlines.push(\n\t\t\t`  ${docType}: ${stats.count} previews, ${stats.averageLoadTime.toFixed(0)}ms avg, ${stats.successRate.toFixed(1)}% success`\n\t\t);\n\t}\n\n\treturn lines.join(\"\\n\");\n}",
    "start_line": 448,
    "end_line": 481,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getPerformanceReport",
    "component_id": "src.utils.telemetry.getPerformanceReport"
  },
  "src.utils.telemetry.clearTelemetry": {
    "id": "src.utils.telemetry.clearTelemetry",
    "name": "clearTelemetry",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.clear"
    ],
    "source_code": "function clearTelemetry(): void {\n\ttelemetryStore.clear();\n}",
    "start_line": 486,
    "end_line": 488,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clearTelemetry",
    "component_id": "src.utils.telemetry.clearTelemetry"
  },
  "src.utils.telemetry.exportMetrics": {
    "id": "src.utils.telemetry.exportMetrics",
    "name": "exportMetrics",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/telemetry.ts",
    "relative_path": "src/utils/telemetry.ts",
    "depends_on": [
      "src.utils.telemetry.getDiagramMetrics",
      "src.utils.telemetry.getPreviewMetrics",
      "src.utils.telemetry.getRefinementMetrics",
      "src.utils.telemetry.PreviewLoadMetrics",
      "src.utils.telemetry.DiagramRenderMetrics",
      "src.utils.telemetry.getFormMetrics",
      "src.utils.telemetry.FormInteractionMetrics",
      "src.utils.telemetry.RefinementRequestMetrics"
    ],
    "source_code": "function exportMetrics(): {\n\tpreviews: readonly PreviewLoadMetrics[];\n\tdiagrams: readonly DiagramRenderMetrics[];\n\tforms: readonly FormInteractionMetrics[];\n\trefinements: readonly RefinementRequestMetrics[];\n} {\n\treturn {\n\t\tpreviews: telemetryStore.getPreviewMetrics(),\n\t\tdiagrams: telemetryStore.getDiagramMetrics(),\n\t\tforms: telemetryStore.getFormMetrics(),\n\t\trefinements: telemetryStore.getRefinementMetrics(),\n\t};\n}",
    "start_line": 493,
    "end_line": 505,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function exportMetrics",
    "component_id": "src.utils.telemetry.exportMetrics"
  },
  "src.utils.workspace-state.hasShownWelcomeBefore": {
    "id": "src.utils.workspace-state.hasShownWelcomeBefore",
    "name": "hasShownWelcomeBefore",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "function hasShownWelcomeBefore(\n\tcontext: vscode.ExtensionContext\n): boolean {\n\treturn context.workspaceState.get<boolean>(WelcomeStateKeys.HAS_SHOWN, false);\n}",
    "start_line": 22,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function hasShownWelcomeBefore",
    "component_id": "src.utils.workspace-state.hasShownWelcomeBefore"
  },
  "src.utils.workspace-state.markWelcomeAsShown": {
    "id": "src.utils.workspace-state.markWelcomeAsShown",
    "name": "markWelcomeAsShown",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [],
    "source_code": "async function markWelcomeAsShown(\n\tcontext: vscode.ExtensionContext\n): Promise<void> {\n\tawait context.workspaceState.update(WelcomeStateKeys.HAS_SHOWN, true);\n}",
    "start_line": 32,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function markWelcomeAsShown",
    "component_id": "src.utils.workspace-state.markWelcomeAsShown"
  },
  "src.utils.workspace-state.getDontShowOnStartup": {
    "id": "src.utils.workspace-state.getDontShowOnStartup",
    "name": "getDontShowOnStartup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [
      "src.features.agents.resource-cache.get"
    ],
    "source_code": "function getDontShowOnStartup(\n\tcontext: vscode.ExtensionContext\n): boolean {\n\treturn context.workspaceState.get<boolean>(WelcomeStateKeys.DONT_SHOW, false);\n}",
    "start_line": 43,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getDontShowOnStartup",
    "component_id": "src.utils.workspace-state.getDontShowOnStartup"
  },
  "src.utils.workspace-state.setDontShowOnStartup": {
    "id": "src.utils.workspace-state.setDontShowOnStartup",
    "name": "setDontShowOnStartup",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [],
    "source_code": "async function setDontShowOnStartup(\n\tcontext: vscode.ExtensionContext,\n\tvalue: boolean\n): Promise<void> {\n\tawait context.workspaceState.update(WelcomeStateKeys.DONT_SHOW, value);\n}",
    "start_line": 54,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function setDontShowOnStartup",
    "component_id": "src.utils.workspace-state.setDontShowOnStartup"
  },
  "src.utils.workspace-state.shouldShowWelcomeAutomatically": {
    "id": "src.utils.workspace-state.shouldShowWelcomeAutomatically",
    "name": "shouldShowWelcomeAutomatically",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [
      "src.utils.workspace-state.getDontShowOnStartup",
      "src.utils.workspace-state.hasShownWelcomeBefore"
    ],
    "source_code": "function shouldShowWelcomeAutomatically(\n\tcontext: vscode.ExtensionContext\n): boolean {\n\t// Don't show if user has opted out\n\tif (getDontShowOnStartup(context)) {\n\t\treturn false;\n\t}\n\n\t// Show if this is first time in workspace\n\treturn !hasShownWelcomeBefore(context);\n}",
    "start_line": 67,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function shouldShowWelcomeAutomatically",
    "component_id": "src.utils.workspace-state.shouldShowWelcomeAutomatically"
  },
  "src.utils.workspace-state.resetWelcomeState": {
    "id": "src.utils.workspace-state.resetWelcomeState",
    "name": "resetWelcomeState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [],
    "source_code": "async function resetWelcomeState(\n\tcontext: vscode.ExtensionContext\n): Promise<void> {\n\tawait context.workspaceState.update(WelcomeStateKeys.HAS_SHOWN, undefined);\n\tawait context.workspaceState.update(WelcomeStateKeys.DONT_SHOW, undefined);\n}",
    "start_line": 83,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function resetWelcomeState",
    "component_id": "src.utils.workspace-state.resetWelcomeState"
  },
  "src.utils.workspace-state.getWelcomeState": {
    "id": "src.utils.workspace-state.getWelcomeState",
    "name": "getWelcomeState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/src/utils/workspace-state.ts",
    "relative_path": "src/utils/workspace-state.ts",
    "depends_on": [
      "src.utils.workspace-state.getDontShowOnStartup",
      "src.utils.workspace-state.hasShownWelcomeBefore"
    ],
    "source_code": "function getWelcomeState(context: vscode.ExtensionContext): {\n\thasShown: boolean;\n\tdontShow: boolean;\n} {\n\treturn {\n\t\thasShown: hasShownWelcomeBefore(context) ?? false,\n\t\tdontShow: getDontShowOnStartup(context) ?? false,\n\t};\n}",
    "start_line": 94,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getWelcomeState",
    "component_id": "src.utils.workspace-state.getWelcomeState"
  },
  "ui.src.bridge.vscode.VsCodeApi": {
    "id": "ui.src.bridge.vscode.VsCodeApi",
    "name": "VsCodeApi",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/bridge/vscode.ts",
    "relative_path": "ui/src/bridge/vscode.ts",
    "depends_on": [],
    "source_code": "interface VsCodeApi {\n\tpostMessage: (message: any) => void;\n\tgetState: () => any;\n\tsetState: (state: any) => void;\n}",
    "start_line": 3,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface VsCodeApi",
    "component_id": "ui.src.bridge.vscode.VsCodeApi"
  },
  "ui.src.bridge.vscode.Window": {
    "id": "ui.src.bridge.vscode.Window",
    "name": "Window",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/bridge/vscode.ts",
    "relative_path": "ui/src/bridge/vscode.ts",
    "depends_on": [
      "ui.src.bridge.vscode.VsCodeApi"
    ],
    "source_code": "interface Window {\n\t\tacquireVsCodeApi?: () => VsCodeApi;\n\t}",
    "start_line": 10,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Window",
    "component_id": "ui.src.bridge.vscode.Window"
  },
  "ui.src.components.cli-options.collapsible-section.CollapsibleSectionProps": {
    "id": "ui.src.components.cli-options.collapsible-section.CollapsibleSectionProps",
    "name": "CollapsibleSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/cli-options/collapsible-section.tsx",
    "relative_path": "ui/src/components/cli-options/collapsible-section.tsx",
    "depends_on": [],
    "source_code": "interface CollapsibleSectionProps {\n\t/** Section title */\n\ttitle: string;\n\t/** Whether the section is open by default */\n\tdefaultOpen?: boolean;\n\t/** Optional badge text (e.g., \"Modified\", \"3 items\") */\n\tbadge?: string;\n\t/** Section content */\n\tchildren: React.ReactNode;\n\t/** Additional CSS class */\n\tclassName?: string;\n\t/** Callback when section is toggled */\n\tonToggle?: (isOpen: boolean) => void;\n}",
    "start_line": 5,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CollapsibleSectionProps",
    "component_id": "ui.src.components.cli-options.collapsible-section.CollapsibleSectionProps"
  },
  "ui.src.components.cli-options.collapsible-section.CollapsibleSection": {
    "id": "ui.src.components.cli-options.collapsible-section.CollapsibleSection",
    "name": "CollapsibleSection",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/cli-options/collapsible-section.tsx",
    "relative_path": "ui/src/components/cli-options/collapsible-section.tsx",
    "depends_on": [
      "ui.src.components.cli-options.collapsible-section.CollapsibleSectionProps"
    ],
    "source_code": "function CollapsibleSection({\n\ttitle,\n\tdefaultOpen = false,\n\tbadge,\n\tchildren,\n\tclassName = \"\",\n\tonToggle,\n}: CollapsibleSectionProps) {\n\tconst [isOpen, setIsOpen] = useState(defaultOpen);\n\n\tconst handleToggle = () => {\n\t\tconst newState = !isOpen;\n\t\tsetIsOpen(newState);\n\t\tonToggle?.(newState);\n\t};\n\n\tconst handleKeyDown = (e: React.KeyboardEvent) => {\n\t\tif (e.key === \"Enter\" || e.key === \" \") {\n\t\t\te.preventDefault();\n\t\t\thandleToggle();\n\t\t}\n\t};\n\n\treturn (\n\t\t<div className={`collapsible-section ${className}`}>\n\t\t\t<button\n\t\t\t\taria-expanded={isOpen}\n\t\t\t\tclassName=\"collapsible-section-header\"\n\t\t\t\tonClick={handleToggle}\n\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\ttype=\"button\"\n\t\t\t>\n\t\t\t\t<svg\n\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\tclassName={`collapsible-section-arrow ${isOpen ? \"open\" : \"\"}`}\n\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t>\n\t\t\t\t\t<path d=\"M6 4l4 4-4 4V4z\" />\n\t\t\t\t</svg>\n\t\t\t\t<span className=\"collapsible-section-title\">{title}</span>\n\t\t\t\t{badge && <span className=\"collapsible-section-badge\">{badge}</span>}\n\t\t\t</button>\n\t\t\t{isOpen && <div className=\"collapsible-section-content\">{children}</div>}\n\t\t</div>\n\t);\n}",
    "start_line": 28,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function CollapsibleSection",
    "component_id": "ui.src.components.cli-options.collapsible-section.CollapsibleSection"
  },
  "ui.src.components.cli-options.info-tooltip.InfoTooltipProps": {
    "id": "ui.src.components.cli-options.info-tooltip.InfoTooltipProps",
    "name": "InfoTooltipProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/cli-options/info-tooltip.tsx",
    "relative_path": "ui/src/components/cli-options/info-tooltip.tsx",
    "depends_on": [],
    "source_code": "interface InfoTooltipProps {\n\t/** Tooltip title */\n\ttitle: string;\n\t/** Detailed description */\n\tdescription: string;\n\t/** Optional warning message (displayed in yellow/orange) */\n\twarning?: string;\n\t/** Optional \"Learn more\" URL */\n\tlearnMoreUrl?: string;\n\t/** Position of the tooltip relative to the icon */\n\tposition?: \"top\" | \"bottom\" | \"left\" | \"right\";\n\t/** Additional CSS class */\n\tclassName?: string;\n}",
    "start_line": 5,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InfoTooltipProps",
    "component_id": "ui.src.components.cli-options.info-tooltip.InfoTooltipProps"
  },
  "ui.src.components.cli-options.multi-input.MultiInputProps": {
    "id": "ui.src.components.cli-options.multi-input.MultiInputProps",
    "name": "MultiInputProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/cli-options/multi-input.tsx",
    "relative_path": "ui/src/components/cli-options/multi-input.tsx",
    "depends_on": [],
    "source_code": "interface MultiInputProps {\n\t/** Array of string values */\n\tvalue: string[];\n\t/** Called when values change */\n\tonChange: (values: string[]) => void;\n\t/** Placeholder text when empty */\n\tplaceholder?: string;\n\t/** Whether the input is disabled */\n\tdisabled?: boolean;\n\t/** Label for the input */\n\tlabel?: string;\n\t/** Additional CSS class */\n\tclassName?: string;\n}",
    "start_line": 4,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MultiInputProps",
    "component_id": "ui.src.components.cli-options.multi-input.MultiInputProps"
  },
  "ui.src.components.forms.preview-form-field.PreviewFormFieldProps": {
    "id": "ui.src.components.forms.preview-form-field.PreviewFormFieldProps",
    "name": "PreviewFormFieldProps",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/forms/preview-form-field.tsx",
    "relative_path": "ui/src/components/forms/preview-form-field.tsx",
    "depends_on": [],
    "source_code": "type PreviewFormFieldProps =\n\t| TextFieldProps\n\t| TextareaFieldProps\n\t| CheckboxFieldProps\n\t| DropdownFieldProps\n\t| MultiselectFieldProps;",
    "start_line": 70,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewFormFieldProps",
    "component_id": "ui.src.components.forms.preview-form-field.PreviewFormFieldProps"
  },
  "ui.src.components.forms.preview-form-field.PreviewFormField": {
    "id": "ui.src.components.forms.preview-form-field.PreviewFormField",
    "name": "PreviewFormField",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/forms/preview-form-field.tsx",
    "relative_path": "ui/src/components/forms/preview-form-field.tsx",
    "depends_on": [
      "ui.src.components.forms.preview-form-field.PreviewFormFieldProps"
    ],
    "source_code": "function PreviewFormField(props: PreviewFormFieldProps) {\n\tswitch (props.type) {\n\t\tcase \"text\":\n\t\t\treturn <TextField {...props} />;\n\t\tcase \"textarea\":\n\t\t\treturn <TextareaField {...props} />;\n\t\tcase \"checkbox\":\n\t\t\treturn <CheckboxField {...props} />;\n\t\tcase \"dropdown\":\n\t\t\treturn <DropdownField {...props} />;\n\t\tcase \"multiselect\":\n\t\t\treturn <MultiselectField {...props} />;\n\t\tdefault:\n\t\t\t// @ts-expect-error - exhaustive check\n\t\t\tconsole.warn(`[PreviewFormField] Unsupported field type: ${props.type}`);\n\t\t\treturn null;\n\t}\n}",
    "start_line": 81,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "props"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function PreviewFormField",
    "component_id": "ui.src.components.forms.preview-form-field.PreviewFormField"
  },
  "ui.src.components.icon-button.IconButtonProps": {
    "id": "ui.src.components.icon-button.IconButtonProps",
    "name": "IconButtonProps",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/icon-button.tsx",
    "relative_path": "ui/src/components/icon-button.tsx",
    "depends_on": [],
    "source_code": "type IconButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n\t/** Extra Tailwind classes to append */\n\tclassName?: string;\n\t/** Inline style override/merge */\n\tstyle?: React.CSSProperties;\n\t/** Accessible label for screen readers */\n\t\"aria-label\"?: string;\n\tchildren: React.ReactNode;\n};",
    "start_line": 3,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type IconButtonProps",
    "component_id": "ui.src.components.icon-button.IconButtonProps"
  },
  "ui.src.components.icon-button.IconButton": {
    "id": "ui.src.components.icon-button.IconButton",
    "name": "IconButton",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/icon-button.tsx",
    "relative_path": "ui/src/components/icon-button.tsx",
    "depends_on": [
      "ui.src.components.icon-button.IconButtonProps"
    ],
    "source_code": "function IconButton({\n\tclassName,\n\tstyle,\n\ttype,\n\tchildren,\n\t...rest\n}: IconButtonProps) {\n\treturn (\n\t\t<button\n\t\t\tclassName={`flex h-6 w-6 cursor-pointer items-center justify-center rounded-full ${className ?? \"\"}`}",
    "start_line": 17,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function IconButton",
    "component_id": "ui.src.components.icon-button.IconButton"
  },
  "ui.src.components.pill-button.PillButtonProps": {
    "id": "ui.src.components.pill-button.PillButtonProps",
    "name": "PillButtonProps",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/pill-button.tsx",
    "relative_path": "ui/src/components/pill-button.tsx",
    "depends_on": [],
    "source_code": "type PillButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {\n\tclassName?: string;\n\tstyle?: React.CSSProperties;\n\tchildren: React.ReactNode;\n};",
    "start_line": 3,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PillButtonProps",
    "component_id": "ui.src.components.pill-button.PillButtonProps"
  },
  "ui.src.components.pill-button.PillButton": {
    "id": "ui.src.components.pill-button.PillButton",
    "name": "PillButton",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/pill-button.tsx",
    "relative_path": "ui/src/components/pill-button.tsx",
    "depends_on": [
      "ui.src.components.pill-button.PillButtonProps"
    ],
    "source_code": "function PillButton({\n\tclassName,\n\tstyle,\n\ttype,\n\tchildren,\n\t...rest\n}: PillButtonProps) {\n\treturn (\n\t\t<button\n\t\t\tclassName={[\n\t\t\t\t\"inline-flex select-none items-center gap-1 rounded-full border-[1px] px-3 py-1.5 text-xs transition-colors\",\n\t\t\t\t\"hover:bg-[color:var(--vscode-button-background,#7c3aed)]/10\",\n\t\t\t\t\"cursor-pointer focus-visible:outline-none focus-visible:ring-1\",\n\t\t\t\tclassName ?? \"\",\n\t\t\t].join(\" \")}\n\t\t\tstyle={{\n\t\t\t\tborderColor:\n\t\t\t\t\t\"color-mix(in srgb, var(--vscode-foreground) 10%, transparent)\",\n\t\t\t\tcolor: \"var(--vscode-textLink-foreground)\",\n\t\t\t\t...(style ?? {}),\n\t\t\t}}\n\t\t\ttype={type ?? \"button\"}\n\t\t\t{...rest}\n\t\t>\n\t\t\t{children}\n\t\t</button>\n\t);\n}",
    "start_line": 13,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function PillButton",
    "component_id": "ui.src.components.pill-button.PillButton"
  },
  "ui.src.components.preview.document-outline.OutlineSection": {
    "id": "ui.src.components.preview.document-outline.OutlineSection",
    "name": "OutlineSection",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/preview/document-outline.tsx",
    "relative_path": "ui/src/components/preview/document-outline.tsx",
    "depends_on": [],
    "source_code": "interface OutlineSection {\n\tid: string;\n\ttitle: string;\n\ttitleHtml?: string;\n}",
    "start_line": 1,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface OutlineSection",
    "component_id": "ui.src.components.preview.document-outline.OutlineSection"
  },
  "ui.src.components.preview.document-outline.DocumentOutlineProps": {
    "id": "ui.src.components.preview.document-outline.DocumentOutlineProps",
    "name": "DocumentOutlineProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/preview/document-outline.tsx",
    "relative_path": "ui/src/components/preview/document-outline.tsx",
    "depends_on": [
      "ui.src.components.preview.document-outline.OutlineSection"
    ],
    "source_code": "interface DocumentOutlineProps {\n\tsections?: OutlineSection[];\n\tonNavigate?: (sectionId: string) => void;\n}",
    "start_line": 7,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentOutlineProps",
    "component_id": "ui.src.components.preview.document-outline.DocumentOutlineProps"
  },
  "ui.src.components.preview.document-outline.DocumentOutline": {
    "id": "ui.src.components.preview.document-outline.DocumentOutline",
    "name": "DocumentOutline",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/preview/document-outline.tsx",
    "relative_path": "ui/src/components/preview/document-outline.tsx",
    "depends_on": [
      "ui.src.components.preview.document-outline.DocumentOutlineProps"
    ],
    "source_code": "DocumentOutline = ({\n\tsections = [],\n\tonNavigate,\n}: DocumentOutlineProps) => {\n\tif (sections.length === 0) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<nav\n\t\t\taria-label=\"Document outline\"\n\t\t\tclassName=\"rounded border border-[color:var(--vscode-input-border,#3c3c3c)] bg-[color:var(--vscode-tree-tableOddRowsBackground,transparent)] px-3 py-3 text-sm\"\n\t\t>\n\t\t\t<p className=\"mb-2 text-[color:var(--vscode-descriptionForeground,rgba(255,255,255,0.65))] text-xs uppercase tracking-wide\">\n\t\t\t\tOutline\n\t\t\t</p>\n\t\t\t<ul className=\"flex flex-col gap-1\">\n\t\t\t\t{sections.map((section) => (\n\t\t\t\t\t<li key={section.id}>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName=\"w-full truncate rounded border border-transparent px-2 py-1 text-left text-[color:var(--vscode-foreground)] transition-colors hover:border-[color:var(--vscode-focusBorder,#0078d4)]\"\n\t\t\t\t\t\t\tonClick={() => onNavigate?.(section.id)}\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{section.titleHtml ? (\n\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t/* biome-ignore lint/security/noDangerouslySetInnerHtml: Markdown is rendered via markdown-it before reaching the webview. */\n\t\t\t\t\t\t\t\t\tdangerouslySetInnerHTML={{ __html: section.titleHtml }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t\tsection.title\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</li>\n\t\t\t\t))}\n\t\t\t</ul>\n\t\t</nav>\n\t);\n}",
    "start_line": 12,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function DocumentOutline",
    "component_id": "ui.src.components.preview.document-outline.DocumentOutline"
  },
  "ui.src.components.refine.refine-dialog.RefineDialogValues": {
    "id": "ui.src.components.refine.refine-dialog.RefineDialogValues",
    "name": "RefineDialogValues",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/refine/refine-dialog.tsx",
    "relative_path": "ui/src/components/refine/refine-dialog.tsx",
    "depends_on": [
      "ui.src.features.preview.types.PreviewRefinementIssueType"
    ],
    "source_code": "interface RefineDialogValues {\n\tsectionRef?: string;\n\tissueType: PreviewRefinementIssueType;\n\tdescription: string;\n}",
    "start_line": 6,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RefineDialogValues",
    "component_id": "ui.src.components.refine.refine-dialog.RefineDialogValues"
  },
  "ui.src.components.spec-explorer.change-request-form.ChangeRequestFormValues": {
    "id": "ui.src.components.spec-explorer.change-request-form.ChangeRequestFormValues",
    "name": "ChangeRequestFormValues",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/change-request-form.tsx",
    "relative_path": "ui/src/components/spec-explorer/change-request-form.tsx",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequestSeverity"
    ],
    "source_code": "interface ChangeRequestFormValues {\n\ttitle: string;\n\tdescription: string;\n\tseverity: ChangeRequestSeverity;\n\tsubmitter?: string;\n}",
    "start_line": 13,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChangeRequestFormValues",
    "component_id": "ui.src.components.spec-explorer.change-request-form.ChangeRequestFormValues"
  },
  "ui.src.components.spec-explorer.change-request-form.ExistingChangeRequest": {
    "id": "ui.src.components.spec-explorer.change-request-form.ExistingChangeRequest",
    "name": "ExistingChangeRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/change-request-form.tsx",
    "relative_path": "ui/src/components/spec-explorer/change-request-form.tsx",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequestStatus",
      "ui.src.services.spec-explorer.ChangeRequestSeverity"
    ],
    "source_code": "interface ExistingChangeRequest {\n\tid: string;\n\ttitle: string;\n\tseverity: ChangeRequestSeverity;\n\tstatus: ChangeRequestStatus;\n}",
    "start_line": 20,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExistingChangeRequest",
    "component_id": "ui.src.components.spec-explorer.change-request-form.ExistingChangeRequest"
  },
  "ui.src.components.spec-explorer.changes-list.ChangeRequestStatus": {
    "id": "ui.src.components.spec-explorer.changes-list.ChangeRequestStatus",
    "name": "ChangeRequestStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/changes-list.tsx",
    "relative_path": "ui/src/components/spec-explorer/changes-list.tsx",
    "depends_on": [],
    "source_code": "type ChangeRequestStatus =\n\t| \"open\"\n\t| \"blocked\"\n\t| \"inProgress\"\n\t| \"addressed\";",
    "start_line": 10,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeRequestStatus",
    "component_id": "ui.src.components.spec-explorer.changes-list.ChangeRequestStatus"
  },
  "ui.src.components.spec-explorer.changes-list.ChangeRequestSeverity": {
    "id": "ui.src.components.spec-explorer.changes-list.ChangeRequestSeverity",
    "name": "ChangeRequestSeverity",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/changes-list.tsx",
    "relative_path": "ui/src/components/spec-explorer/changes-list.tsx",
    "depends_on": [],
    "source_code": "type ChangeRequestSeverity = \"low\" | \"medium\" | \"high\" | \"critical\";",
    "start_line": 15,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeRequestSeverity",
    "component_id": "ui.src.components.spec-explorer.changes-list.ChangeRequestSeverity"
  },
  "ui.src.components.spec-explorer.changes-list.ChangeRequest": {
    "id": "ui.src.components.spec-explorer.changes-list.ChangeRequest",
    "name": "ChangeRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/changes-list.tsx",
    "relative_path": "ui/src/components/spec-explorer/changes-list.tsx",
    "depends_on": [
      "ui.src.components.spec-explorer.changes-list.ChangeRequestSeverity",
      "ui.src.components.spec-explorer.changes-list.ChangeRequestStatus"
    ],
    "source_code": "interface ChangeRequest {\n\tid: string;\n\tspecId: string;\n\ttitle: string;\n\tdescription: string;\n\tseverity: ChangeRequestSeverity;\n\tstatus: ChangeRequestStatus;\n\ttasks: any[];\n\tsubmitter: string;\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n\tsentToTasksAt: Date | null;\n\tnotes?: string;\n}",
    "start_line": 17,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChangeRequest",
    "component_id": "ui.src.components.spec-explorer.changes-list.ChangeRequest"
  },
  "ui.src.components.spec-explorer.changes-list.Specification": {
    "id": "ui.src.components.spec-explorer.changes-list.Specification",
    "name": "Specification",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/changes-list.tsx",
    "relative_path": "ui/src/components/spec-explorer/changes-list.tsx",
    "depends_on": [
      "ui.src.components.spec-explorer.changes-list.ChangeRequest"
    ],
    "source_code": "interface Specification {\n\tid: string;\n\ttitle: string;\n\towner: string;\n\tstatus: string;\n\tcompletedAt: Date | null;\n\tupdatedAt: Date;\n\tlinks: { specPath: string; docUrl?: string };\n\tchangeRequests?: ChangeRequest[];\n}",
    "start_line": 32,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Specification",
    "component_id": "ui.src.components.spec-explorer.changes-list.Specification"
  },
  "ui.src.components.spec-explorer.changes-list.ChangesListItem": {
    "id": "ui.src.components.spec-explorer.changes-list.ChangesListItem",
    "name": "ChangesListItem",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/spec-explorer/changes-list.tsx",
    "relative_path": "ui/src/components/spec-explorer/changes-list.tsx",
    "depends_on": [
      "ui.src.components.spec-explorer.changes-list.Specification",
      "ui.src.components.spec-explorer.changes-list.ChangeRequest"
    ],
    "source_code": "interface ChangesListItem {\n\tspec: Specification;\n\tchangeRequest: ChangeRequest;\n}",
    "start_line": 43,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChangesListItem",
    "component_id": "ui.src.components.spec-explorer.changes-list.ChangesListItem"
  },
  "ui.src.components.textarea-panel.TextareaPanelProps": {
    "id": "ui.src.components.textarea-panel.TextareaPanelProps",
    "name": "TextareaPanelProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/textarea-panel.tsx",
    "relative_path": "ui/src/components/textarea-panel.tsx",
    "depends_on": [],
    "source_code": "interface TextareaPanelProps {\n\tvalue: string;\n\tonChange: React.ChangeEventHandler<HTMLTextAreaElement>;\n\tonKeyDown?: React.KeyboardEventHandler<HTMLTextAreaElement>;\n\tplaceholder?: string;\n\tdisabled?: boolean;\n\trows?: number;\n\ttextareaRef?: React.Ref<HTMLTextAreaElement>;\n\ttextareaProps?: React.TextareaHTMLAttributes<HTMLTextAreaElement>;\n\t/** Additional classes for the textarea element */\n\ttextareaClassName?: string;\n\t/** Additional classes for the container */\n\tcontainerClassName?: string;\n\t/** Optional inline style for container */\n\tcontainerStyle?: React.CSSProperties;\n\tchildren?: React.ReactNode;\n}",
    "start_line": 4,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TextareaPanelProps",
    "component_id": "ui.src.components.textarea-panel.TextareaPanelProps"
  },
  "ui.src.components.textarea-panel.TextareaPanel": {
    "id": "ui.src.components.textarea-panel.TextareaPanel",
    "name": "TextareaPanel",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/textarea-panel.tsx",
    "relative_path": "ui/src/components/textarea-panel.tsx",
    "depends_on": [
      "ui.src.components.textarea-panel.TextareaPanelProps"
    ],
    "source_code": "function TextareaPanel({\n\tvalue,\n\tonChange,\n\tonKeyDown,\n\tplaceholder,\n\tdisabled,\n\trows = 1,\n\ttextareaRef,\n\ttextareaProps,\n\ttextareaClassName,\n\tcontainerClassName,\n\tcontainerStyle,\n\tchildren,\n}: TextareaPanelProps) {\n\tconst textareaInternalRef = useRef<HTMLTextAreaElement | null>(null);\n\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: ignore\n\tuseLayoutEffect(() => {\n\t\tconst node = textareaInternalRef.current;\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tnode.style.height = \"auto\";\n\t\tnode.style.height = `${node.scrollHeight}px`;\n\t}, [value]);\n\n\tconst assignTextareaRef = (node: HTMLTextAreaElement | null) => {\n\t\ttextareaInternalRef.current = node;\n\n\t\tif (!textareaRef) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof textareaRef === \"function\") {\n\t\t\ttextareaRef(node);\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof textareaRef === \"object\") {\n\t\t\t(\n\t\t\t\ttextareaRef as React.MutableRefObject<HTMLTextAreaElement | null>\n\t\t\t).current = node;\n\t\t}\n\t};\n\n\treturn (\n\t\t<div\n\t\t\tclassName={\n\t\t\t\t\"box-border flex h-full w-full min-w-0 flex-col gap-2 rounded-2xl border bg-[var(--vscode-dropdown-background)] pt-4 pb-2\" +\n\t\t\t\t(containerClassName ?? \"\")\n\t\t\t}\n\t\t\tstyle={{\n\t\t\t\tborderColor:\n\t\t\t\t\t\"color-mix(in srgb, var(--vscode-foreground) 10%, transparent)\",\n\t\t\t\t...(containerStyle ?? {}),\n\t\t\t}}\n\t\t>\n\t\t\t<div className=\"h-full min-w-0 flex-1\">\n\t\t\t\t<textarea\n\t\t\t\t\tclassName={\n\t\t\t\t\t\t\"w-full resize-none overflow-x-hidden bg-transparent px-3 text-[color:var(--vscode-foreground)] outline-none ring-0 placeholder:text-[color:var(--vscode-input-placeholderForeground,#888)]\" +\n\t\t\t\t\t\t(textareaClassName ?? \"\")\n\t\t\t\t\t}\n\t\t\t\t\tdisabled={!!disabled}\n\t\t\t\t\tonChange={onChange}\n\t\t\t\t\tonKeyDown={onKeyDown}\n\t\t\t\t\tplaceholder={placeholder}\n\t\t\t\t\tref={assignTextareaRef}\n\t\t\t\t\trows={rows}\n\t\t\t\t\t{...(textareaProps ?? {})}\n\t\t\t\t\tvalue={value}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t{children}\n\t\t</div>\n\t);\n}",
    "start_line": 26,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function TextareaPanel",
    "component_id": "ui.src.components.textarea-panel.TextareaPanel"
  },
  "ui.src.components.ui.button.cn": {
    "id": "ui.src.components.ui.button.cn",
    "name": "cn",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/ui/button.tsx",
    "relative_path": "ui/src/components/ui/button.tsx",
    "depends_on": [],
    "source_code": "cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }",
    "start_line": 52,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method cn",
    "component_id": "ui.src.components.ui.button.cn"
  },
  "ui.src.components.ui.vscode-checkbox.VSCodeCheckboxProps": {
    "id": "ui.src.components.ui.vscode-checkbox.VSCodeCheckboxProps",
    "name": "VSCodeCheckboxProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/ui/vscode-checkbox.tsx",
    "relative_path": "ui/src/components/ui/vscode-checkbox.tsx",
    "depends_on": [],
    "source_code": "interface VSCodeCheckboxProps\n\textends Omit<InputHTMLAttributes<HTMLInputElement>, \"type\"> {\n\t/**\n\t * Whether the checkbox is in an indeterminate state\n\t * (partially selected, used for parent checkboxes)\n\t */\n\tindeterminate?: boolean;\n\t/**\n\t * Optional label to display next to the checkbox\n\t */\n\tlabel?: ReactNode;\n\t/**\n\t * Size variant for the checkbox\n\t */\n\tsize?: \"sm\" | \"md\" | \"lg\";\n}",
    "start_line": 5,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface VSCodeCheckboxProps",
    "component_id": "ui.src.components.ui.vscode-checkbox.VSCodeCheckboxProps"
  },
  "ui.src.components.ui.vscode-select.VSCodeSelectProps": {
    "id": "ui.src.components.ui.vscode-select.VSCodeSelectProps",
    "name": "VSCodeSelectProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/components/ui/vscode-select.tsx",
    "relative_path": "ui/src/components/ui/vscode-select.tsx",
    "depends_on": [],
    "source_code": "interface VSCodeSelectProps\n\textends SelectHTMLAttributes<HTMLSelectElement> {\n\t/**\n\t * Optional label to display above the select\n\t */\n\tlabel?: ReactNode;\n\t/**\n\t * Whether the label should include a required indicator\n\t */\n\trequired?: boolean;\n\t/**\n\t * Optional description text below the select\n\t */\n\tdescription?: ReactNode;\n\t/**\n\t * Optional error message to display\n\t */\n\terror?: string;\n\t/**\n\t * Size variant for the select\n\t */\n\tsize?: \"sm\" | \"md\" | \"lg\";\n}",
    "start_line": 5,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface VSCodeSelectProps",
    "component_id": "ui.src.components.ui.vscode-select.VSCodeSelectProps"
  },
  "ui.src.features.create-spec-view.components.status-banner.StatusTone": {
    "id": "ui.src.features.create-spec-view.components.status-banner.StatusTone",
    "name": "StatusTone",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/components/status-banner.tsx",
    "relative_path": "ui/src/features/create-spec-view/components/status-banner.tsx",
    "depends_on": [],
    "source_code": "type StatusTone = \"info\" | \"warning\" | \"error\";",
    "start_line": 3,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type StatusTone",
    "component_id": "ui.src.features.create-spec-view.components.status-banner.StatusTone"
  },
  "ui.src.features.create-spec-view.components.status-banner.StatusBannerProps": {
    "id": "ui.src.features.create-spec-view.components.status-banner.StatusBannerProps",
    "name": "StatusBannerProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/components/status-banner.tsx",
    "relative_path": "ui/src/features/create-spec-view/components/status-banner.tsx",
    "depends_on": [
      "ui.src.features.create-spec-view.components.status-banner.StatusTone"
    ],
    "source_code": "interface StatusBannerProps {\n\tchildren: ReactNode;\n\ttone: StatusTone;\n\trole: \"status\" | \"alert\";\n\tariaLive?: \"polite\" | \"assertive\";\n}",
    "start_line": 5,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface StatusBannerProps",
    "component_id": "ui.src.features.create-spec-view.components.status-banner.StatusBannerProps"
  },
  "ui.src.features.create-spec-view.components.status-banner.StatusBanner": {
    "id": "ui.src.features.create-spec-view.components.status-banner.StatusBanner",
    "name": "StatusBanner",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/components/status-banner.tsx",
    "relative_path": "ui/src/features/create-spec-view/components/status-banner.tsx",
    "depends_on": [
      "ui.src.features.create-spec-view.components.status-banner.StatusBannerProps"
    ],
    "source_code": "StatusBanner = ({\n\tchildren,\n\ttone,\n\trole,\n\tariaLive = \"polite\",\n}: StatusBannerProps) => (\n\t<div\n\t\taria-live={ariaLive}\n\t\tclassName={`flex items-center gap-2 rounded-md border px-3 py-2 text-sm ${STATUS_TONE_CLASSES[tone]}`}\n\t\trole={role}\n\t>\n\t\t{children}\n\t</div>\n)",
    "start_line": 20,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function StatusBanner",
    "component_id": "ui.src.features.create-spec-view.components.status-banner.StatusBanner"
  },
  "ui.src.features.create-spec-view.index.normalizeFormData": {
    "id": "ui.src.features.create-spec-view.index.normalizeFormData",
    "name": "normalizeFormData",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/index.tsx",
    "relative_path": "ui/src/features/create-spec-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecFormData"
    ],
    "source_code": "normalizeFormData = (\n\tdata: Partial<CreateSpecFormData> | undefined\n): CreateSpecFormData => ({\n\tproductContext:\n\t\ttypeof data?.productContext === \"string\" ? data.productContext : \"\",\n\tkeyScenarios: typeof data?.keyScenarios === \"string\" ? data.keyScenarios : \"\",\n\ttechnicalConstraints:\n\t\ttypeof data?.technicalConstraints === \"string\"\n\t\t\t? data.technicalConstraints\n\t\t\t: \"\",\n\trelatedFiles: typeof data?.relatedFiles === \"string\" ? data.relatedFiles : \"\",\n\topenQuestions:\n\t\ttypeof data?.openQuestions === \"string\" ? data.openQuestions : \"\",\n})",
    "start_line": 31,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function normalizeFormData",
    "component_id": "ui.src.features.create-spec-view.index.normalizeFormData"
  },
  "ui.src.features.create-spec-view.index.areFormsEqual": {
    "id": "ui.src.features.create-spec-view.index.areFormsEqual",
    "name": "areFormsEqual",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/index.tsx",
    "relative_path": "ui/src/features/create-spec-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecFormData"
    ],
    "source_code": "areFormsEqual = (\n\tleft: CreateSpecFormData,\n\tright: CreateSpecFormData\n): boolean =>\n\tleft.productContext === right.productContext &&\n\tleft.keyScenarios === right.keyScenarios &&\n\tleft.technicalConstraints === right.technicalConstraints &&\n\tleft.relatedFiles === right.relatedFiles &&\n\tleft.openQuestions === right.openQuestions",
    "start_line": 46,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "left",
      "right"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function areFormsEqual",
    "component_id": "ui.src.features.create-spec-view.index.areFormsEqual"
  },
  "ui.src.features.create-spec-view.index.formatTimestamp": {
    "id": "ui.src.features.create-spec-view.index.formatTimestamp",
    "name": "formatTimestamp",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/index.tsx",
    "relative_path": "ui/src/features/create-spec-view/index.tsx",
    "depends_on": [],
    "source_code": "formatTimestamp = (timestamp: number | undefined): string | undefined => {\n\tif (!timestamp) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn new Intl.DateTimeFormat(undefined, {\n\t\t\thour: \"2-digit\",\n\t\t\tminute: \"2-digit\",\n\t\t}).format(new Date(timestamp));\n\t} catch {\n\t\treturn;\n\t}\n}",
    "start_line": 56,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "timestamp"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function formatTimestamp",
    "component_id": "ui.src.features.create-spec-view.index.formatTimestamp"
  },
  "ui.src.features.create-spec-view.index.readPersistedDraft": {
    "id": "ui.src.features.create-spec-view.index.readPersistedDraft",
    "name": "readPersistedDraft",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/index.tsx",
    "relative_path": "ui/src/features/create-spec-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecDraftState",
      "ui.src.features.create-spec-view.index.normalizeFormData",
      "ui.src.stores.spec-explorer-store.getState"
    ],
    "source_code": "readPersistedDraft = (): CreateSpecDraftState | undefined => {\n\tconst raw = vscode.getState() as CreateSpecDraftState | undefined;\n\tif (!raw) {\n\t\treturn;\n\t}\n\n\tif (!raw.formData || typeof raw.lastUpdated !== \"number\") {\n\t\treturn;\n\t}\n\n\treturn {\n\t\tformData: normalizeFormData(raw.formData),\n\t\tlastUpdated: raw.lastUpdated,\n\t};\n}",
    "start_line": 71,
    "end_line": 85,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function readPersistedDraft",
    "component_id": "ui.src.features.create-spec-view.index.readPersistedDraft"
  },
  "ui.src.features.create-spec-view.index.CreateSpecView": {
    "id": "ui.src.features.create-spec-view.index.CreateSpecView",
    "name": "CreateSpecView",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/index.tsx",
    "relative_path": "ui/src/features/create-spec-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecDraftState",
      "ui.src.features.create-spec-view.types.CreateSpecInitPayload",
      "ui.src.features.create-spec-view.index.formatTimestamp",
      "ui.src.features.create-spec-view.types.CreateSpecExtensionMessage",
      "ui.src.features.create-spec-view.index.areFormsEqual",
      "ui.src.features.create-spec-view.index.normalizeFormData",
      "src.panels.welcome-screen-panel.postMessage",
      "ui.src.features.create-spec-view.types.CreateSpecFormData",
      "ui.src.features.create-spec-view.index.readPersistedDraft"
    ],
    "source_code": "CreateSpecView = () => {\n\tconst [formData, setFormData] = useState<CreateSpecFormData>(EMPTY_FORM);\n\tconst [isSubmitting, setIsSubmitting] = useState(false);\n\tconst [fieldErrors, setFieldErrors] = useState<CreateSpecFieldErrors>({});\n\tconst [submissionError, setSubmissionError] = useState<string | undefined>();\n\tconst [draftSavedAt, setDraftSavedAt] = useState<number | undefined>();\n\tconst [closeWarningVisible, setCloseWarningVisible] = useState(false);\n\n\tconst lastPersistedRef = useRef<CreateSpecFormData>(EMPTY_FORM);\n\t// const autosaveTimeoutRef = useRef<number | undefined>();\n\n\tconst productContextRef = useRef<HTMLTextAreaElement>(null);\n\tconst keyScenariosRef = useRef<HTMLTextAreaElement>(null);\n\tconst technicalConstraintsRef = useRef<HTMLTextAreaElement>(null);\n\tconst relatedFilesRef = useRef<HTMLTextAreaElement>(null);\n\tconst openQuestionsRef = useRef<HTMLTextAreaElement>(null);\n\n\tconst isDirty = useMemo(\n\t\t() => !areFormsEqual(formData, lastPersistedRef.current),\n\t\t[formData]\n\t);\n\n\t// const clearAutosaveTimer = useCallback(() => {\n\t// \tif (autosaveTimeoutRef.current) {\n\t// \t\twindow.clearTimeout(autosaveTimeoutRef.current);\n\t// \t\tautosaveTimeoutRef.current = undefined;\n\t// \t}\n\t// }, []);\n\n\tconst persistDraft = useCallback((data: CreateSpecFormData) => {\n\t\tconst normalized = normalizeFormData(data);\n\t\tif (areFormsEqual(normalized, lastPersistedRef.current)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextState: CreateSpecDraftState = {\n\t\t\tformData: normalized,\n\t\t\tlastUpdated: Date.now(),\n\t\t};\n\n\t\tlastPersistedRef.current = normalized;\n\t\tsetDraftSavedAt(nextState.lastUpdated);\n\t\tvscode.setState(nextState);\n\t\tvscode.postMessage({ type: \"create-spec/autosave\", payload: normalized });\n\t}, []);\n\n\t// const scheduleAutosave = useCallback(\n\t// \t(data: CreateSpecFormData) => {\n\t// \t\tclearAutosaveTimer();\n\t// \t\tautosaveTimeoutRef.current = window.setTimeout(() => {\n\t// \t\t\tpersistDraft(data);\n\t// \t\t}, AUTOSAVE_DEBOUNCE_MS);\n\t// \t},\n\t// \t[clearAutosaveTimer, persistDraft]\n\t// );\n\n\tconst handleFieldChange = useCallback(\n\t\t(field: keyof CreateSpecFormData) =>\n\t\t\t(event: ChangeEvent<HTMLTextAreaElement>) => {\n\t\t\t\tconst value = event.target.value;\n\t\t\t\tsetFormData((previous) => {\n\t\t\t\t\tconst next = {\n\t\t\t\t\t\t...previous,\n\t\t\t\t\t\t[field]: value,\n\t\t\t\t\t};\n\t\t\t\t\t// scheduleAutosave(next);\n\t\t\t\t\treturn next;\n\t\t\t\t});\n\t\t\t},\n\t\t// [scheduleAutosave]\n\t\t[]\n\t);\n\n\tconst validateForm = useCallback((current: CreateSpecFormData): boolean => {\n\t\tconst trimmedContext = current.productContext.trim();\n\t\tif (!trimmedContext) {\n\t\t\tsetFieldErrors({ productContext: \"Product Context is required.\" });\n\t\t\tproductContextRef.current?.focus();\n\t\t\treturn false;\n\t\t}\n\n\t\tsetFieldErrors({});\n\t\treturn true;\n\t}, []);\n\n\tconst handleSubmit = useCallback(\n\t\t(event: FormEvent<HTMLFormElement>) => {\n\t\t\tevent.preventDefault();\n\t\t\tif (isSubmitting) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst normalized = normalizeFormData({\n\t\t\t\t...formData,\n\t\t\t\tproductContext: formData.productContext.trim(),\n\t\t\t});\n\n\t\t\tif (!validateForm(normalized)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// clearAutosaveTimer();\n\t\t\tsetIsSubmitting(true);\n\t\t\tsetSubmissionError(undefined);\n\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: \"create-spec/submit\",\n\t\t\t\tpayload: normalized,\n\t\t\t});\n\t\t},\n\t\t[formData, isSubmitting, validateForm]\n\t);\n\n\tconst handleCancel = useCallback(() => {\n\t\t// clearAutosaveTimer();\n\t\tvscode.postMessage({\n\t\t\ttype: \"create-spec/close-attempt\",\n\t\t\tpayload: { hasDirtyChanges: isDirty },\n\t\t});\n\t}, [isDirty]);\n\n\tconst focusPrimaryField = useCallback(() => {\n\t\twindow.setTimeout(() => {\n\t\t\tproductContextRef.current?.focus();\n\t\t}, 0);\n\t}, []);\n\n\tconst handleInitMessage = useCallback(\n\t\t(initPayload?: CreateSpecInitPayload) => {\n\t\t\tconst draftData = normalizeFormData(initPayload?.draft?.formData);\n\t\t\tlastPersistedRef.current = draftData;\n\t\t\tsetFormData(draftData);\n\t\t\tsetDraftSavedAt(initPayload?.draft?.lastUpdated);\n\t\t\tsetSubmissionError(undefined);\n\t\t\tsetIsSubmitting(false);\n\t\t\tsetFieldErrors({});\n\t\t\tsetCloseWarningVisible(false);\n\t\t\tvscode.setState(initPayload?.draft);\n\n\t\t\tif (initPayload?.shouldFocusPrimaryField) {\n\t\t\t\tfocusPrimaryField();\n\t\t\t}\n\t\t},\n\t\t[focusPrimaryField]\n\t);\n\n\tuseEffect(() => {\n\t\tconst persistedDraft = readPersistedDraft();\n\t\tif (persistedDraft) {\n\t\t\tlastPersistedRef.current = persistedDraft.formData;\n\t\t\tsetFormData(persistedDraft.formData);\n\t\t\tsetDraftSavedAt(persistedDraft.lastUpdated);\n\t\t}\n\n\t\tvscode.postMessage({ type: \"create-spec/ready\" });\n\n\t\treturn () => {\n\t\t\t// clearAutosaveTimer();\n\t\t};\n\t}, []);\n\n\tuseEffect(() => {\n\t\tconst handleMessage = (event: MessageEvent<CreateSpecExtensionMessage>) => {\n\t\t\tconst payload = event.data;\n\t\t\tif (!payload || typeof payload !== \"object\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (payload.type) {\n\t\t\t\tcase \"create-spec/init\": {\n\t\t\t\t\thandleInitMessage(payload.payload);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-spec/submit:success\": {\n\t\t\t\t\tsetIsSubmitting(false);\n\t\t\t\t\tsetSubmissionError(undefined);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-spec/submit:error\": {\n\t\t\t\t\tsetIsSubmitting(false);\n\t\t\t\t\tsetSubmissionError(payload.payload?.message ?? \"Failed to submit.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-spec/confirm-close\": {\n\t\t\t\t\tsetCloseWarningVisible(!payload.payload?.shouldClose);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-spec/focus\": {\n\t\t\t\t\tfocusPrimaryField();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"message\", handleMessage);\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"message\", handleMessage);\n\t\t};\n\t}, [focusPrimaryField, handleInitMessage]);\n\n\tuseEffect(() => {\n\t\tconst handleBeforeUnload = (event: BeforeUnloadEvent) => {\n\t\t\tif (!isDirty) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.returnValue = \"\";\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: \"create-spec/close-attempt\",\n\t\t\t\tpayload: { hasDirtyChanges: true },\n\t\t\t});\n\t\t};\n\n\t\twindow.addEventListener(\"beforeunload\", handleBeforeUnload);\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"beforeunload\", handleBeforeUnload);\n\t\t};\n\t}, [isDirty]);\n\n\tconst statusBanner = useMemo(() => {\n\t\tif (submissionError) {\n\t\t\treturn (\n\t\t\t\t<StatusBanner ariaLive=\"assertive\" role=\"alert\" tone=\"error\">\n\t\t\t\t\t{submissionError}\n\t\t\t\t</StatusBanner>\n\t\t\t);\n\t\t}\n\n\t\tif (closeWarningVisible) {\n\t\t\treturn (\n\t\t\t\t<StatusBanner role=\"status\" tone=\"warning\">\n\t\t\t\t\tChanges are still available. Close action was cancelled.\n\t\t\t\t</StatusBanner>\n\t\t\t);\n\t\t}\n\n\t\tif (isSubmitting) {\n\t\t\treturn (\n\t\t\t\t<StatusBanner role=\"status\" tone=\"info\">\n\t\t\t\t\tSending spec prompt\n\t\t\t\t</StatusBanner>\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}, [closeWarningVisible, isSubmitting, submissionError]);\n\n\tconst lastSavedLabel = formatTimestamp(draftSavedAt);\n\tconst autosaveStatus = useMemo(() => {\n\t\tif (lastSavedLabel) {\n\t\t\treturn `Draft saved at ${lastSavedLabel}`;\n\t\t}\n\n\t\tif (isDirty) {\n\t\t\treturn \"Unsaved changes\";\n\t\t}\n\n\t\treturn \"All changes saved\";\n\t}, [isDirty, lastSavedLabel]);\n\n\treturn (\n\t\t<div className=\"mx-auto flex h-full w-full max-w-4xl flex-col gap-6 px-4 pb-6\">\n\t\t\t<header className=\"sticky top-0 z-10 flex items-start justify-between gap-4 bg-[var(--vscode-editor-background)] pt-6 pb-4\">\n\t\t\t\t<div className=\"flex flex-col gap-2\">\n\t\t\t\t\t<h1 className=\"font-semibold text-2xl text-[color:var(--vscode-foreground)]\">\n\t\t\t\t\t\tCreate New Spec\n\t\t\t\t\t</h1>\n\t\t\t\t\t<p className=\"text-[color:var(--vscode-descriptionForeground,rgba(255,255,255,0.65))] text-sm\">\n\t\t\t\t\t\tProvide context for the new specification. Product Context is\n\t\t\t\t\t\trequired; other sections are optional but recommended.\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"flex shrink-0 gap-2\">\n\t\t\t\t\t<Button\n\t\t\t\t\t\tdisabled={isSubmitting}\n\t\t\t\t\t\tonClick={handleCancel}\n\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t>\n\t\t\t\t\t\tCancel\n\t\t\t\t\t</Button>\n\t\t\t\t\t<Button\n\t\t\t\t\t\tdisabled={isSubmitting}\n\t\t\t\t\t\tform=\"create-spec-form\"\n\t\t\t\t\t\ttype=\"submit\"\n\t\t\t\t\t\tvariant=\"default\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{isSubmitting ? \"Creating\" : \"Create Spec\"}\n\t\t\t\t\t</Button>\n\t\t\t\t</div>\n\t\t\t</header>\n\n\t\t\t{statusBanner}\n\n\t\t\t<CreateSpecForm\n\t\t\t\tautosaveStatus={autosaveStatus}\n\t\t\t\tfieldErrors={fieldErrors}\n\t\t\t\tformData={formData}\n\t\t\t\tformId=\"create-spec-form\"\n\t\t\t\tisSubmitting={isSubmitting}\n\t\t\t\tkeyScenariosRef={keyScenariosRef}\n\t\t\t\tonFieldChange={handleFieldChange}\n\t\t\t\tonSubmit={handleSubmit}\n\t\t\t\topenQuestionsRef={openQuestionsRef}\n\t\t\t\tproductContextRef={productContextRef}\n\t\t\t\trelatedFilesRef={relatedFilesRef}\n\t\t\t\ttechnicalConstraintsRef={technicalConstraintsRef}\n\t\t\t/>\n\t\t</div>\n\t);\n}",
    "start_line": 87,
    "end_line": 400,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function CreateSpecView",
    "component_id": "ui.src.features.create-spec-view.index.CreateSpecView"
  },
  "ui.src.features.create-spec-view.types.CreateSpecFormData": {
    "id": "ui.src.features.create-spec-view.types.CreateSpecFormData",
    "name": "CreateSpecFormData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/types.ts",
    "relative_path": "ui/src/features/create-spec-view/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecFormData {\n\tproductContext: string;\n\tkeyScenarios: string;\n\ttechnicalConstraints: string;\n\trelatedFiles: string;\n\topenQuestions: string;\n}",
    "start_line": 1,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecFormData",
    "component_id": "ui.src.features.create-spec-view.types.CreateSpecFormData"
  },
  "ui.src.features.create-spec-view.types.CreateSpecDraftState": {
    "id": "ui.src.features.create-spec-view.types.CreateSpecDraftState",
    "name": "CreateSpecDraftState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/types.ts",
    "relative_path": "ui/src/features/create-spec-view/types.ts",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecFormData"
    ],
    "source_code": "interface CreateSpecDraftState {\n\tformData: CreateSpecFormData;\n\tlastUpdated: number;\n}",
    "start_line": 9,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecDraftState",
    "component_id": "ui.src.features.create-spec-view.types.CreateSpecDraftState"
  },
  "ui.src.features.create-spec-view.types.CreateSpecInitPayload": {
    "id": "ui.src.features.create-spec-view.types.CreateSpecInitPayload",
    "name": "CreateSpecInitPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/types.ts",
    "relative_path": "ui/src/features/create-spec-view/types.ts",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecDraftState"
    ],
    "source_code": "interface CreateSpecInitPayload {\n\tshouldFocusPrimaryField: boolean;\n\tdraft?: CreateSpecDraftState;\n}",
    "start_line": 14,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecInitPayload",
    "component_id": "ui.src.features.create-spec-view.types.CreateSpecInitPayload"
  },
  "ui.src.features.create-spec-view.types.CreateSpecExtensionMessage": {
    "id": "ui.src.features.create-spec-view.types.CreateSpecExtensionMessage",
    "name": "CreateSpecExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/types.ts",
    "relative_path": "ui/src/features/create-spec-view/types.ts",
    "depends_on": [
      "ui.src.features.create-spec-view.types.CreateSpecInitPayload"
    ],
    "source_code": "type CreateSpecExtensionMessage =\n\t| { type: \"create-spec/init\"; payload: CreateSpecInitPayload }\n\t| { type: \"create-spec/submit:success\" }\n\t| { type: \"create-spec/submit:error\"; payload: { message: string } }\n\t| { type: \"create-spec/confirm-close\"; payload: { shouldClose: boolean } }\n\t| { type: \"create-spec/focus\" };",
    "start_line": 19,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSpecExtensionMessage",
    "component_id": "ui.src.features.create-spec-view.types.CreateSpecExtensionMessage"
  },
  "ui.src.features.create-spec-view.types.CreateSpecFieldErrors": {
    "id": "ui.src.features.create-spec-view.types.CreateSpecFieldErrors",
    "name": "CreateSpecFieldErrors",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-spec-view/types.ts",
    "relative_path": "ui/src/features/create-spec-view/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSpecFieldErrors {\n\tproductContext?: string;\n}",
    "start_line": 26,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSpecFieldErrors",
    "component_id": "ui.src.features.create-spec-view.types.CreateSpecFieldErrors"
  },
  "ui.src.features.create-steering-view.index.normalizeFormData": {
    "id": "ui.src.features.create-steering-view.index.normalizeFormData",
    "name": "normalizeFormData",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/index.tsx",
    "relative_path": "ui/src/features/create-steering-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringFormData"
    ],
    "source_code": "normalizeFormData = (\n\tdata: Partial<CreateSteeringFormData> | undefined\n): CreateSteeringFormData => ({\n\tsummary: typeof data?.summary === \"string\" ? data.summary : \"\",\n\taudience: typeof data?.audience === \"string\" ? data.audience : \"\",\n\tkeyPractices: typeof data?.keyPractices === \"string\" ? data.keyPractices : \"\",\n\tantiPatterns: typeof data?.antiPatterns === \"string\" ? data.antiPatterns : \"\",\n})",
    "start_line": 29,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function normalizeFormData",
    "component_id": "ui.src.features.create-steering-view.index.normalizeFormData"
  },
  "ui.src.features.create-steering-view.index.areFormsEqual": {
    "id": "ui.src.features.create-steering-view.index.areFormsEqual",
    "name": "areFormsEqual",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/index.tsx",
    "relative_path": "ui/src/features/create-steering-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringFormData"
    ],
    "source_code": "areFormsEqual = (\n\tleft: CreateSteeringFormData,\n\tright: CreateSteeringFormData\n): boolean =>\n\tleft.summary === right.summary &&\n\tleft.audience === right.audience &&\n\tleft.keyPractices === right.keyPractices &&\n\tleft.antiPatterns === right.antiPatterns",
    "start_line": 38,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "left",
      "right"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function areFormsEqual",
    "component_id": "ui.src.features.create-steering-view.index.areFormsEqual"
  },
  "ui.src.features.create-steering-view.index.formatTimestamp": {
    "id": "ui.src.features.create-steering-view.index.formatTimestamp",
    "name": "formatTimestamp",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/index.tsx",
    "relative_path": "ui/src/features/create-steering-view/index.tsx",
    "depends_on": [],
    "source_code": "formatTimestamp = (timestamp: number | undefined): string | undefined => {\n\tif (!timestamp) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\treturn new Intl.DateTimeFormat(undefined, {\n\t\t\thour: \"2-digit\",\n\t\t\tminute: \"2-digit\",\n\t\t}).format(new Date(timestamp));\n\t} catch {\n\t\treturn;\n\t}\n}",
    "start_line": 47,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "timestamp"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function formatTimestamp",
    "component_id": "ui.src.features.create-steering-view.index.formatTimestamp"
  },
  "ui.src.features.create-steering-view.index.readPersistedDraft": {
    "id": "ui.src.features.create-steering-view.index.readPersistedDraft",
    "name": "readPersistedDraft",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/index.tsx",
    "relative_path": "ui/src/features/create-steering-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-steering-view.index.normalizeFormData",
      "ui.src.features.create-steering-view.types.CreateSteeringDraftState",
      "ui.src.stores.spec-explorer-store.getState"
    ],
    "source_code": "readPersistedDraft = (): CreateSteeringDraftState | undefined => {\n\tconst raw = vscode.getState() as CreateSteeringDraftState | undefined;\n\tif (!raw) {\n\t\treturn;\n\t}\n\n\tif (!raw.formData || typeof raw.lastUpdated !== \"number\") {\n\t\treturn;\n\t}\n\n\treturn {\n\t\tformData: normalizeFormData(raw.formData),\n\t\tlastUpdated: raw.lastUpdated,\n\t};\n}",
    "start_line": 62,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function readPersistedDraft",
    "component_id": "ui.src.features.create-steering-view.index.readPersistedDraft"
  },
  "ui.src.features.create-steering-view.index.CreateSteeringView": {
    "id": "ui.src.features.create-steering-view.index.CreateSteeringView",
    "name": "CreateSteeringView",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/index.tsx",
    "relative_path": "ui/src/features/create-steering-view/index.tsx",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringInitPayload",
      "ui.src.features.create-steering-view.types.CreateSteeringFormData",
      "ui.src.features.create-steering-view.index.formatTimestamp",
      "ui.src.features.create-steering-view.index.normalizeFormData",
      "ui.src.features.create-steering-view.types.CreateSteeringDraftState",
      "ui.src.features.create-steering-view.index.readPersistedDraft",
      "ui.src.features.create-steering-view.types.CreateSteeringExtensionMessage",
      "ui.src.features.create-steering-view.index.areFormsEqual",
      "src.panels.welcome-screen-panel.postMessage"
    ],
    "source_code": "CreateSteeringView = () => {\n\tconst [formData, setFormData] = useState<CreateSteeringFormData>(EMPTY_FORM);\n\tconst [isSubmitting, setIsSubmitting] = useState(false);\n\tconst [fieldErrors, setFieldErrors] = useState<CreateSteeringFieldErrors>({});\n\tconst [submissionError, setSubmissionError] = useState<string | undefined>();\n\tconst [draftSavedAt, setDraftSavedAt] = useState<number | undefined>();\n\tconst [closeWarningVisible, setCloseWarningVisible] = useState(false);\n\n\tconst lastPersistedRef = useRef<CreateSteeringFormData>(EMPTY_FORM);\n\tconst autosaveTimeoutRef = useRef<number | undefined>();\n\n\tconst summaryRef = useRef<HTMLTextAreaElement>(null);\n\tconst audienceRef = useRef<HTMLTextAreaElement>(null);\n\tconst keyPracticesRef = useRef<HTMLTextAreaElement>(null);\n\tconst antiPatternsRef = useRef<HTMLTextAreaElement>(null);\n\n\tconst isDirty = useMemo(\n\t\t() => !areFormsEqual(formData, lastPersistedRef.current),\n\t\t[formData]\n\t);\n\n\tconst clearAutosaveTimer = useCallback(() => {\n\t\tif (autosaveTimeoutRef.current) {\n\t\t\twindow.clearTimeout(autosaveTimeoutRef.current);\n\t\t\tautosaveTimeoutRef.current = undefined;\n\t\t}\n\t}, []);\n\n\tconst persistDraft = useCallback((data: CreateSteeringFormData) => {\n\t\tconst normalized = normalizeFormData(data);\n\t\tif (areFormsEqual(normalized, lastPersistedRef.current)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextState: CreateSteeringDraftState = {\n\t\t\tformData: normalized,\n\t\t\tlastUpdated: Date.now(),\n\t\t};\n\n\t\tlastPersistedRef.current = normalized;\n\t\tsetDraftSavedAt(nextState.lastUpdated);\n\t\tvscode.setState(nextState);\n\t\tvscode.postMessage({\n\t\t\ttype: \"create-steering/autosave\",\n\t\t\tpayload: normalized,\n\t\t});\n\t}, []);\n\n\tconst scheduleAutosave = useCallback(\n\t\t(data: CreateSteeringFormData) => {\n\t\t\tclearAutosaveTimer();\n\t\t\tautosaveTimeoutRef.current = window.setTimeout(() => {\n\t\t\t\tpersistDraft(data);\n\t\t\t}, AUTOSAVE_DEBOUNCE_MS);\n\t\t},\n\t\t[clearAutosaveTimer, persistDraft]\n\t);\n\n\tconst handleFieldChange = useCallback(\n\t\t(field: keyof CreateSteeringFormData) =>\n\t\t\t(event: ChangeEvent<HTMLTextAreaElement>) => {\n\t\t\t\tconst value = event.target.value;\n\t\t\t\tsetFormData((previous) => {\n\t\t\t\t\tconst next = {\n\t\t\t\t\t\t...previous,\n\t\t\t\t\t\t[field]: value,\n\t\t\t\t\t};\n\t\t\t\t\tscheduleAutosave(next);\n\t\t\t\t\treturn next;\n\t\t\t\t});\n\t\t\t},\n\t\t[scheduleAutosave]\n\t);\n\n\tconst validateForm = useCallback(\n\t\t(current: CreateSteeringFormData): boolean => {\n\t\t\tconst trimmedSummary = current.summary.trim();\n\t\t\tif (!trimmedSummary) {\n\t\t\t\tsetFieldErrors({ summary: \"Guidance summary is required.\" });\n\t\t\t\tsummaryRef.current?.focus();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsetFieldErrors({});\n\t\t\treturn true;\n\t\t},\n\t\t[]\n\t);\n\n\tconst handleSubmit = useCallback(\n\t\t(event: FormEvent<HTMLFormElement>) => {\n\t\t\tevent.preventDefault();\n\t\t\tif (isSubmitting) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst normalized = normalizeFormData({\n\t\t\t\t...formData,\n\t\t\t\tsummary: formData.summary.trim(),\n\t\t\t});\n\n\t\t\tif (!validateForm(normalized)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearAutosaveTimer();\n\t\t\tsetIsSubmitting(true);\n\t\t\tsetSubmissionError(undefined);\n\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: \"create-steering/submit\",\n\t\t\t\tpayload: normalized,\n\t\t\t});\n\t\t},\n\t\t[clearAutosaveTimer, formData, isSubmitting, validateForm]\n\t);\n\n\tconst handleCancel = useCallback(() => {\n\t\tclearAutosaveTimer();\n\t\tvscode.postMessage({\n\t\t\ttype: \"create-steering/close-attempt\",\n\t\t\tpayload: { hasDirtyChanges: isDirty },\n\t\t});\n\t}, [clearAutosaveTimer, isDirty]);\n\n\tconst focusSummaryField = useCallback(() => {\n\t\twindow.setTimeout(() => {\n\t\t\tsummaryRef.current?.focus();\n\t\t}, 0);\n\t}, []);\n\n\tconst handleInitMessage = useCallback(\n\t\t(initPayload?: CreateSteeringInitPayload) => {\n\t\t\tconst draftData = normalizeFormData(initPayload?.draft?.formData);\n\t\t\tlastPersistedRef.current = draftData;\n\t\t\tsetFormData(draftData);\n\t\t\tsetDraftSavedAt(initPayload?.draft?.lastUpdated);\n\t\t\tsetSubmissionError(undefined);\n\t\t\tsetIsSubmitting(false);\n\t\t\tsetFieldErrors({});\n\t\t\tsetCloseWarningVisible(false);\n\t\t\tvscode.setState(initPayload?.draft);\n\n\t\t\tif (initPayload?.shouldFocusPrimaryField) {\n\t\t\t\tfocusSummaryField();\n\t\t\t}\n\t\t},\n\t\t[focusSummaryField]\n\t);\n\n\tuseEffect(() => {\n\t\tconst persistedDraft = readPersistedDraft();\n\t\tif (persistedDraft) {\n\t\t\tlastPersistedRef.current = persistedDraft.formData;\n\t\t\tsetFormData(persistedDraft.formData);\n\t\t\tsetDraftSavedAt(persistedDraft.lastUpdated);\n\t\t}\n\n\t\tvscode.postMessage({ type: \"create-steering/ready\" });\n\n\t\treturn () => {\n\t\t\tclearAutosaveTimer();\n\t\t};\n\t}, [clearAutosaveTimer]);\n\n\tuseEffect(() => {\n\t\tconst handleMessage = (\n\t\t\tevent: MessageEvent<CreateSteeringExtensionMessage>\n\t\t) => {\n\t\t\tconst payload = event.data;\n\t\t\tif (!payload || typeof payload !== \"object\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (payload.type) {\n\t\t\t\tcase \"create-steering/init\": {\n\t\t\t\t\thandleInitMessage(payload.payload);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-steering/submit:success\": {\n\t\t\t\t\tsetIsSubmitting(false);\n\t\t\t\t\tsetSubmissionError(undefined);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-steering/submit:error\": {\n\t\t\t\t\tsetIsSubmitting(false);\n\t\t\t\t\tsetSubmissionError(\n\t\t\t\t\t\tpayload.payload?.message ?? \"Failed to submit steering prompt.\"\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-steering/confirm-close\": {\n\t\t\t\t\tsetCloseWarningVisible(!payload.payload?.shouldClose);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"create-steering/focus\": {\n\t\t\t\t\tfocusSummaryField();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"message\", handleMessage);\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"message\", handleMessage);\n\t\t};\n\t}, [focusSummaryField, handleInitMessage]);\n\n\tuseEffect(() => {\n\t\tconst handleBeforeUnload = (event: BeforeUnloadEvent) => {\n\t\t\tif (!isDirty) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.returnValue = \"\";\n\t\t\tvscode.postMessage({\n\t\t\t\ttype: \"create-steering/close-attempt\",\n\t\t\t\tpayload: { hasDirtyChanges: true },\n\t\t\t});\n\t\t};\n\n\t\twindow.addEventListener(\"beforeunload\", handleBeforeUnload);\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"beforeunload\", handleBeforeUnload);\n\t\t};\n\t}, [isDirty]);\n\n\tconst statusBanner = useMemo(() => {\n\t\tif (submissionError) {\n\t\t\treturn (\n\t\t\t\t<StatusBanner ariaLive=\"assertive\" role=\"alert\" tone=\"error\">\n\t\t\t\t\t{submissionError}\n\t\t\t\t</StatusBanner>\n\t\t\t);\n\t\t}\n\n\t\tif (closeWarningVisible) {\n\t\t\treturn (\n\t\t\t\t<StatusBanner role=\"status\" tone=\"warning\">\n\t\t\t\t\tChanges are still available. Close action was cancelled.\n\t\t\t\t</StatusBanner>\n\t\t\t);\n\t\t}\n\n\t\tif (isSubmitting) {\n\t\t\treturn (\n\t\t\t\t<StatusBanner role=\"status\" tone=\"info\">\n\t\t\t\t\tSending steering prompt\n\t\t\t\t</StatusBanner>\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}, [closeWarningVisible, isSubmitting, submissionError]);\n\n\tconst lastSavedLabel = formatTimestamp(draftSavedAt);\n\tconst autosaveStatus = useMemo(() => {\n\t\tif (lastSavedLabel) {\n\t\t\treturn `Draft saved at ${lastSavedLabel}`;\n\t\t}\n\n\t\tif (isDirty) {\n\t\t\treturn \"Unsaved changes\";\n\t\t}\n\n\t\treturn \"All changes saved\";\n\t}, [isDirty, lastSavedLabel]);\n\n\treturn (\n\t\t<div className=\"mx-auto flex h-full w-full max-w-4xl flex-col gap-6 px-4 py-6\">\n\t\t\t<header className=\"flex flex-col gap-2\">\n\t\t\t\t<h1 className=\"font-semibold text-2xl text-[color:var(--vscode-foreground)]\">\n\t\t\t\t\tCreate Custom Steering\n\t\t\t\t</h1>\n\t\t\t\t<p className=\"text-[color:var(--vscode-descriptionForeground,rgba(255,255,255,0.65))] text-sm\">\n\t\t\t\t\tShare the guardrails and project-specific rules you want every agent\n\t\t\t\t\tto follow. Summary is required; other sections are optional.\n\t\t\t\t</p>\n\t\t\t</header>\n\n\t\t\t{statusBanner}\n\n\t\t\t<CreateSteeringForm\n\t\t\t\tantiPatternsRef={antiPatternsRef}\n\t\t\t\taudienceRef={audienceRef}\n\t\t\t\tautosaveStatus={autosaveStatus}\n\t\t\t\tfieldErrors={fieldErrors}\n\t\t\t\tformData={formData}\n\t\t\t\tisSubmitting={isSubmitting}\n\t\t\t\tkeyPracticesRef={keyPracticesRef}\n\t\t\t\tonCancel={handleCancel}\n\t\t\t\tonFieldChange={handleFieldChange}\n\t\t\t\tonSubmit={handleSubmit}\n\t\t\t\tsummaryRef={summaryRef}\n\t\t\t/>\n\t\t</div>\n\t);\n}",
    "start_line": 78,
    "end_line": 378,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function CreateSteeringView",
    "component_id": "ui.src.features.create-steering-view.index.CreateSteeringView"
  },
  "ui.src.features.create-steering-view.types.CreateSteeringFormData": {
    "id": "ui.src.features.create-steering-view.types.CreateSteeringFormData",
    "name": "CreateSteeringFormData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/types.ts",
    "relative_path": "ui/src/features/create-steering-view/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringFormData {\n\tsummary: string;\n\taudience: string;\n\tkeyPractices: string;\n\tantiPatterns: string;\n}",
    "start_line": 1,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringFormData",
    "component_id": "ui.src.features.create-steering-view.types.CreateSteeringFormData"
  },
  "ui.src.features.create-steering-view.types.CreateSteeringDraftState": {
    "id": "ui.src.features.create-steering-view.types.CreateSteeringDraftState",
    "name": "CreateSteeringDraftState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/types.ts",
    "relative_path": "ui/src/features/create-steering-view/types.ts",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringFormData"
    ],
    "source_code": "interface CreateSteeringDraftState {\n\tformData: CreateSteeringFormData;\n\tlastUpdated: number;\n}",
    "start_line": 8,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringDraftState",
    "component_id": "ui.src.features.create-steering-view.types.CreateSteeringDraftState"
  },
  "ui.src.features.create-steering-view.types.CreateSteeringInitPayload": {
    "id": "ui.src.features.create-steering-view.types.CreateSteeringInitPayload",
    "name": "CreateSteeringInitPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/types.ts",
    "relative_path": "ui/src/features/create-steering-view/types.ts",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringDraftState"
    ],
    "source_code": "interface CreateSteeringInitPayload {\n\tshouldFocusPrimaryField: boolean;\n\tdraft?: CreateSteeringDraftState;\n}",
    "start_line": 13,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringInitPayload",
    "component_id": "ui.src.features.create-steering-view.types.CreateSteeringInitPayload"
  },
  "ui.src.features.create-steering-view.types.CreateSteeringExtensionMessage": {
    "id": "ui.src.features.create-steering-view.types.CreateSteeringExtensionMessage",
    "name": "CreateSteeringExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/types.ts",
    "relative_path": "ui/src/features/create-steering-view/types.ts",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringInitPayload"
    ],
    "source_code": "type CreateSteeringExtensionMessage =\n\t| { type: \"create-steering/init\"; payload: CreateSteeringInitPayload }\n\t| { type: \"create-steering/submit:success\" }\n\t| { type: \"create-steering/submit:error\"; payload: { message: string } }\n\t| { type: \"create-steering/confirm-close\"; payload: { shouldClose: boolean } }\n\t| { type: \"create-steering/focus\" };",
    "start_line": 18,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSteeringExtensionMessage",
    "component_id": "ui.src.features.create-steering-view.types.CreateSteeringExtensionMessage"
  },
  "ui.src.features.create-steering-view.types.CreateSteeringFieldErrors": {
    "id": "ui.src.features.create-steering-view.types.CreateSteeringFieldErrors",
    "name": "CreateSteeringFieldErrors",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/types.ts",
    "relative_path": "ui/src/features/create-steering-view/types.ts",
    "depends_on": [],
    "source_code": "interface CreateSteeringFieldErrors {\n\tsummary?: string;\n}",
    "start_line": 25,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CreateSteeringFieldErrors",
    "component_id": "ui.src.features.create-steering-view.types.CreateSteeringFieldErrors"
  },
  "ui.src.features.create-steering-view.types.CreateSteeringWebviewMessage": {
    "id": "ui.src.features.create-steering-view.types.CreateSteeringWebviewMessage",
    "name": "CreateSteeringWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/create-steering-view/types.ts",
    "relative_path": "ui/src/features/create-steering-view/types.ts",
    "depends_on": [
      "ui.src.features.create-steering-view.types.CreateSteeringFormData"
    ],
    "source_code": "type CreateSteeringWebviewMessage =\n\t| { type: \"create-steering/submit\"; payload: CreateSteeringFormData }\n\t| { type: \"create-steering/autosave\"; payload: CreateSteeringFormData }\n\t| {\n\t\t\ttype: \"create-steering/close-attempt\";\n\t\t\tpayload: { hasDirtyChanges: boolean };\n\t  }\n\t| { type: \"create-steering/cancel\" }\n\t| { type: \"create-steering/ready\" };",
    "start_line": 29,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CreateSteeringWebviewMessage",
    "component_id": "ui.src.features.create-steering-view.types.CreateSteeringWebviewMessage"
  },
  "ui.src.features.dependencies-view.types.DependencyStatus": {
    "id": "ui.src.features.dependencies-view.types.DependencyStatus",
    "name": "DependencyStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/dependencies-view/types.ts",
    "relative_path": "ui/src/features/dependencies-view/types.ts",
    "depends_on": [],
    "source_code": "interface DependencyStatus {\n\tname: string;\n\tinstalled: boolean;\n\tversion?: string;\n\terror?: string;\n\tcommand: string;\n}",
    "start_line": 5,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependencyStatus",
    "component_id": "ui.src.features.dependencies-view.types.DependencyStatus"
  },
  "ui.src.features.dependencies-view.types.InstallationStep": {
    "id": "ui.src.features.dependencies-view.types.InstallationStep",
    "name": "InstallationStep",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/dependencies-view/types.ts",
    "relative_path": "ui/src/features/dependencies-view/types.ts",
    "depends_on": [],
    "source_code": "interface InstallationStep {\n\tid: string;\n\ttitle: string;\n\tdescription: string;\n\tcommand: string;\n\tplatform?: \"darwin\" | \"linux\" | \"win32\" | \"all\";\n}",
    "start_line": 13,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InstallationStep",
    "component_id": "ui.src.features.dependencies-view.types.InstallationStep"
  },
  "ui.src.features.dependencies-view.types.DependenciesWebviewMessage": {
    "id": "ui.src.features.dependencies-view.types.DependenciesWebviewMessage",
    "name": "DependenciesWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/dependencies-view/types.ts",
    "relative_path": "ui/src/features/dependencies-view/types.ts",
    "depends_on": [],
    "source_code": "type DependenciesWebviewMessage =\n\t| { type: \"dependencies/ready\" }\n\t| { type: \"dependencies/check\" }\n\t| { type: \"dependencies/check-one\"; payload: { name: string } }\n\t| { type: \"dependencies/copy\"; payload: { command: string } }\n\t| { type: \"dependencies/paste\"; payload: { command: string } }\n\t| { type: \"dependencies/execute\"; payload: { command: string } };",
    "start_line": 24,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type DependenciesWebviewMessage",
    "component_id": "ui.src.features.dependencies-view.types.DependenciesWebviewMessage"
  },
  "ui.src.features.dependencies-view.types.DependenciesExtensionMessage": {
    "id": "ui.src.features.dependencies-view.types.DependenciesExtensionMessage",
    "name": "DependenciesExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/dependencies-view/types.ts",
    "relative_path": "ui/src/features/dependencies-view/types.ts",
    "depends_on": [
      "ui.src.features.dependencies-view.types.DependencyStatus",
      "ui.src.features.dependencies-view.types.InstallationStep"
    ],
    "source_code": "type DependenciesExtensionMessage =\n\t| {\n\t\t\ttype: \"dependencies/status\";\n\t\t\tpayload: {\n\t\t\t\tdependencies: DependencyStatus[];\n\t\t\t\tsteps: InstallationStep[];\n\t\t\t};\n\t  }\n\t| { type: \"dependencies/updated\"; payload: DependencyStatus }\n\t| { type: \"dependencies/checking\"; payload: { name?: string } }\n\t| { type: \"dependencies/error\"; payload: { message: string } }\n\t| {\n\t\t\ttype: \"dependencies/action-result\";\n\t\t\tpayload: { action: string; success: boolean; message?: string };\n\t  };",
    "start_line": 35,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type DependenciesExtensionMessage",
    "component_id": "ui.src.features.dependencies-view.types.DependenciesExtensionMessage"
  },
  "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelectorProps": {
    "id": "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelectorProps",
    "name": "AgentTypeSelectorProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/agent-type-selector.tsx",
    "relative_path": "ui/src/features/hooks-view/components/agent-type-selector.tsx",
    "depends_on": [],
    "source_code": "interface AgentTypeSelectorProps {\n\tvalue?: \"local\" | \"background\";\n\tonChange: (type: \"local\" | \"background\" | undefined) => void;\n\tdisabled?: boolean;\n}",
    "start_line": 3,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentTypeSelectorProps",
    "component_id": "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelectorProps"
  },
  "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelector": {
    "id": "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelector",
    "name": "AgentTypeSelector",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/agent-type-selector.tsx",
    "relative_path": "ui/src/features/hooks-view/components/agent-type-selector.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelectorProps"
    ],
    "source_code": "function AgentTypeSelector({\n\tvalue,\n\tonChange,\n\tdisabled = false,\n}: AgentTypeSelectorProps) {\n\treturn (\n\t\t<div className=\"flex flex-col gap-2\">\n\t\t\t<label\n\t\t\t\tclassName=\"font-medium text-[color:var(--vscode-foreground)] text-sm\"\n\t\t\t\thtmlFor=\"agent-type-selector\"\n\t\t\t>\n\t\t\t\tAgent Type\n\t\t\t</label>\n\t\t\t<VSCodeSelect\n\t\t\t\tdisabled={disabled}\n\t\t\t\tid=\"agent-type-selector\"\n\t\t\t\tonChange={(e) => {\n\t\t\t\t\tconst target = e.target as HTMLSelectElement;\n\t\t\t\t\tconst newValue = target.value;\n\t\t\t\t\tif (newValue === \"\") {\n\t\t\t\t\t\tonChange(undefined);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonChange(newValue as \"local\" | \"background\");\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t\tvalue={value || \"\"}\n\t\t\t>\n\t\t\t\t<option value=\"\">Auto-detect (recommended)</option>\n\t\t\t\t<option value=\"local\">Local Agent (in-process)</option>\n\t\t\t\t<option value=\"background\">Background Agent (CLI)</option>\n\t\t\t</VSCodeSelect>\n\t\t\t<p className=\"text-[color:var(--vscode-descriptionForeground)] text-xs\">\n\t\t\t\t{value\n\t\t\t\t\t? \"Manual override: Agent will execute as selected type\"\n\t\t\t\t\t: \"Automatic: Type determined from agent source\"}\n\t\t\t</p>\n\t\t</div>\n\t);\n}",
    "start_line": 17,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function AgentTypeSelector",
    "component_id": "ui.src.features.hooks-view.components.agent-type-selector.AgentTypeSelector"
  },
  "ui.src.features.hooks-view.components.cli-options.copilot-cli-options-panel.CopilotCliOptionsPanelProps": {
    "id": "ui.src.features.hooks-view.components.cli-options.copilot-cli-options-panel.CopilotCliOptionsPanelProps",
    "name": "CopilotCliOptionsPanelProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/copilot-cli-options-panel.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/copilot-cli-options-panel.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface CopilotCliOptionsPanelProps {\n\t/** Current CLI options */\n\tvalue: CopilotCliOptions;\n\t/** Called when options change */\n\tonChange: (value: CopilotCliOptions) => void;\n\t/** Whether the options are disabled */\n\tdisabled?: boolean;\n}",
    "start_line": 11,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CopilotCliOptionsPanelProps",
    "component_id": "ui.src.features.hooks-view.components.cli-options.copilot-cli-options-panel.CopilotCliOptionsPanelProps"
  },
  "ui.src.features.hooks-view.components.cli-options.mcp-server-options.McpServerOptionsProps": {
    "id": "ui.src.features.hooks-view.components.cli-options.mcp-server-options.McpServerOptionsProps",
    "name": "McpServerOptionsProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/mcp-server-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/mcp-server-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface McpServerOptionsProps {\n\t/** Current CLI options */\n\tvalue: CopilotCliOptions;\n\t/** Called when options change */\n\tonChange: (value: Partial<CopilotCliOptions>) => void;\n\t/** Whether the options are disabled */\n\tdisabled?: boolean;\n}",
    "start_line": 9,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface McpServerOptionsProps",
    "component_id": "ui.src.features.hooks-view.components.cli-options.mcp-server-options.McpServerOptionsProps"
  },
  "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptionsProps": {
    "id": "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptionsProps",
    "name": "ModelExecutionOptionsProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/model-execution-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/model-execution-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface ModelExecutionOptionsProps {\n\t/** Current CLI options */\n\tvalue: CopilotCliOptions;\n\t/** Called when options change */\n\tonChange: (value: Partial<CopilotCliOptions>) => void;\n\t/** Whether the options are disabled */\n\tdisabled?: boolean;\n}",
    "start_line": 5,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ModelExecutionOptionsProps",
    "component_id": "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptionsProps"
  },
  "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptions": {
    "id": "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptions",
    "name": "ModelExecutionOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/model-execution-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/model-execution-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptionsProps"
    ],
    "source_code": "function ModelExecutionOptions({\n\tvalue,\n\tonChange,\n\tdisabled = false,\n}: ModelExecutionOptionsProps) {\n\treturn (\n\t\t<div className=\"model-execution-options\">\n\t\t\t<div className=\"model-execution-header\">\n\t\t\t\t<h4>\n\t\t\t\t\tModel & Execution\n\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\tdescription=\"Configure which AI model to use and how it should execute tasks. These settings control the agent's behavior and capabilities.\"\n\t\t\t\t\t\ttitle=\"Model and Execution Settings\"\n\t\t\t\t\t/>\n\t\t\t\t</h4>\n\t\t\t</div>\n\n\t\t\t<div className=\"model-execution-options-grid\">\n\t\t\t\t{/* Model Selection */}\n\t\t\t\t<div className=\"model-execution-option\">\n\t\t\t\t\t<label htmlFor=\"model-select\">\n\t\t\t\t\t\tAI Model\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Select which AI model to use for the agent. Different models have different capabilities, speeds, and cost profiles.\"\n\t\t\t\t\t\t\ttitle=\"--model\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t\t<select\n\t\t\t\t\t\tclassName=\"model-select\"\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"model-select\"\n\t\t\t\t\t\tonChange={(e) =>\n\t\t\t\t\t\t\tonChange({ model: e.target.value as CopilotModel })\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue={value.model || \"claude-sonnet-4.5\"}\n\t\t\t\t\t>\n\t\t\t\t\t\t{AVAILABLE_MODELS.map((model) => (\n\t\t\t\t\t\t\t<option key={model.value} value={model.value}>\n\t\t\t\t\t\t\t\t{model.label}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Custom Agent */}\n\t\t\t\t<div className=\"model-execution-option\">\n\t\t\t\t\t<label htmlFor=\"custom-agent-input\">\n\t\t\t\t\t\tCustom Agent Override\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Override the default agent with a custom agent ID. Use this to specify a specialized agent configuration.\"\n\t\t\t\t\t\t\ttitle=\"--agent\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tclassName=\"model-execution-input\"\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"custom-agent-input\"\n\t\t\t\t\t\tonChange={(e) => onChange({ agent: e.target.value || undefined })}\n\t\t\t\t\t\tplaceholder=\"e.g., my-custom-agent\"\n\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\tvalue={value.agent || \"\"}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* No Ask User (Autonomous Mode) */}\n\t\t\t\t<div className=\"model-execution-checkbox-row\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={value.noAskUser}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"no-ask-user-checkbox\"\n\t\t\t\t\t\tonChange={(e) => onChange({ noAskUser: e.target.checked })}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"no-ask-user-checkbox\">\n\t\t\t\t\t\tAutonomous Mode (No Ask User)\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Enable autonomous mode where the agent can make decisions and take actions without asking for confirmation for each step.\"\n\t\t\t\t\t\t\ttitle=\"--no-ask-user\"\n\t\t\t\t\t\t\twarning=\"Autonomous mode gives the agent more control. Ensure proper permissions are configured.\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Parallel Execution */}\n\t\t\t\t<div className=\"model-execution-checkbox-row\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={!value.disableParallelToolsExecution}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"parallel-checkbox\"\n\t\t\t\t\t\tonChange={(e) =>\n\t\t\t\t\t\t\tonChange({ disableParallelToolsExecution: !e.target.checked })\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"parallel-checkbox\">\n\t\t\t\t\t\tEnable Parallel Tool Execution\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Allow the agent to execute multiple tools in parallel when possible. This can significantly speed up execution.\"\n\t\t\t\t\t\t\ttitle=\"--disable-parallel-tools-execution\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Use Custom Instructions */}\n\t\t\t\t<div className=\"model-execution-checkbox-row\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={!value.noCustomInstructions}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"use-custom-instructions-checkbox\"\n\t\t\t\t\t\tonChange={(e) =>\n\t\t\t\t\t\t\tonChange({ noCustomInstructions: !e.target.checked })\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"use-custom-instructions-checkbox\">\n\t\t\t\t\t\tUse Custom Instructions\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Apply custom instructions from your Copilot configuration. This includes any personalized prompts or guidelines you've configured.\"\n\t\t\t\t\t\t\ttitle=\"--no-custom-instructions\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}",
    "start_line": 29,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ModelExecutionOptions",
    "component_id": "ui.src.features.hooks-view.components.cli-options.model-execution-options.ModelExecutionOptions"
  },
  "ui.src.features.hooks-view.components.cli-options.output-logging-options.OutputLoggingOptionsProps": {
    "id": "ui.src.features.hooks-view.components.cli-options.output-logging-options.OutputLoggingOptionsProps",
    "name": "OutputLoggingOptionsProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/output-logging-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/output-logging-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface OutputLoggingOptionsProps {\n\t/** Current CLI options */\n\tvalue: CopilotCliOptions;\n\t/** Called when options change */\n\tonChange: (value: Partial<CopilotCliOptions>) => void;\n\t/** Whether the options are disabled */\n\tdisabled?: boolean;\n}",
    "start_line": 5,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface OutputLoggingOptionsProps",
    "component_id": "ui.src.features.hooks-view.components.cli-options.output-logging-options.OutputLoggingOptionsProps"
  },
  "ui.src.features.hooks-view.components.cli-options.permission-options.PermissionOptionsProps": {
    "id": "ui.src.features.hooks-view.components.cli-options.permission-options.PermissionOptionsProps",
    "name": "PermissionOptionsProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/permission-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/permission-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface PermissionOptionsProps {\n\t/** Current CLI options */\n\tvalue: CopilotCliOptions;\n\t/** Called when options change */\n\tonChange: (value: Partial<CopilotCliOptions>) => void;\n\t/** Whether the options are disabled */\n\tdisabled?: boolean;\n}",
    "start_line": 10,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PermissionOptionsProps",
    "component_id": "ui.src.features.hooks-view.components.cli-options.permission-options.PermissionOptionsProps"
  },
  "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptionsProps": {
    "id": "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptionsProps",
    "name": "SessionConfigOptionsProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface SessionConfigOptionsProps {\n\t/** Current CLI options */\n\tvalue: CopilotCliOptions;\n\t/** Called when options change */\n\tonChange: (value: Partial<CopilotCliOptions>) => void;\n\t/** Whether the options are disabled */\n\tdisabled?: boolean;\n}",
    "start_line": 5,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SessionConfigOptionsProps",
    "component_id": "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptionsProps"
  },
  "ui.src.features.hooks-view.components.cli-options.session-config-options.boolOrStringToInputValue": {
    "id": "ui.src.features.hooks-view.components.cli-options.session-config-options.boolOrStringToInputValue",
    "name": "boolOrStringToInputValue",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "depends_on": [],
    "source_code": "function boolOrStringToInputValue(val: boolean | string | undefined): string {\n\tif (typeof val === \"string\") {\n\t\treturn val;\n\t}\n\tif (val === true) {\n\t\treturn \"true\";\n\t}\n\treturn \"\";\n}",
    "start_line": 17,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "val"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function boolOrStringToInputValue",
    "component_id": "ui.src.features.hooks-view.components.cli-options.session-config-options.boolOrStringToInputValue"
  },
  "ui.src.features.hooks-view.components.cli-options.session-config-options.inputValueToBoolOrString": {
    "id": "ui.src.features.hooks-view.components.cli-options.session-config-options.inputValueToBoolOrString",
    "name": "inputValueToBoolOrString",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "depends_on": [],
    "source_code": "function inputValueToBoolOrString(val: string): boolean | string | undefined {\n\tif (val === \"\") {\n\t\treturn;\n\t}\n\tif (val === \"true\") {\n\t\treturn true;\n\t}\n\treturn val;\n}",
    "start_line": 30,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "val"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function inputValueToBoolOrString",
    "component_id": "ui.src.features.hooks-view.components.cli-options.session-config-options.inputValueToBoolOrString"
  },
  "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptions": {
    "id": "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptions",
    "name": "SessionConfigOptions",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "relative_path": "ui/src/features/hooks-view/components/cli-options/session-config-options.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptionsProps",
      "ui.src.features.hooks-view.components.cli-options.session-config-options.inputValueToBoolOrString"
    ],
    "source_code": "function SessionConfigOptions({\n\tvalue,\n\tonChange,\n\tdisabled = false,\n}: SessionConfigOptionsProps) {\n\treturn (\n\t\t<div className=\"session-config-options\">\n\t\t\t<div className=\"session-config-header\">\n\t\t\t\t<h4>\n\t\t\t\t\tSession & Configuration\n\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\tdescription=\"Manage session persistence, sharing, and configuration directories.\"\n\t\t\t\t\t\ttitle=\"Session and Configuration Settings\"\n\t\t\t\t\t/>\n\t\t\t\t</h4>\n\t\t\t</div>\n\n\t\t\t<div className=\"session-config-options-grid\">\n\t\t\t\t{/* Resume Session */}\n\t\t\t\t<div className=\"session-config-option\">\n\t\t\t\t\t<label htmlFor=\"resume-session-input\">\n\t\t\t\t\t\tResume Session\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Resume a previous session. Can be true to resume the last session, or a session ID string.\"\n\t\t\t\t\t\t\ttitle=\"--resume\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tclassName=\"session-config-input\"\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"resume-session-input\"\n\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\tonChange({\n\t\t\t\t\t\t\t\tresume: inputValueToBoolOrString(e.target.value),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tplaceholder=\"e.g., session-abc123 or 'true'\"\n\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\tvalue={boolOrStringToInputValue(value.resume)}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Config Directory */}\n\t\t\t\t<div className=\"session-config-option\">\n\t\t\t\t\t<label htmlFor=\"config-dir-input\">\n\t\t\t\t\t\tConfig Directory\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Specify a custom configuration directory instead of the default location.\"\n\t\t\t\t\t\t\ttitle=\"--config-dir\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tclassName=\"session-config-input\"\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"config-dir-input\"\n\t\t\t\t\t\tonChange={(e) =>\n\t\t\t\t\t\t\tonChange({ configDir: e.target.value || undefined })\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplaceholder=\"e.g., ~/.config/copilot\"\n\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\tvalue={value.configDir || \"\"}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Continue Session */}\n\t\t\t\t<div className=\"session-config-checkbox\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={value.continue}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"continue-session-checkbox\"\n\t\t\t\t\t\tonChange={(e) => onChange({ continue: e.target.checked })}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"continue-session-checkbox\">\n\t\t\t\t\t\tContinue Session\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Continue from the previous session automatically.\"\n\t\t\t\t\t\t\ttitle=\"--continue\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Share Session */}\n\t\t\t\t<div className=\"session-config-option\">\n\t\t\t\t\t<label htmlFor=\"share-session-input\">\n\t\t\t\t\t\tShare Session\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Share the session. Can be true for default sharing, or a custom share URL.\"\n\t\t\t\t\t\t\ttitle=\"--share\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tclassName=\"session-config-input\"\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"share-session-input\"\n\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\tonChange({\n\t\t\t\t\t\t\t\tshare: inputValueToBoolOrString(e.target.value),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tplaceholder=\"e.g., 'true' or custom URL\"\n\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\tvalue={boolOrStringToInputValue(value.share)}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Share to Gist */}\n\t\t\t\t<div className=\"session-config-checkbox\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={value.shareGist}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"share-gist-checkbox\"\n\t\t\t\t\t\tonChange={(e) => onChange({ shareGist: e.target.checked })}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"share-gist-checkbox\">\n\t\t\t\t\t\tShare to GitHub Gist\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Automatically create a GitHub Gist with the session transcript when complete.\"\n\t\t\t\t\t\t\ttitle=\"--share-gist\"\n\t\t\t\t\t\t\twarning=\"This will make the session publicly accessible on GitHub.\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Enable Banner */}\n\t\t\t\t<div className=\"session-config-checkbox\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={value.banner !== false}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"banner-checkbox\"\n\t\t\t\t\t\tonChange={(e) => onChange({ banner: e.target.checked })}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"banner-checkbox\">\n\t\t\t\t\t\tShow Welcome Banner\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Show the welcome banner and version information at startup.\"\n\t\t\t\t\t\t\ttitle=\"--banner\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Enable Auto-Update Check */}\n\t\t\t\t<div className=\"session-config-checkbox\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tchecked={!value.noAutoUpdate}\n\t\t\t\t\t\tdisabled={disabled}\n\t\t\t\t\t\tid=\"auto-update-checkbox\"\n\t\t\t\t\t\tonChange={(e) => onChange({ noAutoUpdate: !e.target.checked })}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t/>\n\t\t\t\t\t<label htmlFor=\"auto-update-checkbox\">\n\t\t\t\t\t\tEnable Auto-Update Check\n\t\t\t\t\t\t<InfoTooltip\n\t\t\t\t\t\t\tdescription=\"Check for CLI updates at startup.\"\n\t\t\t\t\t\t\ttitle=\"--no-auto-update\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}",
    "start_line": 43,
    "end_line": 206,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function SessionConfigOptions",
    "component_id": "ui.src.features.hooks-view.components.cli-options.session-config-options.SessionConfigOptions"
  },
  "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsListProps": {
    "id": "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsListProps",
    "name": "ExecutionLogsListProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/execution-logs-list.tsx",
    "relative_path": "ui/src/features/hooks-view/components/execution-logs-list.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook",
      "ui.src.features.hooks-view.types.HookExecutionLog"
    ],
    "source_code": "interface ExecutionLogsListProps {\n\thooks: Hook[];\n\tlogs: HookExecutionLog[];\n\tisLoading: boolean;\n\tselectedHookId?: string;\n\tonSelectHook: (hookId?: string) => void;\n\tonRefresh: () => void;\n\tonClose: () => void;\n}",
    "start_line": 5,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExecutionLogsListProps",
    "component_id": "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsListProps"
  },
  "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsList": {
    "id": "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsList",
    "name": "ExecutionLogsList",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/execution-logs-list.tsx",
    "relative_path": "ui/src/features/hooks-view/components/execution-logs-list.tsx",
    "depends_on": [
      "src.features.agents.resource-cache.get",
      "ui.src.features.hooks-view.types.HookExecutionLog",
      "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsListProps"
    ],
    "source_code": "ExecutionLogsList = ({\n\thooks,\n\tisLoading,\n\tlogs,\n\tonClose,\n\tonRefresh,\n\tonSelectHook,\n\tselectedHookId,\n}: ExecutionLogsListProps) => {\n\tconst hookLookup = new Map(hooks.map((hook) => [hook.id, hook.name]));\n\tconst sortedLogs = [...logs].sort((a, b) => {\n\t\tconst aTs = a.completedAt ?? a.triggeredAt;\n\t\tconst bTs = b.completedAt ?? b.triggeredAt;\n\t\treturn bTs - aTs;\n\t});\n\n\tconst handleFilterChange = (event: ChangeEvent<HTMLSelectElement>) => {\n\t\tconst value = event.target.value;\n\t\tonSelectHook(value === \"all\" ? undefined : value);\n\t};\n\n\tconst renderLog = (log: HookExecutionLog) => {\n\t\tconst hookName = hookLookup.get(log.hookId) ?? log.hookId;\n\t\tconst statusClass = statusStyles[log.status];\n\t\tconst statusLabel = statusLabels[log.status];\n\t\tconst timestamp = new Date(log.triggeredAt).toLocaleString();\n\t\treturn (\n\t\t\t<article\n\t\t\t\tclassName=\"flex flex-col gap-1 border-[color:var(--vscode-panel-border)] border-b px-2 py-2 last:border-b-0\"\n\t\t\t\tkey={log.id}\n\t\t\t>\n\t\t\t\t<div className=\"flex flex-wrap items-center justify-between gap-2\">\n\t\t\t\t\t<div className=\"flex flex-col\">\n\t\t\t\t\t\t<span className=\"font-medium text-[color:var(--vscode-foreground)] text-sm\">\n\t\t\t\t\t\t\t{hookName}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span className=\"text-[color:var(--vscode-descriptionForeground)] text-xs\">\n\t\t\t\t\t\t\tTriggered at {timestamp}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className={`font-semibold text-xs ${statusClass}`}>\n\t\t\t\t\t\t{statusLabel}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"text-[color:var(--vscode-descriptionForeground)] text-xs\">\n\t\t\t\t\t<span className=\"mr-2\">\n\t\t\t\t\t\tChain depth: <strong>{log.chainDepth}</strong>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span className=\"mr-2\">\n\t\t\t\t\t\tDuration:{\" \"}\n\t\t\t\t\t\t<strong>\n\t\t\t\t\t\t\t{log.duration !== undefined ? `${log.duration}ms` : \"\"}\n\t\t\t\t\t\t</strong>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span>\n\t\t\t\t\t\tExecution ID: <strong>{log.executionId}</strong>\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t\t{log.error?.message && (\n\t\t\t\t\t<div className=\"text-[color:var(--vscode-errorForeground)] text-xs\">\n\t\t\t\t\t\tError: {log.error.message}\n\t\t\t\t\t</div>\n\t\t\t\t)}",
    "start_line": 29,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function ExecutionLogsList",
    "component_id": "ui.src.features.hooks-view.components.execution-logs-list.ExecutionLogsList"
  },
  "ui.src.features.hooks-view.components.hook-list-item.HookListItem": {
    "id": "ui.src.features.hooks-view.components.hook-list-item.HookListItem",
    "name": "HookListItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/hook-list-item.tsx",
    "relative_path": "ui/src/features/hooks-view/components/hook-list-item.tsx",
    "depends_on": [],
    "source_code": "HookListItem = ({\n\texecutionStatus,\n\thook,\n\tonToggle,\n\tonDelete,\n\tonEdit,\n\tclassName,\n}: HookListItemProps) => {\n\tconst [showDeleteConfirm, setShowDeleteConfirm] = useState(false);\n\n\tconst handleToggle = useCallback(() => {\n\t\tonToggle(hook.id, !hook.enabled);\n\t}, [hook.id, hook.enabled, onToggle]);\n\n\tconst handleEdit = useCallback(() => {\n\t\tonEdit(hook);\n\t}, [hook, onEdit]);\n\n\tconst handleDeleteClick = useCallback(() => {\n\t\tsetShowDeleteConfirm(true);\n\t}, []);\n\n\tconst handleDeleteConfirm = useCallback(() => {\n\t\tonDelete(hook.id);\n\t\tsetShowDeleteConfirm(false);\n\t}, [hook.id, onDelete]);\n\n\tconst handleDeleteCancel = useCallback(() => {\n\t\tsetShowDeleteConfirm(false);\n\t}, []);\n\n\t// Format trigger display\n\tconst triggerDisplay = `${hook.trigger.agent}/${hook.trigger.operation}`;\n\n\t// Format action display\n\tconst getActionDisplay = (): string => {\n\t\tswitch (hook.action.type) {\n\t\t\tcase \"agent\":\n\t\t\t\treturn `Agent: ${(hook.action.parameters as { command: string }).command}`;\n\t\t\tcase \"git\":\n\t\t\t\treturn `Git: ${(hook.action.parameters as { operation: string }).operation}`;\n\t\t\tcase \"github\":\n\t\t\t\treturn `GitHub: ${(hook.action.parameters as { operation: string }).operation}`;\n\t\t\tcase \"custom\":\n\t\t\t\treturn `Custom: ${(hook.action.parameters as { agentName: string }).agentName}`;\n\t\t\tdefault:\n\t\t\t\treturn hook.action.type;\n\t\t}\n\t};\n\n\t// Render timing badge\n\tconst renderTimingBadge = () => {\n\t\tconst timing = hook.trigger.timing || \"after\"; // Default to \"after\" for backward compatibility\n\t\tconst isBlocking = timing === \"before\" && hook.trigger.waitForCompletion;\n\n\t\tconst timingColors = {\n\t\t\tbefore: \"text-[color:var(--vscode-charts-blue,#3794ff)]\",\n\t\t\tafter: \"text-[color:var(--vscode-charts-green,#89d185)]\",\n\t\t};\n\n\t\tlet tooltipText = \"Runs after operation completes\";\n\t\tif (timing === \"before\") {\n\t\t\ttooltipText = isBlocking\n\t\t\t\t? \"Runs before operation and blocks until complete\"\n\t\t\t\t: \"Runs before operation (non-blocking)\";\n\t\t}\n\n\t\treturn (\n\t\t\t<span\n\t\t\t\tclassName={`rounded border border-[color:color-mix(in_srgb,var(--vscode-foreground)_20%,transparent)] px-2 py-0.5 ${timingColors[timing]}`}\n\t\t\t\ttitle={tooltipText}\n\t\t\t>\n\t\t\t\t{timing}\n\t\t\t\t{isBlocking && \" (blocking)\"}\n\t\t\t</span>\n\t\t);\n\t}",
    "start_line": 13,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function HookListItem",
    "component_id": "ui.src.features.hooks-view.components.hook-list-item.HookListItem"
  },
  "ui.src.features.hooks-view.components.mcp-action-picker.MCPServer": {
    "id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPServer",
    "name": "MCPServer",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.mcp-action-picker.MCPTool"
    ],
    "source_code": "interface MCPServer {\n\tid: string;\n\tname: string;\n\tdescription: string;\n\tstatus: \"available\" | \"unavailable\" | \"unknown\";\n\ttools: MCPTool[];\n\tlastDiscovered: number;\n}",
    "start_line": 7,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServer",
    "component_id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPServer"
  },
  "ui.src.features.hooks-view.components.mcp-action-picker.MCPTool": {
    "id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPTool",
    "name": "MCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchema"
    ],
    "source_code": "interface MCPTool {\n\tname: string;\n\tdisplayName: string;\n\tdescription: string;\n\tinputSchema: JSONSchema;\n\tserverId: string;\n}",
    "start_line": 19,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPTool",
    "component_id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPTool"
  },
  "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchema": {
    "id": "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchema",
    "name": "JSONSchema",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchemaProperty"
    ],
    "source_code": "interface JSONSchema {\n\ttype: string;\n\tproperties?: Record<string, JSONSchemaProperty>;\n\trequired?: string[];\n}",
    "start_line": 30,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchema",
    "component_id": "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchema"
  },
  "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchemaProperty": {
    "id": "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchemaProperty",
    "name": "JSONSchemaProperty",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "depends_on": [],
    "source_code": "interface JSONSchemaProperty {\n\ttype: string;\n\tdescription?: string;\n\tenum?: string[];\n}",
    "start_line": 39,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchemaProperty",
    "component_id": "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchemaProperty"
  },
  "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionSelection": {
    "id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionSelection",
    "name": "MCPActionSelection",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.mcp-action-picker.JSONSchema"
    ],
    "source_code": "interface MCPActionSelection {\n\tserverId: string;\n\tserverName: string;\n\ttoolName: string;\n\ttoolDisplayName: string;\n\tinputSchema: JSONSchema;\n}",
    "start_line": 48,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPActionSelection",
    "component_id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionSelection"
  },
  "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionPickerProps": {
    "id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionPickerProps",
    "name": "MCPActionPickerProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-action-picker.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.components.mcp-action-picker.MCPServer",
      "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionSelection"
    ],
    "source_code": "interface MCPActionPickerProps {\n\tservers?: MCPServer[];\n\tloading?: boolean;\n\terror?: string;\n\tdisabled?: boolean;\n\tonSelectionChange?: (selection: MCPActionSelection | null) => void;\n}",
    "start_line": 56,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPActionPickerProps",
    "component_id": "ui.src.features.hooks-view.components.mcp-action-picker.MCPActionPickerProps"
  },
  "ui.src.features.hooks-view.components.mcp-tools-selector.MCPToolsSelectorProps": {
    "id": "ui.src.features.hooks-view.components.mcp-tools-selector.MCPToolsSelectorProps",
    "name": "MCPToolsSelectorProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/components/mcp-tools-selector.tsx",
    "relative_path": "ui/src/features/hooks-view/components/mcp-tools-selector.tsx",
    "depends_on": [
      "ui.src.features.hooks-view.types.SelectedMCPTool",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer"
    ],
    "source_code": "interface MCPToolsSelectorProps {\n\tservers: MCPServer[];\n\tselectedTools: SelectedMCPTool[];\n\tonSelectionChange: (selectedTools: SelectedMCPTool[]) => void;\n\tdisabled?: boolean;\n}",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPToolsSelectorProps",
    "component_id": "ui.src.features.hooks-view.components.mcp-tools-selector.MCPToolsSelectorProps"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer",
    "name": "MCPServer",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool"
    ],
    "source_code": "interface MCPServer {\n\tid: string;\n\tname: string;\n\tdescription: string;\n\tstatus: \"available\" | \"unavailable\" | \"unknown\";\n\ttools: MCPTool[];\n\tlastDiscovered: number;\n}",
    "start_line": 7,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPServer",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool",
    "name": "MCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchema"
    ],
    "source_code": "interface MCPTool {\n\tname: string;\n\tdisplayName: string;\n\tdescription: string;\n\tinputSchema: JSONSchema;\n\tserverId: string;\n}",
    "start_line": 19,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPTool",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPTool"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchema": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchema",
    "name": "JSONSchema",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchemaProperty"
    ],
    "source_code": "interface JSONSchema {\n\ttype: string;\n\tproperties?: Record<string, JSONSchemaProperty>;\n\trequired?: string[];\n}",
    "start_line": 30,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchema",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchema"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchemaProperty": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchemaProperty",
    "name": "JSONSchemaProperty",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [],
    "source_code": "interface JSONSchemaProperty {\n\ttype: string;\n\tdescription?: string;\n\tenum?: string[];\n}",
    "start_line": 39,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface JSONSchemaProperty",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.JSONSchemaProperty"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryRequest": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryRequest",
    "name": "MCPDiscoveryRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [],
    "source_code": "interface MCPDiscoveryRequest {\n\ttype: \"hooks/mcp-discover\";\n\tpayload?: {\n\t\tforceRefresh?: boolean;\n\t};\n}",
    "start_line": 48,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPDiscoveryRequest",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryRequest"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryResponse": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryResponse",
    "name": "MCPDiscoveryResponse",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer"
    ],
    "source_code": "interface MCPDiscoveryResponse {\n\ttype: \"hooks/mcp-servers\" | \"hooks.mcp-servers\";\n\tpayload: {\n\t\tservers: MCPServer[];\n\t};\n}",
    "start_line": 58,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPDiscoveryResponse",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryResponse"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryError": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryError",
    "name": "MCPDiscoveryError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [],
    "source_code": "interface MCPDiscoveryError {\n\ttype: \"hooks/mcp-error\" | \"hooks.mcp-error\";\n\tpayload: {\n\t\tmessage: string;\n\t};\n}",
    "start_line": 68,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPDiscoveryError",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryError"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.UseMCPServersState": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.UseMCPServersState",
    "name": "UseMCPServersState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPServer"
    ],
    "source_code": "interface UseMCPServersState {\n\tservers: MCPServer[];\n\tloading: boolean;\n\terror: string | undefined;\n\tdiscover: (forceRefresh?: boolean) => void;\n\tclearError: () => void;\n}",
    "start_line": 78,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseMCPServersState",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.UseMCPServersState"
  },
  "ui.src.features.hooks-view.hooks.use-mcp-servers.useMCPServers": {
    "id": "ui.src.features.hooks-view.hooks.use-mcp-servers.useMCPServers",
    "name": "useMCPServers",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "relative_path": "ui/src/features/hooks-view/hooks/use-mcp-servers.ts",
    "depends_on": [
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryError",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryResponse",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.MCPDiscoveryRequest",
      "ui.src.features.hooks-view.hooks.use-mcp-servers.UseMCPServersState",
      "src.panels.welcome-screen-panel.postMessage"
    ],
    "source_code": "useMCPServers = (): UseMCPServersState => {\n\t// State management\n\tconst [servers, setServers] = useState<MCPServer[]>([]);\n\tconst [loading, setLoading] = useState(true);\n\tconst [error, setError] = useState<string | undefined>();\n\n\t/**\n\t * Request MCP server discovery from extension\n\t */\n\tconst discover = useCallback((forceRefresh = false) => {\n\t\tsetLoading(true);\n\t\tsetError(undefined);\n\n\t\tconst message: MCPDiscoveryRequest = {\n\t\t\ttype: \"hooks/mcp-discover\",\n\t\t\tpayload: { forceRefresh },\n\t\t};\n\n\t\tvscode.postMessage({\n\t\t\t...message,\n\t\t\tcommand: message.type.replace(/\\//g, \".\"),\n\t\t});\n\t}, []);\n\n\t/**\n\t * Clear error state\n\t */\n\tconst clearError = useCallback(() => {\n\t\tsetError(undefined);\n\t}, []);\n\n\t/**\n\t * Handle incoming messages from extension\n\t */\n\tuseEffect(() => {\n\t\tconst isServersMessage = (type: string | undefined) =>\n\t\t\ttype === \"hooks/mcp-servers\" || type === \"hooks.mcp-servers\";\n\t\tconst isErrorMessage = (type: string | undefined) =>\n\t\t\ttype === \"hooks/mcp-error\" || type === \"hooks.mcp-error\";\n\t\tconst extractBody = (payload: Record<string, unknown>) =>\n\t\t\t(payload as Record<string, unknown>).payload ??\n\t\t\t(payload as Record<string, unknown>).data;\n\n\t\tconst handleServersMessage = (body: Record<string, unknown>) => {\n\t\t\tconst discoveredServers = Array.isArray((body as any).servers)\n\t\t\t\t? ((body as any).servers as unknown[])\n\t\t\t\t: [];\n\t\t\tsetServers(discoveredServers);\n\t\t\tsetLoading(false);\n\t\t\tsetError(undefined);\n\t\t};\n\n\t\tconst handleErrorMessage = (body: Record<string, unknown>) => {\n\t\t\tconst message = (body as MCPDiscoveryError[\"payload\"])?.message;\n\t\t\tif (!message) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetError(message);\n\t\t\tsetLoading(false);\n\t\t};\n\n\t\tconst handleMessage = (\n\t\t\tevent: MessageEvent<\n\t\t\t\tMCPDiscoveryResponse | MCPDiscoveryError | Record<string, unknown>\n\t\t\t>\n\t\t) => {\n\t\t\tconst payload = event.data;\n\t\t\tif (!payload || typeof payload !== \"object\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst messageType = (payload as any).type ?? (payload as any).command;\n\t\t\tconst body = extractBody(payload as Record<string, unknown>);\n\n\t\t\tif (isServersMessage(messageType) && body) {\n\t\t\t\thandleServersMessage(body as Record<string, unknown>);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isErrorMessage(messageType) && body) {\n\t\t\t\thandleErrorMessage(body as Record<string, unknown>);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"message\", handleMessage);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"message\", handleMessage);\n\t\t};\n\t}, []);\n\n\t/**\n\t * Auto-discover on mount\n\t */\n\tuseEffect(() => {\n\t\tdiscover();\n\t}, [discover]);\n\n\treturn {\n\t\tservers,\n\t\tloading,\n\t\terror,\n\t\tdiscover,\n\t\tclearError,\n\t};\n}",
    "start_line": 105,
    "end_line": 210,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useMCPServers",
    "component_id": "ui.src.features.hooks-view.hooks.use-mcp-servers.useMCPServers"
  },
  "ui.src.features.hooks-view.types.AgentType": {
    "id": "ui.src.features.hooks-view.types.AgentType",
    "name": "AgentType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type AgentType = \"speckit\" | \"openspec\";",
    "start_line": 3,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AgentType",
    "component_id": "ui.src.features.hooks-view.types.AgentType"
  },
  "ui.src.features.hooks-view.types.OperationType": {
    "id": "ui.src.features.hooks-view.types.OperationType",
    "name": "OperationType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type OperationType =\n\t| \"research\"\n\t| \"datamodel\"\n\t| \"design\"\n\t| \"specify\"\n\t| \"clarify\"\n\t| \"plan\"\n\t| \"tasks\"\n\t| \"taskstoissues\"\n\t| \"analyze\"\n\t| \"checklist\"\n\t| \"constitution\"\n\t| \"implementation\"\n\t| \"unit-test\"\n\t| \"integration-test\";",
    "start_line": 5,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type OperationType",
    "component_id": "ui.src.features.hooks-view.types.OperationType"
  },
  "ui.src.features.hooks-view.types.TriggerTiming": {
    "id": "ui.src.features.hooks-view.types.TriggerTiming",
    "name": "TriggerTiming",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type TriggerTiming = \"before\" | \"after\";",
    "start_line": 21,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type TriggerTiming",
    "component_id": "ui.src.features.hooks-view.types.TriggerTiming"
  },
  "ui.src.features.hooks-view.types.TriggerCondition": {
    "id": "ui.src.features.hooks-view.types.TriggerCondition",
    "name": "TriggerCondition",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.TriggerTiming",
      "ui.src.features.hooks-view.types.OperationType",
      "ui.src.features.hooks-view.types.AgentType"
    ],
    "source_code": "interface TriggerCondition {\n\tagent: AgentType;\n\toperation: OperationType;\n\ttiming: TriggerTiming;\n\twaitForCompletion?: boolean; // Only for \"before\" timing: block operation until hook completes\n}",
    "start_line": 23,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TriggerCondition",
    "component_id": "ui.src.features.hooks-view.types.TriggerCondition"
  },
  "ui.src.features.hooks-view.types.ActionType": {
    "id": "ui.src.features.hooks-view.types.ActionType",
    "name": "ActionType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type ActionType = \"agent\" | \"git\" | \"github\" | \"custom\" | \"mcp\";",
    "start_line": 30,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ActionType",
    "component_id": "ui.src.features.hooks-view.types.ActionType"
  },
  "ui.src.features.hooks-view.types.AgentActionParams": {
    "id": "ui.src.features.hooks-view.types.AgentActionParams",
    "name": "AgentActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "interface AgentActionParams {\n\tcommand: string;\n}",
    "start_line": 32,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AgentActionParams",
    "component_id": "ui.src.features.hooks-view.types.AgentActionParams"
  },
  "ui.src.features.hooks-view.types.GitActionParams": {
    "id": "ui.src.features.hooks-view.types.GitActionParams",
    "name": "GitActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "interface GitActionParams {\n\toperation: \"commit\" | \"push\";\n\tmessageTemplate: string;\n\tpushToRemote?: boolean;\n}",
    "start_line": 36,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitActionParams",
    "component_id": "ui.src.features.hooks-view.types.GitActionParams"
  },
  "ui.src.features.hooks-view.types.GitHubActionParams": {
    "id": "ui.src.features.hooks-view.types.GitHubActionParams",
    "name": "GitHubActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "interface GitHubActionParams {\n\toperation: \"open-issue\" | \"close-issue\" | \"create-pr\" | \"add-comment\";\n\trepository?: string;\n\ttitleTemplate?: string;\n\tbodyTemplate?: string;\n\tissueNumber?: number;\n}",
    "start_line": 42,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GitHubActionParams",
    "component_id": "ui.src.features.hooks-view.types.GitHubActionParams"
  },
  "ui.src.features.hooks-view.types.CustomActionParams": {
    "id": "ui.src.features.hooks-view.types.CustomActionParams",
    "name": "CustomActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.SelectedMCPTool",
      "ui.src.features.hooks-view.types.CopilotCliOptions"
    ],
    "source_code": "interface CustomActionParams {\n\tagentId?: string; // Optional: Agent ID from agent registry\n\tagentName?: string; // Custom agent identifier (deprecated - use agentId)\n\tagentType?: \"local\" | \"background\"; // Explicit execution type override\n\tprompt?: string; // Instruction/action text for the agent\n\tselectedTools?: SelectedMCPTool[]; // Optional: MCP tools available to agent\n\targuments?: string; // Template string with $variable syntax for passing trigger context\n\tcliOptions?: CopilotCliOptions; // GitHub Copilot CLI options\n}",
    "start_line": 50,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CustomActionParams",
    "component_id": "ui.src.features.hooks-view.types.CustomActionParams"
  },
  "ui.src.features.hooks-view.types.CopilotCliOptions": {
    "id": "ui.src.features.hooks-view.types.CopilotCliOptions",
    "name": "CopilotCliOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.CopilotModel",
      "ui.src.features.hooks-view.types.CopilotLogLevel"
    ],
    "source_code": "interface CopilotCliOptions {\n\t// Directory and Path Options\n\taddDir?: string[];\n\tallowAllPaths?: boolean;\n\tdisallowTempDir?: boolean;\n\n\t// Tool Permissions\n\tallowAllTools?: boolean;\n\tallowTool?: string[];\n\tavailableTools?: string[];\n\texcludedTools?: string[];\n\tdenyTool?: string[];\n\n\t// URL Permissions\n\tallowAllUrls?: boolean;\n\tallowUrl?: string[];\n\tdenyUrl?: string[];\n\n\t// GitHub MCP Server Options\n\taddGithubMcpTool?: string[];\n\taddGithubMcpToolset?: string[];\n\tenableAllGithubMcpTools?: boolean;\n\n\t// MCP Server Configuration\n\tadditionalMcpConfig?: string[];\n\tdisableBuiltinMcps?: boolean;\n\tdisableMcpServer?: string[];\n\n\t// Execution Options\n\tagent?: string;\n\tmodel?: CopilotModel;\n\tnoAskUser?: boolean;\n\tdisableParallelToolsExecution?: boolean;\n\tnoCustomInstructions?: boolean;\n\n\t// Output and Logging Options\n\tsilent?: boolean;\n\tlogLevel?: CopilotLogLevel;\n\tlogDir?: string;\n\tnoColor?: boolean;\n\tplainDiff?: boolean;\n\tscreenReader?: boolean;\n\tstream?: \"on\" | \"off\";\n\n\t// Session Options\n\tresume?: boolean | string;\n\tcontinue?: boolean;\n\tshare?: boolean | string;\n\tshareGist?: boolean;\n\n\t// Configuration\n\tconfigDir?: string;\n\tbanner?: boolean;\n\tnoAutoUpdate?: boolean;\n\n\t// Combined Flags\n\tallowAll?: boolean;\n}",
    "start_line": 63,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CopilotCliOptions",
    "component_id": "ui.src.features.hooks-view.types.CopilotCliOptions"
  },
  "ui.src.features.hooks-view.types.CopilotModel": {
    "id": "ui.src.features.hooks-view.types.CopilotModel",
    "name": "CopilotModel",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type CopilotModel =\n\t| \"claude-sonnet-4.5\"\n\t| \"claude-haiku-4.5\"\n\t| \"claude-opus-4.5\"\n\t| \"claude-sonnet-4\"\n\t| \"gpt-5.2-codex\"\n\t| \"gpt-5.1-codex-max\"\n\t| \"gpt-5.1-codex\"\n\t| \"gpt-5.2\"\n\t| \"gpt-5.1\"\n\t| \"gpt-5\"\n\t| \"gpt-5.1-codex-mini\"\n\t| \"gpt-5-mini\"\n\t| \"gpt-4.1\";",
    "start_line": 122,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CopilotModel",
    "component_id": "ui.src.features.hooks-view.types.CopilotModel"
  },
  "ui.src.features.hooks-view.types.CopilotLogLevel": {
    "id": "ui.src.features.hooks-view.types.CopilotLogLevel",
    "name": "CopilotLogLevel",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type CopilotLogLevel =\n\t| \"none\"\n\t| \"error\"\n\t| \"warning\"\n\t| \"info\"\n\t| \"debug\"\n\t| \"all\"\n\t| \"default\";",
    "start_line": 137,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type CopilotLogLevel",
    "component_id": "ui.src.features.hooks-view.types.CopilotLogLevel"
  },
  "ui.src.features.hooks-view.types.MCPActionParams": {
    "id": "ui.src.features.hooks-view.types.MCPActionParams",
    "name": "MCPActionParams",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.SelectedMCPTool"
    ],
    "source_code": "interface MCPActionParams {\n\t// Model and instruction\n\tmodelId?: string; // Optional: LLM model ID from GitHub subscription (e.g., 'gpt-4o', 'claude-3-5-sonnet')\n\tprompt: string; // Instruction/action text for the agent to execute\n\n\t// Selected tools (multiple selection supported)\n\tselectedTools: SelectedMCPTool[]; // Array of selected MCP tools\n\n\t// Legacy fields (kept for backward compatibility)\n\tserverId?: string; // MCP server identifier (deprecated, use selectedTools)\n\tserverName?: string; // Server display name (deprecated)\n\ttoolName?: string; // Tool to execute (deprecated, use selectedTools)\n\ttoolDisplayName?: string; // Tool display name (deprecated)\n\tparameterMappings?: Array<{\n\t\ttoolParam: string;\n\t\tsource: \"context\" | \"literal\" | \"template\";\n\t\tvalue: string;\n\t}>;\n\ttimeout?: number;\n}",
    "start_line": 146,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MCPActionParams",
    "component_id": "ui.src.features.hooks-view.types.MCPActionParams"
  },
  "ui.src.features.hooks-view.types.SelectedMCPTool": {
    "id": "ui.src.features.hooks-view.types.SelectedMCPTool",
    "name": "SelectedMCPTool",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "interface SelectedMCPTool {\n\tserverId: string; // Server providing the tool\n\tserverName: string; // Display name of server\n\ttoolName: string; // Tool identifier\n\ttoolDisplayName: string; // Human-readable tool name\n}",
    "start_line": 167,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SelectedMCPTool",
    "component_id": "ui.src.features.hooks-view.types.SelectedMCPTool"
  },
  "ui.src.features.hooks-view.types.ActionParameters": {
    "id": "ui.src.features.hooks-view.types.ActionParameters",
    "name": "ActionParameters",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type ActionParameters =\n\t| AgentActionParams\n\t| GitActionParams\n\t| GitHubActionParams\n\t| CustomActionParams\n\t| MCPActionParams;",
    "start_line": 174,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ActionParameters",
    "component_id": "ui.src.features.hooks-view.types.ActionParameters"
  },
  "ui.src.features.hooks-view.types.ActionConfig": {
    "id": "ui.src.features.hooks-view.types.ActionConfig",
    "name": "ActionConfig",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.ActionParameters",
      "ui.src.features.hooks-view.types.ActionType"
    ],
    "source_code": "interface ActionConfig {\n\ttype: ActionType;\n\tparameters: ActionParameters;\n}",
    "start_line": 181,
    "end_line": 184,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ActionConfig",
    "component_id": "ui.src.features.hooks-view.types.ActionConfig"
  },
  "ui.src.features.hooks-view.types.Hook": {
    "id": "ui.src.features.hooks-view.types.Hook",
    "name": "Hook",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.ActionConfig",
      "ui.src.features.hooks-view.types.TriggerCondition"
    ],
    "source_code": "interface Hook {\n\tid: string;\n\tname: string;\n\tenabled: boolean;\n\ttrigger: TriggerCondition;\n\taction: ActionConfig;\n\tcreatedAt: number;\n\tmodifiedAt: number;\n\tlastExecutedAt?: number;\n\texecutionCount: number;\n}",
    "start_line": 186,
    "end_line": 196,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Hook",
    "component_id": "ui.src.features.hooks-view.types.Hook"
  },
  "ui.src.features.hooks-view.types.HookExecutionStatusState": {
    "id": "ui.src.features.hooks-view.types.HookExecutionStatusState",
    "name": "HookExecutionStatusState",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type HookExecutionStatusState = \"executing\" | \"completed\" | \"failed\";",
    "start_line": 198,
    "end_line": 198,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type HookExecutionStatusState",
    "component_id": "ui.src.features.hooks-view.types.HookExecutionStatusState"
  },
  "ui.src.features.hooks-view.types.HookExecutionStatusPayload": {
    "id": "ui.src.features.hooks-view.types.HookExecutionStatusPayload",
    "name": "HookExecutionStatusPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.HookExecutionStatusState"
    ],
    "source_code": "interface HookExecutionStatusPayload {\n\thookId: string;\n\tstatus: HookExecutionStatusState;\n\terrorMessage?: string;\n}",
    "start_line": 200,
    "end_line": 204,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookExecutionStatusPayload",
    "component_id": "ui.src.features.hooks-view.types.HookExecutionStatusPayload"
  },
  "ui.src.features.hooks-view.types.HookExecutionStatusEntry": {
    "id": "ui.src.features.hooks-view.types.HookExecutionStatusEntry",
    "name": "HookExecutionStatusEntry",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "interface HookExecutionStatusEntry extends HookExecutionStatusPayload {\n\tupdatedAt: number;\n}",
    "start_line": 206,
    "end_line": 208,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookExecutionStatusEntry",
    "component_id": "ui.src.features.hooks-view.types.HookExecutionStatusEntry"
  },
  "ui.src.features.hooks-view.types.ExecutionStatus": {
    "id": "ui.src.features.hooks-view.types.ExecutionStatus",
    "name": "ExecutionStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [],
    "source_code": "type ExecutionStatus = \"success\" | \"failure\" | \"skipped\" | \"timeout\";",
    "start_line": 210,
    "end_line": 210,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ExecutionStatus",
    "component_id": "ui.src.features.hooks-view.types.ExecutionStatus"
  },
  "ui.src.features.hooks-view.types.HookExecutionLog": {
    "id": "ui.src.features.hooks-view.types.HookExecutionLog",
    "name": "HookExecutionLog",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.ExecutionStatus"
    ],
    "source_code": "interface HookExecutionLog {\n\tid: string;\n\thookId: string;\n\texecutionId: string;\n\tchainDepth: number;\n\ttriggeredAt: number;\n\tcompletedAt?: number;\n\tduration?: number;\n\tstatus: ExecutionStatus;\n\terror?: {\n\t\tcode?: string;\n\t\tmessage: string;\n\t};\n\tcontextSnapshot: Record<string, unknown>;\n}",
    "start_line": 212,
    "end_line": 226,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface HookExecutionLog",
    "component_id": "ui.src.features.hooks-view.types.HookExecutionLog"
  },
  "ui.src.features.hooks-view.types.HooksExtensionMessage": {
    "id": "ui.src.features.hooks-view.types.HooksExtensionMessage",
    "name": "HooksExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.HookExecutionStatusPayload",
      "ui.src.features.hooks-view.types.Hook",
      "ui.src.features.hooks-view.types.HookExecutionLog"
    ],
    "source_code": "type HooksExtensionMessage =\n\t| {\n\t\t\ttype: \"hooks/sync\";\n\t\t\tcommand?: \"hooks.sync\";\n\t\t\tpayload: { hooks: Hook[] };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/created\";\n\t\t\tcommand?: \"hooks.created\";\n\t\t\tpayload: { hook: Hook };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/updated\";\n\t\t\tcommand?: \"hooks.updated\";\n\t\t\tpayload: { hook: Hook };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/deleted\";\n\t\t\tcommand?: \"hooks.deleted\";\n\t\t\tpayload: { id: string };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/error\";\n\t\t\tcommand?: \"hooks.error\";\n\t\t\tpayload: {\n\t\t\t\tmessage: string;\n\t\t\t\tvalidationErrors?: Array<{ field: string; message: string }>;\n\t\t\t};\n\t  }\n\t| {\n\t\t\ttype: \"hooks/execution-status\";\n\t\t\tcommand?: \"hooks.execution-status\";\n\t\t\tpayload: HookExecutionStatusPayload;\n\t  }\n\t| {\n\t\t\ttype: \"hooks/logs\";\n\t\t\tcommand?: \"hooks.logs\";\n\t\t\tpayload: { logs: HookExecutionLog[] };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/show-form\";\n\t\t\tcommand?: \"hooks.show-form\";\n\t\t\tpayload?: { mode?: \"create\" | \"edit\"; hook?: Hook };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/show-logs\";\n\t\t\tcommand?: \"hooks.show-logs\";\n\t\t\tpayload: { visible: boolean; hookId?: string };\n\t  };",
    "start_line": 229,
    "end_line": 277,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type HooksExtensionMessage",
    "component_id": "ui.src.features.hooks-view.types.HooksExtensionMessage"
  },
  "ui.src.features.hooks-view.types.HooksWebviewMessage": {
    "id": "ui.src.features.hooks-view.types.HooksWebviewMessage",
    "name": "HooksWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/hooks-view/types.ts",
    "relative_path": "ui/src/features/hooks-view/types.ts",
    "depends_on": [
      "ui.src.features.hooks-view.types.Hook"
    ],
    "source_code": "type HooksWebviewMessage =\n\t| { type: \"hooks/ready\"; command?: \"hooks.ready\" }\n\t| { type: \"hooks/list\"; command?: \"hooks.list\" }\n\t| {\n\t\t\ttype: \"hooks/create\";\n\t\t\tcommand?: \"hooks.create\";\n\t\t\tpayload: Omit<Hook, \"id\" | \"createdAt\" | \"modifiedAt\" | \"executionCount\">;\n\t  }\n\t| {\n\t\t\ttype: \"hooks/update\";\n\t\t\tcommand?: \"hooks.update\";\n\t\t\tpayload: { id: string; updates: Partial<Hook> };\n\t  }\n\t| { type: \"hooks/delete\"; command?: \"hooks.delete\"; payload: { id: string } }\n\t| {\n\t\t\ttype: \"hooks/toggle\";\n\t\t\tcommand?: \"hooks.toggle\";\n\t\t\tpayload: { id: string; enabled: boolean };\n\t  }\n\t| {\n\t\t\ttype: \"hooks/logs\";\n\t\t\tcommand?: \"hooks.logs\";\n\t\t\tpayload?: { hookId?: string };\n\t  };",
    "start_line": 280,
    "end_line": 303,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type HooksWebviewMessage",
    "component_id": "ui.src.features.hooks-view.types.HooksWebviewMessage"
  },
  "ui.src.features.preview.api.form-bridge.FormFieldDelta": {
    "id": "ui.src.features.preview.api.form-bridge.FormFieldDelta",
    "name": "FormFieldDelta",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [],
    "source_code": "interface FormFieldDelta {\n\tfieldId: string;\n\tvalue: string | string[];\n\tdirty: boolean;\n}",
    "start_line": 3,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormFieldDelta",
    "component_id": "ui.src.features.preview.api.form-bridge.FormFieldDelta"
  },
  "ui.src.features.preview.api.form-bridge.FormSubmissionPayload": {
    "id": "ui.src.features.preview.api.form-bridge.FormSubmissionPayload",
    "name": "FormSubmissionPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [
      "ui.src.features.preview.api.form-bridge.FormFieldDelta"
    ],
    "source_code": "interface FormSubmissionPayload {\n\tdocumentId: string;\n\tsessionId: string;\n\tfields: FormFieldDelta[];\n\tsubmittedAt: string;\n\trequestId?: string;\n}",
    "start_line": 9,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormSubmissionPayload",
    "component_id": "ui.src.features.preview.api.form-bridge.FormSubmissionPayload"
  },
  "ui.src.features.preview.api.form-bridge.FormSubmissionResult": {
    "id": "ui.src.features.preview.api.form-bridge.FormSubmissionResult",
    "name": "FormSubmissionResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [],
    "source_code": "interface FormSubmissionResult {\n\trequestId: string;\n\tstatus: \"success\" | \"error\";\n\tmessage?: string;\n}",
    "start_line": 17,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormSubmissionResult",
    "component_id": "ui.src.features.preview.api.form-bridge.FormSubmissionResult"
  },
  "ui.src.features.preview.api.form-bridge.PendingRequest": {
    "id": "ui.src.features.preview.api.form-bridge.PendingRequest",
    "name": "PendingRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [
      "ui.src.features.preview.api.form-bridge.FormSubmissionResult"
    ],
    "source_code": "interface PendingRequest {\n\tresolve: (result: FormSubmissionResult) => void;\n\treject: (error: Error) => void;\n\ttimer: number;\n}",
    "start_line": 23,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PendingRequest",
    "component_id": "ui.src.features.preview.api.form-bridge.PendingRequest"
  },
  "ui.src.features.preview.api.form-bridge.ensureListener": {
    "id": "ui.src.features.preview.api.form-bridge.ensureListener",
    "name": "ensureListener",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [
      "src.features.agents.resource-cache.get",
      "src.features.spec.spec-manager.delete",
      "src.features.hooks.services.mcp-parameter-resolver.resolve"
    ],
    "source_code": "function ensureListener() {\n\tif (listenerRegistered || typeof window === \"undefined\") {\n\t\treturn;\n\t}\n\n\twindow.addEventListener(\"message\", (event) => {\n\t\tconst payload = event.data;\n\t\tif (!payload || typeof payload !== \"object\") {\n\t\t\treturn;\n\t\t}\n\n\t\tif (payload.type !== \"preview/forms/result\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst data = payload.payload as FormSubmissionResult | undefined;\n\t\tif (!data?.requestId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pendingRequest = pending.get(data.requestId);\n\t\tif (!pendingRequest) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.clearTimeout(pendingRequest.timer);\n\t\tpending.delete(data.requestId);\n\t\tpendingRequest.resolve(data);\n\t});\n\n\tlistenerRegistered = true;\n}",
    "start_line": 33,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensureListener",
    "component_id": "ui.src.features.preview.api.form-bridge.ensureListener"
  },
  "ui.src.features.preview.api.form-bridge.generateRequestId": {
    "id": "ui.src.features.preview.api.form-bridge.generateRequestId",
    "name": "generateRequestId",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [],
    "source_code": "function generateRequestId() {\n\tif (\n\t\ttypeof crypto !== \"undefined\" &&\n\t\ttypeof crypto.randomUUID === \"function\"\n\t) {\n\t\treturn crypto.randomUUID();\n\t}\n\treturn `form-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n}",
    "start_line": 66,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateRequestId",
    "component_id": "ui.src.features.preview.api.form-bridge.generateRequestId"
  },
  "ui.src.features.preview.api.form-bridge.submitForm": {
    "id": "ui.src.features.preview.api.form-bridge.submitForm",
    "name": "submitForm",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/form-bridge.ts",
    "relative_path": "ui/src/features/preview/api/form-bridge.ts",
    "depends_on": [
      "ui.src.features.preview.api.form-bridge.FormSubmissionResult",
      "src.features.spec.spec-manager.delete",
      "ui.src.features.preview.api.form-bridge.ensureListener",
      "ui.src.features.preview.api.form-bridge.generateRequestId",
      "ui.src.features.preview.api.form-bridge.FormSubmissionPayload",
      "src.panels.welcome-screen-panel.postMessage"
    ],
    "source_code": "function submitForm(\n\tpayload: FormSubmissionPayload\n): Promise<FormSubmissionResult> {\n\tif (payload.fields.length === 0) {\n\t\treturn Promise.reject(new Error(\"No fields changed\"));\n\t}\n\n\tensureListener();\n\n\tconst requestId = payload.requestId ?? generateRequestId();\n\n\treturn new Promise<FormSubmissionResult>((resolve, reject) => {\n\t\tconst timer = window.setTimeout(() => {\n\t\t\tpending.delete(requestId);\n\t\t\treject(new Error(\"Form submission timed out\"));\n\t\t}, DEFAULT_TIMEOUT_MS);\n\n\t\tpending.set(requestId, { resolve, reject, timer });\n\n\t\tvscode.postMessage({\n\t\t\ttype: \"preview/forms/submit\",\n\t\t\tpayload: {\n\t\t\t\t...payload,\n\t\t\t\trequestId,\n\t\t\t},\n\t\t});\n\t});\n}",
    "start_line": 76,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "payload"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function submitForm",
    "component_id": "ui.src.features.preview.api.form-bridge.submitForm"
  },
  "ui.src.features.preview.api.refine-bridge.SubmitRefinementInput": {
    "id": "ui.src.features.preview.api.refine-bridge.SubmitRefinementInput",
    "name": "SubmitRefinementInput",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/refine-bridge.ts",
    "relative_path": "ui/src/features/preview/api/refine-bridge.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewRefinementIssueType"
    ],
    "source_code": "interface SubmitRefinementInput {\n\tdocumentId: string;\n\tdocumentType: string;\n\tdocumentVersion?: string;\n\tsectionRef?: string;\n\tissueType: PreviewRefinementIssueType;\n\tdescription: string;\n}",
    "start_line": 4,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SubmitRefinementInput",
    "component_id": "ui.src.features.preview.api.refine-bridge.SubmitRefinementInput"
  },
  "ui.src.features.preview.api.refine-bridge.SubmitRefinementResult": {
    "id": "ui.src.features.preview.api.refine-bridge.SubmitRefinementResult",
    "name": "SubmitRefinementResult",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/refine-bridge.ts",
    "relative_path": "ui/src/features/preview/api/refine-bridge.ts",
    "depends_on": [],
    "source_code": "interface SubmitRefinementResult {\n\trequestId: string;\n\tstatus: \"success\" | \"error\";\n\tmessage?: string;\n}",
    "start_line": 13,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SubmitRefinementResult",
    "component_id": "ui.src.features.preview.api.refine-bridge.SubmitRefinementResult"
  },
  "ui.src.features.preview.api.refine-bridge.PendingRequest": {
    "id": "ui.src.features.preview.api.refine-bridge.PendingRequest",
    "name": "PendingRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/refine-bridge.ts",
    "relative_path": "ui/src/features/preview/api/refine-bridge.ts",
    "depends_on": [
      "ui.src.features.preview.api.refine-bridge.SubmitRefinementResult"
    ],
    "source_code": "interface PendingRequest {\n\tresolve: (value: SubmitRefinementResult) => void;\n\treject: (error: Error) => void;\n\ttimer: number;\n}",
    "start_line": 19,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PendingRequest",
    "component_id": "ui.src.features.preview.api.refine-bridge.PendingRequest"
  },
  "ui.src.features.preview.api.refine-bridge.ensureListener": {
    "id": "ui.src.features.preview.api.refine-bridge.ensureListener",
    "name": "ensureListener",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/refine-bridge.ts",
    "relative_path": "ui/src/features/preview/api/refine-bridge.ts",
    "depends_on": [
      "src.features.agents.resource-cache.get",
      "src.features.spec.spec-manager.delete",
      "src.features.hooks.services.mcp-parameter-resolver.resolve"
    ],
    "source_code": "function ensureListener() {\n\tif (listenerRegistered || typeof window === \"undefined\") {\n\t\treturn;\n\t}\n\n\twindow.addEventListener(\"message\", (event) => {\n\t\tconst payload = event.data;\n\t\tif (!payload || typeof payload !== \"object\") {\n\t\t\treturn;\n\t\t}\n\n\t\tif (payload.type !== \"preview/refine/result\" || !payload.payload) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { requestId, status, message } =\n\t\t\tpayload.payload as SubmitRefinementResult;\n\t\tconst pendingRequest = requestId ? pending.get(requestId) : undefined;\n\t\tif (!pendingRequest) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.clearTimeout(pendingRequest.timer);\n\t\tpending.delete(requestId);\n\n\t\tif (status === \"error\") {\n\t\t\tpendingRequest.reject(\n\t\t\t\tnew Error(message ?? \"Failed to submit refinement\")\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tpendingRequest.resolve({ requestId, status, message });\n\t});\n\n\tlistenerRegistered = true;\n}",
    "start_line": 29,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensureListener",
    "component_id": "ui.src.features.preview.api.refine-bridge.ensureListener"
  },
  "ui.src.features.preview.api.refine-bridge.generateRequestId": {
    "id": "ui.src.features.preview.api.refine-bridge.generateRequestId",
    "name": "generateRequestId",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/refine-bridge.ts",
    "relative_path": "ui/src/features/preview/api/refine-bridge.ts",
    "depends_on": [],
    "source_code": "function generateRequestId() {\n\tif (\n\t\ttypeof crypto !== \"undefined\" &&\n\t\ttypeof crypto.randomUUID === \"function\"\n\t) {\n\t\treturn crypto.randomUUID();\n\t}\n\treturn `refine-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n}",
    "start_line": 67,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateRequestId",
    "component_id": "ui.src.features.preview.api.refine-bridge.generateRequestId"
  },
  "ui.src.features.preview.api.refine-bridge.submitRefinement": {
    "id": "ui.src.features.preview.api.refine-bridge.submitRefinement",
    "name": "submitRefinement",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/api/refine-bridge.ts",
    "relative_path": "ui/src/features/preview/api/refine-bridge.ts",
    "depends_on": [
      "ui.src.features.preview.api.refine-bridge.SubmitRefinementInput",
      "src.features.spec.spec-manager.delete",
      "ui.src.features.preview.api.refine-bridge.generateRequestId",
      "ui.src.features.preview.api.refine-bridge.SubmitRefinementResult",
      "ui.src.features.preview.api.refine-bridge.ensureListener",
      "src.panels.welcome-screen-panel.postMessage"
    ],
    "source_code": "function submitRefinement(\n\tinput: SubmitRefinementInput\n): Promise<SubmitRefinementResult> {\n\tensureListener();\n\n\tconst requestId = generateRequestId();\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst timer = window.setTimeout(() => {\n\t\t\tpending.delete(requestId);\n\t\t\treject(new Error(\"Refinement request timed out\"));\n\t\t}, DEFAULT_TIMEOUT_MS);\n\n\t\tpending.set(requestId, { resolve, reject, timer });\n\n\t\tvscode.postMessage({\n\t\t\ttype: \"preview/refine/submit\",\n\t\t\tpayload: {\n\t\t\t\trequestId,\n\t\t\t\t...input,\n\t\t\t\tsubmittedAt: new Date().toISOString(),\n\t\t\t},\n\t\t});\n\t});\n}",
    "start_line": 77,
    "end_line": 101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "input"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function submitRefinement",
    "component_id": "ui.src.features.preview.api.refine-bridge.submitRefinement"
  },
  "ui.src.features.preview.hooks.use-form-validation.FormValidationState": {
    "id": "ui.src.features.preview.hooks.use-form-validation.FormValidationState",
    "name": "FormValidationState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/hooks/use-form-validation.ts",
    "relative_path": "ui/src/features/preview/hooks/use-form-validation.ts",
    "depends_on": [],
    "source_code": "interface FormValidationState {\n\tvalidationErrors: Array<{ fieldId: string; message: string }>;\n\thasErrors: boolean;\n\thasDirtyFields: boolean;\n\tisSubmitting: boolean;\n\treadOnlyMode: boolean;\n\treadOnlyReason?: string;\n\tvalidateAll: () => boolean;\n\tlastSubmittedAt?: string;\n}",
    "start_line": 5,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormValidationState",
    "component_id": "ui.src.features.preview.hooks.use-form-validation.FormValidationState"
  },
  "ui.src.features.preview.hooks.use-form-validation.useFormValidation": {
    "id": "ui.src.features.preview.hooks.use-form-validation.useFormValidation",
    "name": "useFormValidation",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/hooks/use-form-validation.ts",
    "relative_path": "ui/src/features/preview/hooks/use-form-validation.ts",
    "depends_on": [
      "ui.src.features.preview.stores.form-store.validateAll",
      "ui.src.stores.spec-explorer-store.subscribe",
      "ui.src.features.preview.hooks.use-form-validation.FormValidationState",
      "ui.src.features.preview.stores.form-store.hasDirtyFields"
    ],
    "source_code": "function useFormValidation(): FormValidationState {\n\tconst snapshot = useSyncExternalStore(\n\t\tformStore.subscribe,\n\t\tformStore.getSnapshot\n\t);\n\n\tconst validateAll = useCallback(() => formStore.validateAll(), []);\n\n\treturn {\n\t\tvalidationErrors: snapshot.validationErrors,\n\t\thasErrors: snapshot.validationErrors.length > 0,\n\t\thasDirtyFields: formStore.hasDirtyFields(),\n\t\tisSubmitting: snapshot.isSubmitting,\n\t\treadOnlyMode: snapshot.readOnlyMode,\n\t\treadOnlyReason: snapshot.readOnlyReason,\n\t\tvalidateAll,\n\t\tlastSubmittedAt: snapshot.lastSubmittedAt,\n\t};\n}",
    "start_line": 20,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useFormValidation",
    "component_id": "ui.src.features.preview.hooks.use-form-validation.useFormValidation"
  },
  "ui.src.features.preview.stores.form-store.FormFieldType": {
    "id": "ui.src.features.preview.stores.form-store.FormFieldType",
    "name": "FormFieldType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "type FormFieldType =\n\t| \"checkbox\"\n\t| \"dropdown\"\n\t| \"text\"\n\t| \"textarea\"\n\t| \"multiselect\";",
    "start_line": 18,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type FormFieldType",
    "component_id": "ui.src.features.preview.stores.form-store.FormFieldType"
  },
  "ui.src.features.preview.stores.form-store.FormField": {
    "id": "ui.src.features.preview.stores.form-store.FormField",
    "name": "FormField",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [
      "ui.src.features.preview.stores.form-store.FormFieldType"
    ],
    "source_code": "interface FormField {\n\tfieldId: string;\n\tlabel: string;\n\ttype: FormFieldType;\n\toptions?: string[];\n\trequired?: boolean;\n\tvalue?: string | string[]; // string[] for multiselect\n\tvalidationRules?: Record<string, unknown>;\n\treadOnly?: boolean;\n}",
    "start_line": 25,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormField",
    "component_id": "ui.src.features.preview.stores.form-store.FormField"
  },
  "ui.src.features.preview.stores.form-store.FormFieldState": {
    "id": "ui.src.features.preview.stores.form-store.FormFieldState",
    "name": "FormFieldState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "interface FormFieldState extends FormField {\n\tdirty: boolean;\n\terrors: string[];\n}",
    "start_line": 36,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormFieldState",
    "component_id": "ui.src.features.preview.stores.form-store.FormFieldState"
  },
  "ui.src.features.preview.stores.form-store.ValidationError": {
    "id": "ui.src.features.preview.stores.form-store.ValidationError",
    "name": "ValidationError",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "interface ValidationError {\n\tfieldId: string;\n\tmessage: string;\n}",
    "start_line": 41,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ValidationError",
    "component_id": "ui.src.features.preview.stores.form-store.ValidationError"
  },
  "ui.src.features.preview.stores.form-store.FormStoreSnapshot": {
    "id": "ui.src.features.preview.stores.form-store.FormStoreSnapshot",
    "name": "FormStoreSnapshot",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [
      "ui.src.features.preview.stores.form-store.ValidationError",
      "ui.src.features.preview.stores.form-store.FormFieldState"
    ],
    "source_code": "interface FormStoreSnapshot {\n\tdocumentId?: string;\n\tsessionId?: string;\n\tfields: Map<string, FormFieldState>;\n\tisSubmitting: boolean;\n\tlastSubmittedAt?: string;\n\tvalidationErrors: ValidationError[];\n\treadOnlyMode: boolean;\n\treadOnlyReason?: string;\n}",
    "start_line": 46,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FormStoreSnapshot",
    "component_id": "ui.src.features.preview.stores.form-store.FormStoreSnapshot"
  },
  "ui.src.features.preview.stores.form-store.InitializeFieldsOptions": {
    "id": "ui.src.features.preview.stores.form-store.InitializeFieldsOptions",
    "name": "InitializeFieldsOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [
      "ui.src.features.preview.stores.form-store.FormField"
    ],
    "source_code": "interface InitializeFieldsOptions {\n\tdocumentId: string;\n\tsessionId: string;\n\tfields: FormField[];\n\treadOnlyMode?: boolean;\n\treadOnlyReason?: string;\n}",
    "start_line": 57,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InitializeFieldsOptions",
    "component_id": "ui.src.features.preview.stores.form-store.InitializeFieldsOptions"
  },
  "ui.src.features.preview.stores.form-store.Listener": {
    "id": "ui.src.features.preview.stores.form-store.Listener",
    "name": "Listener",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "type Listener = () => void;",
    "start_line": 65,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Listener",
    "component_id": "ui.src.features.preview.stores.form-store.Listener"
  },
  "ui.src.features.preview.stores.form-store.FormStore": {
    "id": "ui.src.features.preview.stores.form-store.FormStore",
    "name": "FormStore",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [
      "ui.src.features.preview.stores.form-store.getDirtyFields",
      "ui.src.features.preview.stores.form-store.isFieldValueEmpty",
      "ui.src.features.preview.stores.form-store.InitializeFieldsOptions",
      "ui.src.features.preview.stores.form-store.validateField",
      "ui.src.features.preview.stores.form-store.validateAll",
      "ui.src.features.preview.stores.form-store.getAllValidationErrors",
      "ui.src.features.preview.stores.form-store.applyCustomValidations",
      "ui.src.features.preview.stores.form-store.ValidationError",
      "ui.src.features.preview.stores.form-store.Listener",
      "ui.src.features.preview.stores.form-store.FormStoreSnapshot",
      "src.features.agents.resource-cache.get",
      "ui.src.features.preview.stores.form-store.FormFieldState",
      "ui.src.features.preview.stores.form-store.emit",
      "src.features.spec.spec-manager.delete",
      "ui.src.features.preview.stores.preview-store.emit",
      "ui.src.features.preview.stores.form-store.validateSelectionField"
    ],
    "source_code": "class FormStore {\n\tprivate snapshot: FormStoreSnapshot = {\n\t\tfields: new Map(),\n\t\tisSubmitting: false,\n\t\tvalidationErrors: [],\n\t\treadOnlyMode: false,\n\t};\n\tprivate readonly listeners = new Set<Listener>();\n\n\tsubscribe = (listener: Listener) => {\n\t\tthis.listeners.add(listener);\n\t\treturn () => this.listeners.delete(listener);\n\t};\n\n\tgetSnapshot = (): FormStoreSnapshot => this.snapshot;\n\n\t/**\n\t * Initialize form fields from document payload\n\t * Called when preview loads a new document\n\t */\n\tinitializeFields(options: InitializeFieldsOptions) {\n\t\tconst fieldMap = new Map<string, FormFieldState>();\n\t\tconst {\n\t\t\tdocumentId,\n\t\t\tsessionId,\n\t\t\tfields,\n\t\t\treadOnlyMode = false,\n\t\t\treadOnlyReason,\n\t\t} = options;\n\n\t\tfor (const field of fields) {\n\t\t\tfieldMap.set(field.fieldId, {\n\t\t\t\t...field,\n\t\t\t\tdirty: false,\n\t\t\t\terrors: [],\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\tdocumentId,\n\t\t\tsessionId,\n\t\t\tfields: fieldMap,\n\t\t\tisSubmitting: false,\n\t\t\tvalidationErrors: [],\n\t\t\treadOnlyMode,\n\t\t\treadOnlyReason,\n\t\t};\n\n\t\tthis.emit();\n\t}\n\n\t/**\n\t * Update a single field's value\n\t * Marks field as dirty and triggers validation\n\t */\n\tupdateField(fieldId: string, value: string | string[]) {\n\t\tif (this.snapshot.readOnlyMode) {\n\t\t\tconsole.warn(\n\t\t\t\t`[FormStore] Cannot update field in read-only mode: ${fieldId}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst field = this.snapshot.fields.get(fieldId);\n\t\tif (!field) {\n\t\t\tconsole.warn(`[FormStore] Field not found: ${fieldId}`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (field.readOnly) {\n\t\t\tconsole.warn(`[FormStore] Field is read-only: ${fieldId}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update field state\n\t\tconst updatedField: FormFieldState = {\n\t\t\t...field,\n\t\t\tvalue,\n\t\t\tdirty: true,\n\t\t\terrors: this.validateField({ ...field, value }),\n\t\t};\n\n\t\tconst updatedFields = new Map(this.snapshot.fields);\n\t\tupdatedFields.set(fieldId, updatedField);\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tvalidationErrors: this.getAllValidationErrors(updatedFields),\n\t\t};\n\t\tthis.emit();\n\t}\n\n\t/**\n\t * Validate a single field based on its rules\n\t * Returns array of error messages\n\t */\n\tprivate validateField(field: FormFieldState): string[] {\n\t\tconst errors: string[] = [];\n\n\t\tif (field.required && this.isFieldValueEmpty(field)) {\n\t\t\terrors.push(`${field.label} is required`);\n\t\t}\n\n\t\terrors.push(...this.validateSelectionField(field));\n\n\t\tif (field.validationRules) {\n\t\t\terrors.push(...this.applyCustomValidations(field));\n\t\t}\n\n\t\treturn errors;\n\t}\n\n\tprivate isFieldValueEmpty(field: FormFieldState): boolean {\n\t\tif (Array.isArray(field.value)) {\n\t\t\treturn field.value.length === 0;\n\t\t}\n\t\treturn field.value === undefined || field.value === \"\";\n\t}\n\n\tprivate validateSelectionField(field: FormFieldState): string[] {\n\t\tconst errors: string[] = [];\n\n\t\tif (\n\t\t\tfield.type === \"dropdown\" &&\n\t\t\tfield.value &&\n\t\t\tfield.options &&\n\t\t\t!field.options.includes(field.value as string)\n\t\t) {\n\t\t\terrors.push(`Invalid selection for ${field.label}`);\n\t\t}\n\n\t\tif (field.type === \"multiselect\" && field.value && field.options) {\n\t\t\tconst values = Array.isArray(field.value) ? field.value : [field.value];\n\t\t\tconst invalidValues = values.filter(\n\t\t\t\t(value) => !field.options!.includes(value)\n\t\t\t);\n\t\t\tif (invalidValues.length > 0) {\n\t\t\t\terrors.push(\n\t\t\t\t\t`Invalid selections for ${field.label}: ${invalidValues.join(\", \")}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Apply custom validation rules defined in validationRules object\n\t * This is extensible for future validation needs\n\t */\n\tprivate applyCustomValidations(field: FormFieldState): string[] {\n\t\tconst errors: string[] = [];\n\t\tconst rules = field.validationRules || {};\n\n\t\t// Example: min/max length for text fields\n\t\tif (\n\t\t\trules.minLength &&\n\t\t\ttypeof field.value === \"string\" &&\n\t\t\tfield.value.length < (rules.minLength as number)\n\t\t) {\n\t\t\terrors.push(\n\t\t\t\t`${field.label} must be at least ${rules.minLength} characters`\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\trules.maxLength &&\n\t\t\ttypeof field.value === \"string\" &&\n\t\t\tfield.value.length > (rules.maxLength as number)\n\t\t) {\n\t\t\terrors.push(\n\t\t\t\t`${field.label} must not exceed ${rules.maxLength} characters`\n\t\t\t);\n\t\t}\n\n\t\t// Example: pattern matching (regex)\n\t\tif (rules.pattern && typeof field.value === \"string\") {\n\t\t\tconst regex = new RegExp(rules.pattern as string);\n\t\t\tif (!regex.test(field.value)) {\n\t\t\t\terrors.push(\n\t\t\t\t\trules.patternMessage\n\t\t\t\t\t\t? (rules.patternMessage as string)\n\t\t\t\t\t\t: `${field.label} format is invalid`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Collect all validation errors across all fields\n\t */\n\tprivate getAllValidationErrors(\n\t\tfields: Map<string, FormFieldState> = this.snapshot.fields\n\t): ValidationError[] {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tfor (const [fieldId, field] of fields) {\n\t\t\tif (field.errors.length > 0) {\n\t\t\t\terrors.push(\n\t\t\t\t\t...field.errors.map((message) => ({\n\t\t\t\t\t\tfieldId,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t}))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn errors;\n\t}\n\n\t/**\n\t * Validate all fields and return whether form is valid\n\t */\n\tvalidateAll(): boolean {\n\t\tconst updatedFields = new Map<string, FormFieldState>();\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tupdatedFields.set(fieldId, {\n\t\t\t\t...field,\n\t\t\t\terrors: this.validateField(field),\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tvalidationErrors: this.getAllValidationErrors(updatedFields),\n\t\t};\n\t\tthis.emit();\n\n\t\treturn this.snapshot.validationErrors.length === 0;\n\t}\n\n\t/**\n\t * Get dirty fields ready for submission\n\t * Returns only fields that have been modified\n\t */\n\tgetDirtyFields(): Array<{\n\t\tfieldId: string;\n\t\tvalue: string | string[];\n\t\tdirty: boolean;\n\t}> {\n\t\tconst dirtyFields: Array<{\n\t\t\tfieldId: string;\n\t\t\tvalue: string | string[];\n\t\t\tdirty: boolean;\n\t\t}> = [];\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tif (field.dirty && field.value !== undefined) {\n\t\t\t\tdirtyFields.push({\n\t\t\t\t\tfieldId,\n\t\t\t\t\tvalue: field.value,\n\t\t\t\t\tdirty: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyFields;\n\t}\n\n\t/**\n\t * Prepare submission payload for extension bridge\n\t * Validates all fields and returns payload if valid\n\t */\n\tprepareSubmission(): {\n\t\tdocumentId: string;\n\t\tsessionId: string;\n\t\tfields: Array<{\n\t\t\tfieldId: string;\n\t\t\tvalue: string | string[];\n\t\t\tdirty: boolean;\n\t\t}>;\n\t\tsubmittedAt: string;\n\t} | null {\n\t\tif (!(this.snapshot.documentId && this.snapshot.sessionId)) {\n\t\t\tconsole.error(\n\t\t\t\t\"[FormStore] Cannot submit: missing document or session ID\"\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.snapshot.readOnlyMode) {\n\t\t\tconsole.error(\"[FormStore] Cannot submit in read-only mode\");\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!this.validateAll()) {\n\t\t\tconsole.error(\n\t\t\t\t\"[FormStore] Validation failed\",\n\t\t\t\tthis.snapshot.validationErrors\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tconst dirtyFields = this.getDirtyFields();\n\n\t\tif (dirtyFields.length === 0) {\n\t\t\tconsole.warn(\"[FormStore] No dirty fields to submit\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tdocumentId: this.snapshot.documentId,\n\t\t\tsessionId: this.snapshot.sessionId,\n\t\t\tfields: dirtyFields,\n\t\t\tsubmittedAt: new Date().toISOString(),\n\t\t};\n\t}\n\n\t/**\n\t * Mark submission as in progress\n\t * Used to disable form during async submission\n\t */\n\tsetSubmitting(isSubmitting: boolean) {\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tisSubmitting,\n\t\t};\n\t\tthis.emit();\n\t}\n\n\t/**\n\t * Mark submission as successful and clear dirty flags\n\t */\n\tmarkSubmitted() {\n\t\tconst updatedFields = new Map<string, FormFieldState>();\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tupdatedFields.set(fieldId, {\n\t\t\t\t...field,\n\t\t\t\tdirty: false,\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tisSubmitting: false,\n\t\t\tlastSubmittedAt: new Date().toISOString(),\n\t\t};\n\n\t\tthis.emit();\n\t}\n\n\t/**\n\t * Discard all pending changes and revert to original values\n\t * Called when user cancels edits or preview becomes stale\n\t */\n\tdiscardChanges() {\n\t\t// Note: This requires storing original values, which we'll add if needed\n\t\t// For now, just clear dirty flags and errors\n\t\tconst updatedFields = new Map<string, FormFieldState>();\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tupdatedFields.set(fieldId, {\n\t\t\t\t...field,\n\t\t\t\tdirty: false,\n\t\t\t\terrors: [],\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tvalidationErrors: [],\n\t\t\tisSubmitting: false,\n\t\t};\n\n\t\tthis.emit();\n\t}\n\n\t/**\n\t * Check if form has any unsaved changes\n\t */\n\thasDirtyFields(): boolean {\n\t\tfor (const field of this.snapshot.fields.values()) {\n\t\t\tif (field.dirty) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reset the entire form state\n\t * Called when preview closes or loads a new document\n\t */\n\treset() {\n\t\tthis.snapshot = {\n\t\t\tfields: new Map(),\n\t\t\tisSubmitting: false,\n\t\t\tvalidationErrors: [],\n\t\t\treadOnlyMode: false,\n\t\t\treadOnlyReason: undefined,\n\t\t};\n\t\tthis.emit();\n\t}\n\n\t/**\n\t * Enable or disable read-only mode\n\t */\n\tsetReadOnlyMode(readOnly: boolean, reason?: string) {\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\treadOnlyMode: readOnly,\n\t\t\treadOnlyReason: reason,\n\t\t};\n\t\tthis.emit();\n\t}\n\n\tprivate emit() {\n\t\tfor (const listener of this.listeners) {\n\t\t\tlistener();\n\t\t}\n\t}\n}",
    "start_line": 77,
    "end_line": 496,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class FormStore",
    "component_id": "ui.src.features.preview.stores.form-store.FormStore"
  },
  "ui.src.features.preview.stores.form-store.initializeFields": {
    "id": "ui.src.features.preview.stores.form-store.initializeFields",
    "name": "initializeFields",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "initializeFields(options: InitializeFieldsOptions) {\n\t\tconst fieldMap = new Map<string, FormFieldState>();\n\t\tconst {\n\t\t\tdocumentId,\n\t\t\tsessionId,\n\t\t\tfields,\n\t\t\treadOnlyMode = false,\n\t\t\treadOnlyReason,\n\t\t} = options;\n\n\t\tfor (const field of fields) {\n\t\t\tfieldMap.set(field.fieldId, {\n\t\t\t\t...field,\n\t\t\t\tdirty: false,\n\t\t\t\terrors: [],\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\tdocumentId,\n\t\t\tsessionId,\n\t\t\tfields: fieldMap,\n\t\t\tisSubmitting: false,\n\t\t\tvalidationErrors: [],\n\t\t\treadOnlyMode,\n\t\t\treadOnlyReason,\n\t\t};\n\n\t\tthis.emit();\n\t}",
    "start_line": 97,
    "end_line": 126,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initializeFields",
    "component_id": "ui.src.features.preview.stores.form-store.initializeFields"
  },
  "ui.src.features.preview.stores.form-store.updateField": {
    "id": "ui.src.features.preview.stores.form-store.updateField",
    "name": "updateField",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "updateField(fieldId: string, value: string | string[]) {\n\t\tif (this.snapshot.readOnlyMode) {\n\t\t\tconsole.warn(\n\t\t\t\t`[FormStore] Cannot update field in read-only mode: ${fieldId}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst field = this.snapshot.fields.get(fieldId);\n\t\tif (!field) {\n\t\t\tconsole.warn(`[FormStore] Field not found: ${fieldId}`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (field.readOnly) {\n\t\t\tconsole.warn(`[FormStore] Field is read-only: ${fieldId}`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update field state\n\t\tconst updatedField: FormFieldState = {\n\t\t\t...field,\n\t\t\tvalue,\n\t\t\tdirty: true,\n\t\t\terrors: this.validateField({ ...field, value }),\n\t\t};\n\n\t\tconst updatedFields = new Map(this.snapshot.fields);\n\t\tupdatedFields.set(fieldId, updatedField);\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tvalidationErrors: this.getAllValidationErrors(updatedFields),\n\t\t};\n\t\tthis.emit();\n\t}",
    "start_line": 132,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fieldId",
      "value"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method updateField",
    "component_id": "ui.src.features.preview.stores.form-store.updateField"
  },
  "ui.src.features.preview.stores.form-store.validateField": {
    "id": "ui.src.features.preview.stores.form-store.validateField",
    "name": "validateField",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "private validateField(field: FormFieldState): string[] {\n\t\tconst errors: string[] = [];\n\n\t\tif (field.required && this.isFieldValueEmpty(field)) {\n\t\t\terrors.push(`${field.label} is required`);\n\t\t}\n\n\t\terrors.push(...this.validateSelectionField(field));\n\n\t\tif (field.validationRules) {\n\t\t\terrors.push(...this.applyCustomValidations(field));\n\t\t}\n\n\t\treturn errors;\n\t}",
    "start_line": 174,
    "end_line": 188,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "field"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateField",
    "component_id": "ui.src.features.preview.stores.form-store.validateField"
  },
  "ui.src.features.preview.stores.form-store.isFieldValueEmpty": {
    "id": "ui.src.features.preview.stores.form-store.isFieldValueEmpty",
    "name": "isFieldValueEmpty",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "private isFieldValueEmpty(field: FormFieldState): boolean {\n\t\tif (Array.isArray(field.value)) {\n\t\t\treturn field.value.length === 0;\n\t\t}\n\t\treturn field.value === undefined || field.value === \"\";\n\t}",
    "start_line": 190,
    "end_line": 195,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "field"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isFieldValueEmpty",
    "component_id": "ui.src.features.preview.stores.form-store.isFieldValueEmpty"
  },
  "ui.src.features.preview.stores.form-store.validateSelectionField": {
    "id": "ui.src.features.preview.stores.form-store.validateSelectionField",
    "name": "validateSelectionField",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "private validateSelectionField(field: FormFieldState): string[] {\n\t\tconst errors: string[] = [];\n\n\t\tif (\n\t\t\tfield.type === \"dropdown\" &&\n\t\t\tfield.value &&\n\t\t\tfield.options &&\n\t\t\t!field.options.includes(field.value as string)\n\t\t) {\n\t\t\terrors.push(`Invalid selection for ${field.label}`);\n\t\t}\n\n\t\tif (field.type === \"multiselect\" && field.value && field.options) {\n\t\t\tconst values = Array.isArray(field.value) ? field.value : [field.value];\n\t\t\tconst invalidValues = values.filter(\n\t\t\t\t(value) => !field.options!.includes(value)\n\t\t\t);\n\t\t\tif (invalidValues.length > 0) {\n\t\t\t\terrors.push(\n\t\t\t\t\t`Invalid selections for ${field.label}: ${invalidValues.join(\", \")}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn errors;\n\t}",
    "start_line": 197,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "field"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateSelectionField",
    "component_id": "ui.src.features.preview.stores.form-store.validateSelectionField"
  },
  "ui.src.features.preview.stores.form-store.applyCustomValidations": {
    "id": "ui.src.features.preview.stores.form-store.applyCustomValidations",
    "name": "applyCustomValidations",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "private applyCustomValidations(field: FormFieldState): string[] {\n\t\tconst errors: string[] = [];\n\t\tconst rules = field.validationRules || {};\n\n\t\t// Example: min/max length for text fields\n\t\tif (\n\t\t\trules.minLength &&\n\t\t\ttypeof field.value === \"string\" &&\n\t\t\tfield.value.length < (rules.minLength as number)\n\t\t) {\n\t\t\terrors.push(\n\t\t\t\t`${field.label} must be at least ${rules.minLength} characters`\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\trules.maxLength &&\n\t\t\ttypeof field.value === \"string\" &&\n\t\t\tfield.value.length > (rules.maxLength as number)\n\t\t) {\n\t\t\terrors.push(\n\t\t\t\t`${field.label} must not exceed ${rules.maxLength} characters`\n\t\t\t);\n\t\t}\n\n\t\t// Example: pattern matching (regex)\n\t\tif (rules.pattern && typeof field.value === \"string\") {\n\t\t\tconst regex = new RegExp(rules.pattern as string);\n\t\t\tif (!regex.test(field.value)) {\n\t\t\t\terrors.push(\n\t\t\t\t\trules.patternMessage\n\t\t\t\t\t\t? (rules.patternMessage as string)\n\t\t\t\t\t\t: `${field.label} format is invalid`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn errors;\n\t}",
    "start_line": 228,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "field"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method applyCustomValidations",
    "component_id": "ui.src.features.preview.stores.form-store.applyCustomValidations"
  },
  "ui.src.features.preview.stores.form-store.getAllValidationErrors": {
    "id": "ui.src.features.preview.stores.form-store.getAllValidationErrors",
    "name": "getAllValidationErrors",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "private getAllValidationErrors(\n\t\tfields: Map<string, FormFieldState> = this.snapshot.fields\n\t): ValidationError[] {\n\t\tconst errors: ValidationError[] = [];\n\n\t\tfor (const [fieldId, field] of fields) {\n\t\t\tif (field.errors.length > 0) {\n\t\t\t\terrors.push(\n\t\t\t\t\t...field.errors.map((message) => ({\n\t\t\t\t\t\tfieldId,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t}))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn errors;\n\t}",
    "start_line": 271,
    "end_line": 288,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fields"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAllValidationErrors",
    "component_id": "ui.src.features.preview.stores.form-store.getAllValidationErrors"
  },
  "ui.src.features.preview.stores.form-store.validateAll": {
    "id": "ui.src.features.preview.stores.form-store.validateAll",
    "name": "validateAll",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "validateAll(): boolean {\n\t\tconst updatedFields = new Map<string, FormFieldState>();\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tupdatedFields.set(fieldId, {\n\t\t\t\t...field,\n\t\t\t\terrors: this.validateField(field),\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tvalidationErrors: this.getAllValidationErrors(updatedFields),\n\t\t};\n\t\tthis.emit();\n\n\t\treturn this.snapshot.validationErrors.length === 0;\n\t}",
    "start_line": 293,
    "end_line": 311,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method validateAll",
    "component_id": "ui.src.features.preview.stores.form-store.validateAll"
  },
  "ui.src.features.preview.stores.form-store.getDirtyFields": {
    "id": "ui.src.features.preview.stores.form-store.getDirtyFields",
    "name": "getDirtyFields",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "getDirtyFields(): Array<{\n\t\tfieldId: string;\n\t\tvalue: string | string[];\n\t\tdirty: boolean;\n\t}> {\n\t\tconst dirtyFields: Array<{\n\t\t\tfieldId: string;\n\t\t\tvalue: string | string[];\n\t\t\tdirty: boolean;\n\t\t}> = [];\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tif (field.dirty && field.value !== undefined) {\n\t\t\t\tdirtyFields.push({\n\t\t\t\t\tfieldId,\n\t\t\t\t\tvalue: field.value,\n\t\t\t\t\tdirty: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyFields;\n\t}",
    "start_line": 317,
    "end_line": 339,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getDirtyFields",
    "component_id": "ui.src.features.preview.stores.form-store.getDirtyFields"
  },
  "ui.src.features.preview.stores.form-store.prepareSubmission": {
    "id": "ui.src.features.preview.stores.form-store.prepareSubmission",
    "name": "prepareSubmission",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "prepareSubmission(): {\n\t\tdocumentId: string;\n\t\tsessionId: string;\n\t\tfields: Array<{\n\t\t\tfieldId: string;\n\t\t\tvalue: string | string[];\n\t\t\tdirty: boolean;\n\t\t}>;\n\t\tsubmittedAt: string;\n\t} | null {\n\t\tif (!(this.snapshot.documentId && this.snapshot.sessionId)) {\n\t\t\tconsole.error(\n\t\t\t\t\"[FormStore] Cannot submit: missing document or session ID\"\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.snapshot.readOnlyMode) {\n\t\t\tconsole.error(\"[FormStore] Cannot submit in read-only mode\");\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!this.validateAll()) {\n\t\t\tconsole.error(\n\t\t\t\t\"[FormStore] Validation failed\",\n\t\t\t\tthis.snapshot.validationErrors\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tconst dirtyFields = this.getDirtyFields();\n\n\t\tif (dirtyFields.length === 0) {\n\t\t\tconsole.warn(\"[FormStore] No dirty fields to submit\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tdocumentId: this.snapshot.documentId,\n\t\t\tsessionId: this.snapshot.sessionId,\n\t\t\tfields: dirtyFields,\n\t\t\tsubmittedAt: new Date().toISOString(),\n\t\t};\n\t}",
    "start_line": 345,
    "end_line": 388,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method prepareSubmission",
    "component_id": "ui.src.features.preview.stores.form-store.prepareSubmission"
  },
  "ui.src.features.preview.stores.form-store.setSubmitting": {
    "id": "ui.src.features.preview.stores.form-store.setSubmitting",
    "name": "setSubmitting",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "setSubmitting(isSubmitting: boolean) {\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tisSubmitting,\n\t\t};\n\t\tthis.emit();\n\t}",
    "start_line": 394,
    "end_line": 400,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "isSubmitting"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setSubmitting",
    "component_id": "ui.src.features.preview.stores.form-store.setSubmitting"
  },
  "ui.src.features.preview.stores.form-store.markSubmitted": {
    "id": "ui.src.features.preview.stores.form-store.markSubmitted",
    "name": "markSubmitted",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "markSubmitted() {\n\t\tconst updatedFields = new Map<string, FormFieldState>();\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tupdatedFields.set(fieldId, {\n\t\t\t\t...field,\n\t\t\t\tdirty: false,\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tisSubmitting: false,\n\t\t\tlastSubmittedAt: new Date().toISOString(),\n\t\t};\n\n\t\tthis.emit();\n\t}",
    "start_line": 405,
    "end_line": 423,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method markSubmitted",
    "component_id": "ui.src.features.preview.stores.form-store.markSubmitted"
  },
  "ui.src.features.preview.stores.form-store.discardChanges": {
    "id": "ui.src.features.preview.stores.form-store.discardChanges",
    "name": "discardChanges",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "discardChanges() {\n\t\t// Note: This requires storing original values, which we'll add if needed\n\t\t// For now, just clear dirty flags and errors\n\t\tconst updatedFields = new Map<string, FormFieldState>();\n\n\t\tfor (const [fieldId, field] of this.snapshot.fields) {\n\t\t\tupdatedFields.set(fieldId, {\n\t\t\t\t...field,\n\t\t\t\tdirty: false,\n\t\t\t\terrors: [],\n\t\t\t});\n\t\t}\n\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tfields: updatedFields,\n\t\t\tvalidationErrors: [],\n\t\t\tisSubmitting: false,\n\t\t};\n\n\t\tthis.emit();\n\t}",
    "start_line": 429,
    "end_line": 450,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method discardChanges",
    "component_id": "ui.src.features.preview.stores.form-store.discardChanges"
  },
  "ui.src.features.preview.stores.form-store.hasDirtyFields": {
    "id": "ui.src.features.preview.stores.form-store.hasDirtyFields",
    "name": "hasDirtyFields",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "hasDirtyFields(): boolean {\n\t\tfor (const field of this.snapshot.fields.values()) {\n\t\t\tif (field.dirty) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "start_line": 455,
    "end_line": 462,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method hasDirtyFields",
    "component_id": "ui.src.features.preview.stores.form-store.hasDirtyFields"
  },
  "ui.src.features.preview.stores.form-store.reset": {
    "id": "ui.src.features.preview.stores.form-store.reset",
    "name": "reset",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "reset() {\n\t\tthis.snapshot = {\n\t\t\tfields: new Map(),\n\t\t\tisSubmitting: false,\n\t\t\tvalidationErrors: [],\n\t\t\treadOnlyMode: false,\n\t\t\treadOnlyReason: undefined,\n\t\t};\n\t\tthis.emit();\n\t}",
    "start_line": 468,
    "end_line": 477,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method reset",
    "component_id": "ui.src.features.preview.stores.form-store.reset"
  },
  "ui.src.features.preview.stores.form-store.setReadOnlyMode": {
    "id": "ui.src.features.preview.stores.form-store.setReadOnlyMode",
    "name": "setReadOnlyMode",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "setReadOnlyMode(readOnly: boolean, reason?: string) {\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\treadOnlyMode: readOnly,\n\t\t\treadOnlyReason: reason,\n\t\t};\n\t\tthis.emit();\n\t}",
    "start_line": 482,
    "end_line": 489,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "readOnly",
      "reason"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setReadOnlyMode",
    "component_id": "ui.src.features.preview.stores.form-store.setReadOnlyMode"
  },
  "ui.src.features.preview.stores.form-store.emit": {
    "id": "ui.src.features.preview.stores.form-store.emit",
    "name": "emit",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/form-store.ts",
    "relative_path": "ui/src/features/preview/stores/form-store.ts",
    "depends_on": [],
    "source_code": "private emit() {\n\t\tfor (const listener of this.listeners) {\n\t\t\tlistener();\n\t\t}\n\t}",
    "start_line": 491,
    "end_line": 495,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method emit",
    "component_id": "ui.src.features.preview.stores.form-store.emit"
  },
  "ui.src.features.preview.stores.preview-store.PreviewStoreSnapshot": {
    "id": "ui.src.features.preview.stores.preview-store.PreviewStoreSnapshot",
    "name": "PreviewStoreSnapshot",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/preview-store.ts",
    "relative_path": "ui/src/features/preview/stores/preview-store.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewDocumentPayload"
    ],
    "source_code": "interface PreviewStoreSnapshot {\n\tdocument?: PreviewDocumentPayload;\n\tstaleReason?: string;\n}",
    "start_line": 3,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewStoreSnapshot",
    "component_id": "ui.src.features.preview.stores.preview-store.PreviewStoreSnapshot"
  },
  "ui.src.features.preview.stores.preview-store.Listener": {
    "id": "ui.src.features.preview.stores.preview-store.Listener",
    "name": "Listener",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/preview-store.ts",
    "relative_path": "ui/src/features/preview/stores/preview-store.ts",
    "depends_on": [],
    "source_code": "type Listener = () => void;",
    "start_line": 8,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Listener",
    "component_id": "ui.src.features.preview.stores.preview-store.Listener"
  },
  "ui.src.features.preview.stores.preview-store.PreviewStore": {
    "id": "ui.src.features.preview.stores.preview-store.PreviewStore",
    "name": "PreviewStore",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/preview-store.ts",
    "relative_path": "ui/src/features/preview/stores/preview-store.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewDocumentPayload",
      "ui.src.features.preview.stores.preview-store.PreviewStoreSnapshot",
      "ui.src.features.preview.stores.preview-store.Listener",
      "src.features.spec.spec-manager.delete",
      "ui.src.features.preview.stores.preview-store.emit"
    ],
    "source_code": "class PreviewStore {\n\tprivate snapshot: PreviewStoreSnapshot = {};\n\tprivate readonly listeners = new Set<Listener>();\n\n\tsubscribe = (listener: Listener) => {\n\t\tthis.listeners.add(listener);\n\t\treturn () => this.listeners.delete(listener);\n\t};\n\n\tgetSnapshot = () => this.snapshot;\n\n\tsetDocument(document: PreviewDocumentPayload) {\n\t\tthis.snapshot = { document, staleReason: undefined };\n\t\tthis.emit();\n\t}\n\n\tmarkStale(reason?: string) {\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tstaleReason:\n\t\t\t\treason ??\n\t\t\t\t\"Underlying document changed. Reload to view the latest content.\",\n\t\t};\n\t\tthis.emit();\n\t}\n\n\tprivate emit() {\n\t\tfor (const listener of this.listeners) {\n\t\t\tlistener();\n\t\t}\n\t}\n}",
    "start_line": 10,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class PreviewStore",
    "component_id": "ui.src.features.preview.stores.preview-store.PreviewStore"
  },
  "ui.src.features.preview.stores.preview-store.setDocument": {
    "id": "ui.src.features.preview.stores.preview-store.setDocument",
    "name": "setDocument",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/preview-store.ts",
    "relative_path": "ui/src/features/preview/stores/preview-store.ts",
    "depends_on": [],
    "source_code": "setDocument(document: PreviewDocumentPayload) {\n\t\tthis.snapshot = { document, staleReason: undefined };\n\t\tthis.emit();\n\t}",
    "start_line": 21,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "document"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setDocument",
    "component_id": "ui.src.features.preview.stores.preview-store.setDocument"
  },
  "ui.src.features.preview.stores.preview-store.markStale": {
    "id": "ui.src.features.preview.stores.preview-store.markStale",
    "name": "markStale",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/preview-store.ts",
    "relative_path": "ui/src/features/preview/stores/preview-store.ts",
    "depends_on": [],
    "source_code": "markStale(reason?: string) {\n\t\tthis.snapshot = {\n\t\t\t...this.snapshot,\n\t\t\tstaleReason:\n\t\t\t\treason ??\n\t\t\t\t\"Underlying document changed. Reload to view the latest content.\",\n\t\t};\n\t\tthis.emit();\n\t}",
    "start_line": 26,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "reason"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method markStale",
    "component_id": "ui.src.features.preview.stores.preview-store.markStale"
  },
  "ui.src.features.preview.stores.preview-store.emit": {
    "id": "ui.src.features.preview.stores.preview-store.emit",
    "name": "emit",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/stores/preview-store.ts",
    "relative_path": "ui/src/features/preview/stores/preview-store.ts",
    "depends_on": [],
    "source_code": "private emit() {\n\t\tfor (const listener of this.listeners) {\n\t\t\tlistener();\n\t\t}\n\t}",
    "start_line": 36,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method emit",
    "component_id": "ui.src.features.preview.stores.preview-store.emit"
  },
  "ui.src.features.preview.types.PreviewSectionPayload": {
    "id": "ui.src.features.preview.types.PreviewSectionPayload",
    "name": "PreviewSectionPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "interface PreviewSectionPayload {\n\tid: string;\n\ttitle: string;\n\tbody?: string;\n}",
    "start_line": 1,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewSectionPayload",
    "component_id": "ui.src.features.preview.types.PreviewSectionPayload"
  },
  "ui.src.features.preview.types.PreviewFormField": {
    "id": "ui.src.features.preview.types.PreviewFormField",
    "name": "PreviewFormField",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "interface PreviewFormField {\n\tfieldId: string;\n\tlabel: string;\n\ttype: \"checkbox\" | \"dropdown\" | \"text\" | \"textarea\" | \"multiselect\";\n\toptions?: string[];\n\trequired?: boolean;\n\tvalue?: string | string[];\n\tvalidationRules?: Record<string, unknown>;\n\treadOnly?: boolean;\n}",
    "start_line": 7,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewFormField",
    "component_id": "ui.src.features.preview.types.PreviewFormField"
  },
  "ui.src.features.preview.types.PreviewDocumentPermissions": {
    "id": "ui.src.features.preview.types.PreviewDocumentPermissions",
    "name": "PreviewDocumentPermissions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "interface PreviewDocumentPermissions {\n\tcanEditForms: boolean;\n\treason?: string;\n}",
    "start_line": 18,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewDocumentPermissions",
    "component_id": "ui.src.features.preview.types.PreviewDocumentPermissions"
  },
  "ui.src.features.preview.types.PreviewRefinementIssueType": {
    "id": "ui.src.features.preview.types.PreviewRefinementIssueType",
    "name": "PreviewRefinementIssueType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "type PreviewRefinementIssueType =\n\t| \"missingDetail\"\n\t| \"incorrectInfo\"\n\t| \"missingAsset\"\n\t| \"other\";",
    "start_line": 23,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewRefinementIssueType",
    "component_id": "ui.src.features.preview.types.PreviewRefinementIssueType"
  },
  "ui.src.features.preview.types.PreviewRefinementActionType": {
    "id": "ui.src.features.preview.types.PreviewRefinementActionType",
    "name": "PreviewRefinementActionType",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "type PreviewRefinementActionType = \"refine\" | \"update\";",
    "start_line": 29,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewRefinementActionType",
    "component_id": "ui.src.features.preview.types.PreviewRefinementActionType"
  },
  "ui.src.features.preview.types.DocumentArtifact": {
    "id": "ui.src.features.preview.types.DocumentArtifact",
    "name": "DocumentArtifact",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewFormField",
      "ui.src.features.preview.types.PreviewSectionPayload",
      "ui.src.features.preview.types.PreviewDocumentPermissions"
    ],
    "source_code": "interface DocumentArtifact {\n\tdocumentId: string;\n\tdocumentType: string;\n\ttitle: string;\n\tfilePath?: string;\n\tversion?: string;\n\towner?: string;\n\tupdatedAt?: string;\n\trenderStandard?: string;\n\trawContent?: string;\n\tsessionId?: string;\n\tisOutdated?: boolean;\n\toutdatedInfo?: {\n\t\toutdatedSince: number;\n\t\tchangedDependencies: Array<{\n\t\t\tdocumentId: string;\n\t\t\tdocumentType: string;\n\t\t}>;\n\t};\n\tsections?: PreviewSectionPayload[];\n\tforms?: PreviewFormField[];\n\tpermissions?: PreviewDocumentPermissions;\n}",
    "start_line": 31,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DocumentArtifact",
    "component_id": "ui.src.features.preview.types.DocumentArtifact"
  },
  "ui.src.features.preview.types.PreviewDocumentPayload": {
    "id": "ui.src.features.preview.types.PreviewDocumentPayload",
    "name": "PreviewDocumentPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "interface PreviewDocumentPayload extends DocumentArtifact {}",
    "start_line": 55,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewDocumentPayload",
    "component_id": "ui.src.features.preview.types.PreviewDocumentPayload"
  },
  "ui.src.features.preview.types.PreviewRefinementPayload": {
    "id": "ui.src.features.preview.types.PreviewRefinementPayload",
    "name": "PreviewRefinementPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewRefinementIssueType",
      "ui.src.features.preview.types.PreviewRefinementActionType"
    ],
    "source_code": "interface PreviewRefinementPayload {\n\trequestId: string;\n\tdocumentId: string;\n\tdocumentType: string;\n\tdocumentVersion?: string;\n\tsectionRef?: string;\n\tissueType: PreviewRefinementIssueType;\n\tdescription: string;\n\tsubmittedAt: string;\n\tactionType?: PreviewRefinementActionType;\n\tchangedDependencies?: Array<{\n\t\tdocumentId: string;\n\t\tdocumentType: string;\n\t}>;\n}",
    "start_line": 57,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewRefinementPayload",
    "component_id": "ui.src.features.preview.types.PreviewRefinementPayload"
  },
  "ui.src.features.preview.types.PreviewFormSubmissionPayload": {
    "id": "ui.src.features.preview.types.PreviewFormSubmissionPayload",
    "name": "PreviewFormSubmissionPayload",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [],
    "source_code": "interface PreviewFormSubmissionPayload {\n\trequestId: string;\n\tdocumentId: string;\n\tsessionId: string;\n\tfields: Array<{ fieldId: string; value: string | string[]; dirty: boolean }>;\n\tsubmittedAt: string;\n}",
    "start_line": 73,
    "end_line": 79,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewFormSubmissionPayload",
    "component_id": "ui.src.features.preview.types.PreviewFormSubmissionPayload"
  },
  "ui.src.features.preview.types.PreviewExtensionMessage": {
    "id": "ui.src.features.preview.types.PreviewExtensionMessage",
    "name": "PreviewExtensionMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewDocumentPayload"
    ],
    "source_code": "type PreviewExtensionMessage =\n\t| { type: \"preview/load-document\"; payload: PreviewDocumentPayload }\n\t| { type: \"preview/show-placeholder\"; payload?: { reason?: string } }\n\t| {\n\t\t\ttype: \"preview/forms/result\";\n\t\t\tpayload: {\n\t\t\t\trequestId: string;\n\t\t\t\tstatus: \"success\" | \"error\";\n\t\t\t\tmessage?: string;\n\t\t\t};\n\t  }\n\t| {\n\t\t\ttype: \"preview/refine/result\";\n\t\t\tpayload: {\n\t\t\t\trequestId: string;\n\t\t\t\tstatus: \"success\" | \"error\";\n\t\t\t\tmessage?: string;\n\t\t\t};\n\t  };",
    "start_line": 81,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewExtensionMessage",
    "component_id": "ui.src.features.preview.types.PreviewExtensionMessage"
  },
  "ui.src.features.preview.types.PreviewWebviewMessage": {
    "id": "ui.src.features.preview.types.PreviewWebviewMessage",
    "name": "PreviewWebviewMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/preview/types.ts",
    "relative_path": "ui/src/features/preview/types.ts",
    "depends_on": [
      "ui.src.features.preview.types.PreviewFormSubmissionPayload",
      "ui.src.features.preview.types.PreviewRefinementPayload"
    ],
    "source_code": "type PreviewWebviewMessage =\n\t| { type: \"preview/ready\" }\n\t| { type: \"preview/request-reload\" }\n\t| { type: \"preview/open-in-editor\" }\n\t| { type: \"preview/edit-attempt\"; payload?: { reason?: string } }\n\t| { type: \"preview/forms/submit\"; payload: PreviewFormSubmissionPayload }\n\t| { type: \"preview/refine/submit\"; payload: PreviewRefinementPayload }\n\t| { type: \"preview/execute-task-group\"; payload: { groupName: string } }\n\t| { type: \"preview/open-file\"; payload: { filePath: string } };",
    "start_line": 101,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type PreviewWebviewMessage",
    "component_id": "ui.src.features.preview.types.PreviewWebviewMessage"
  },
  "ui.src.features.simple-view.index.SimpleView": {
    "id": "ui.src.features.simple-view.index.SimpleView",
    "name": "SimpleView",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/simple-view/index.tsx",
    "relative_path": "ui/src/features/simple-view/index.tsx",
    "depends_on": [],
    "source_code": "SimpleView = () => (\n\t<div className=\"px-3 py-0.5\">\n\t\t<h1 className=\"font-semibold text-[color:var(--vscode-foreground)] text-xl leading-tight\">\n\t\t\tSimple View\n\t\t</h1>\n\t\t<p className=\"text-[color:var(--vscode-descriptionForeground,rgba(255,255,255,0.65))] text-sm\">\n\t\t\tThis is a simple WebView view.\n\t\t</p>\n\t\t<img\n\t\t\talt=\"Animated sample preview\"\n\t\t\theight=\"300\"\n\t\t\tsrc={sampleGif}\n\t\t\twidth=\"300\"\n\t\t/>\n\t</div>\n)",
    "start_line": 3,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function SimpleView",
    "component_id": "ui.src.features.simple-view.index.SimpleView"
  },
  "ui.src.features.welcome.components.status-section.StatusSectionProps": {
    "id": "ui.src.features.welcome.components.status-section.StatusSectionProps",
    "name": "StatusSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus",
      "ui.src.features.welcome.types.SystemDiagnostic"
    ],
    "source_code": "interface StatusSectionProps {\n\textensionVersion: string;\n\tvscodeVersion: string;\n\tdependencies: DependencyStatus;\n\tdiagnostics: SystemDiagnostic[];\n\tonInstallDependency: (dependencyId: string) => void;\n\tonOpenExternal?: (url: string) => void;\n}",
    "start_line": 10,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface StatusSectionProps",
    "component_id": "ui.src.features.welcome.components.status-section.StatusSectionProps"
  },
  "ui.src.features.welcome.components.status-section.DependencyItem": {
    "id": "ui.src.features.welcome.components.status-section.DependencyItem",
    "name": "DependencyItem",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [],
    "source_code": "interface DependencyItem {\n\tid: \"copilot-chat\" | \"speckit\" | \"openspec\";\n\tname: string;\n\tinstalled: boolean;\n\tversion: string | null;\n\trequired: boolean;\n}",
    "start_line": 22,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependencyItem",
    "component_id": "ui.src.features.welcome.components.status-section.DependencyItem"
  },
  "ui.src.features.welcome.components.status-section.getHealthStatus": {
    "id": "ui.src.features.welcome.components.status-section.getHealthStatus",
    "name": "getHealthStatus",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus",
      "ui.src.features.welcome.types.SystemDiagnostic"
    ],
    "source_code": "function getHealthStatus(\n\tdependencies: DependencyStatus,\n\tdiagnostics: SystemDiagnostic[]\n) {\n\tconst hasErrors = diagnostics.some((d) => d.severity === \"error\");\n\n\t// Check if any required dependencies are missing\n\tconst hasMissingDeps = !(\n\t\tdependencies.copilotChat.installed &&\n\t\tdependencies.speckit.installed &&\n\t\tdependencies.openspec.installed\n\t);\n\n\tif (hasErrors || hasMissingDeps) {\n\t\treturn \"error\";\n\t}\n\n\tconst hasWarnings = diagnostics.some((d) => d.severity === \"warning\");\n\tif (hasWarnings) {\n\t\treturn \"warning\";\n\t}\n\n\treturn \"healthy\";\n}",
    "start_line": 33,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dependencies",
      "diagnostics"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getHealthStatus",
    "component_id": "ui.src.features.welcome.components.status-section.getHealthStatus"
  },
  "ui.src.features.welcome.components.status-section.getDependencyItems": {
    "id": "ui.src.features.welcome.components.status-section.getDependencyItems",
    "name": "getDependencyItems",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus",
      "ui.src.features.welcome.components.status-section.DependencyItem"
    ],
    "source_code": "function getDependencyItems(dependencies: DependencyStatus): DependencyItem[] {\n\treturn [\n\t\t{\n\t\t\tid: \"copilot-chat\",\n\t\t\tname: \"GitHub Copilot Chat\",\n\t\t\tinstalled: dependencies.copilotChat.installed,\n\t\t\tversion: dependencies.copilotChat.version,\n\t\t\trequired: true,\n\t\t},\n\t\t{\n\t\t\tid: \"speckit\",\n\t\t\tname: \"SpecKit CLI\",\n\t\t\tinstalled: dependencies.speckit.installed,\n\t\t\tversion: dependencies.speckit.version,\n\t\t\trequired: true,\n\t\t},\n\t\t{\n\t\t\tid: \"openspec\",\n\t\t\tname: \"OpenSpec CLI\",\n\t\t\tinstalled: dependencies.openspec.installed,\n\t\t\tversion: dependencies.openspec.version,\n\t\t\trequired: false,\n\t\t},\n\t];\n}",
    "start_line": 61,
    "end_line": 85,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dependencies"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getDependencyItems",
    "component_id": "ui.src.features.welcome.components.status-section.getDependencyItems"
  },
  "ui.src.features.welcome.components.status-section.formatRelativeTime": {
    "id": "ui.src.features.welcome.components.status-section.formatRelativeTime",
    "name": "formatRelativeTime",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [],
    "source_code": "function formatRelativeTime(timestamp: number): string {\n\tconst now = Date.now();\n\tconst diff = now - timestamp;\n\n\tconst minutes = Math.floor(diff / 60_000);\n\tconst hours = Math.floor(diff / 3_600_000);\n\tconst days = Math.floor(diff / 86_400_000);\n\n\tif (minutes < 1) {\n\t\treturn \"just now\";\n\t}\n\tif (minutes < 60) {\n\t\treturn `${minutes}m ago`;\n\t}\n\tif (hours < 24) {\n\t\treturn `${hours}h ago`;\n\t}\n\treturn `${days}d ago`;\n}",
    "start_line": 90,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "timestamp"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatRelativeTime",
    "component_id": "ui.src.features.welcome.components.status-section.formatRelativeTime"
  },
  "ui.src.features.welcome.components.status-section.getSeverityIconClass": {
    "id": "ui.src.features.welcome.components.status-section.getSeverityIconClass",
    "name": "getSeverityIconClass",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [],
    "source_code": "function getSeverityIconClass(severity: \"error\" | \"warning\"): string {\n\treturn severity === \"error\" ? \"codicon-error\" : \"codicon-warning\";\n}",
    "start_line": 113,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "severity"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getSeverityIconClass",
    "component_id": "ui.src.features.welcome.components.status-section.getSeverityIconClass"
  },
  "ui.src.features.welcome.components.status-section.getHealthIconClass": {
    "id": "ui.src.features.welcome.components.status-section.getHealthIconClass",
    "name": "getHealthIconClass",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [],
    "source_code": "function getHealthIconClass(status: \"healthy\" | \"warning\" | \"error\"): string {\n\tswitch (status) {\n\t\tcase \"healthy\":\n\t\t\treturn \"codicon-pass-filled\";\n\t\tcase \"warning\":\n\t\t\treturn \"codicon-warning\";\n\t\tcase \"error\":\n\t\t\treturn \"codicon-error\";\n\t\tdefault:\n\t\t\treturn \"codicon-error\";\n\t}\n}",
    "start_line": 120,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "status"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getHealthIconClass",
    "component_id": "ui.src.features.welcome.components.status-section.getHealthIconClass"
  },
  "ui.src.features.welcome.components.status-section.getDependencyIconClass": {
    "id": "ui.src.features.welcome.components.status-section.getDependencyIconClass",
    "name": "getDependencyIconClass",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [],
    "source_code": "function getDependencyIconClass(installed: boolean, required: boolean): string {\n\tif (!required) {\n\t\treturn \"codicon-info\";\n\t}\n\treturn installed ? \"codicon-pass-filled\" : \"codicon-error\";\n}",
    "start_line": 136,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "installed",
      "required"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getDependencyIconClass",
    "component_id": "ui.src.features.welcome.components.status-section.getDependencyIconClass"
  },
  "ui.src.features.welcome.components.status-section.StatusSection": {
    "id": "ui.src.features.welcome.components.status-section.StatusSection",
    "name": "StatusSection",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/components/status-section.tsx",
    "relative_path": "ui/src/features/welcome/components/status-section.tsx",
    "depends_on": [
      "ui.src.features.welcome.components.status-section.getHealthStatus",
      "ui.src.features.welcome.components.status-section.StatusSectionProps",
      "ui.src.features.welcome.components.status-section.getDependencyItems"
    ],
    "source_code": "function StatusSection({\n\textensionVersion,\n\tvscodeVersion,\n\tdependencies,\n\tdiagnostics,\n\tonInstallDependency,\n\tonOpenExternal,\n}: StatusSectionProps) {\n\tconst healthStatus = getHealthStatus(dependencies, diagnostics);\n\tconst allHealthy = healthStatus === \"healthy\";\n\tconst dependencyItems = getDependencyItems(dependencies);\n\n\treturn (\n\t\t<div className=\"status-section\">\n\t\t\t{/* Health Status Banner */}\n\t\t\t<div className={`health-banner health-banner--${healthStatus}`}>\n\t\t\t\t<i\n\t\t\t\t\tclassName={`codicon ${getHealthIconClass(healthStatus)} health-icon`}\n\t\t\t\t/>\n\t\t\t\t<div className=\"health-content\">\n\t\t\t\t\t{allHealthy ? (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<h3>All Systems Healthy</h3>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\tExtension is working correctly with all dependencies installed\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t<h3>\n\t\t\t\t\t\t\t\t{healthStatus === \"error\"\n\t\t\t\t\t\t\t\t\t? \"Issues Detected\"\n\t\t\t\t\t\t\t\t\t: \"Warnings Present\"}\n\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t{healthStatus === \"error\"\n\t\t\t\t\t\t\t\t\t? \"Some features may not work correctly\"\n\t\t\t\t\t\t\t\t\t: \"Extension is working but has minor issues\"}\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t{/* Version Information */}\n\t\t\t<div className=\"version-info\">\n\t\t\t\t<h3>Version Information</h3>\n\t\t\t\t<div className=\"version-grid\">\n\t\t\t\t\t<div className=\"version-item\">\n\t\t\t\t\t\t<span className=\"version-label\">Gatomia Extension</span>\n\t\t\t\t\t\t<span className=\"version-value\">v{extensionVersion}</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"version-item\">\n\t\t\t\t\t\t<span className=\"version-label\">VS Code</span>\n\t\t\t\t\t\t<span className=\"version-value\">v{vscodeVersion}</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"changelog-link\"\n\t\t\t\t\tonClick={(e) => {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tconst url =\n\t\t\t\t\t\t\t\"https://github.com/gatomia/gatomia-vscode/blob/main/CHANGELOG.md\";\n\t\t\t\t\t\tif (onOpenExternal) {\n\t\t\t\t\t\t\tonOpenExternal(url);\n\t\t\t\t\t\t} else if (vscode) {\n\t\t\t\t\t\t\tvscode.postMessage({\n\t\t\t\t\t\t\t\ttype: \"welcome/open-external\",\n\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t>\n\t\t\t\t\t<i className=\"codicon codicon-book\" /> View Changelog\n\t\t\t\t</button>\n\t\t\t</div>\n\n\t\t\t{/* Dependency Status */}\n\t\t\t<div className=\"dependency-status\">\n\t\t\t\t<h3>Dependencies</h3>\n\t\t\t\t<div className=\"dependency-list\">\n\t\t\t\t\t{dependencyItems.map((dep) => (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName={`dependency-item ${!dep.installed && dep.required ? \"dependency-item--missing\" : \"\"}`}\n\t\t\t\t\t\t\tkey={dep.id}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div className=\"dependency-info\">\n\t\t\t\t\t\t\t\t<i\n\t\t\t\t\t\t\t\t\tclassName={`codicon ${getDependencyIconClass(dep.installed, dep.required)} dependency-icon`}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<div className=\"dependency-details\">\n\t\t\t\t\t\t\t\t\t<div className=\"dependency-name\">\n\t\t\t\t\t\t\t\t\t\t{dep.name}\n\t\t\t\t\t\t\t\t\t\t{dep.required && (\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"dependency-badge\">Required</span>\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t{dep.installed && dep.version && (\n\t\t\t\t\t\t\t\t\t\t<div className=\"dependency-version\">v{dep.version}</div>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t{!dep.installed && (\n\t\t\t\t\t\t\t\t\t\t<div className=\"dependency-status-text\">Not installed</div>\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{!dep.installed && dep.required && (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tclassName=\"install-button\"\n\t\t\t\t\t\t\t\t\tonClick={() => onInstallDependency(dep.id)}\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tInstall\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t{/* Recent Diagnostics */}\n\t\t\t{diagnostics.length > 0 && (\n\t\t\t\t<div className=\"diagnostics-section\">\n\t\t\t\t\t<h3>Recent Diagnostics</h3>\n\t\t\t\t\t<p className=\"diagnostics-description\">\n\t\t\t\t\t\tLast 5 issues from the past 24 hours\n\t\t\t\t\t</p>\n\t\t\t\t\t<div className=\"diagnostic-list\">\n\t\t\t\t\t\t{diagnostics.map((diag) => (\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName={`diagnostic-item diagnostic-item--${diag.severity}`}\n\t\t\t\t\t\t\t\tkey={diag.id}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div className=\"diagnostic-header\">\n\t\t\t\t\t\t\t\t\t<i\n\t\t\t\t\t\t\t\t\t\tclassName={`codicon ${getSeverityIconClass(diag.severity)} diagnostic-icon`}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<div className=\"diagnostic-info\">\n\t\t\t\t\t\t\t\t\t\t<div className=\"diagnostic-message\">{diag.message}</div>\n\t\t\t\t\t\t\t\t\t\t<div className=\"diagnostic-meta\">\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"diagnostic-source\">{diag.source}</span>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"diagnostic-separator\"></span>\n\t\t\t\t\t\t\t\t\t\t\t<span className=\"diagnostic-time\">\n\t\t\t\t\t\t\t\t\t\t\t\t{formatRelativeTime(diag.timestamp)}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t{diag.suggestedAction && (\n\t\t\t\t\t\t\t\t\t<div className=\"diagnostic-action\">\n\t\t\t\t\t\t\t\t\t\t<strong>Suggested action:</strong> {diag.suggestedAction}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t{/* Quick Tips */}\n\t\t\t<div className=\"status-tips\">\n\t\t\t\t<h4>\n\t\t\t\t\t<i className=\"codicon codicon-lightbulb\" /> Quick Tips\n\t\t\t\t</h4>\n\t\t\t\t<ul>\n\t\t\t\t\t<li>Diagnostics are automatically cleaned up after 24 hours</li>\n\t\t\t\t\t<li>Only the 5 most recent issues are shown</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\tMissing required dependencies may prevent some features from working\n\t\t\t\t\t</li>\n\t\t\t\t\t<li>Check the Output panel (View  Output) for detailed logs</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\n\t\t\t<style>{`\n\t\t\t\t.status-section {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t\tgap: 24px;\n\t\t\t\t\tpadding: 16px;\n\t\t\t\t}\n\n\t\t\t\t/* Health Banner */\n\t\t\t\t.health-banner {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\talign-items: flex-start;\n\t\t\t\t\tgap: 12px;\n\t\t\t\t\tpadding: 16px;\n\t\t\t\t\tborder-radius: 8px;\n\t\t\t\t\tborder: 1px solid;\n\t\t\t\t}\n\n\t\t\t\t.health-banner--healthy {\n\t\t\t\t\tbackground: color-mix(in srgb, var(--vscode-testing-iconPassed) 10%, transparent);\n\t\t\t\t\tborder-color: var(--vscode-testing-iconPassed);\n\t\t\t\t}\n\n\t\t\t\t.health-banner--warning {\n\t\t\t\t\tbackground: color-mix(in srgb, var(--vscode-editorWarning-foreground) 10%, transparent);\n\t\t\t\t\tborder-color: var(--vscode-editorWarning-foreground);\n\t\t\t\t}\n\n\t\t\t\t.health-banner--error {\n\t\t\t\t\tbackground: color-mix(in srgb, var(--vscode-editorError-foreground) 10%, transparent);\n\t\t\t\t\tborder-color: var(--vscode-editorError-foreground);\n\t\t\t\t}\n\n\t\t\t\t.health-icon {\n\t\t\t\t\tfont-size: 20px;\n\t\t\t\t\tline-height: 1;\n\t\t\t\t\tmargin-top: 2px;\n\t\t\t\t}\n\n\t\t\t\t.health-content h3 {\n\t\t\t\t\tmargin: 0 0 4px 0;\n\t\t\t\t\tfont-size: 16px;\n\t\t\t\t\tfont-weight: 600;\n\t\t\t\t}\n\n\t\t\t\t.health-content p {\n\t\t\t\t\tmargin: 0;\n\t\t\t\t\tfont-size: 14px;\n\t\t\t\t\topacity: 0.8;\n\t\t\t\t}\n\n\t\t\t\t/* Version Information */\n\t\t\t\t.version-info h3 {\n\t\t\t\t\tmargin: 0 0 12px 0;\n\t\t\t\t\tfont-size: 14px;\n\t\t\t\t\tfont-weight: 600;\n\t\t\t\t\ttext-transform: uppercase;\n\t\t\t\t\topacity: 0.7;\n\t\t\t\t}\n\n\t\t\t\t.version-grid {\n\t\t\t\t\tdisplay: grid;\n\t\t\t\t\tgrid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n\t\t\t\t\tgap: 12px;\n\t\t\t\t\tmargin-bottom: 12px;\n\t\t\t\t}\n\n\t\t\t\t.version-item {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t\tgap: 4px;\n\t\t\t\t\tpadding: 12px;\n\t\t\t\t\tbackground: var(--vscode-textBlockQuote-background);\n\t\t\t\t\tborder-radius: 6px;\n\t\t\t\t}",
    "start_line": 143,
    "end_line": 391,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function StatusSection",
    "component_id": "ui.src.features.welcome.components.status-section.StatusSection"
  },
  "ui.src.features.welcome.types.ViewSection": {
    "id": "ui.src.features.welcome.types.ViewSection",
    "name": "ViewSection",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "type ViewSection =\n\t| \"setup\"\n\t| \"features\"\n\t| \"configuration\"\n\t| \"status\"\n\t| \"learning\";",
    "start_line": 10,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ViewSection",
    "component_id": "ui.src.features.welcome.types.ViewSection"
  },
  "ui.src.features.welcome.types.DependencyStatus": {
    "id": "ui.src.features.welcome.types.DependencyStatus",
    "name": "DependencyStatus",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface DependencyStatus {\n\tcopilotChat: {\n\t\tinstalled: boolean;\n\t\tactive: boolean;\n\t\tversion: string | null;\n\t};\n\tspeckit: {\n\t\tinstalled: boolean;\n\t\tversion: string | null;\n\t};\n\topenspec: {\n\t\tinstalled: boolean;\n\t\tversion: string | null;\n\t};\n\tlastChecked: number;\n}",
    "start_line": 17,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DependencyStatus",
    "component_id": "ui.src.features.welcome.types.DependencyStatus"
  },
  "ui.src.features.welcome.types.ConfigurationItem": {
    "id": "ui.src.features.welcome.types.ConfigurationItem",
    "name": "ConfigurationItem",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface ConfigurationItem {\n\tkey: string;\n\tlabel: string;\n\tcurrentValue: string | boolean;\n\teditable: boolean;\n\toptions?: string[];\n\tdescription?: string;\n}",
    "start_line": 34,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConfigurationItem",
    "component_id": "ui.src.features.welcome.types.ConfigurationItem"
  },
  "ui.src.features.welcome.types.ConfigurationState": {
    "id": "ui.src.features.welcome.types.ConfigurationState",
    "name": "ConfigurationState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.ConfigurationItem"
    ],
    "source_code": "interface ConfigurationState {\n\tspecSystem: ConfigurationItem & {\n\t\tcurrentValue: \"auto\" | \"speckit\" | \"openspec\";\n\t\toptions: string[];\n\t};\n\tspeckitSpecsPath: ConfigurationItem & { currentValue: string };\n\tspeckitMemoryPath: ConfigurationItem & { currentValue: string };\n\tspeckitTemplatesPath: ConfigurationItem & { currentValue: string };\n\topenspecPath: ConfigurationItem & { currentValue: string };\n\tpromptsPath: ConfigurationItem & { currentValue: string };\n\totherSettings: Array<ConfigurationItem & { editable: false }>;\n}",
    "start_line": 43,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConfigurationState",
    "component_id": "ui.src.features.welcome.types.ConfigurationState"
  },
  "ui.src.features.welcome.types.SystemDiagnostic": {
    "id": "ui.src.features.welcome.types.SystemDiagnostic",
    "name": "SystemDiagnostic",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface SystemDiagnostic {\n\tid: string;\n\ttimestamp: number;\n\tseverity: \"error\" | \"warning\";\n\tmessage: string;\n\tsource: string;\n\tsuggestedAction: string | null;\n}",
    "start_line": 56,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SystemDiagnostic",
    "component_id": "ui.src.features.welcome.types.SystemDiagnostic"
  },
  "ui.src.features.welcome.types.ResourceCategory": {
    "id": "ui.src.features.welcome.types.ResourceCategory",
    "name": "ResourceCategory",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "type ResourceCategory =\n\t| \"Getting Started\"\n\t| \"Advanced Features\"\n\t| \"Troubleshooting\";",
    "start_line": 65,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ResourceCategory",
    "component_id": "ui.src.features.welcome.types.ResourceCategory"
  },
  "ui.src.features.welcome.types.LearningResource": {
    "id": "ui.src.features.welcome.types.LearningResource",
    "name": "LearningResource",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.ResourceCategory"
    ],
    "source_code": "interface LearningResource {\n\tid: string;\n\ttitle: string;\n\tdescription: string;\n\turl: string;\n\tcategory: ResourceCategory;\n\tkeywords: string[];\n\testimatedMinutes: number | null;\n}",
    "start_line": 70,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LearningResource",
    "component_id": "ui.src.features.welcome.types.LearningResource"
  },
  "ui.src.features.welcome.types.FeatureArea": {
    "id": "ui.src.features.welcome.types.FeatureArea",
    "name": "FeatureArea",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "type FeatureArea = \"Specs\" | \"Prompts\" | \"Hooks\" | \"Steering\";",
    "start_line": 80,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type FeatureArea",
    "component_id": "ui.src.features.welcome.types.FeatureArea"
  },
  "ui.src.features.welcome.types.FeatureAction": {
    "id": "ui.src.features.welcome.types.FeatureAction",
    "name": "FeatureAction",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.FeatureArea"
    ],
    "source_code": "interface FeatureAction {\n\tid: string;\n\tfeatureArea: FeatureArea;\n\tlabel: string;\n\tdescription: string;\n\tcommandId: string;\n\tenabled: boolean;\n\ticon?: string;\n}",
    "start_line": 82,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FeatureAction",
    "component_id": "ui.src.features.welcome.types.FeatureAction"
  },
  "ui.src.features.welcome.types.WelcomeScreenState": {
    "id": "ui.src.features.welcome.types.WelcomeScreenState",
    "name": "WelcomeScreenState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.FeatureAction",
      "ui.src.features.welcome.types.SystemDiagnostic",
      "ui.src.features.welcome.types.LearningResource",
      "ui.src.features.welcome.types.ViewSection",
      "ui.src.features.welcome.types.ConfigurationState",
      "ui.src.features.welcome.types.DependencyStatus"
    ],
    "source_code": "interface WelcomeScreenState {\n\thasShownBefore: boolean;\n\tdontShowOnStartup: boolean;\n\tcurrentView: ViewSection;\n\tdependencies: DependencyStatus;\n\tconfiguration: ConfigurationState;\n\tdiagnostics: SystemDiagnostic[];\n\tlearningResources: LearningResource[];\n\tfeatureActions: FeatureAction[];\n}",
    "start_line": 92,
    "end_line": 101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeScreenState",
    "component_id": "ui.src.features.welcome.types.WelcomeScreenState"
  },
  "ui.src.features.welcome.types.WelcomeInitData": {
    "id": "ui.src.features.welcome.types.WelcomeInitData",
    "name": "WelcomeInitData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface WelcomeInitData {\n\textensionVersion: string;\n\tvscodeVersion: string;\n}",
    "start_line": 107,
    "end_line": 110,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeInitData",
    "component_id": "ui.src.features.welcome.types.WelcomeInitData"
  },
  "ui.src.features.welcome.types.WelcomeStateData": {
    "id": "ui.src.features.welcome.types.WelcomeStateData",
    "name": "WelcomeStateData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface WelcomeStateData extends WelcomeScreenState {}",
    "start_line": 112,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeStateData",
    "component_id": "ui.src.features.welcome.types.WelcomeStateData"
  },
  "ui.src.features.welcome.types.WelcomeConfigUpdateData": {
    "id": "ui.src.features.welcome.types.WelcomeConfigUpdateData",
    "name": "WelcomeConfigUpdateData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface WelcomeConfigUpdateData {\n\tkey: string;\n\tnewValue: string | boolean;\n}",
    "start_line": 114,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeConfigUpdateData",
    "component_id": "ui.src.features.welcome.types.WelcomeConfigUpdateData"
  },
  "ui.src.features.welcome.types.WelcomeDependencyStatusData": {
    "id": "ui.src.features.welcome.types.WelcomeDependencyStatusData",
    "name": "WelcomeDependencyStatusData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus"
    ],
    "source_code": "interface WelcomeDependencyStatusData {\n\tcopilotChat: DependencyStatus[\"copilotChat\"];\n\tspeckit: DependencyStatus[\"speckit\"];\n\topenspec: DependencyStatus[\"openspec\"];\n\tlastChecked: number;\n}",
    "start_line": 119,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeDependencyStatusData",
    "component_id": "ui.src.features.welcome.types.WelcomeDependencyStatusData"
  },
  "ui.src.features.welcome.types.WelcomeErrorData": {
    "id": "ui.src.features.welcome.types.WelcomeErrorData",
    "name": "WelcomeErrorData",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [],
    "source_code": "interface WelcomeErrorData {\n\tcode: string;\n\tmessage: string;\n\tcontext?: string;\n}",
    "start_line": 126,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeErrorData",
    "component_id": "ui.src.features.welcome.types.WelcomeErrorData"
  },
  "ui.src.features.welcome.types.SetupSectionProps": {
    "id": "ui.src.features.welcome.types.SetupSectionProps",
    "name": "SetupSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus"
    ],
    "source_code": "interface SetupSectionProps {\n\tdependencies: DependencyStatus;\n\tonInstallDependency: (\n\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\"\n\t) => void;\n\tonRefreshDependencies: () => void;\n\tonNavigateNext: () => void;\n}",
    "start_line": 136,
    "end_line": 143,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SetupSectionProps",
    "component_id": "ui.src.features.welcome.types.SetupSectionProps"
  },
  "ui.src.features.welcome.types.FeaturesSectionProps": {
    "id": "ui.src.features.welcome.types.FeaturesSectionProps",
    "name": "FeaturesSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.FeatureAction"
    ],
    "source_code": "interface FeaturesSectionProps {\n\tfeatureActions: FeatureAction[];\n\tonExecuteCommand: (commandId: string, args?: unknown[]) => void;\n}",
    "start_line": 145,
    "end_line": 148,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FeaturesSectionProps",
    "component_id": "ui.src.features.welcome.types.FeaturesSectionProps"
  },
  "ui.src.features.welcome.types.ConfigSectionProps": {
    "id": "ui.src.features.welcome.types.ConfigSectionProps",
    "name": "ConfigSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.ConfigurationState"
    ],
    "source_code": "interface ConfigSectionProps {\n\tconfiguration: ConfigurationState;\n\tonUpdateConfig: (key: string, value: string | boolean) => void;\n\tonOpenSettings: () => void;\n}",
    "start_line": 150,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConfigSectionProps",
    "component_id": "ui.src.features.welcome.types.ConfigSectionProps"
  },
  "ui.src.features.welcome.types.StatusSectionProps": {
    "id": "ui.src.features.welcome.types.StatusSectionProps",
    "name": "StatusSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.DependencyStatus",
      "ui.src.features.welcome.types.SystemDiagnostic"
    ],
    "source_code": "interface StatusSectionProps {\n\textensionVersion: string;\n\tvscodeVersion: string;\n\tdependencies: DependencyStatus;\n\tdiagnostics: SystemDiagnostic[];\n\tonInstallDependency: (\n\t\tdependency: \"copilot-chat\" | \"speckit\" | \"openspec\"\n\t) => void;\n}",
    "start_line": 156,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface StatusSectionProps",
    "component_id": "ui.src.features.welcome.types.StatusSectionProps"
  },
  "ui.src.features.welcome.types.LearningSectionProps": {
    "id": "ui.src.features.welcome.types.LearningSectionProps",
    "name": "LearningSectionProps",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.LearningResource"
    ],
    "source_code": "interface LearningSectionProps {\n\tresources: LearningResource[];\n\tonOpenExternal: (url: string) => void;\n\tonSearch: (query: string) => void;\n}",
    "start_line": 166,
    "end_line": 170,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LearningSectionProps",
    "component_id": "ui.src.features.welcome.types.LearningSectionProps"
  },
  "ui.src.features.welcome.types.WelcomeStore": {
    "id": "ui.src.features.welcome.types.WelcomeStore",
    "name": "WelcomeStore",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/features/welcome/types.ts",
    "relative_path": "ui/src/features/welcome/types.ts",
    "depends_on": [
      "ui.src.features.welcome.types.WelcomeInitData",
      "ui.src.features.welcome.types.WelcomeScreenState",
      "ui.src.features.welcome.types.SystemDiagnostic",
      "ui.src.features.welcome.types.WelcomeErrorData",
      "ui.src.features.welcome.types.ViewSection",
      "ui.src.features.welcome.types.DependencyStatus"
    ],
    "source_code": "interface WelcomeStore {\n\t// State\n\tstate: WelcomeScreenState | null;\n\tloading: boolean;\n\terror: WelcomeErrorData | null;\n\textensionVersion: string;\n\tvscodeVersion: string;\n\n\t// Actions\n\tsetState: (state: WelcomeScreenState) => void;\n\tupdateConfig: (key: string, value: string | boolean) => void;\n\tupdateDependencies: (dependencies: DependencyStatus) => void;\n\taddDiagnostic: (diagnostic: SystemDiagnostic) => void;\n\tsetCurrentView: (view: ViewSection) => void;\n\tsetDontShowOnStartup: (value: boolean) => void;\n\tsetError: (error: WelcomeErrorData | null) => void;\n\tsetLoading: (loading: boolean) => void;\n\tinitialize: (init: WelcomeInitData) => void;\n\treset: () => void;\n}",
    "start_line": 176,
    "end_line": 195,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface WelcomeStore",
    "component_id": "ui.src.features.welcome.types.WelcomeStore"
  },
  "ui.src.lib.document-title-utils.toFriendlyName": {
    "id": "ui.src.lib.document-title-utils.toFriendlyName",
    "name": "toFriendlyName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/document-title-utils.ts",
    "relative_path": "ui/src/lib/document-title-utils.ts",
    "depends_on": [],
    "source_code": "function toFriendlyName(filename: string): string {\n\t// Get just the filename if path provided\n\tconst name = filename.split(\"/\").pop() || filename;\n\n\t// Remove extension\n\tlet baseName = name.replace(EXTENSION_PATTERN, \"\");\n\n\t// Remove leading numbers and dashes (e.g., \"001-\")\n\tbaseName = baseName.replace(LEADING_NUMBERS_PATTERN, \"\");\n\n\t// Replace hyphens and underscores with spaces\n\tbaseName = baseName.replace(WHITESPACE_PATTERN, \" \");\n\n\t// Capitalize first letter of each word\n\tbaseName = baseName\n\t\t.split(\" \")\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n\t\t.join(\" \");\n\n\treturn baseName;\n}",
    "start_line": 12,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toFriendlyName",
    "component_id": "ui.src.lib.document-title-utils.toFriendlyName"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.isTaskListItem": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.isTaskListItem",
    "name": "isTaskListItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [],
    "source_code": "function isTaskListItem(token: Token): boolean {\n\tif (token.type !== \"inline\" || !token.content) {\n\t\treturn false;\n\t}\n\treturn CHECKBOX_PATTERN.test(token.content);\n}",
    "start_line": 15,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "token"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isTaskListItem",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.isTaskListItem"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.findInlineTokenIndex": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.findInlineTokenIndex",
    "name": "findInlineTokenIndex",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [],
    "source_code": "function findInlineTokenIndex(tokens: Token[], startIndex: number): number {\n\tfor (let j = startIndex + 1; j < tokens.length; j++) {\n\t\tif (tokens[j].type === \"list_item_close\") {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tokens[j].type === \"inline\") {\n\t\t\treturn j;\n\t\t}\n\t}\n\treturn -1;\n}",
    "start_line": 22,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "tokens",
      "startIndex"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findInlineTokenIndex",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.findInlineTokenIndex"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.createCheckboxToken": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.createCheckboxToken",
    "name": "createCheckboxToken",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [],
    "source_code": "function createCheckboxToken(state: StateCore, isChecked: boolean): Token {\n\tconst checkboxHtml = `<input type=\"checkbox\" class=\"task-list-checkbox\" disabled${isChecked ? \" checked\" : \"\"} /> `;\n\tconst checkboxToken = new state.Token(\"html_inline\", \"\", 0);\n\tcheckboxToken.content = checkboxHtml;\n\treturn checkboxToken;\n}",
    "start_line": 34,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state",
      "isChecked"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createCheckboxToken",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.createCheckboxToken"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.updateInlineTokenContent": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.updateInlineTokenContent",
    "name": "updateInlineTokenContent",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [],
    "source_code": "function updateInlineTokenContent(inlineToken: Token): void {\n\tinlineToken.content = inlineToken.content.replace(CHECKBOX_PATTERN, \"\");\n\n\tif (inlineToken.children && inlineToken.children.length > 0) {\n\t\tconst firstChild = inlineToken.children[0];\n\t\tif (firstChild.type === \"text\") {\n\t\t\tfirstChild.content = firstChild.content.replace(CHECKBOX_PATTERN, \"\");\n\t\t}\n\t}\n}",
    "start_line": 41,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "inlineToken"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateInlineTokenContent",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.updateInlineTokenContent"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.processListItem": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.processListItem",
    "name": "processListItem",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [
      "ui.src.lib.markdown.plugins.checkbox-plugin.createCheckboxToken",
      "ui.src.lib.markdown.plugins.checkbox-plugin.isTaskListItem",
      "ui.src.lib.markdown.plugins.checkbox-plugin.updateInlineTokenContent",
      "ui.src.lib.markdown.plugins.checkbox-plugin.findInlineTokenIndex"
    ],
    "source_code": "function processListItem(\n\tstate: StateCore,\n\ttokens: Token[],\n\tlistItemIndex: number\n): void {\n\tconst inlineIndex = findInlineTokenIndex(tokens, listItemIndex);\n\tif (inlineIndex === -1) {\n\t\treturn;\n\t}\n\n\tconst inlineToken = tokens[inlineIndex];\n\tif (!isTaskListItem(inlineToken)) {\n\t\treturn;\n\t}\n\n\tconst match = inlineToken.content.match(CHECKBOX_PATTERN);\n\tif (!match) {\n\t\treturn;\n\t}\n\n\tconst isChecked = match[1].toLowerCase() === \"x\";\n\tconst listItemToken = tokens[listItemIndex];\n\n\tlistItemToken.attrJoin(\"class\", \"task-list-item\");\n\tupdateInlineTokenContent(inlineToken);\n\n\tconst checkboxToken = createCheckboxToken(state, isChecked);\n\tif (inlineToken.children) {\n\t\tinlineToken.children.unshift(checkboxToken);\n\t}\n}",
    "start_line": 52,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state",
      "tokens",
      "listItemIndex"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function processListItem",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.processListItem"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.processTaskLists": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.processTaskLists",
    "name": "processTaskLists",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [
      "ui.src.lib.markdown.plugins.checkbox-plugin.processListItem"
    ],
    "source_code": "function processTaskLists(state: StateCore): void {\n\tconst tokens = state.tokens;\n\n\tfor (let i = 0; i < tokens.length; i++) {\n\t\tif (tokens[i].type === \"list_item_open\") {\n\t\t\tprocessListItem(state, tokens, i);\n\t\t}\n\t}\n}",
    "start_line": 84,
    "end_line": 92,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function processTaskLists",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.processTaskLists"
  },
  "ui.src.lib.markdown.plugins.checkbox-plugin.checkboxPlugin": {
    "id": "ui.src.lib.markdown.plugins.checkbox-plugin.checkboxPlugin",
    "name": "checkboxPlugin",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/checkbox-plugin.ts",
    "depends_on": [],
    "source_code": "function checkboxPlugin(md: MarkdownIt): void {\n\tmd.core.ruler.after(\"inline\", \"task-lists\", processTaskLists);\n}",
    "start_line": 94,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "md"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function checkboxPlugin",
    "component_id": "ui.src.lib.markdown.plugins.checkbox-plugin.checkboxPlugin"
  },
  "ui.src.lib.markdown.plugins.task-group-plugin.escapeHtml": {
    "id": "ui.src.lib.markdown.plugins.task-group-plugin.escapeHtml",
    "name": "escapeHtml",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "depends_on": [],
    "source_code": "function escapeHtml(text: string): string {\n\tconst map: Record<string, string> = {\n\t\t\"&\": \"&amp;\",\n\t\t\"<\": \"&lt;\",\n\t\t\">\": \"&gt;\",\n\t\t'\"': \"&quot;\",\n\t\t\"'\": \"&#039;\",\n\t};\n\treturn text.replace(/[&<>\"']/g, (char) => map[char]);\n}",
    "start_line": 8,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function escapeHtml",
    "component_id": "ui.src.lib.markdown.plugins.task-group-plugin.escapeHtml"
  },
  "ui.src.lib.markdown.plugins.task-group-plugin.isTaskGroupHeading": {
    "id": "ui.src.lib.markdown.plugins.task-group-plugin.isTaskGroupHeading",
    "name": "isTaskGroupHeading",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "depends_on": [],
    "source_code": "function isTaskGroupHeading(token: Token): boolean {\n\tif (token.type !== \"inline\") {\n\t\treturn false;\n\t}\n\tif (!token.content) {\n\t\treturn false;\n\t}\n\treturn PHASE_USER_STORY_PATTERN.test(token.content);\n}",
    "start_line": 25,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "token"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isTaskGroupHeading",
    "component_id": "ui.src.lib.markdown.plugins.task-group-plugin.isTaskGroupHeading"
  },
  "ui.src.lib.markdown.plugins.task-group-plugin.processTaskGroupHeading": {
    "id": "ui.src.lib.markdown.plugins.task-group-plugin.processTaskGroupHeading",
    "name": "processTaskGroupHeading",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "depends_on": [
      "ui.src.lib.markdown.plugins.task-group-plugin.isTaskGroupHeading",
      "ui.src.lib.markdown.plugins.task-group-plugin.escapeHtml"
    ],
    "source_code": "function processTaskGroupHeading(\n\tstate: StateCore,\n\ttokens: Token[],\n\theadingIndex: number\n): void {\n\t// Look for the heading_open token and check if next inline token matches pattern\n\tif (headingIndex + 2 >= tokens.length) {\n\t\treturn;\n\t}\n\n\tconst headingOpen = tokens[headingIndex];\n\tconst inline = tokens[headingIndex + 1];\n\tconst headingClose = tokens[headingIndex + 2];\n\n\t// Only process h2 headings (##)\n\tif (headingOpen.type !== \"heading_open\" || headingOpen.tag !== \"h2\") {\n\t\treturn;\n\t}\n\n\tif (!isTaskGroupHeading(inline)) {\n\t\treturn;\n\t}\n\n\tconst match = inline.content.match(PHASE_USER_STORY_PATTERN);\n\tif (!match) {\n\t\treturn;\n\t}\n\n\tconst groupName = match[1];\n\n\t// Create button token\n\tconst buttonToken = new state.Token(\"html_inline\", \"\", 0);\n\tbuttonToken.content = `\n<button \n  class=\"ml-2 rounded border border-[color:var(--vscode-button-border,transparent)] bg-[color:var(--vscode-button-background)] px-2 py-1 text-[color:var(--vscode-button-foreground)] text-xs hover:bg-[color:var(--vscode-button-hoverBackground)] transition-colors\"\n  data-execute-task-group=\"${escapeHtml(groupName)}\"\n  type=\"button\"\n  title=\"Execute all tasks in this group\"\n>\n  $(play) Execute Group\n</button>`;\n\n\t// Insert button token after the inline token\n\ttokens.splice(headingIndex + 2, 0, buttonToken);\n}",
    "start_line": 35,
    "end_line": 79,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state",
      "tokens",
      "headingIndex"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function processTaskGroupHeading",
    "component_id": "ui.src.lib.markdown.plugins.task-group-plugin.processTaskGroupHeading"
  },
  "ui.src.lib.markdown.plugins.task-group-plugin.taskGroupPlugin": {
    "id": "ui.src.lib.markdown.plugins.task-group-plugin.taskGroupPlugin",
    "name": "taskGroupPlugin",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "relative_path": "ui/src/lib/markdown/plugins/task-group-plugin.ts",
    "depends_on": [
      "ui.src.lib.markdown.plugins.task-group-plugin.processTaskGroupHeading"
    ],
    "source_code": "taskGroupPlugin = (md: MarkdownIt) => {\n\tmd.core.ruler.push(\"task_group_buttons\", (state: StateCore) => {\n\t\tconst tokens = state.tokens;\n\n\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\tif (tokens[i].type === \"heading_open\") {\n\t\t\t\tprocessTaskGroupHeading(state, tokens, i);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t});\n}",
    "start_line": 81,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "md"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function taskGroupPlugin",
    "component_id": "ui.src.lib.markdown.plugins.task-group-plugin.taskGroupPlugin"
  },
  "ui.src.lib.markdown.preview-renderer.PreviewRendererOptions": {
    "id": "ui.src.lib.markdown.preview-renderer.PreviewRendererOptions",
    "name": "PreviewRendererOptions",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/preview-renderer.ts",
    "relative_path": "ui/src/lib/markdown/preview-renderer.ts",
    "depends_on": [],
    "source_code": "interface PreviewRendererOptions {\n\tmarkdown?: MarkdownIt.Options;\n\tenableMermaid?: boolean;\n\tenablePlantUML?: boolean;\n}",
    "start_line": 10,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PreviewRendererOptions",
    "component_id": "ui.src.lib.markdown.preview-renderer.PreviewRendererOptions"
  },
  "ui.src.lib.markdown.preview-renderer.createPreviewRenderer": {
    "id": "ui.src.lib.markdown.preview-renderer.createPreviewRenderer",
    "name": "createPreviewRenderer",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/preview-renderer.ts",
    "relative_path": "ui/src/lib/markdown/preview-renderer.ts",
    "depends_on": [
      "ui.src.lib.markdown.preview-renderer.PreviewRendererOptions"
    ],
    "source_code": "createPreviewRenderer = (\n\toptions: PreviewRendererOptions = {}\n): MarkdownIt => {\n\tconst md = new MarkdownIt({ ...DEFAULT_OPTIONS, ...options.markdown });\n\n\t// Add custom checkbox plugin for task lists\n\tmd.use(checkboxPlugin);\n\n\t// Add task group button plugin\n\tmd.use(taskGroupPlugin);\n\n\t// Diagram plugins are disabled - they access document during initialization\n\t// if (options.enableMermaid !== false) { ... }\n\t// if (options.enablePlantUML !== false) { ... }\n\n\treturn md;\n}",
    "start_line": 42,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function createPreviewRenderer",
    "component_id": "ui.src.lib.markdown.preview-renderer.createPreviewRenderer"
  },
  "ui.src.lib.markdown.preview-renderer.renderPreviewMarkdown": {
    "id": "ui.src.lib.markdown.preview-renderer.renderPreviewMarkdown",
    "name": "renderPreviewMarkdown",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/markdown/preview-renderer.ts",
    "relative_path": "ui/src/lib/markdown/preview-renderer.ts",
    "depends_on": [
      "ui.src.lib.markdown.preview-renderer.PreviewRendererOptions",
      "ui.src.lib.markdown.preview-renderer.createPreviewRenderer"
    ],
    "source_code": "renderPreviewMarkdown = (\n\tcontent: string,\n\toptions?: PreviewRendererOptions\n): string => {\n\tif (options) {\n\t\treturn createPreviewRenderer(options).render(content);\n\t}\n\n\tif (!cachedRenderer) {\n\t\tcachedRenderer = createPreviewRenderer();\n\t}\n\n\treturn cachedRenderer.render(content);\n}",
    "start_line": 60,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content",
      "options"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function renderPreviewMarkdown",
    "component_id": "ui.src.lib.markdown.preview-renderer.renderPreviewMarkdown"
  },
  "ui.src.lib.mcp-utils.extractServerIdFromToolName": {
    "id": "ui.src.lib.mcp-utils.extractServerIdFromToolName",
    "name": "extractServerIdFromToolName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/mcp-utils.ts",
    "relative_path": "ui/src/lib/mcp-utils.ts",
    "depends_on": [],
    "source_code": "function extractServerIdFromToolName(toolName: string): string {\n\tif (!toolName.startsWith(\"mcp_\")) {\n\t\t// Fallback for non-standard naming\n\t\treturn toolName.toLowerCase();\n\t}\n\n\t// Remove \"mcp_\" prefix\n\tconst withoutPrefix = toolName.substring(4);\n\n\t// Server IDs do NOT contain underscores - find the first underscore to get the boundary\n\t// For complex server IDs (with / or .), we need to find where the server ends\n\t// Strategy: find the first underscore that is NOT part of a path segment\n\n\t// Check if this looks like a path-based or domain-based server ID\n\t// These contain / or . and the server ID ends at the underscore after the path\n\tif (withoutPrefix.includes(\"/\") || withoutPrefix.includes(\".\")) {\n\t\t// Find the position of the first underscore that comes AFTER any / or .\n\t\t// This is where the tool action begins\n\t\tconst slashIndex = withoutPrefix.lastIndexOf(\"/\");\n\t\tconst dotIndex = withoutPrefix.lastIndexOf(\".\");\n\t\tconst pathEnd = Math.max(slashIndex, dotIndex);\n\n\t\tif (pathEnd !== -1) {\n\t\t\t// Find the underscore after the path segment\n\t\t\tconst underscoreAfterPath = withoutPrefix.indexOf(\"_\", pathEnd);\n\t\t\tif (underscoreAfterPath !== -1) {\n\t\t\t\treturn withoutPrefix.substring(0, underscoreAfterPath).toLowerCase();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Simple server ID - find the first underscore\n\tconst firstUnderscoreIndex = withoutPrefix.indexOf(\"_\");\n\n\tif (firstUnderscoreIndex === -1) {\n\t\t// No underscore found, entire string is server ID\n\t\treturn withoutPrefix.toLowerCase();\n\t}\n\n\t// Extract server ID (everything before first underscore)\n\tconst serverId = withoutPrefix.substring(0, firstUnderscoreIndex);\n\treturn serverId.toLowerCase();\n}",
    "start_line": 40,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "toolName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractServerIdFromToolName",
    "component_id": "ui.src.lib.mcp-utils.extractServerIdFromToolName"
  },
  "ui.src.lib.mcp-utils.formatServerNameFromPath": {
    "id": "ui.src.lib.mcp-utils.formatServerNameFromPath",
    "name": "formatServerNameFromPath",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/mcp-utils.ts",
    "relative_path": "ui/src/lib/mcp-utils.ts",
    "depends_on": [],
    "source_code": "function formatServerNameFromPath(pathPart: string): string {\n\treturn pathPart\n\t\t.split(SERVER_PATH_SEPARATOR_REGEX)\n\t\t.map((word) => {\n\t\t\t// Handle known acronyms\n\t\t\tif (word.toLowerCase() === \"mcp\") {\n\t\t\t\treturn \"MCP\";\n\t\t\t}\n\t\t\tif (word.toLowerCase() === \"github\") {\n\t\t\t\treturn \"GitHub\";\n\t\t\t}\n\t\t\tif (word.toLowerCase() === \"gitlab\") {\n\t\t\t\treturn \"GitLab\";\n\t\t\t}\n\t\t\treturn word.charAt(0).toUpperCase() + word.slice(1);\n\t\t})\n\t\t.join(\" \");\n}",
    "start_line": 95,
    "end_line": 112,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pathPart"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatServerNameFromPath",
    "component_id": "ui.src.lib.mcp-utils.formatServerNameFromPath"
  },
  "ui.src.lib.mcp-utils.formatServerName": {
    "id": "ui.src.lib.mcp-utils.formatServerName",
    "name": "formatServerName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/mcp-utils.ts",
    "relative_path": "ui/src/lib/mcp-utils.ts",
    "depends_on": [
      "ui.src.lib.mcp-utils.formatServerNameFromPath"
    ],
    "source_code": "function formatServerName(serverId: string): string {\n\t// Handle known server names with exact mappings\n\tconst knownServers: Record<string, string> = {\n\t\t// Simple names\n\t\tsequentialthinking: \"Sequential Thinking\",\n\t\tmemory: \"Memory\",\n\t\talchemy: \"Alchemy\",\n\t\tflipside: \"Flipside\",\n\t\tetherscan: \"Etherscan\",\n\t\t// Path-based servers\n\t\t\"microsoft/playwright-mcp\": \"Playwright MCP\",\n\t\t\"firecrawl/firecrawl-mcp-server\": \"Firecrawl MCP Server\",\n\t\t\"oraios/serena\": \"Serena\",\n\t\t// Reverse domain notation\n\t\t\"io.github.github/github-mcp-server\": \"GitHub MCP Server\",\n\t\t\"io.github.upstash/context7\": \"Context7\",\n\t\t// Other known servers\n\t\tgithub: \"GitHub\",\n\t\tgitlab: \"GitLab\",\n\t\tslack: \"Slack\",\n\t\tnotion: \"Notion\",\n\t\tjira: \"Jira\",\n\t\ttrello: \"Trello\",\n\t\tasana: \"Asana\",\n\t};\n\n\t// Check if we have a known mapping\n\tconst lowerServerId = serverId.toLowerCase();\n\tif (knownServers[lowerServerId]) {\n\t\treturn knownServers[lowerServerId];\n\t}\n\n\t// For unknown servers, try to format intelligently\n\t// Handle reverse domain notation (io.github.org/server-name  Server Name)\n\tif (serverId.includes(\"/\")) {\n\t\tconst parts = serverId.split(\"/\");\n\t\tconst lastPart = parts.at(-1);\n\t\tif (lastPart) {\n\t\t\treturn formatServerNameFromPath(lastPart);\n\t\t}\n\t}\n\n\t// Handle dot notation (io.github.org  Io Github Org)\n\tif (serverId.includes(\".\")) {\n\t\treturn serverId\n\t\t\t.split(\".\")\n\t\t\t.map((part) => part.charAt(0).toUpperCase() + part.slice(1))\n\t\t\t.join(\" \");\n\t}\n\n\t// Default: capitalize first letter\n\treturn serverId.charAt(0).toUpperCase() + serverId.slice(1);\n}",
    "start_line": 129,
    "end_line": 181,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "serverId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatServerName",
    "component_id": "ui.src.lib.mcp-utils.formatServerName"
  },
  "ui.src.lib.mcp-utils.formatDisplayName": {
    "id": "ui.src.lib.mcp-utils.formatDisplayName",
    "name": "formatDisplayName",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/mcp-utils.ts",
    "relative_path": "ui/src/lib/mcp-utils.ts",
    "depends_on": [
      "ui.src.lib.mcp-utils.extractServerIdFromToolName"
    ],
    "source_code": "function formatDisplayName(toolName: string): string {\n\t// First extract the server ID to know how much to remove\n\tconst serverId = extractServerIdFromToolName(toolName);\n\n\t// Remove mcp_ prefix if present\n\tlet remaining = toolName;\n\tif (toolName.startsWith(\"mcp_\")) {\n\t\tremaining = toolName.substring(4);\n\t}\n\n\t// Remove the server ID prefix and the underscore separator\n\t// The action part is everything after \"serverId_\"\n\tconst serverIdPrefix = `${serverId}_`;\n\tlet actionPart = remaining;\n\n\tif (remaining.toLowerCase().startsWith(serverIdPrefix.toLowerCase())) {\n\t\tactionPart = remaining.substring(serverIdPrefix.length);\n\t} else if (remaining.toLowerCase() === serverId.toLowerCase()) {\n\t\t// Edge case: tool name is just the server ID (no action part)\n\t\tactionPart = serverId;\n\t}\n\n\t// Convert underscores, hyphens, dots, spaces to title case words\n\treturn actionPart\n\t\t.split(TOOL_NAME_SEPARATOR_REGEX)\n\t\t.filter((word) => word.length > 0)\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n\t\t.join(\" \");\n}",
    "start_line": 201,
    "end_line": 229,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "toolName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function formatDisplayName",
    "component_id": "ui.src.lib.mcp-utils.formatDisplayName"
  },
  "ui.src.lib.utils.cn": {
    "id": "ui.src.lib.utils.cn",
    "name": "cn",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/lib/utils.ts",
    "relative_path": "ui/src/lib/utils.ts",
    "depends_on": [],
    "source_code": "function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs));\n}",
    "start_line": 4,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cn",
    "component_id": "ui.src.lib.utils.cn"
  },
  "ui.src.page-registry.SupportedPage": {
    "id": "ui.src.page-registry.SupportedPage",
    "name": "SupportedPage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/page-registry.tsx",
    "relative_path": "ui/src/page-registry.tsx",
    "depends_on": [],
    "source_code": "type SupportedPage =\n\t| \"simple\"\n\t| \"interactive\"\n\t| \"create-spec\"\n\t| \"create-steering\"\n\t| \"hooks\"\n\t| \"dependencies\"\n\t| \"document-preview\"\n\t| \"welcome-screen\";",
    "start_line": 13,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SupportedPage",
    "component_id": "ui.src.page-registry.SupportedPage"
  },
  "ui.src.services.spec-explorer.SpecStatus": {
    "id": "ui.src.services.spec-explorer.SpecStatus",
    "name": "SpecStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "type SpecStatus = \"current\" | \"readyToReview\" | \"reopened\";",
    "start_line": 7,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SpecStatus",
    "component_id": "ui.src.services.spec-explorer.SpecStatus"
  },
  "ui.src.services.spec-explorer.ChangeRequestStatus": {
    "id": "ui.src.services.spec-explorer.ChangeRequestStatus",
    "name": "ChangeRequestStatus",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "type ChangeRequestStatus =\n\t| \"open\"\n\t| \"blocked\"\n\t| \"inProgress\"\n\t| \"addressed\";",
    "start_line": 8,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeRequestStatus",
    "component_id": "ui.src.services.spec-explorer.ChangeRequestStatus"
  },
  "ui.src.services.spec-explorer.ChangeRequestSeverity": {
    "id": "ui.src.services.spec-explorer.ChangeRequestSeverity",
    "name": "ChangeRequestSeverity",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "type ChangeRequestSeverity = \"low\" | \"medium\" | \"high\" | \"critical\";",
    "start_line": 13,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ChangeRequestSeverity",
    "component_id": "ui.src.services.spec-explorer.ChangeRequestSeverity"
  },
  "ui.src.services.spec-explorer.Specification": {
    "id": "ui.src.services.spec-explorer.Specification",
    "name": "Specification",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "ui.src.services.spec-explorer.SpecStatus"
    ],
    "source_code": "interface Specification {\n\tid: string;\n\ttitle: string;\n\towner: string;\n\tstatus: SpecStatus;\n\tcompletedAt: Date | null;\n\tupdatedAt: Date;\n\tlinks: { specPath: string; docUrl?: string };\n\tchangeRequests?: ChangeRequest[];\n}",
    "start_line": 15,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Specification",
    "component_id": "ui.src.services.spec-explorer.Specification"
  },
  "ui.src.services.spec-explorer.ChangeRequest": {
    "id": "ui.src.services.spec-explorer.ChangeRequest",
    "name": "ChangeRequest",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequestStatus",
      "ui.src.services.spec-explorer.ChangeRequestSeverity"
    ],
    "source_code": "interface ChangeRequest {\n\tid: string;\n\tspecId: string;\n\ttitle: string;\n\tdescription: string;\n\tseverity: ChangeRequestSeverity;\n\tstatus: ChangeRequestStatus;\n\ttasks: any[];\n\tsubmitter: string;\n\tcreatedAt: Date;\n\tupdatedAt: Date;\n\tsentToTasksAt: Date | null;\n\tnotes?: string;\n}",
    "start_line": 26,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChangeRequest",
    "component_id": "ui.src.services.spec-explorer.ChangeRequest"
  },
  "ui.src.services.spec-explorer.SpecExplorerMessage": {
    "id": "ui.src.services.spec-explorer.SpecExplorerMessage",
    "name": "SpecExplorerMessage",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "type SpecExplorerMessage =\n\t| {\n\t\t\ttype: \"ready-to-review:fetch\";\n\t  }\n\t| {\n\t\t\ttype: \"ready-to-review:specs-updated\";\n\t\t\tpayload: { specs: Specification[] };\n\t  }\n\t| {\n\t\t\ttype: \"changes:fetch\";\n\t  }\n\t| {\n\t\t\ttype: \"changes:updated\";\n\t\t\tpayload: {\n\t\t\t\titems: Array<{\n\t\t\t\t\tspec: Specification;\n\t\t\t\t\tchangeRequest: ChangeRequest;\n\t\t\t\t}>;\n\t\t\t};\n\t  }\n\t| {\n\t\t\ttype: \"change-request:file\";\n\t\t\tpayload: { specId: string };\n\t  }\n\t| {\n\t\t\ttype: \"change-request:submit\";\n\t\t\tpayload: {\n\t\t\t\tspecId: string;\n\t\t\t\ttitle: string;\n\t\t\t\tdescription: string;\n\t\t\t\tseverity: \"low\" | \"medium\" | \"high\" | \"critical\";\n\t\t\t\tsubmitter: string;\n\t\t\t};\n\t  }\n\t| {\n\t\t\ttype: \"change-request:submitted\";\n\t\t\tpayload: {\n\t\t\t\tsuccess: boolean;\n\t\t\t\terror?: string;\n\t\t\t};\n\t  }\n\t| {\n\t\t\ttype: \"spec:navigate\";\n\t\t\tpayload: { specId: string; target: \"spec\" | \"plan\" | \"design\" };\n\t  };",
    "start_line": 44,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SpecExplorerMessage",
    "component_id": "ui.src.services.spec-explorer.SpecExplorerMessage"
  },
  "ui.src.services.spec-explorer.SpecExplorerService": {
    "id": "ui.src.services.spec-explorer.SpecExplorerService",
    "name": "SpecExplorerService",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.ChangeRequest",
      "ui.src.services.spec-explorer.Specification",
      "src.features.hooks.services.mcp-parameter-resolver.resolve",
      "src.panels.welcome-screen-panel.postMessage",
      "ui.src.services.spec-explorer.on",
      "ui.src.services.spec-explorer.sendMessage",
      "src.features.agents.resource-cache.get",
      "ui.src.services.spec-explorer.handleMessage",
      "src.features.spec.spec-manager.delete",
      "ui.src.services.spec-explorer.SpecExplorerMessage"
    ],
    "source_code": "class SpecExplorerService {\n\tprivate readonly listeners: Map<string, Set<(data: any) => void>> = new Map();\n\n\t/**\n\t * Initialize message listener from extension host\n\t */\n\tinitializeMessageListener(): void {\n\t\tif (typeof window !== \"undefined\" && \"acquireVsCodeApi\" in window) {\n\t\t\tconst vscode = (window as any).acquireVsCodeApi();\n\t\t\t(window as any).specExplorerVscode = vscode;\n\n\t\t\t// Listen for messages from extension\n\t\t\twindow.addEventListener(\"message\", (event) => {\n\t\t\t\tconst message = event.data as SpecExplorerMessage;\n\t\t\t\tthis.handleMessage(message);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming message from extension\n\t */\n\tprivate handleMessage(message: SpecExplorerMessage): void {\n\t\tconst listeners = this.listeners.get(message.type);\n\t\tif (listeners) {\n\t\t\tfor (const listener of listeners) {\n\t\t\t\tlistener((message as any).payload);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Send message to extension host\n\t */\n\tsendMessage(message: SpecExplorerMessage): void {\n\t\tif (typeof window !== \"undefined\" && (window as any).specExplorerVscode) {\n\t\t\t(window as any).specExplorerVscode.postMessage(message);\n\t\t}\n\t}\n\n\t/**\n\t * Subscribe to message type\n\t */\n\ton<T extends SpecExplorerMessage[\"type\"]>(\n\t\ttype: T,\n\t\tlistener: (data: any) => void\n\t): () => void {\n\t\tif (!this.listeners.has(type)) {\n\t\t\tthis.listeners.set(type, new Set());\n\t\t}\n\t\tthis.listeners.get(type)!.add(listener);\n\n\t\t// Return unsubscribe function\n\t\treturn () => {\n\t\t\tthis.listeners.get(type)?.delete(listener);\n\t\t};\n\t}\n\n\t/**\n\t * Fetch ready-to-review specs from extension\n\t */\n\tfetchReadyToReviewSpecs(): Promise<Specification[]> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst unsubscribe = this.on(\n\t\t\t\t\"ready-to-review:specs-updated\",\n\t\t\t\t(payload) => {\n\t\t\t\t\tunsubscribe();\n\t\t\t\t\tresolve(payload.specs);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tthis.sendMessage({ type: \"ready-to-review:fetch\" });\n\n\t\t\t// Timeout after 5 seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tunsubscribe();\n\t\t\t\tresolve([]);\n\t\t\t}, 5000);\n\t\t});\n\t}\n\n\t/**\n\t * Fetch active change requests from extension\n\t */\n\tfetchChangeRequests(): Promise<\n\t\tArray<{ spec: Specification; changeRequest: ChangeRequest }>\n\t> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst unsubscribe = this.on(\"changes:updated\", (payload) => {\n\t\t\t\tunsubscribe();\n\t\t\t\tresolve(payload.items);\n\t\t\t});\n\n\t\t\tthis.sendMessage({ type: \"changes:fetch\" });\n\n\t\t\t// Timeout after 5 seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tunsubscribe();\n\t\t\t\tresolve([]);\n\t\t\t}, 5000);\n\t\t});\n\t}\n\n\t/**\n\t * Request to file a change request for a spec\n\t */\n\tfileChangeRequest(specId: string): void {\n\t\tthis.sendMessage({ type: \"change-request:file\", payload: { specId } });\n\t}\n\n\t/**\n\t * Submit a change request to the extension\n\t */\n\tsubmitChangeRequest(options: {\n\t\tspecId: string;\n\t\ttitle: string;\n\t\tdescription: string;\n\t\tseverity: \"low\" | \"medium\" | \"high\" | \"critical\";\n\t\tsubmitter: string;\n\t}): void {\n\t\tthis.sendMessage({\n\t\t\ttype: \"change-request:submit\",\n\t\t\tpayload: options,\n\t\t});\n\t}\n\n\t/**\n\t * Navigate to a spec document\n\t */\n\tnavigateToSpec(\n\t\tspecId: string,\n\t\ttarget: \"spec\" | \"plan\" | \"design\" = \"spec\"\n\t): void {\n\t\tthis.sendMessage({ type: \"spec:navigate\", payload: { specId, target } });\n\t}\n}",
    "start_line": 93,
    "end_line": 228,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecExplorerService",
    "component_id": "ui.src.services.spec-explorer.SpecExplorerService"
  },
  "ui.src.services.spec-explorer.initializeMessageListener": {
    "id": "ui.src.services.spec-explorer.initializeMessageListener",
    "name": "initializeMessageListener",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "initializeMessageListener(): void {\n\t\tif (typeof window !== \"undefined\" && \"acquireVsCodeApi\" in window) {\n\t\t\tconst vscode = (window as any).acquireVsCodeApi();\n\t\t\t(window as any).specExplorerVscode = vscode;\n\n\t\t\t// Listen for messages from extension\n\t\t\twindow.addEventListener(\"message\", (event) => {\n\t\t\t\tconst message = event.data as SpecExplorerMessage;\n\t\t\t\tthis.handleMessage(message);\n\t\t\t});\n\t\t}\n\t}",
    "start_line": 99,
    "end_line": 110,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initializeMessageListener",
    "component_id": "ui.src.services.spec-explorer.initializeMessageListener"
  },
  "ui.src.services.spec-explorer.handleMessage": {
    "id": "ui.src.services.spec-explorer.handleMessage",
    "name": "handleMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "private handleMessage(message: SpecExplorerMessage): void {\n\t\tconst listeners = this.listeners.get(message.type);\n\t\tif (listeners) {\n\t\t\tfor (const listener of listeners) {\n\t\t\t\tlistener((message as any).payload);\n\t\t\t}\n\t\t}\n\t}",
    "start_line": 115,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleMessage",
    "component_id": "ui.src.services.spec-explorer.handleMessage"
  },
  "ui.src.services.spec-explorer.sendMessage": {
    "id": "ui.src.services.spec-explorer.sendMessage",
    "name": "sendMessage",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "sendMessage(message: SpecExplorerMessage): void {\n\t\tif (typeof window !== \"undefined\" && (window as any).specExplorerVscode) {\n\t\t\t(window as any).specExplorerVscode.postMessage(message);\n\t\t}\n\t}",
    "start_line": 127,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method sendMessage",
    "component_id": "ui.src.services.spec-explorer.sendMessage"
  },
  "ui.src.services.spec-explorer.on": {
    "id": "ui.src.services.spec-explorer.on",
    "name": "on",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "on<T extends SpecExplorerMessage[\"type\"]>(\n\t\ttype: T,\n\t\tlistener: (data: any) => void\n\t): () => void {\n\t\tif (!this.listeners.has(type)) {\n\t\t\tthis.listeners.set(type, new Set());\n\t\t}\n\t\tthis.listeners.get(type)!.add(listener);\n\n\t\t// Return unsubscribe function\n\t\treturn () => {\n\t\t\tthis.listeners.get(type)?.delete(listener);\n\t\t};\n\t}",
    "start_line": 136,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type",
      "listener"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method on",
    "component_id": "ui.src.services.spec-explorer.on"
  },
  "ui.src.services.spec-explorer.fetchReadyToReviewSpecs": {
    "id": "ui.src.services.spec-explorer.fetchReadyToReviewSpecs",
    "name": "fetchReadyToReviewSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "fetchReadyToReviewSpecs(): Promise<Specification[]> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst unsubscribe = this.on(\n\t\t\t\t\"ready-to-review:specs-updated\",\n\t\t\t\t(payload) => {\n\t\t\t\t\tunsubscribe();\n\t\t\t\t\tresolve(payload.specs);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tthis.sendMessage({ type: \"ready-to-review:fetch\" });\n\n\t\t\t// Timeout after 5 seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tunsubscribe();\n\t\t\t\tresolve([]);\n\t\t\t}, 5000);\n\t\t});\n\t}",
    "start_line": 154,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method fetchReadyToReviewSpecs",
    "component_id": "ui.src.services.spec-explorer.fetchReadyToReviewSpecs"
  },
  "ui.src.services.spec-explorer.fetchChangeRequests": {
    "id": "ui.src.services.spec-explorer.fetchChangeRequests",
    "name": "fetchChangeRequests",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "fetchChangeRequests(): Promise<\n\t\tArray<{ spec: Specification; changeRequest: ChangeRequest }>\n\t> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst unsubscribe = this.on(\"changes:updated\", (payload) => {\n\t\t\t\tunsubscribe();\n\t\t\t\tresolve(payload.items);\n\t\t\t});\n\n\t\t\tthis.sendMessage({ type: \"changes:fetch\" });\n\n\t\t\t// Timeout after 5 seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tunsubscribe();\n\t\t\t\tresolve([]);\n\t\t\t}, 5000);\n\t\t});\n\t}",
    "start_line": 177,
    "end_line": 194,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method fetchChangeRequests",
    "component_id": "ui.src.services.spec-explorer.fetchChangeRequests"
  },
  "ui.src.services.spec-explorer.fileChangeRequest": {
    "id": "ui.src.services.spec-explorer.fileChangeRequest",
    "name": "fileChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "fileChangeRequest(specId: string): void {\n\t\tthis.sendMessage({ type: \"change-request:file\", payload: { specId } });\n\t}",
    "start_line": 199,
    "end_line": 201,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method fileChangeRequest",
    "component_id": "ui.src.services.spec-explorer.fileChangeRequest"
  },
  "ui.src.services.spec-explorer.submitChangeRequest": {
    "id": "ui.src.services.spec-explorer.submitChangeRequest",
    "name": "submitChangeRequest",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "submitChangeRequest(options: {\n\t\tspecId: string;\n\t\ttitle: string;\n\t\tdescription: string;\n\t\tseverity: \"low\" | \"medium\" | \"high\" | \"critical\";\n\t\tsubmitter: string;\n\t}): void {\n\t\tthis.sendMessage({\n\t\t\ttype: \"change-request:submit\",\n\t\t\tpayload: options,\n\t\t});\n\t}",
    "start_line": 206,
    "end_line": 217,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method submitChangeRequest",
    "component_id": "ui.src.services.spec-explorer.submitChangeRequest"
  },
  "ui.src.services.spec-explorer.navigateToSpec": {
    "id": "ui.src.services.spec-explorer.navigateToSpec",
    "name": "navigateToSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/services/spec-explorer.ts",
    "relative_path": "ui/src/services/spec-explorer.ts",
    "depends_on": [],
    "source_code": "navigateToSpec(\n\t\tspecId: string,\n\t\ttarget: \"spec\" | \"plan\" | \"design\" = \"spec\"\n\t): void {\n\t\tthis.sendMessage({ type: \"spec:navigate\", payload: { specId, target } });\n\t}",
    "start_line": 222,
    "end_line": 227,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "target"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method navigateToSpec",
    "component_id": "ui.src.services.spec-explorer.navigateToSpec"
  },
  "ui.src.stores.spec-explorer-store.SpecExplorerState": {
    "id": "ui.src.stores.spec-explorer-store.SpecExplorerState",
    "name": "SpecExplorerState",
    "component_type": "interface",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification"
    ],
    "source_code": "interface SpecExplorerState {\n\treviewSpecs: Specification[];\n\tarchivedSpecs: Specification[];\n}",
    "start_line": 4,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SpecExplorerState",
    "component_id": "ui.src.stores.spec-explorer-store.SpecExplorerState"
  },
  "ui.src.stores.spec-explorer-store.Listener": {
    "id": "ui.src.stores.spec-explorer-store.Listener",
    "name": "Listener",
    "component_type": "type",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "type Listener = () => void;",
    "start_line": 9,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Listener",
    "component_id": "ui.src.stores.spec-explorer-store.Listener"
  },
  "ui.src.stores.spec-explorer-store.SpecExplorerStore": {
    "id": "ui.src.stores.spec-explorer-store.SpecExplorerStore",
    "name": "SpecExplorerStore",
    "component_type": "class",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [
      "ui.src.services.spec-explorer.Specification",
      "ui.src.stores.spec-explorer-store.notify",
      "ui.src.stores.spec-explorer-store.Listener",
      "ui.src.stores.spec-explorer-store.SpecExplorerState",
      "src.features.spec.spec-manager.delete"
    ],
    "source_code": "class SpecExplorerStore {\n\tprivate state: SpecExplorerState = {\n\t\treviewSpecs: [],\n\t\tarchivedSpecs: [],\n\t};\n\n\tprivate readonly listeners: Set<Listener> = new Set();\n\n\tgetState(): SpecExplorerState {\n\t\treturn this.state;\n\t}\n\n\tsubscribe(listener: Listener): () => void {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tprivate notify(): void {\n\t\tfor (const listener of this.listeners) {\n\t\t\tlistener();\n\t\t}\n\t}\n\n\tsetReviewSpecs(specs: Specification[]): void {\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\treviewSpecs: specs,\n\t\t};\n\t\tthis.notify();\n\t}\n\n\tsetArchivedSpecs(specs: Specification[]): void {\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tarchivedSpecs: specs,\n\t\t};\n\t\tthis.notify();\n\t}\n\n\tupdateSpec(specId: string, updates: Partial<Specification>): void {\n\t\tconst mapSpec = (spec: Specification) =>\n\t\t\tspec.id === specId ? { ...spec, ...updates } : spec;\n\t\tthis.state = {\n\t\t\treviewSpecs: this.state.reviewSpecs.map(mapSpec),\n\t\t\tarchivedSpecs: this.state.archivedSpecs.map(mapSpec),\n\t\t};\n\t\tthis.notify();\n\t}\n\n\treset(): void {\n\t\tthis.state = {\n\t\t\treviewSpecs: [],\n\t\t\tarchivedSpecs: [],\n\t\t};\n\t\tthis.notify();\n\t}\n}",
    "start_line": 11,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SpecExplorerStore",
    "component_id": "ui.src.stores.spec-explorer-store.SpecExplorerStore"
  },
  "ui.src.stores.spec-explorer-store.getState": {
    "id": "ui.src.stores.spec-explorer-store.getState",
    "name": "getState",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "getState(): SpecExplorerState {\n\t\treturn this.state;\n\t}",
    "start_line": 19,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getState",
    "component_id": "ui.src.stores.spec-explorer-store.getState"
  },
  "ui.src.stores.spec-explorer-store.subscribe": {
    "id": "ui.src.stores.spec-explorer-store.subscribe",
    "name": "subscribe",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "subscribe(listener: Listener): () => void {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}",
    "start_line": 23,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "listener"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method subscribe",
    "component_id": "ui.src.stores.spec-explorer-store.subscribe"
  },
  "ui.src.stores.spec-explorer-store.notify": {
    "id": "ui.src.stores.spec-explorer-store.notify",
    "name": "notify",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "private notify(): void {\n\t\tfor (const listener of this.listeners) {\n\t\t\tlistener();\n\t\t}\n\t}",
    "start_line": 30,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method notify",
    "component_id": "ui.src.stores.spec-explorer-store.notify"
  },
  "ui.src.stores.spec-explorer-store.setReviewSpecs": {
    "id": "ui.src.stores.spec-explorer-store.setReviewSpecs",
    "name": "setReviewSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "setReviewSpecs(specs: Specification[]): void {\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\treviewSpecs: specs,\n\t\t};\n\t\tthis.notify();\n\t}",
    "start_line": 36,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specs"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setReviewSpecs",
    "component_id": "ui.src.stores.spec-explorer-store.setReviewSpecs"
  },
  "ui.src.stores.spec-explorer-store.setArchivedSpecs": {
    "id": "ui.src.stores.spec-explorer-store.setArchivedSpecs",
    "name": "setArchivedSpecs",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "setArchivedSpecs(specs: Specification[]): void {\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tarchivedSpecs: specs,\n\t\t};\n\t\tthis.notify();\n\t}",
    "start_line": 44,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specs"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setArchivedSpecs",
    "component_id": "ui.src.stores.spec-explorer-store.setArchivedSpecs"
  },
  "ui.src.stores.spec-explorer-store.updateSpec": {
    "id": "ui.src.stores.spec-explorer-store.updateSpec",
    "name": "updateSpec",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "updateSpec(specId: string, updates: Partial<Specification>): void {\n\t\tconst mapSpec = (spec: Specification) =>\n\t\t\tspec.id === specId ? { ...spec, ...updates } : spec;\n\t\tthis.state = {\n\t\t\treviewSpecs: this.state.reviewSpecs.map(mapSpec),\n\t\t\tarchivedSpecs: this.state.archivedSpecs.map(mapSpec),\n\t\t};\n\t\tthis.notify();\n\t}",
    "start_line": 52,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "specId",
      "updates"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method updateSpec",
    "component_id": "ui.src.stores.spec-explorer-store.updateSpec"
  },
  "ui.src.stores.spec-explorer-store.reset": {
    "id": "ui.src.stores.spec-explorer-store.reset",
    "name": "reset",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [],
    "source_code": "reset(): void {\n\t\tthis.state = {\n\t\t\treviewSpecs: [],\n\t\t\tarchivedSpecs: [],\n\t\t};\n\t\tthis.notify();\n\t}",
    "start_line": 62,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method reset",
    "component_id": "ui.src.stores.spec-explorer-store.reset"
  },
  "ui.src.stores.spec-explorer-store.useSpecExplorerStore": {
    "id": "ui.src.stores.spec-explorer-store.useSpecExplorerStore",
    "name": "useSpecExplorerStore",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/src/stores/spec-explorer-store.ts",
    "relative_path": "ui/src/stores/spec-explorer-store.ts",
    "depends_on": [
      "ui.src.stores.spec-explorer-store.SpecExplorerState",
      "ui.src.stores.spec-explorer-store.subscribe",
      "ui.src.stores.spec-explorer-store.getState"
    ],
    "source_code": "function useSpecExplorerStore<T>(\n\tselector: (state: SpecExplorerState) => T\n): T {\n\treturn useSyncExternalStore(\n\t\t(listener) => store.subscribe(listener),\n\t\t() => selector(store.getState()),\n\t\t() => selector(store.getState())\n\t);\n}",
    "start_line": 73,
    "end_line": 81,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "selector"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useSpecExplorerStore",
    "component_id": "ui.src.stores.spec-explorer-store.useSpecExplorerStore"
  },
  "ui.vite.config.defineConfig": {
    "id": "ui.vite.config.defineConfig",
    "name": "defineConfig",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/ui/vite.config.ts",
    "relative_path": "ui/vite.config.ts",
    "depends_on": [
      "ui.vite.config.defineConfig",
      "src.features.hooks.services.mcp-parameter-resolver.resolve"
    ],
    "source_code": "export default defineConfig({\n\tbase: \"./\",\n\tplugins: [react(), tailwindcss()],\n\tresolve: {\n\t\talias: {\n\t\t\t\"@\": resolve(__dirname, \"src\"),\n\t\t},\n\t},\n\tbuild: {\n\t\toutDir: resolve(__dirname, \"../dist/webview/app\"),\n\t\temptyOutDir: true,\n\t\trollupOptions: {\n\t\t\tinput: resolve(__dirname, \"index.html\"),\n\t\t\toutput: {\n\t\t\t\tentryFileNames: \"index.js\",\n\t\t\t\tchunkFileNames: \"chunks/[name].js\",\n\t\t\t\tassetFileNames: \"assets/[name][extname]\",\n\t\t\t},\n\t\t},\n\t},\n});",
    "start_line": 8,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "export_default_call",
    "base_classes": null,
    "class_name": null,
    "display_name": "export default defineConfig(...)",
    "component_id": "ui.vite.config.defineConfig"
  },
  "vitest.config.defineConfig": {
    "id": "vitest.config.defineConfig",
    "name": "defineConfig",
    "component_type": "function",
    "file_path": "/Users/italo/Projects/italo/gatomia-vscode/vitest.config.ts",
    "relative_path": "vitest.config.ts",
    "depends_on": [
      "vitest.config.defineConfig",
      "src.features.hooks.services.mcp-parameter-resolver.resolve"
    ],
    "source_code": "export default defineConfig({\n\ttest: {\n\t\tenvironment: \"jsdom\",\n\t\tinclude: [\n\t\t\t\"src/**/*.test.ts\",\n\t\t\t\"tests/**/*.test.ts\",\n\t\t\t\"tests/**/*.test.tsx\",\n\t\t\t\"ui/tests/**/*.spec.tsx\",\n\t\t],\n\t\tsetupFiles: [\"./vitest.setup.ts\"],\n\t\tcoverage: { reporter: [\"text\", \"lcov\", \"html\"], provider: \"v8\" },\n\t},\n\tresolve: {\n\t\talias: {\n\t\t\tvscode: path.resolve(__dirname, \"tests/__mocks__/vscode.ts\"),\n\t\t\t\"@\": path.resolve(__dirname, \"ui/src\"),\n\t\t\t// Add explicit aliases for UI dependencies\n\t\t\tclsx: path.resolve(__dirname, \"ui/node_modules/clsx\"),\n\t\t\t\"@radix-ui/react-slot\": path.resolve(\n\t\t\t\t__dirname,\n\t\t\t\t\"ui/node_modules/@radix-ui/react-slot\"\n\t\t\t),\n\t\t\t\"class-variance-authority\": path.resolve(\n\t\t\t\t__dirname,\n\t\t\t\t\"ui/node_modules/class-variance-authority\"\n\t\t\t),\n\t\t\t\"tailwind-merge\": path.resolve(\n\t\t\t\t__dirname,\n\t\t\t\t\"ui/node_modules/tailwind-merge\"\n\t\t\t),\n\t\t\t// Force all React imports to use the root version (testing library uses root)\n\t\t\treact: path.resolve(__dirname, \"node_modules/react\"),\n\t\t\t\"react-dom\": path.resolve(__dirname, \"node_modules/react-dom\"),\n\t\t\t\"react/jsx-runtime\": path.resolve(\n\t\t\t\t__dirname,\n\t\t\t\t\"node_modules/react/jsx-runtime\"\n\t\t\t),\n\t\t\t\"react/jsx-dev-runtime\": path.resolve(\n\t\t\t\t__dirname,\n\t\t\t\t\"node_modules/react/jsx-dev-runtime\"\n\t\t\t),\n\t\t},\n\t\tdedupe: [\"react\", \"react-dom\"],\n\t},\n\tesbuild: {\n\t\tjsx: \"automatic\",\n\t},\n});",
    "start_line": 4,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "export_default_call",
    "base_classes": null,
    "class_name": null,
    "display_name": "export default defineConfig(...)",
    "component_id": "vitest.config.defineConfig"
  }
}